
SMOK:     file format elf32-littlearm


Disassembly of section .bootloader:

08000000 <resetisr>:
 8000000:	00 10 00 10 95 01 00 08 89 01 00 08 89 01 00 08     ................
 8000010:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000020:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000030:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000040:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000050:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000060:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000070:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000080:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000090:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 80000a0:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 80000b0:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 80000c0:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 80000d0:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 80000e0:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 80000f0:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000100:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000110:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000120:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000130:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000140:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000150:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000160:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000170:	89 01 00 08 89 01 00 08 89 01 00 08 89 01 00 08     ................
 8000180:	89 01 00 08 89 01 00 08                             ........

08000188 <resetDefaultIRQHandler>:
uint64_t common_stack[STACK_SIZE / 8] __attribute__ ((section(".stack"), aligned(8), used));
#define NVICE(arg_name) (uint32_t)(arg_name)

//////////////////////////////////////////////// BOOTLOADER ////////////////////////////////////////////////
static void __attribute__ ((no_instrument_function, interrupt, optimize("-O3"), section(".bootloader"))) resetDefaultIRQHandler(void)
{
 8000188:	4668      	mov	r0, sp
 800018a:	f020 0107 	bic.w	r1, r0, #7
 800018e:	468d      	mov	sp, r1
 8000190:	b401      	push	{r0}
 8000192:	e7fe      	b.n	8000192 <resetDefaultIRQHandler+0xa>

08000194 <Boot_Reset_Handler>:

extern uint32_t _new_image[2];
static void Boot_Reset_Handler(void)
{
  //Update FW if new one available
  updateFW();
 8000194:	f000 f83c 	bl	8000210 <updateFW>

  //Set new interrupt table
  SCB->VTOR = ((uint32_t)_new_image);
 8000198:	4b06      	ldr	r3, [pc, #24]	; (80001b4 <Boot_Reset_Handler+0x20>)
 800019a:	4a07      	ldr	r2, [pc, #28]	; (80001b8 <Boot_Reset_Handler+0x24>)
 800019c:	609a      	str	r2, [r3, #8]
  //Set new stack
  __set_MSP(_new_image[0]);
 800019e:	4b06      	ldr	r3, [pc, #24]	; (80001b8 <Boot_Reset_Handler+0x24>)
 80001a0:	681b      	ldr	r3, [r3, #0]
 80001a2:	461c      	mov	r4, r3

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 80001a4:	f384 8808 	msr	MSP, r4

  //Proceed to main image by calling it's reset
  void (*mainImageReset)(void) = (void*)_new_image[1];
 80001a8:	4b03      	ldr	r3, [pc, #12]	; (80001b8 <Boot_Reset_Handler+0x24>)
 80001aa:	685b      	ldr	r3, [r3, #4]
 80001ac:	461c      	mov	r4, r3
  mainImageReset();
 80001ae:	47a0      	blx	r4
  while(1);
 80001b0:	e7fe      	b.n	80001b0 <Boot_Reset_Handler+0x1c>
 80001b2:	bf00      	nop
 80001b4:	e000ed00 	.word	0xe000ed00
 80001b8:	08008000 	.word	0x08008000

080001bc <cfgInit>:
  (void)cfgSizeTest;
  uint8_t *src = (uint8_t*)&cfgnvs;
  uint8_t *dst = (uint8_t*)&cfg;
  int idx;
  for(idx = 0; idx < sizeof(cfg); idx++)
    dst[idx] = src[idx];
 80001bc:	4a04      	ldr	r2, [pc, #16]	; (80001d0 <cfgInit+0x14>)
 80001be:	4805      	ldr	r0, [pc, #20]	; (80001d4 <cfgInit+0x18>)
{
  (void)cfgSizeTest;
  uint8_t *src = (uint8_t*)&cfgnvs;
  uint8_t *dst = (uint8_t*)&cfg;
  int idx;
  for(idx = 0; idx < sizeof(cfg); idx++)
 80001c0:	2300      	movs	r3, #0
    dst[idx] = src[idx];
 80001c2:	5c19      	ldrb	r1, [r3, r0]
 80001c4:	5499      	strb	r1, [r3, r2]
{
  (void)cfgSizeTest;
  uint8_t *src = (uint8_t*)&cfgnvs;
  uint8_t *dst = (uint8_t*)&cfg;
  int idx;
  for(idx = 0; idx < sizeof(cfg); idx++)
 80001c6:	3301      	adds	r3, #1
 80001c8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80001cc:	d1f9      	bne.n	80001c2 <cfgInit+0x6>
    dst[idx] = src[idx];
}
 80001ce:	4770      	bx	lr
 80001d0:	10001000 	.word	0x10001000
 80001d4:	08004000 	.word	0x08004000

080001d8 <cfgFlush>:
void cfgFlush(void)
{
 80001d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR );
 80001da:	20f2      	movs	r0, #242	; 0xf2
 80001dc:	f000 fb9c 	bl	8000918 <FLASH_ClearFlag>
  FLASH_Unlock();
 80001e0:	f000 fb8c 	bl	80008fc <FLASH_Unlock>
  FLASH_EraseSector(FLASH_Sector_1, VoltageRange_3);
 80001e4:	2102      	movs	r1, #2
 80001e6:	2008      	movs	r0, #8
  uint32_t *src = (uint32_t*)&cfg;
  uint32_t addr = (uint32_t)&cfgnvs;
  uint32_t eaddr = (uint32_t)&cfgnvs + sizeof(cfgnvs);
 80001e8:	4d07      	ldr	r5, [pc, #28]	; (8000208 <cfgFlush+0x30>)
 80001ea:	4f08      	ldr	r7, [pc, #32]	; (800020c <cfgFlush+0x34>)
}
void cfgFlush(void)
{
  FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR );
  FLASH_Unlock();
  FLASH_EraseSector(FLASH_Sector_1, VoltageRange_3);
 80001ec:	f000 fbda 	bl	80009a4 <FLASH_EraseSector>
  uint32_t *src = (uint32_t*)&cfg;
  uint32_t addr = (uint32_t)&cfgnvs;
  uint32_t eaddr = (uint32_t)&cfgnvs + sizeof(cfgnvs);
  for(; addr < eaddr; addr+=4)
 80001f0:	2400      	movs	r4, #0
 80001f2:	f5a5 7600 	sub.w	r6, r5, #512	; 0x200
 80001f6:	19a0      	adds	r0, r4, r6
 80001f8:	4285      	cmp	r5, r0
 80001fa:	d904      	bls.n	8000206 <cfgFlush+0x2e>
    FLASH_ProgramWord(addr, *(src++));
 80001fc:	5939      	ldr	r1, [r7, r4]
 80001fe:	f000 fc25 	bl	8000a4c <FLASH_ProgramWord>
 8000202:	3404      	adds	r4, #4
 8000204:	e7f7      	b.n	80001f6 <cfgFlush+0x1e>
}
 8000206:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000208:	08004200 	.word	0x08004200
 800020c:	10001000 	.word	0x10001000

08000210 <updateFW>:

uint8_t __attribute__((section(".storage")))flashStorage[0];
extern uint8_t _nvs[0];
void updateFW(void)
{
 8000210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  cfgInit();
  if(cfg.fSize > 0)
 8000212:	4c23      	ldr	r4, [pc, #140]	; (80002a0 <updateFW+0x90>)

uint8_t __attribute__((section(".storage")))flashStorage[0];
extern uint8_t _nvs[0];
void updateFW(void)
{
  cfgInit();
 8000214:	f7ff ffd2 	bl	80001bc <cfgInit>
  if(cfg.fSize > 0)
 8000218:	6823      	ldr	r3, [r4, #0]
 800021a:	2b00      	cmp	r3, #0
 800021c:	dd3e      	ble.n	800029c <updateFW+0x8c>
    {
      uint32_t crc = crc32(0, flashStorage, cfg.fSize);
 800021e:	6822      	ldr	r2, [r4, #0]
 8000220:	4920      	ldr	r1, [pc, #128]	; (80002a4 <updateFW+0x94>)
 8000222:	2000      	movs	r0, #0
 8000224:	f000 f842 	bl	80002ac <crc32>
      if((int)crc != cfg.fCRC)
 8000228:	6863      	ldr	r3, [r4, #4]
 800022a:	4283      	cmp	r3, r0
 800022c:	d136      	bne.n	800029c <updateFW+0x8c>
        return;

      //Update FW
      FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR );
 800022e:	20f2      	movs	r0, #242	; 0xf2
 8000230:	f000 fb72 	bl	8000918 <FLASH_ClearFlag>
      FLASH_Unlock();
 8000234:	f000 fb62 	bl	80008fc <FLASH_Unlock>
      FLASH_EraseSector(FLASH_Sector_1, VoltageRange_3);
 8000238:	2102      	movs	r1, #2
 800023a:	2008      	movs	r0, #8
 800023c:	f000 fbb2 	bl	80009a4 <FLASH_EraseSector>
      FLASH_EraseSector(FLASH_Sector_2, VoltageRange_3);
 8000240:	2102      	movs	r1, #2
 8000242:	2010      	movs	r0, #16
 8000244:	f000 fbae 	bl	80009a4 <FLASH_EraseSector>
      FLASH_EraseSector(FLASH_Sector_3, VoltageRange_3);
 8000248:	2102      	movs	r1, #2
 800024a:	2018      	movs	r0, #24
 800024c:	f000 fbaa 	bl	80009a4 <FLASH_EraseSector>
      FLASH_EraseSector(FLASH_Sector_4, VoltageRange_3);
 8000250:	2102      	movs	r1, #2
 8000252:	2020      	movs	r0, #32
 8000254:	f000 fba6 	bl	80009a4 <FLASH_EraseSector>
      FLASH_EraseSector(FLASH_Sector_5, VoltageRange_3);
 8000258:	2102      	movs	r1, #2
 800025a:	2028      	movs	r0, #40	; 0x28
 800025c:	f000 fba2 	bl	80009a4 <FLASH_EraseSector>
      FLASH_EraseSector(FLASH_Sector_6, VoltageRange_3);
 8000260:	2102      	movs	r1, #2
 8000262:	2030      	movs	r0, #48	; 0x30
 8000264:	f000 fb9e 	bl	80009a4 <FLASH_EraseSector>
      FLASH_EraseSector(FLASH_Sector_7, VoltageRange_3);
 8000268:	2102      	movs	r1, #2
 800026a:	2038      	movs	r0, #56	; 0x38
 800026c:	f000 fb9a 	bl	80009a4 <FLASH_EraseSector>
      uint32_t *src = (uint32_t*)(&flashStorage[16*1024]);//Omit bootloader
      uint32_t addr = (uint32_t)(&_nvs[0]);
      int num =  (cfg.fSize+3-16*1024)/4;
 8000270:	6823      	ldr	r3, [r4, #0]
 8000272:	4e0d      	ldr	r6, [pc, #52]	; (80002a8 <updateFW+0x98>)
      while(num--)
        {
          FLASH_ProgramWord(addr, *src);
 8000274:	4f0b      	ldr	r7, [pc, #44]	; (80002a4 <updateFW+0x94>)
 8000276:	f5a3 537f 	sub.w	r3, r3, #16320	; 0x3fc0
      FLASH_EraseSector(FLASH_Sector_6, VoltageRange_3);
      FLASH_EraseSector(FLASH_Sector_7, VoltageRange_3);
      uint32_t *src = (uint32_t*)(&flashStorage[16*1024]);//Omit bootloader
      uint32_t addr = (uint32_t)(&_nvs[0]);
      int num =  (cfg.fSize+3-16*1024)/4;
      while(num--)
 800027a:	2500      	movs	r5, #0
 800027c:	3b3d      	subs	r3, #61	; 0x3d
 800027e:	2404      	movs	r4, #4
 8000280:	fb93 f4f4 	sdiv	r4, r3, r4
 8000284:	00ab      	lsls	r3, r5, #2
 8000286:	42a5      	cmp	r5, r4
 8000288:	eb03 0006 	add.w	r0, r3, r6
 800028c:	d006      	beq.n	800029c <updateFW+0x8c>
        {
          FLASH_ProgramWord(addr, *src);
 800028e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8000292:	3501      	adds	r5, #1
 8000294:	58f9      	ldr	r1, [r7, r3]
 8000296:	f000 fbd9 	bl	8000a4c <FLASH_ProgramWord>
 800029a:	e7f3      	b.n	8000284 <updateFW+0x74>
 800029c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800029e:	bf00      	nop
 80002a0:	10001000 	.word	0x10001000
 80002a4:	08080000 	.word	0x08080000
 80002a8:	08004000 	.word	0x08004000

080002ac <crc32>:
  while (size--) crc = arg_table[(crc ^ *p++) & 0xFF] ^ (crc >> 8);   \
  return (arg_invert)?crc ^ ~0U:crc;                                  \
  }


CRC_FUNC(32, crc32_tab, 1)
 80002ac:	b510      	push	{r4, lr}
 80002ae:	4c08      	ldr	r4, [pc, #32]	; (80002d0 <crc32+0x24>)
 80002b0:	43c0      	mvns	r0, r0
 80002b2:	440a      	add	r2, r1
 80002b4:	4291      	cmp	r1, r2
 80002b6:	d008      	beq.n	80002ca <crc32+0x1e>
 80002b8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80002bc:	4043      	eors	r3, r0
 80002be:	b2db      	uxtb	r3, r3
 80002c0:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 80002c4:	ea83 2010 	eor.w	r0, r3, r0, lsr #8
 80002c8:	e7f4      	b.n	80002b4 <crc32+0x8>
 80002ca:	43c0      	mvns	r0, r0
 80002cc:	bd10      	pop	{r4, pc}
 80002ce:	bf00      	nop
 80002d0:	080002fc 	.word	0x080002fc

080002d4 <crc16>:
CRC_FUNC(16, crc16_tab, 0)
 80002d4:	b510      	push	{r4, lr}
 80002d6:	4c08      	ldr	r4, [pc, #32]	; (80002f8 <crc16+0x24>)
 80002d8:	440a      	add	r2, r1
 80002da:	4291      	cmp	r1, r2
 80002dc:	d00a      	beq.n	80002f4 <crc16+0x20>
 80002de:	f811 3b01 	ldrb.w	r3, [r1], #1
 80002e2:	4043      	eors	r3, r0
 80002e4:	b2db      	uxtb	r3, r3
 80002e6:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 80002ea:	f8b3 3400 	ldrh.w	r3, [r3, #1024]	; 0x400
 80002ee:	ea83 2010 	eor.w	r0, r3, r0, lsr #8
 80002f2:	e7f2      	b.n	80002da <crc16+0x6>
 80002f4:	bd10      	pop	{r4, pc}
 80002f6:	bf00      	nop
 80002f8:	080002fc 	.word	0x080002fc

080002fc <crc32_tab>:
 80002fc:	00000000 77073096 ee0e612c 990951ba     .....0.w,a...Q..
 800030c:	076dc419 706af48f e963a535 9e6495a3     ..m...jp5.c...d.
 800031c:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     2......y........
 800032c:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     +L...|.~.-......
 800033c:	1db71064 6ab020f2 f3b97148 84be41de     d.... .jHq...A..
 800034c:	1adad47d 6ddde4eb f4d4b551 83d385c7     }......mQ.......
 800035c:	136c9856 646ba8c0 fd62f97a 8a65c9ec     V.l...kdz.b...e.
 800036c:	14015c4f 63066cd9 fa0f3d63 8d080df5     O\...l.cc=......
 800037c:	3b6e20c8 4c69105e d56041e4 a2677172     . n;^.iL.A`.rqg.
 800038c:	3c03e4d1 4b04d447 d20d85fd a50ab56b     ...<G..K....k...
 800039c:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     ...5l..B....@...
 80003ac:	32d86ce3 45df5c75 dcd60dcf abd13d59     .l.2u\.E....Y=..
 80003bc:	26d930ac 51de003a c8d75180 bfd06116     .0.&:..Q.Q...a..
 80003cc:	21b4f4b5 56b3c423 cfba9599 b8bda50f     ...!#..V........
 80003dc:	2802b89e 5f058808 c60cd9b2 b10be924     ...(..._....$...
 80003ec:	2f6f7c87 58684c11 c1611dab b6662d3d     .|o/.LhX..a.=-f.
 80003fc:	76dc4190 01db7106 98d220bc efd5102a     .A.v.q... ..*...
 800040c:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     ...q........3...
 800041c:	7807c9a2 0f00f934 9609a88e e10e9818     ...x4...........
 800042c:	7f6a0dbb 086d3d2d 91646c97 e6635c01     ..j.-=m..ld..\c.
 800043c:	6b6b51f4 1c6c6162 856530d8 f262004e     .Qkkbal..0e.N.b.
 800044c:	6c0695ed 1b01a57b 8208f4c1 f50fc457     ...l{.......W...
 800045c:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     ...eP.......|...
 800046c:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     ...bI-...|..eL..
 800047c:	4db26158 3ab551ce a3bc0074 d4bb30e2     Xa.M.Q.:t....0..
 800048c:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     A..J...=m.......
 800049c:	4369e96a 346ed9fc ad678846 da60b8d0     j.iC..n4F.g...`.
 80004ac:	44042d73 33031de5 aa0a4c5f dd0d7cc9     s-.D...3_L...|..
 80004bc:	5005713c 270241aa be0b1010 c90c2086     <q.P.A.'..... ..
 80004cc:	5768b525 206f85b3 b966d409 ce61e49f     %.hW..o ..f...a.
 80004dc:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ...^...)".......
 80004ec:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     .=.Y....;\...l..
 80004fc:	edb88320 9abfb3b6 03b6e20c 74b1d29a      ..............t
 800050c:	ead54739 9dd277af 04db2615 73dc1683     9G...w...&.....s
 800051c:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     ..c..;d.>jm..Zjz
 800052c:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ........'......}
 800053c:	f00f9344 8708a3d2 1e01f268 6906c2fe     D.......h......i
 800054c:	f762575d 806567cb 196c3671 6e6b06e7     ]Wb..ge.q6l...kn
 800055c:	fed41b76 89d32be0 10da7a5a 67dd4acc     v....+..Zz...J.g
 800056c:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     o.......C......`
 800057c:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     ....~......8R..O
 800058c:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     .g..gW.....?K6.H
 800059c:	d80d2bda af0a1b4c 36034af6 41047a60     .+..L....J.6`z.A
 80005ac:	df60efc3 a867df55 316e8eef 4669be79     ..`.U.g...n1y.iF
 80005bc:	cb61b38c bc66831a 256fd2a0 5268e236     ..a...f...o%6.hR
 80005cc:	cc0c7795 bb0b4703 220216b9 5505262f     .w...G....."/&.U
 80005dc:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     .;..(....Z.+.j.\
 80005ec:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     ....1......,...[
 80005fc:	9b64c2b0 ec63f226 756aa39c 026d930a     ..d.&.c...ju..m.
 800060c:	9c0906a9 eb0e363f 72076785 05005713     ....?6...g.r.W..
 800061c:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     .J...z...+.{8...
 800062c:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ...........|!...
 800063c:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     ....B......hn...
 800064c:	81be16cd f6b9265b 6fb077e1 18b74777     ....[&...w.owG..
 800065c:	88085ae6 ff0f6a70 66063bca 11010b5c     .Z..pj...;.f\...
 800066c:	8f659eff f862ae69 616bffd3 166ccf45     ..e.i.b...kaE.l.
 800067c:	a00ae278 d70dd2ee 4e048354 3903b3c2     x.......T..N...9
 800068c:	a7672661 d06016f7 4969474d 3e6e77db     a&g...`.MGiI.wn>
 800069c:	aed16a4a d9d65adc 40df0b66 37d83bf0     Jj...Z..f..@.;.7
 80006ac:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     S..........G...0
 80006bc:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........0..S...$
 80006cc:	bad03605 cdd70693 54de5729 23d967bf     .6......)W.T.g.#
 80006dc:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .zf..Ja...h].+o*
 80006ec:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     7..........Z...-

080006fc <crc16_tab>:
 80006fc:	c0c10000 0140c181 03c0c301 c2410280     ......@.......A.
 800070c:	06c0c601 c7410780 c5c10500 0440c481     ......A.......@.
 800071c:	0cc0cc01 cd410d80 cfc10f00 0e40ce81     ......A.......@.
 800072c:	cac10a00 0b40cb81 09c0c901 c8410880     ......@.......A.
 800073c:	18c0d801 d9411980 dbc11b00 1a40da81     ......A.......@.
 800074c:	dec11e00 1f40df81 1dc0dd01 dc411c80     ......@.......A.
 800075c:	d4c11400 1540d581 17c0d701 d6411680     ......@.......A.
 800076c:	12c0d201 d3411380 d1c11100 1040d081     ......A.......@.
 800077c:	30c0f001 f1413180 f3c13300 3240f281     ...0.1A..3....@2
 800078c:	f6c13600 3740f781 35c0f501 f4413480     .6....@7...5.4A.
 800079c:	fcc13c00 3d40fd81 3fc0ff01 fe413e80     .<....@=...?.>A.
 80007ac:	3ac0fa01 fb413b80 f9c13900 3840f881     ...:.;A..9....@8
 80007bc:	e8c12800 2940e981 2bc0eb01 ea412a80     .(....@)...+.*A.
 80007cc:	2ec0ee01 ef412f80 edc12d00 2c40ec81     ...../A..-....@,
 80007dc:	24c0e401 e5412580 e7c12700 2640e681     ...$.%A..'....@&
 80007ec:	e2c12200 2340e381 21c0e101 e0412080     ."....@#...!. A.
 80007fc:	60c0a001 a1416180 a3c16300 6240a281     ...`.aA..c....@b
 800080c:	a6c16600 6740a781 65c0a501 a4416480     .f....@g...e.dA.
 800081c:	acc16c00 6d40ad81 6fc0af01 ae416e80     .l....@m...o.nA.
 800082c:	6ac0aa01 ab416b80 a9c16900 6840a881     ...j.kA..i....@h
 800083c:	b8c17800 7940b981 7bc0bb01 ba417a80     .x....@y...{.zA.
 800084c:	7ec0be01 bf417f80 bdc17d00 7c40bc81     ...~..A..}....@|
 800085c:	74c0b401 b5417580 b7c17700 7640b681     ...t.uA..w....@v
 800086c:	b2c17200 7340b381 71c0b101 b0417080     .r....@s...q.pA.
 800087c:	90c15000 51409181 53c09301 92415280     .P....@Q...S.RA.
 800088c:	56c09601 97415780 95c15500 54409481     ...V.WA..U....@T
 800089c:	5cc09c01 9d415d80 9fc15f00 5e409e81     ...\.]A.._....@^
 80008ac:	9ac15a00 5b409b81 59c09901 98415880     .Z....@[...Y.XA.
 80008bc:	48c08801 89414980 8bc14b00 4a408a81     ...H.IA..K....@J
 80008cc:	8ec14e00 4f408f81 4dc08d01 8c414c80     .N....@O...M.LA.
 80008dc:	84c14400 45408581 47c08701 86414680     .D....@E...G.FA.
 80008ec:	42c08201 83414380 81c14100 40408081     ...B.CA..A....@@

080008fc <FLASH_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 80008fc:	4b04      	ldr	r3, [pc, #16]	; (8000910 <FLASH_Unlock+0x14>)
 80008fe:	691a      	ldr	r2, [r3, #16]
 8000900:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8000902:	bfbf      	itttt	lt
 8000904:	4a03      	ldrlt	r2, [pc, #12]	; (8000914 <FLASH_Unlock+0x18>)
 8000906:	605a      	strlt	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8000908:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 800090c:	605a      	strlt	r2, [r3, #4]
 800090e:	4770      	bx	lr
 8000910:	40023c00 	.word	0x40023c00
 8000914:	45670123 	.word	0x45670123

08000918 <FLASH_ClearFlag>:
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
 8000918:	f420 73f9 	bic.w	r3, r0, #498	; 0x1f2
 800091c:	f023 0301 	bic.w	r3, r3, #1
  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
  *            @arg FLASH_FLAG_RDERR: FLASH Read Protection error flag (STM32F42/43xxx and STM32F401xx devices)   
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
 8000920:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
 8000922:	b923      	cbnz	r3, 800092e <FLASH_ClearFlag+0x16>
 8000924:	b118      	cbz	r0, 800092e <FLASH_ClearFlag+0x16>
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8000926:	4b05      	ldr	r3, [pc, #20]	; (800093c <FLASH_ClearFlag+0x24>)
 8000928:	60d8      	str	r0, [r3, #12]
}
 800092a:	b002      	add	sp, #8
 800092c:	4770      	bx	lr
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
 800092e:	2301      	movs	r3, #1
 8000930:	9301      	str	r3, [sp, #4]
 8000932:	9b01      	ldr	r3, [sp, #4]
 8000934:	2b00      	cmp	r3, #0
 8000936:	d1fc      	bne.n	8000932 <FLASH_ClearFlag+0x1a>
 8000938:	e7f5      	b.n	8000926 <FLASH_ClearFlag+0xe>
 800093a:	bf00      	nop
 800093c:	40023c00 	.word	0x40023c00

08000940 <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8000940:	4b0e      	ldr	r3, [pc, #56]	; (800097c <FLASH_GetStatus+0x3c>)
 8000942:	68da      	ldr	r2, [r3, #12]
 8000944:	03d2      	lsls	r2, r2, #15
 8000946:	d410      	bmi.n	800096a <FLASH_GetStatus+0x2a>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 8000948:	68da      	ldr	r2, [r3, #12]
 800094a:	06d1      	lsls	r1, r2, #27
 800094c:	d40f      	bmi.n	800096e <FLASH_GetStatus+0x2e>
    { 
      flashstatus = FLASH_ERROR_WRP;
    }
    else
    {
      if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
 800094e:	68da      	ldr	r2, [r3, #12]
 8000950:	05d2      	lsls	r2, r2, #23
 8000952:	d40e      	bmi.n	8000972 <FLASH_GetStatus+0x32>
      { 
        flashstatus = FLASH_ERROR_RD;
      } 
      else 
      {
        if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 8000954:	68da      	ldr	r2, [r3, #12]
 8000956:	f012 0fef 	tst.w	r2, #239	; 0xef
 800095a:	d10c      	bne.n	8000976 <FLASH_GetStatus+0x36>
        {
          flashstatus = FLASH_ERROR_PROGRAM; 
        }
        else
        {
          if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 800095c:	68db      	ldr	r3, [r3, #12]
 800095e:	f013 0f02 	tst.w	r3, #2
          {
            flashstatus = FLASH_ERROR_OPERATION;
          }
          else
          {
            flashstatus = FLASH_COMPLETE;
 8000962:	bf14      	ite	ne
 8000964:	2008      	movne	r0, #8
 8000966:	2009      	moveq	r0, #9
 8000968:	4770      	bx	lr
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
  {
    flashstatus = FLASH_BUSY;
 800096a:	2001      	movs	r0, #1
 800096c:	4770      	bx	lr
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
    { 
      flashstatus = FLASH_ERROR_WRP;
 800096e:	2006      	movs	r0, #6
 8000970:	4770      	bx	lr
    }
    else
    {
      if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
      { 
        flashstatus = FLASH_ERROR_RD;
 8000972:	2002      	movs	r0, #2
 8000974:	4770      	bx	lr
      } 
      else 
      {
        if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
        {
          flashstatus = FLASH_ERROR_PROGRAM; 
 8000976:	2007      	movs	r0, #7
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
}
 8000978:	4770      	bx	lr
 800097a:	bf00      	nop
 800097c:	40023c00 	.word	0x40023c00

08000980 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 8000980:	b507      	push	{r0, r1, r2, lr}
  __IO FLASH_Status status = FLASH_COMPLETE;
 8000982:	2309      	movs	r3, #9
 8000984:	f88d 3007 	strb.w	r3, [sp, #7]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
  {
    status = FLASH_GetStatus();
 8000988:	f7ff ffda 	bl	8000940 <FLASH_GetStatus>
 800098c:	f88d 0007 	strb.w	r0, [sp, #7]
  status = FLASH_GetStatus();

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 8000990:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000994:	2b01      	cmp	r3, #1
 8000996:	d0f7      	beq.n	8000988 <FLASH_WaitForLastOperation+0x8>
  {
    status = FLASH_GetStatus();
  }
  /* Return the operation status */
  return status;
 8000998:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 800099c:	b003      	add	sp, #12
 800099e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080009a4 <FLASH_EraseSector>:
{
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
 80009a4:	f030 0318 	bics.w	r3, r0, #24
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 80009a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80009aa:	4606      	mov	r6, r0
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
 80009ac:	d104      	bne.n	80009b8 <FLASH_EraseSector+0x14>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 80009ae:	2903      	cmp	r1, #3
 80009b0:	d916      	bls.n	80009e0 <FLASH_EraseSector+0x3c>
 80009b2:	2301      	movs	r3, #1
 80009b4:	9301      	str	r3, [sp, #4]
 80009b6:	e00f      	b.n	80009d8 <FLASH_EraseSector+0x34>
{
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
 80009b8:	2b20      	cmp	r3, #32
 80009ba:	d0f8      	beq.n	80009ae <FLASH_EraseSector+0xa>
 80009bc:	2b40      	cmp	r3, #64	; 0x40
 80009be:	d0f6      	beq.n	80009ae <FLASH_EraseSector+0xa>
 80009c0:	2b80      	cmp	r3, #128	; 0x80
 80009c2:	d0f4      	beq.n	80009ae <FLASH_EraseSector+0xa>
 80009c4:	2ba0      	cmp	r3, #160	; 0xa0
 80009c6:	d0f2      	beq.n	80009ae <FLASH_EraseSector+0xa>
 80009c8:	2bc0      	cmp	r3, #192	; 0xc0
 80009ca:	d0f0      	beq.n	80009ae <FLASH_EraseSector+0xa>
 80009cc:	2301      	movs	r3, #1
 80009ce:	9300      	str	r3, [sp, #0]
 80009d0:	9b00      	ldr	r3, [sp, #0]
 80009d2:	2b00      	cmp	r3, #0
 80009d4:	d1fc      	bne.n	80009d0 <FLASH_EraseSector+0x2c>
 80009d6:	e7ea      	b.n	80009ae <FLASH_EraseSector+0xa>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 80009d8:	9b01      	ldr	r3, [sp, #4]
 80009da:	2b00      	cmp	r3, #0
 80009dc:	d1fc      	bne.n	80009d8 <FLASH_EraseSector+0x34>
 80009de:	e002      	b.n	80009e6 <FLASH_EraseSector+0x42>
  
  if(VoltageRange == VoltageRange_1)
 80009e0:	b159      	cbz	r1, 80009fa <FLASH_EraseSector+0x56>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 80009e2:	2901      	cmp	r1, #1
 80009e4:	d006      	beq.n	80009f4 <FLASH_EraseSector+0x50>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
  {
    tmp_psize = FLASH_PSIZE_WORD;
 80009e6:	2902      	cmp	r1, #2
 80009e8:	bf14      	ite	ne
 80009ea:	f44f 7540 	movne.w	r5, #768	; 0x300
 80009ee:	f44f 7500 	moveq.w	r5, #512	; 0x200
 80009f2:	e003      	b.n	80009fc <FLASH_EraseSector+0x58>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 80009f4:	f44f 7580 	mov.w	r5, #256	; 0x100
 80009f8:	e000      	b.n	80009fc <FLASH_EraseSector+0x58>
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 80009fa:	460d      	mov	r5, r1
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80009fc:	f7ff ffc0 	bl	8000980 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000a00:	2809      	cmp	r0, #9
 8000a02:	d11e      	bne.n	8000a42 <FLASH_EraseSector+0x9e>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 8000a04:	4c10      	ldr	r4, [pc, #64]	; (8000a48 <FLASH_EraseSector+0xa4>)
 8000a06:	6923      	ldr	r3, [r4, #16]
 8000a08:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000a0c:	6123      	str	r3, [r4, #16]
    FLASH->CR |= tmp_psize;
 8000a0e:	6921      	ldr	r1, [r4, #16]
 8000a10:	4329      	orrs	r1, r5
 8000a12:	6121      	str	r1, [r4, #16]
    FLASH->CR &= SECTOR_MASK;
 8000a14:	6923      	ldr	r3, [r4, #16]
 8000a16:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000a1a:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 8000a1c:	6923      	ldr	r3, [r4, #16]
 8000a1e:	f043 0302 	orr.w	r3, r3, #2
 8000a22:	431e      	orrs	r6, r3
 8000a24:	6126      	str	r6, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8000a26:	6923      	ldr	r3, [r4, #16]
 8000a28:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000a2c:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000a2e:	f7ff ffa7 	bl	8000980 <FLASH_WaitForLastOperation>
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 8000a32:	6923      	ldr	r3, [r4, #16]
 8000a34:	f023 0302 	bic.w	r3, r3, #2
 8000a38:	6123      	str	r3, [r4, #16]
    FLASH->CR &= SECTOR_MASK; 
 8000a3a:	6923      	ldr	r3, [r4, #16]
 8000a3c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000a40:	6123      	str	r3, [r4, #16]
  }
  /* Return the Erase Status */
  return status;
}
 8000a42:	b002      	add	sp, #8
 8000a44:	bd70      	pop	{r4, r5, r6, pc}
 8000a46:	bf00      	nop
 8000a48:	40023c00 	.word	0x40023c00

08000a4c <FLASH_ProgramWord>:
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
 8000a4c:	4b18      	ldr	r3, [pc, #96]	; (8000ab0 <FLASH_ProgramWord+0x64>)
 8000a4e:	f100 4278 	add.w	r2, r0, #4160749568	; 0xf8000000
 8000a52:	429a      	cmp	r2, r3
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8000a54:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8000a56:	4605      	mov	r5, r0
 8000a58:	460e      	mov	r6, r1
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
 8000a5a:	d818      	bhi.n	8000a8e <FLASH_ProgramWord+0x42>

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8000a5c:	f7ff ff90 	bl	8000980 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8000a60:	2809      	cmp	r0, #9
 8000a62:	d122      	bne.n	8000aaa <FLASH_ProgramWord+0x5e>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8000a64:	4c13      	ldr	r4, [pc, #76]	; (8000ab4 <FLASH_ProgramWord+0x68>)
 8000a66:	6923      	ldr	r3, [r4, #16]
 8000a68:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000a6c:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 8000a6e:	6923      	ldr	r3, [r4, #16]
 8000a70:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000a74:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8000a76:	6923      	ldr	r3, [r4, #16]
 8000a78:	f043 0301 	orr.w	r3, r3, #1
 8000a7c:	6123      	str	r3, [r4, #16]
  
    *(__IO uint32_t*)Address = Data;
 8000a7e:	602e      	str	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8000a80:	f7ff ff7e 	bl	8000980 <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8000a84:	6923      	ldr	r3, [r4, #16]
 8000a86:	f023 0301 	bic.w	r3, r3, #1
 8000a8a:	6123      	str	r3, [r4, #16]
 8000a8c:	e00d      	b.n	8000aaa <FLASH_ProgramWord+0x5e>
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
 8000a8e:	f100 4360 	add.w	r3, r0, #3758096384	; 0xe0000000
 8000a92:	f503 4308 	add.w	r3, r3, #34816	; 0x8800
 8000a96:	f240 220e 	movw	r2, #526	; 0x20e
 8000a9a:	4293      	cmp	r3, r2
 8000a9c:	d9de      	bls.n	8000a5c <FLASH_ProgramWord+0x10>
 8000a9e:	2301      	movs	r3, #1
 8000aa0:	9301      	str	r3, [sp, #4]
 8000aa2:	9b01      	ldr	r3, [sp, #4]
 8000aa4:	2b00      	cmp	r3, #0
 8000aa6:	d1fc      	bne.n	8000aa2 <FLASH_ProgramWord+0x56>
 8000aa8:	e7d8      	b.n	8000a5c <FLASH_ProgramWord+0x10>
    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
  } 
  /* Return the Program Status */
  return status;
}
 8000aaa:	b002      	add	sp, #8
 8000aac:	bd70      	pop	{r4, r5, r6, pc}
 8000aae:	bf00      	nop
 8000ab0:	000ffffe 	.word	0x000ffffe
 8000ab4:	40023c00 	.word	0x40023c00

Disassembly of section .text:

08008000 <_new_image>:
 8008000:	10001000 	.word	0x10001000
 8008004:	080081e5 	.word	0x080081e5
 8008008:	08008299 	.word	0x08008299
 800800c:	08008449 	.word	0x08008449
 8008010:	08008299 	.word	0x08008299
 8008014:	08008299 	.word	0x08008299
 8008018:	08008299 	.word	0x08008299
 800801c:	08008259 	.word	0x08008259
 8008020:	08008259 	.word	0x08008259
 8008024:	08008259 	.word	0x08008259
 8008028:	08008259 	.word	0x08008259
 800802c:	0800a0c9 	.word	0x0800a0c9
 8008030:	08008299 	.word	0x08008299
 8008034:	08008259 	.word	0x08008259
 8008038:	0800a16d 	.word	0x0800a16d
 800803c:	08008331 	.word	0x08008331
 8008040:	08008259 	.word	0x08008259
 8008044:	08008259 	.word	0x08008259
 8008048:	08008259 	.word	0x08008259
 800804c:	08008259 	.word	0x08008259
 8008050:	08008259 	.word	0x08008259
 8008054:	08008259 	.word	0x08008259
 8008058:	08008259 	.word	0x08008259
 800805c:	08008259 	.word	0x08008259
 8008060:	08008259 	.word	0x08008259
 8008064:	08008259 	.word	0x08008259
 8008068:	08008259 	.word	0x08008259
 800806c:	08008259 	.word	0x08008259
 8008070:	08008259 	.word	0x08008259
 8008074:	08008259 	.word	0x08008259
 8008078:	08008259 	.word	0x08008259
 800807c:	08008259 	.word	0x08008259
 8008080:	08008259 	.word	0x08008259
 8008084:	08008259 	.word	0x08008259
 8008088:	08008259 	.word	0x08008259
 800808c:	08008259 	.word	0x08008259
 8008090:	08008259 	.word	0x08008259
 8008094:	08008259 	.word	0x08008259
 8008098:	08008259 	.word	0x08008259
 800809c:	08008259 	.word	0x08008259
 80080a0:	08008259 	.word	0x08008259
 80080a4:	08008259 	.word	0x08008259
 80080a8:	08008259 	.word	0x08008259
 80080ac:	08008259 	.word	0x08008259
 80080b0:	08008259 	.word	0x08008259
 80080b4:	08008259 	.word	0x08008259
 80080b8:	08008259 	.word	0x08008259
 80080bc:	08008259 	.word	0x08008259
 80080c0:	08008259 	.word	0x08008259
 80080c4:	08008259 	.word	0x08008259
 80080c8:	08008259 	.word	0x08008259
 80080cc:	08008259 	.word	0x08008259
 80080d0:	08008259 	.word	0x08008259
 80080d4:	08008259 	.word	0x08008259
 80080d8:	08008259 	.word	0x08008259
 80080dc:	08008259 	.word	0x08008259
 80080e0:	08008259 	.word	0x08008259
 80080e4:	08008259 	.word	0x08008259
 80080e8:	08008259 	.word	0x08008259
 80080ec:	08008259 	.word	0x08008259
 80080f0:	08008259 	.word	0x08008259
 80080f4:	08008259 	.word	0x08008259
 80080f8:	08008259 	.word	0x08008259
 80080fc:	08008259 	.word	0x08008259
 8008100:	08008259 	.word	0x08008259
 8008104:	08008259 	.word	0x08008259
 8008108:	08008259 	.word	0x08008259
 800810c:	08008259 	.word	0x08008259
 8008110:	08008259 	.word	0x08008259
 8008114:	08008259 	.word	0x08008259
 8008118:	08008259 	.word	0x08008259
 800811c:	08008259 	.word	0x08008259
 8008120:	08008259 	.word	0x08008259
 8008124:	08008259 	.word	0x08008259
 8008128:	08008259 	.word	0x08008259
 800812c:	08008259 	.word	0x08008259
 8008130:	08008259 	.word	0x08008259
 8008134:	08008259 	.word	0x08008259
 8008138:	08008259 	.word	0x08008259
 800813c:	08008259 	.word	0x08008259
 8008140:	08008259 	.word	0x08008259
 8008144:	08008259 	.word	0x08008259
 8008148:	08008259 	.word	0x08008259
 800814c:	08008259 	.word	0x08008259
 8008150:	08008259 	.word	0x08008259
 8008154:	08008259 	.word	0x08008259
 8008158:	08008259 	.word	0x08008259
 800815c:	08008259 	.word	0x08008259
 8008160:	08008259 	.word	0x08008259
 8008164:	08008259 	.word	0x08008259
 8008168:	08008259 	.word	0x08008259
 800816c:	08008259 	.word	0x08008259
 8008170:	08008259 	.word	0x08008259
 8008174:	08008259 	.word	0x08008259
 8008178:	08008259 	.word	0x08008259
 800817c:	08008259 	.word	0x08008259
 8008180:	08008259 	.word	0x08008259
 8008184:	08008259 	.word	0x08008259

08008188 <_init>:
 8008188:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800818a:	bf00      	nop
 800818c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800818e:	bc08      	pop	{r3}
 8008190:	469e      	mov	lr, r3
 8008192:	4770      	bx	lr

08008194 <_fini>:
 8008194:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008196:	bf00      	nop
 8008198:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800819a:	bc08      	pop	{r3}
 800819c:	469e      	mov	lr, r3
 800819e:	4770      	bx	lr

080081a0 <systemInit>:


///////////////////////////////////////////////////
/*-----------------------------------------------------------*/
void systemInit(void)
{
 80081a0:	b508      	push	{r3, lr}
  hwBoardInit();
 80081a2:	f007 fd41 	bl	800fc28 <hwBoardInit>

  void messageProcessorInit(void);
  messageProcessorInit();
 80081a6:	f000 fb11 	bl	80087cc <messageProcessorInit>

  /* Initialize tasks */
  LEDInit();
 80081aa:	f004 feb9 	bl	800cf20 <LEDInit>
  ADCInit();
 80081ae:	f005 f9db 	bl	800d568 <ADCInit>
  spiHelperInit();
 80081b2:	f003 ffbd 	bl	800c130 <spiHelperInit>
  CommunicatorInit();
 80081b6:	f003 f88b 	bl	800b2d0 <CommunicatorInit>
  HWCommInit();
 80081ba:	f003 fce7 	bl	800bb8c <HWCommInit>
  debugInit();
 80081be:	f006 fde7 	bl	800ed90 <debugInit>
  tasksInitEnd();
}
 80081c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  ADCInit();
  spiHelperInit();
  CommunicatorInit();
  HWCommInit();
  debugInit();
  tasksInitEnd();
 80081c6:	f000 b9c1 	b.w	800854c <tasksInitEnd>

080081ca <main>:
}
int main(void)
{
 80081ca:	b508      	push	{r3, lr}

  /* Set up the clocks and memory interface. */
  /* Initialize HW ports, ADCs. LEDs */
  NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
 80081cc:	f44f 7040 	mov.w	r0, #768	; 0x300
 80081d0:	f008 fdba 	bl	8010d48 <NVIC_PriorityGroupConfig>
  SystemInit();
 80081d4:	f008 fd6a 	bl	8010cac <SystemInit>
  watchdogInit();
 80081d8:	f006 fe5e 	bl	800ee98 <watchdogInit>

  vTaskStartScheduler();
 80081dc:	f002 fa30 	bl	800a640 <vTaskStartScheduler>
 80081e0:	e7fe      	b.n	80081e0 <main+0x16>
	...

080081e4 <Reset_Handler>:


void Reset_Handler(void)
{
#ifdef DEBUG
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80081e4:	4a12      	ldr	r2, [pc, #72]	; (8008230 <Reset_Handler+0x4c>)

  //Move initialization data int RAM
  uint32_t *dst = (uint32_t *) & __sdata;
  uint32_t *src = (uint32_t *) & __etext;

  while (dst < (uint32_t *) & __edata)
 80081e6:	4913      	ldr	r1, [pc, #76]	; (8008234 <Reset_Handler+0x50>)


void Reset_Handler(void)
{
#ifdef DEBUG
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80081e8:	68d3      	ldr	r3, [r2, #12]
 80081ea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80081ee:	60d3      	str	r3, [r2, #12]
 80081f0:	4a11      	ldr	r2, [pc, #68]	; (8008238 <Reset_Handler+0x54>)
 80081f2:	4b12      	ldr	r3, [pc, #72]	; (800823c <Reset_Handler+0x58>)

  //Move initialization data int RAM
  uint32_t *dst = (uint32_t *) & __sdata;
  uint32_t *src = (uint32_t *) & __etext;

  while (dst < (uint32_t *) & __edata)
 80081f4:	428b      	cmp	r3, r1
 80081f6:	d204      	bcs.n	8008202 <Reset_Handler+0x1e>
    *(dst++) = *(src++);
 80081f8:	f852 0f04 	ldr.w	r0, [r2, #4]!
 80081fc:	f843 0b04 	str.w	r0, [r3], #4
 8008200:	e7f8      	b.n	80081f4 <Reset_Handler+0x10>

  int irq;

  for (irq = 0; irq < IRQ_HANDLER_POOL; irq++)
    pool[irq].next = &pool[irq + 1];
 8008202:	490f      	ldr	r1, [pc, #60]	; (8008240 <Reset_Handler+0x5c>)
 8008204:	2300      	movs	r3, #0
 8008206:	f103 0208 	add.w	r2, r3, #8
 800820a:	1888      	adds	r0, r1, r2
  while (dst < (uint32_t *) & __edata)
    *(dst++) = *(src++);

  int irq;

  for (irq = 0; irq < IRQ_HANDLER_POOL; irq++)
 800820c:	f5b2 7f44 	cmp.w	r2, #784	; 0x310
    pool[irq].next = &pool[irq + 1];
 8008210:	5058      	str	r0, [r3, r1]
 8008212:	4613      	mov	r3, r2
 8008214:	4a0b      	ldr	r2, [pc, #44]	; (8008244 <Reset_Handler+0x60>)
  while (dst < (uint32_t *) & __edata)
    *(dst++) = *(src++);

  int irq;

  for (irq = 0; irq < IRQ_HANDLER_POOL; irq++)
 8008216:	d1f6      	bne.n	8008206 <Reset_Handler+0x22>
    pool[irq].next = &pool[irq + 1];
  pool[IRQ_HANDLER_POOL - 1].next = NULL;
 8008218:	2300      	movs	r3, #0
 800821a:	f8c2 3490 	str.w	r3, [r2, #1168]	; 0x490
  for (irq = 0; irq < ISR_SIZE; irq++)
    handlers[irq] = NULL;
 800821e:	4619      	mov	r1, r3
 8008220:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  int irq;

  for (irq = 0; irq < IRQ_HANDLER_POOL; irq++)
    pool[irq].next = &pool[irq + 1];
  pool[IRQ_HANDLER_POOL - 1].next = NULL;
  for (irq = 0; irq < ISR_SIZE; irq++)
 8008224:	3301      	adds	r3, #1
 8008226:	2b62      	cmp	r3, #98	; 0x62
 8008228:	d1fa      	bne.n	8008220 <Reset_Handler+0x3c>
    handlers[irq] = NULL;

  main();
 800822a:	f7ff bfce 	b.w	80081ca <main>
 800822e:	bf00      	nop
 8008230:	e000edf0 	.word	0xe000edf0
 8008234:	2001af23 	.word	0x2001af23
 8008238:	0801e590 	.word	0x0801e590
 800823c:	2001a1d0 	.word	0x2001a1d0
 8008240:	20018188 	.word	0x20018188
 8008244:	20018000 	.word	0x20018000

08008248 <amIInIRQ>:
}

static int irqRef = 0;
int amIInIRQ(void)
{
  return (irqRef != 0);
 8008248:	4b02      	ldr	r3, [pc, #8]	; (8008254 <amIInIRQ+0xc>)
 800824a:	6818      	ldr	r0, [r3, #0]
}
 800824c:	3000      	adds	r0, #0
 800824e:	bf18      	it	ne
 8008250:	2001      	movne	r0, #1
 8008252:	4770      	bx	lr
 8008254:	2001ac08 	.word	0x2001ac08

08008258 <IRQHandler>:

static void __attribute__ ((no_instrument_function, interrupt, optimize("-O3"))) IRQHandler(void)
{
 8008258:	4668      	mov	r0, sp
 800825a:	f020 0107 	bic.w	r1, r0, #7
 800825e:	468d      	mov	sp, r1
 8008260:	b531      	push	{r0, r4, r5, lr}
  irqRef++;
 8008262:	4d0b      	ldr	r5, [pc, #44]	; (8008290 <IRQHandler+0x38>)
 8008264:	682b      	ldr	r3, [r5, #0]
 8008266:	3301      	adds	r3, #1
 8008268:	602b      	str	r3, [r5, #0]

  irqHandler_t *handle = handlers[getIrqNum()];
 800826a:	f000 f87b 	bl	8008364 <getIrqNum>
 800826e:	4b09      	ldr	r3, [pc, #36]	; (8008294 <IRQHandler+0x3c>)
 8008270:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]

  while (handle)
 8008274:	b124      	cbz	r4, 8008280 <IRQHandler+0x28>
    {
      handle->handler();
 8008276:	6863      	ldr	r3, [r4, #4]
 8008278:	4798      	blx	r3
      handle = handle->next;
 800827a:	6824      	ldr	r4, [r4, #0]
{
  irqRef++;

  irqHandler_t *handle = handlers[getIrqNum()];

  while (handle)
 800827c:	2c00      	cmp	r4, #0
 800827e:	d1fa      	bne.n	8008276 <IRQHandler+0x1e>
    {
      handle->handler();
      handle = handle->next;
    }
  irqRef--;
 8008280:	682b      	ldr	r3, [r5, #0]
 8008282:	3b01      	subs	r3, #1
 8008284:	602b      	str	r3, [r5, #0]
}
 8008286:	e8bd 4031 	ldmia.w	sp!, {r0, r4, r5, lr}
 800828a:	4685      	mov	sp, r0
 800828c:	4770      	bx	lr
 800828e:	bf00      	nop
 8008290:	2001ac08 	.word	0x2001ac08
 8008294:	20018000 	.word	0x20018000

08008298 <BusFault_Handler>:

static void __attribute__ ((no_instrument_function, interrupt)) Unused_Handler(void)
{
 8008298:	4668      	mov	r0, sp
 800829a:	f020 0107 	bic.w	r1, r0, #7
 800829e:	468d      	mov	sp, r1
 80082a0:	b501      	push	{r0, lr}
}
 80082a2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 80082a6:	4685      	mov	sp, r0
 80082a8:	4770      	bx	lr
	...

080082ac <registerIRQ>:


int registerIRQ(int irq, void (*handler) (void))
{
 80082ac:	b538      	push	{r3, r4, r5, lr}
 80082ae:	4604      	mov	r4, r0
 80082b0:	460d      	mov	r5, r1
  taskENTER_CRITICAL();
 80082b2:	f001 ff3f 	bl	800a134 <vPortEnterCritical>
  if (!poolFree)
 80082b6:	4a19      	ldr	r2, [pc, #100]	; (800831c <registerIRQ+0x70>)
 80082b8:	6813      	ldr	r3, [r2, #0]
 80082ba:	b95b      	cbnz	r3, 80082d4 <registerIRQ+0x28>
    {
      taskEXIT_CRITICAL();
 80082bc:	f001 ff4c 	bl	800a158 <vPortExitCritical>
      dprintf(LL_ERROR, "IRQ handlers pool depleted.");
 80082c0:	4b17      	ldr	r3, [pc, #92]	; (8008320 <registerIRQ+0x74>)
 80082c2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80082c4:	2b00      	cmp	r3, #0
 80082c6:	db22      	blt.n	800830e <registerIRQ+0x62>
 80082c8:	4816      	ldr	r0, [pc, #88]	; (8008324 <registerIRQ+0x78>)
 80082ca:	f000 fa4b 	bl	8008764 <xprintf>
      return -1;
 80082ce:	f04f 30ff 	mov.w	r0, #4294967295
 80082d2:	bd38      	pop	{r3, r4, r5, pc}
    }
  irq += 16;
 80082d4:	f104 0010 	add.w	r0, r4, #16
  if (irq >= ISR_SIZE)
 80082d8:	2861      	cmp	r0, #97	; 0x61
 80082da:	dd0b      	ble.n	80082f4 <registerIRQ+0x48>
    {
      taskEXIT_CRITICAL();
 80082dc:	f001 ff3c 	bl	800a158 <vPortExitCritical>
      dprintf(LL_ERROR, "IRQ handler index invalid.");
 80082e0:	4b0f      	ldr	r3, [pc, #60]	; (8008320 <registerIRQ+0x74>)
 80082e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80082e4:	2b00      	cmp	r3, #0
 80082e6:	db15      	blt.n	8008314 <registerIRQ+0x68>
 80082e8:	480f      	ldr	r0, [pc, #60]	; (8008328 <registerIRQ+0x7c>)
 80082ea:	f000 fa3b 	bl	8008764 <xprintf>
      return -2;
 80082ee:	f06f 0001 	mvn.w	r0, #1
 80082f2:	bd38      	pop	{r3, r4, r5, pc}
    }
  irqHandler_t *handle = poolFree;

  poolFree = poolFree->next;
 80082f4:	6819      	ldr	r1, [r3, #0]
 80082f6:	6011      	str	r1, [r2, #0]

  handle->next = handlers[irq];
 80082f8:	4a0c      	ldr	r2, [pc, #48]	; (800832c <registerIRQ+0x80>)
 80082fa:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
 80082fe:	6019      	str	r1, [r3, #0]
  handlers[irq] = handle;
 8008300:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  handle->handler = handler;
 8008304:	605d      	str	r5, [r3, #4]
  taskEXIT_CRITICAL();
 8008306:	f001 ff27 	bl	800a158 <vPortExitCritical>
  return 0;
 800830a:	2000      	movs	r0, #0
 800830c:	bd38      	pop	{r3, r4, r5, pc}
  taskENTER_CRITICAL();
  if (!poolFree)
    {
      taskEXIT_CRITICAL();
      dprintf(LL_ERROR, "IRQ handlers pool depleted.");
      return -1;
 800830e:	f04f 30ff 	mov.w	r0, #4294967295
 8008312:	bd38      	pop	{r3, r4, r5, pc}
  irq += 16;
  if (irq >= ISR_SIZE)
    {
      taskEXIT_CRITICAL();
      dprintf(LL_ERROR, "IRQ handler index invalid.");
      return -2;
 8008314:	f06f 0001 	mvn.w	r0, #1
  handle->next = handlers[irq];
  handlers[irq] = handle;
  handle->handler = handler;
  taskEXIT_CRITICAL();
  return 0;
}
 8008318:	bd38      	pop	{r3, r4, r5, pc}
 800831a:	bf00      	nop
 800831c:	2001a1d0 	.word	0x2001a1d0
 8008320:	10001000 	.word	0x10001000
 8008324:	0801471c 	.word	0x0801471c
 8008328:	08014738 	.word	0x08014738
 800832c:	20018000 	.word	0x20018000

08008330 <sysTickHandler>:
void xPortSysTickHandler(void);
static uint64_t uptime = 0;
static uint64_t preciseUptime = 0;

void sysTickHandler(void)
{
 8008330:	4668      	mov	r0, sp
 8008332:	f020 0107 	bic.w	r1, r0, #7
 8008336:	468d      	mov	sp, r1
 8008338:	b531      	push	{r0, r4, r5, lr}
  uptime += 1000000ULL;
 800833a:	4908      	ldr	r1, [pc, #32]	; (800835c <sysTickHandler+0x2c>)
 800833c:	4a08      	ldr	r2, [pc, #32]	; (8008360 <sysTickHandler+0x30>)
 800833e:	e9d1 4500 	ldrd	r4, r5, [r1]
 8008342:	2300      	movs	r3, #0
 8008344:	1912      	adds	r2, r2, r4
 8008346:	416b      	adcs	r3, r5
 8008348:	e9c1 2300 	strd	r2, r3, [r1]
  preciseUptime = uptime;
 800834c:	e9c1 2302 	strd	r2, r3, [r1, #8]
  xPortSysTickHandler();
 8008350:	f001 ff2a 	bl	800a1a8 <xPortSysTickHandler>
}
 8008354:	e8bd 4031 	ldmia.w	sp!, {r0, r4, r5, lr}
 8008358:	4685      	mov	sp, r0
 800835a:	4770      	bx	lr
 800835c:	2001ac10 	.word	0x2001ac10
 8008360:	000f4240 	.word	0x000f4240

08008364 <getIrqNum>:
  return primask & 1;
}
int getIrqNum(void)
{
  uint32_t irqNum;
  asm volatile ("mrs %0, ipsr":"=r" (irqNum));
 8008364:	f3ef 8005 	mrs	r0, IPSR
  return irqNum;
}
 8008368:	4770      	bx	lr

0800836a <vApplicationStackOverflowHook>:
    __asm volatile ("cpsie i");
}
/*-----------------------------------------------------------*/
void vApplicationStackOverflowHook(xTaskHandle pxTask, signed char *pcTaskName);
void vApplicationStackOverflowHook(xTaskHandle pxTask, signed char *pcTaskName)
{
 800836a:	b082      	sub	sp, #8
     parameters are corrupt then inspect pxCurrentTCB to find which was the
     offending task. */
  (void)pxTask;
  (void)pcTaskName;
  {
    volatile int s = 1;
 800836c:	2301      	movs	r3, #1
 800836e:	9301      	str	r3, [sp, #4]
    while (s);
 8008370:	9b01      	ldr	r3, [sp, #4]
 8008372:	2b00      	cmp	r3, #0
 8008374:	d1fc      	bne.n	8008370 <vApplicationStackOverflowHook+0x6>
  }
}
 8008376:	b002      	add	sp, #8
 8008378:	4770      	bx	lr
	...

0800837c <vApplicationMallocFailedHook>:

void vApplicationMallocFailedHook(void);
void vApplicationMallocFailedHook(void)
{
 800837c:	b507      	push	{r0, r1, r2, lr}
  dprintf(LL_ERROR, "Heap depleted\n");
 800837e:	4b07      	ldr	r3, [pc, #28]	; (800839c <vApplicationMallocFailedHook+0x20>)
 8008380:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008382:	2b00      	cmp	r3, #0
 8008384:	db02      	blt.n	800838c <vApplicationMallocFailedHook+0x10>
 8008386:	4806      	ldr	r0, [pc, #24]	; (80083a0 <vApplicationMallocFailedHook+0x24>)
 8008388:	f000 f9ec 	bl	8008764 <xprintf>
  {
    volatile int s = 1;
 800838c:	2301      	movs	r3, #1
 800838e:	9301      	str	r3, [sp, #4]
    while (s);
 8008390:	9b01      	ldr	r3, [sp, #4]
 8008392:	2b00      	cmp	r3, #0
 8008394:	d1fc      	bne.n	8008390 <vApplicationMallocFailedHook+0x14>
  }
}
 8008396:	b003      	add	sp, #12
 8008398:	f85d fb04 	ldr.w	pc, [sp], #4
 800839c:	10001000 	.word	0x10001000
 80083a0:	080147bf 	.word	0x080147bf

080083a4 <getRegistersFromStack>:

void HardFault_Handler(void);
#if 1
void  __attribute__ ((optimize("-O0"))) getRegistersFromStack( uint32_t *pulFaultStackAddress );
void  __attribute__ ((optimize("-O0"))) getRegistersFromStack( uint32_t *pulFaultStackAddress )
{
 80083a4:	b580      	push	{r7, lr}
 80083a6:	b086      	sub	sp, #24
 80083a8:	af02      	add	r7, sp, #8
 80083aa:	6078      	str	r0, [r7, #4]
  uint32_t sptr;
  asm("mov %0, sp": "=r" (sptr));
 80083ac:	466b      	mov	r3, sp
 80083ae:	60fb      	str	r3, [r7, #12]
  dprintf(LL_ERROR, "HARDFAULT!!\n");
 80083b0:	4b20      	ldr	r3, [pc, #128]	; (8008434 <getRegistersFromStack+0x90>)
 80083b2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80083b4:	2b00      	cmp	r3, #0
 80083b6:	db02      	blt.n	80083be <getRegistersFromStack+0x1a>
 80083b8:	481f      	ldr	r0, [pc, #124]	; (8008438 <getRegistersFromStack+0x94>)
 80083ba:	f000 f9d3 	bl	8008764 <xprintf>
  dprintf(LL_ERROR, "r0   %08x r1  %08x r2  %08x r3  %08x \n", pulFaultStackAddress[0], pulFaultStackAddress[1], pulFaultStackAddress[2], pulFaultStackAddress[3]);
 80083be:	4b1d      	ldr	r3, [pc, #116]	; (8008434 <getRegistersFromStack+0x90>)
 80083c0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80083c2:	2b00      	cmp	r3, #0
 80083c4:	db0f      	blt.n	80083e6 <getRegistersFromStack+0x42>
 80083c6:	687b      	ldr	r3, [r7, #4]
 80083c8:	6819      	ldr	r1, [r3, #0]
 80083ca:	687b      	ldr	r3, [r7, #4]
 80083cc:	3304      	adds	r3, #4
 80083ce:	681a      	ldr	r2, [r3, #0]
 80083d0:	687b      	ldr	r3, [r7, #4]
 80083d2:	3308      	adds	r3, #8
 80083d4:	6818      	ldr	r0, [r3, #0]
 80083d6:	687b      	ldr	r3, [r7, #4]
 80083d8:	330c      	adds	r3, #12
 80083da:	681b      	ldr	r3, [r3, #0]
 80083dc:	9300      	str	r3, [sp, #0]
 80083de:	4603      	mov	r3, r0
 80083e0:	4816      	ldr	r0, [pc, #88]	; (800843c <getRegistersFromStack+0x98>)
 80083e2:	f000 f9bf 	bl	8008764 <xprintf>
  dprintf(LL_ERROR, "r12  %08x lr  %08x pc  %08x psr %08x \n", pulFaultStackAddress[4], pulFaultStackAddress[5], pulFaultStackAddress[6], pulFaultStackAddress[7]);
 80083e6:	4b13      	ldr	r3, [pc, #76]	; (8008434 <getRegistersFromStack+0x90>)
 80083e8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80083ea:	2b00      	cmp	r3, #0
 80083ec:	db10      	blt.n	8008410 <getRegistersFromStack+0x6c>
 80083ee:	687b      	ldr	r3, [r7, #4]
 80083f0:	3310      	adds	r3, #16
 80083f2:	6819      	ldr	r1, [r3, #0]
 80083f4:	687b      	ldr	r3, [r7, #4]
 80083f6:	3314      	adds	r3, #20
 80083f8:	681a      	ldr	r2, [r3, #0]
 80083fa:	687b      	ldr	r3, [r7, #4]
 80083fc:	3318      	adds	r3, #24
 80083fe:	6818      	ldr	r0, [r3, #0]
 8008400:	687b      	ldr	r3, [r7, #4]
 8008402:	331c      	adds	r3, #28
 8008404:	681b      	ldr	r3, [r3, #0]
 8008406:	9300      	str	r3, [sp, #0]
 8008408:	4603      	mov	r3, r0
 800840a:	480d      	ldr	r0, [pc, #52]	; (8008440 <getRegistersFromStack+0x9c>)
 800840c:	f000 f9aa 	bl	8008764 <xprintf>
  dprintf(LL_ERROR, "sp   %08x\n", sptr);
 8008410:	4b08      	ldr	r3, [pc, #32]	; (8008434 <getRegistersFromStack+0x90>)
 8008412:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008414:	2b00      	cmp	r3, #0
 8008416:	db03      	blt.n	8008420 <getRegistersFromStack+0x7c>
 8008418:	68f9      	ldr	r1, [r7, #12]
 800841a:	480a      	ldr	r0, [pc, #40]	; (8008444 <getRegistersFromStack+0xa0>)
 800841c:	f000 f9a2 	bl	8008764 <xprintf>
  {
    volatile int s = 1;
 8008420:	2301      	movs	r3, #1
 8008422:	60bb      	str	r3, [r7, #8]
    while (s);
 8008424:	bf00      	nop
 8008426:	68bb      	ldr	r3, [r7, #8]
 8008428:	2b00      	cmp	r3, #0
 800842a:	d1fc      	bne.n	8008426 <getRegistersFromStack+0x82>
  }
}
 800842c:	bf00      	nop
 800842e:	3710      	adds	r7, #16
 8008430:	46bd      	mov	sp, r7
 8008432:	bd80      	pop	{r7, pc}
 8008434:	10001000 	.word	0x10001000
 8008438:	08014754 	.word	0x08014754
 800843c:	08014764 	.word	0x08014764
 8008440:	0801478c 	.word	0x0801478c
 8008444:	080147b4 	.word	0x080147b4

08008448 <HardFault_Handler>:
void __attribute__ ((optimize("-O0"),no_instrument_function,naked)) HardFault_Handler(void)
{
  __asm volatile
 8008448:	f01e 0f04 	tst.w	lr, #4
 800844c:	bf0c      	ite	eq
 800844e:	f3ef 8008 	mrseq	r0, MSP
 8008452:	f3ef 8009 	mrsne	r0, PSP
 8008456:	6981      	ldr	r1, [r0, #24]
 8008458:	4a00      	ldr	r2, [pc, #0]	; (800845c <handler2_address_const>)
 800845a:	4710      	bx	r2

0800845c <handler2_address_const>:
 800845c:	080083a5 	.word	0x080083a5
    " ldr r1, [r0, #24]\n"
    " ldr r2, handler2_address_const\n"
    " bx r2\n"
    " handler2_address_const: .word getRegistersFromStack \n"
  );
}
 8008460:	bf00      	nop

08008462 <intSafeMalloc>:
  }
}
#endif

void *intSafeMalloc(int size)
{
 8008462:	b538      	push	{r3, r4, r5, lr}
 8008464:	4605      	mov	r5, r0
  int irq = amIInIRQ();
 8008466:	f7ff feef 	bl	8008248 <amIInIRQ>
  if(!irq) taskENTER_CRITICAL();
 800846a:	4604      	mov	r4, r0
 800846c:	b908      	cbnz	r0, 8008472 <intSafeMalloc+0x10>
 800846e:	f001 fe61 	bl	800a134 <vPortEnterCritical>
  void *buf =  pvPortMalloc(size);
 8008472:	4628      	mov	r0, r5
 8008474:	f001 ff50 	bl	800a318 <pvPortMalloc>
 8008478:	4605      	mov	r5, r0
  if(!irq) taskEXIT_CRITICAL();
 800847a:	b90c      	cbnz	r4, 8008480 <intSafeMalloc+0x1e>
 800847c:	f001 fe6c 	bl	800a158 <vPortExitCritical>
  return buf;
}
 8008480:	4628      	mov	r0, r5
 8008482:	bd38      	pop	{r3, r4, r5, pc}

08008484 <intSafeFree>:
void intSafeFree(void *buf)
{
 8008484:	b538      	push	{r3, r4, r5, lr}
 8008486:	4605      	mov	r5, r0
  int irq = amIInIRQ();
 8008488:	f7ff fede 	bl	8008248 <amIInIRQ>
  if(!irq) taskENTER_CRITICAL();
 800848c:	4604      	mov	r4, r0
 800848e:	b908      	cbnz	r0, 8008494 <intSafeFree+0x10>
 8008490:	f001 fe50 	bl	800a134 <vPortEnterCritical>
  vPortFree(buf);
 8008494:	4628      	mov	r0, r5
 8008496:	f001 ffab 	bl	800a3f0 <vPortFree>
  if(!irq) taskEXIT_CRITICAL();
 800849a:	b91c      	cbnz	r4, 80084a4 <intSafeFree+0x20>
}
 800849c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void intSafeFree(void *buf)
{
  int irq = amIInIRQ();
  if(!irq) taskENTER_CRITICAL();
  vPortFree(buf);
  if(!irq) taskEXIT_CRITICAL();
 80084a0:	f001 be5a 	b.w	800a158 <vPortExitCritical>
 80084a4:	bd38      	pop	{r3, r4, r5, pc}
	...

080084a8 <consoleLock>:

uint8_t refresh = 0;
#ifdef DEBUG_UART
static int consoleLocked = 0;
void consoleLock(void)
{
 80084a8:	b510      	push	{r4, lr}
  taskENTER_CRITICAL();
 80084aa:	f001 fe43 	bl	800a134 <vPortEnterCritical>
  while(consoleLocked)
 80084ae:	4c09      	ldr	r4, [pc, #36]	; (80084d4 <consoleLock+0x2c>)
 80084b0:	6963      	ldr	r3, [r4, #20]
 80084b2:	b13b      	cbz	r3, 80084c4 <consoleLock+0x1c>
    {
      taskEXIT_CRITICAL();
 80084b4:	f001 fe50 	bl	800a158 <vPortExitCritical>
      mdelay(1);
 80084b8:	2001      	movs	r0, #1
 80084ba:	f002 f9e9 	bl	800a890 <vTaskDelay>
      taskENTER_CRITICAL();
 80084be:	f001 fe39 	bl	800a134 <vPortEnterCritical>
 80084c2:	e7f5      	b.n	80084b0 <consoleLock+0x8>
    }
  consoleLocked = 1;
 80084c4:	4b03      	ldr	r3, [pc, #12]	; (80084d4 <consoleLock+0x2c>)
 80084c6:	2201      	movs	r2, #1
 80084c8:	615a      	str	r2, [r3, #20]
  taskEXIT_CRITICAL();
}
 80084ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      taskEXIT_CRITICAL();
      mdelay(1);
      taskENTER_CRITICAL();
    }
  consoleLocked = 1;
  taskEXIT_CRITICAL();
 80084ce:	f001 be43 	b.w	800a158 <vPortExitCritical>
 80084d2:	bf00      	nop
 80084d4:	2001ac10 	.word	0x2001ac10

080084d8 <consoleUnlock>:
}

void consoleUnlock(void)
{
 80084d8:	b508      	push	{r3, lr}
  taskENTER_CRITICAL();
 80084da:	f001 fe2b 	bl	800a134 <vPortEnterCritical>
  consoleLocked = 0;
 80084de:	4b03      	ldr	r3, [pc, #12]	; (80084ec <consoleUnlock+0x14>)
 80084e0:	2200      	movs	r2, #0
 80084e2:	615a      	str	r2, [r3, #20]
  taskEXIT_CRITICAL();
}
 80084e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void consoleUnlock(void)
{
  taskENTER_CRITICAL();
  consoleLocked = 0;
  taskEXIT_CRITICAL();
 80084e8:	f001 be36 	b.w	800a158 <vPortExitCritical>
 80084ec:	2001ac10 	.word	0x2001ac10

080084f0 <putChar>:
}

void putChar(unsigned char ch)
{
 80084f0:	b510      	push	{r4, lr}
 80084f2:	4604      	mov	r4, r0
  while(!USART_GetFlagStatus(DEBUG_UART, USART_FLAG_TXE));
 80084f4:	2180      	movs	r1, #128	; 0x80
 80084f6:	4805      	ldr	r0, [pc, #20]	; (800850c <putChar+0x1c>)
 80084f8:	f009 f92a 	bl	8011750 <USART_GetFlagStatus>
 80084fc:	2800      	cmp	r0, #0
 80084fe:	d0f9      	beq.n	80084f4 <putChar+0x4>
  USART_SendData(DEBUG_UART, ch);
 8008500:	4621      	mov	r1, r4
 8008502:	4802      	ldr	r0, [pc, #8]	; (800850c <putChar+0x1c>)
}
 8008504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void putChar(unsigned char ch)
{
  while(!USART_GetFlagStatus(DEBUG_UART, USART_FLAG_TXE));
  USART_SendData(DEBUG_UART, ch);
 8008508:	f009 b822 	b.w	8011550 <USART_SendData>
 800850c:	40005000 	.word	0x40005000

08008510 <sendChar>:
  if(USART_GetFlagStatus(DEBUG_UART, USART_FLAG_RXNE))
    return USART_ReceiveData(DEBUG_UART);
  return -1;
}
void sendChar(unsigned char ch)
{
 8008510:	b510      	push	{r4, lr}
 8008512:	4604      	mov	r4, r0
  consoleLock();
 8008514:	f7ff ffc8 	bl	80084a8 <consoleLock>
  putChar(ch);
 8008518:	4620      	mov	r0, r4
 800851a:	f7ff ffe9 	bl	80084f0 <putChar>
  if(ch == '\n')refresh = 1;
 800851e:	2c0a      	cmp	r4, #10
 8008520:	bf02      	ittt	eq
 8008522:	4b03      	ldreq	r3, [pc, #12]	; (8008530 <sendChar+0x20>)
 8008524:	2201      	moveq	r2, #1
 8008526:	741a      	strbeq	r2, [r3, #16]
  consoleUnlock();

}
 8008528:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void sendChar(unsigned char ch)
{
  consoleLock();
  putChar(ch);
  if(ch == '\n')refresh = 1;
  consoleUnlock();
 800852c:	f7ff bfd4 	b.w	80084d8 <consoleUnlock>
 8008530:	2001ac10 	.word	0x2001ac10

08008534 <taskWaitInit>:
    }
}

static int taskInitWait = 1;
void taskWaitInit(void)
{
 8008534:	b510      	push	{r4, lr}
  while(taskInitWait)
 8008536:	4c04      	ldr	r4, [pc, #16]	; (8008548 <taskWaitInit+0x14>)
 8008538:	6823      	ldr	r3, [r4, #0]
 800853a:	b11b      	cbz	r3, 8008544 <taskWaitInit+0x10>
    mdelay(1);
 800853c:	2001      	movs	r0, #1
 800853e:	f002 f9a7 	bl	800a890 <vTaskDelay>
 8008542:	e7f9      	b.n	8008538 <taskWaitInit+0x4>
}
 8008544:	bd10      	pop	{r4, pc}
 8008546:	bf00      	nop
 8008548:	2001a1d4 	.word	0x2001a1d4

0800854c <tasksInitEnd>:

void tasksInitEnd(void)
{
  taskInitWait = 0;
 800854c:	4b01      	ldr	r3, [pc, #4]	; (8008554 <tasksInitEnd+0x8>)
 800854e:	2200      	movs	r2, #0
 8008550:	601a      	str	r2, [r3, #0]
 8008552:	4770      	bx	lr
 8008554:	2001a1d4 	.word	0x2001a1d4

08008558 <xprintf_init>:
#if _USE_XFUNC_OUT
#include <stdarg.h>
void (*xfunc_out)(unsigned char);	/* Pointer to the output stream */
static xSemaphoreHandle mutex;
void xprintf_init(void (*xfunc)(unsigned char))
{
 8008558:	b510      	push	{r4, lr}
 800855a:	4604      	mov	r4, r0
  mutex = xSemaphoreCreateMutex();
 800855c:	2001      	movs	r0, #1
 800855e:	f002 fcaa 	bl	800aeb6 <xQueueCreateMutex>
 8008562:	4b02      	ldr	r3, [pc, #8]	; (800856c <xprintf_init+0x14>)
 8008564:	6018      	str	r0, [r3, #0]
  xfunc_out = xfunc;
 8008566:	4b02      	ldr	r3, [pc, #8]	; (8008570 <xprintf_init+0x18>)
 8008568:	601c      	str	r4, [r3, #0]
 800856a:	bd10      	pop	{r4, pc}
 800856c:	2001ac28 	.word	0x2001ac28
 8008570:	2001adc8 	.word	0x2001adc8

08008574 <xputc>:
/* Put a character                              */
/*----------------------------------------------*/

void xputc (char c)
{
  if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
 8008574:	280a      	cmp	r0, #10
/*----------------------------------------------*/
/* Put a character                              */
/*----------------------------------------------*/

void xputc (char c)
{
 8008576:	b510      	push	{r4, lr}
 8008578:	4604      	mov	r4, r0
  if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
 800857a:	d102      	bne.n	8008582 <xputc+0xe>
 800857c:	200d      	movs	r0, #13
 800857e:	f7ff fff9 	bl	8008574 <xputc>

  if (outptr)
 8008582:	4a07      	ldr	r2, [pc, #28]	; (80085a0 <xputc+0x2c>)
 8008584:	6853      	ldr	r3, [r2, #4]
 8008586:	b11b      	cbz	r3, 8008590 <xputc+0x1c>
    {
      *outptr++ = (unsigned char)c;
 8008588:	1c59      	adds	r1, r3, #1
 800858a:	6051      	str	r1, [r2, #4]
 800858c:	701c      	strb	r4, [r3, #0]
      return;
 800858e:	bd10      	pop	{r4, pc}
    }

  if (xfunc_out) xfunc_out((unsigned char)c);
 8008590:	4b04      	ldr	r3, [pc, #16]	; (80085a4 <xputc+0x30>)
 8008592:	681b      	ldr	r3, [r3, #0]
 8008594:	b11b      	cbz	r3, 800859e <xputc+0x2a>
 8008596:	4620      	mov	r0, r4
}
 8008598:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      *outptr++ = (unsigned char)c;
      return;
    }

  if (xfunc_out) xfunc_out((unsigned char)c);
 800859c:	4718      	bx	r3
 800859e:	bd10      	pop	{r4, pc}
 80085a0:	2001ac28 	.word	0x2001ac28
 80085a4:	2001adc8 	.word	0x2001adc8

080085a8 <xputs>:
/*----------------------------------------------*/

void xputs (					/* Put a string to the default device */
  const char* str				/* Pointer to the string */
)
{
 80085a8:	b510      	push	{r4, lr}
 80085aa:	1e44      	subs	r4, r0, #1
  while (*str)
 80085ac:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80085b0:	b110      	cbz	r0, 80085b8 <xputs+0x10>
    xputc(*str++);
 80085b2:	f7ff ffdf 	bl	8008574 <xputc>
 80085b6:	e7f9      	b.n	80085ac <xputs+0x4>
}
 80085b8:	bd10      	pop	{r4, pc}

080085ba <xvprintf>:
static
void xvprintf (
  const char*	fmt,	/* Pointer to the format string */
  va_list arp			/* Pointer to arguments */
)
{
 80085ba:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80085be:	4602      	mov	r2, r0
 80085c0:	460d      	mov	r5, r1
  char s[16], c, d, *p;


  for (;;)
    {
      c = *fmt++;					/* Get a char */
 80085c2:	7810      	ldrb	r0, [r2, #0]
      if (!c) break;				/* End of format? */
 80085c4:	2800      	cmp	r0, #0
 80085c6:	f000 80c9 	beq.w	800875c <xvprintf+0x1a2>
      if (c != '%')  				/* Pass through it if not a % sequense */
 80085ca:	2825      	cmp	r0, #37	; 0x25
 80085cc:	d001      	beq.n	80085d2 <xvprintf+0x18>
  char s[16], c, d, *p;


  for (;;)
    {
      c = *fmt++;					/* Get a char */
 80085ce:	1c57      	adds	r7, r2, #1
 80085d0:	e06b      	b.n	80086aa <xvprintf+0xf0>
        {
          xputc(c);
          continue;
        }
      f = 0;
      c = *fmt++;					/* Get first char of the sequense */
 80085d2:	7853      	ldrb	r3, [r2, #1]
      if (c == '0')  				/* Flag: '0' padded */
 80085d4:	2b30      	cmp	r3, #48	; 0x30
 80085d6:	d103      	bne.n	80085e0 <xvprintf+0x26>
        {
          f = 1;
          c = *fmt++;
 80085d8:	1cd7      	adds	r7, r2, #3
 80085da:	7893      	ldrb	r3, [r2, #2]
        }
      f = 0;
      c = *fmt++;					/* Get first char of the sequense */
      if (c == '0')  				/* Flag: '0' padded */
        {
          f = 1;
 80085dc:	2601      	movs	r6, #1
 80085de:	e007      	b.n	80085f0 <xvprintf+0x36>
          c = *fmt++;
        }
      else
        {
          if (c == '-')  			/* Flag: left justified */
 80085e0:	2b2d      	cmp	r3, #45	; 0x2d
            {
              f = 2;
              c = *fmt++;
 80085e2:	bf0d      	iteet	eq
 80085e4:	7893      	ldrbeq	r3, [r2, #2]
        {
          xputc(c);
          continue;
        }
      f = 0;
      c = *fmt++;					/* Get first char of the sequense */
 80085e6:	1c97      	addne	r7, r2, #2
      if (c != '%')  				/* Pass through it if not a % sequense */
        {
          xputc(c);
          continue;
        }
      f = 0;
 80085e8:	2600      	movne	r6, #0
      else
        {
          if (c == '-')  			/* Flag: left justified */
            {
              f = 2;
              c = *fmt++;
 80085ea:	1cd7      	addeq	r7, r2, #3
        }
      else
        {
          if (c == '-')  			/* Flag: left justified */
            {
              f = 2;
 80085ec:	bf08      	it	eq
 80085ee:	2602      	moveq	r6, #2
              c = *fmt++;
            }
        }
      for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
 80085f0:	f04f 0800 	mov.w	r8, #0
        w = w * 10 + c - '0';
 80085f4:	210a      	movs	r1, #10
            {
              f = 2;
              c = *fmt++;
            }
        }
      for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
 80085f6:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80085fa:	2a09      	cmp	r2, #9
 80085fc:	d806      	bhi.n	800860c <xvprintf+0x52>
        w = w * 10 + c - '0';
 80085fe:	fb01 3808 	mla	r8, r1, r8, r3
 8008602:	f1a8 0830 	sub.w	r8, r8, #48	; 0x30
            {
              f = 2;
              c = *fmt++;
            }
        }
      for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
 8008606:	f817 3b01 	ldrb.w	r3, [r7], #1
 800860a:	e7f4      	b.n	80085f6 <xvprintf+0x3c>
        w = w * 10 + c - '0';
      if (c == 'l' || c == 'L')  	/* Prefix: Size is long int */
 800860c:	f003 02df 	and.w	r2, r3, #223	; 0xdf
 8008610:	2a4c      	cmp	r2, #76	; 0x4c
        {
          f |= 4;
          c = *fmt++;
 8008612:	bf02      	ittt	eq
 8008614:	783b      	ldrbeq	r3, [r7, #0]
        }
      for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
        w = w * 10 + c - '0';
      if (c == 'l' || c == 'L')  	/* Prefix: Size is long int */
        {
          f |= 4;
 8008616:	f046 0604 	orreq.w	r6, r6, #4
          c = *fmt++;
 800861a:	3701      	addeq	r7, #1
        }
      if (!c) break;				/* End of format? */
 800861c:	2b00      	cmp	r3, #0
 800861e:	f000 809d 	beq.w	800875c <xvprintf+0x1a2>
      d = c;
      if (d >= 'a') d -= 0x20;
 8008622:	2b60      	cmp	r3, #96	; 0x60
 8008624:	bf86      	itte	hi
 8008626:	f1a3 0220 	subhi.w	r2, r3, #32
 800862a:	b2d2      	uxtbhi	r2, r2
 800862c:	461a      	movls	r2, r3
      switch (d)  				/* Type is... */
 800862e:	2a4f      	cmp	r2, #79	; 0x4f
 8008630:	d012      	beq.n	8008658 <xvprintf+0x9e>
 8008632:	d806      	bhi.n	8008642 <xvprintf+0x88>
 8008634:	2a43      	cmp	r2, #67	; 0x43
 8008636:	d030      	beq.n	800869a <xvprintf+0xe0>
 8008638:	2a44      	cmp	r2, #68	; 0x44
 800863a:	d03c      	beq.n	80086b6 <xvprintf+0xfc>
 800863c:	2a42      	cmp	r2, #66	; 0x42
 800863e:	d038      	beq.n	80086b2 <xvprintf+0xf8>
 8008640:	e032      	b.n	80086a8 <xvprintf+0xee>
 8008642:	2a55      	cmp	r2, #85	; 0x55
 8008644:	d037      	beq.n	80086b6 <xvprintf+0xfc>
 8008646:	2a58      	cmp	r2, #88	; 0x58
 8008648:	d02c      	beq.n	80086a4 <xvprintf+0xea>
 800864a:	2a53      	cmp	r2, #83	; 0x53
 800864c:	d12c      	bne.n	80086a8 <xvprintf+0xee>
        {
        case 'S' :					/* String */
          p = va_arg(arp, char*);
 800864e:	f8d5 9000 	ldr.w	r9, [r5]
 8008652:	1d2c      	adds	r4, r5, #4
          for (j = 0; p[j]; j++) ;
 8008654:	464b      	mov	r3, r9
 8008656:	e001      	b.n	800865c <xvprintf+0xa2>
          continue;
        case 'B' :					/* Binary */
          r = 2;
          break;
        case 'O' :					/* Octal */
          r = 8;
 8008658:	2008      	movs	r0, #8
 800865a:	e02d      	b.n	80086b8 <xvprintf+0xfe>
 800865c:	ebc9 0503 	rsb	r5, r9, r3
      if (d >= 'a') d -= 0x20;
      switch (d)  				/* Type is... */
        {
        case 'S' :					/* String */
          p = va_arg(arp, char*);
          for (j = 0; p[j]; j++) ;
 8008660:	f813 2b01 	ldrb.w	r2, [r3], #1
 8008664:	2a00      	cmp	r2, #0
 8008666:	d1f9      	bne.n	800865c <xvprintf+0xa2>
          while (!(f & 2) && j++ < w) xputc(' ');
 8008668:	07b0      	lsls	r0, r6, #30
 800866a:	d409      	bmi.n	8008680 <xvprintf+0xc6>
 800866c:	4545      	cmp	r5, r8
 800866e:	f105 0601 	add.w	r6, r5, #1
 8008672:	d204      	bcs.n	800867e <xvprintf+0xc4>
 8008674:	2020      	movs	r0, #32
 8008676:	f7ff ff7d 	bl	8008574 <xputc>
 800867a:	4635      	mov	r5, r6
 800867c:	e7f6      	b.n	800866c <xvprintf+0xb2>
 800867e:	4635      	mov	r5, r6
          xputs(p);
 8008680:	4648      	mov	r0, r9
 8008682:	f7ff ff91 	bl	80085a8 <xputs>
          while (j++ < w) xputc(' ');
 8008686:	45a8      	cmp	r8, r5
 8008688:	d802      	bhi.n	8008690 <xvprintf+0xd6>
        case 'X' :					/* Hexdecimal */
          r = 16;
          break;
        default:					/* Unknown type (passthrough) */
          xputc(c);
          continue;
 800868a:	4625      	mov	r5, r4
 800868c:	463a      	mov	r2, r7
 800868e:	e798      	b.n	80085c2 <xvprintf+0x8>
        case 'S' :					/* String */
          p = va_arg(arp, char*);
          for (j = 0; p[j]; j++) ;
          while (!(f & 2) && j++ < w) xputc(' ');
          xputs(p);
          while (j++ < w) xputc(' ');
 8008690:	2020      	movs	r0, #32
 8008692:	f7ff ff6f 	bl	8008574 <xputc>
 8008696:	3501      	adds	r5, #1
 8008698:	e7f5      	b.n	8008686 <xvprintf+0xcc>
          continue;
        case 'C' :					/* Character */
          xputc((char)va_arg(arp, int));
 800869a:	7828      	ldrb	r0, [r5, #0]
 800869c:	1d2c      	adds	r4, r5, #4
 800869e:	f7ff ff69 	bl	8008574 <xputc>
          continue;
 80086a2:	e7f2      	b.n	800868a <xvprintf+0xd0>
        case 'D' :					/* Signed decimal */
        case 'U' :					/* Unsigned decimal */
          r = 10;
          break;
        case 'X' :					/* Hexdecimal */
          r = 16;
 80086a4:	2010      	movs	r0, #16
          break;
 80086a6:	e007      	b.n	80086b8 <xvprintf+0xfe>
        default:					/* Unknown type (passthrough) */
          xputc(c);
 80086a8:	4618      	mov	r0, r3
 80086aa:	f7ff ff63 	bl	8008574 <xputc>
          continue;
 80086ae:	462c      	mov	r4, r5
 80086b0:	e7eb      	b.n	800868a <xvprintf+0xd0>
          continue;
        case 'C' :					/* Character */
          xputc((char)va_arg(arp, int));
          continue;
        case 'B' :					/* Binary */
          r = 2;
 80086b2:	2002      	movs	r0, #2
 80086b4:	e000      	b.n	80086b8 <xvprintf+0xfe>
        case 'O' :					/* Octal */
          r = 8;
          break;
        case 'D' :					/* Signed decimal */
        case 'U' :					/* Unsigned decimal */
          r = 10;
 80086b6:	200a      	movs	r0, #10
          xputc(c);
          continue;
        }

      /* Get an argument and put it in numeral */
      v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
 80086b8:	2a44      	cmp	r2, #68	; 0x44
 80086ba:	6829      	ldr	r1, [r5, #0]
 80086bc:	f105 0404 	add.w	r4, r5, #4
 80086c0:	d104      	bne.n	80086cc <xvprintf+0x112>
      if (d == 'D' && (v & 0x80000000))
 80086c2:	2900      	cmp	r1, #0
        {
          v = 0 - v;
 80086c4:	bfbc      	itt	lt
 80086c6:	4249      	neglt	r1, r1
          f |= 8;
 80086c8:	f046 0608 	orrlt.w	r6, r6, #8
 80086cc:	2b78      	cmp	r3, #120	; 0x78
 80086ce:	bf14      	ite	ne
 80086d0:	f04f 0c07 	movne.w	ip, #7
 80086d4:	f04f 0c27 	moveq.w	ip, #39	; 0x27
        }
      i = 0;
 80086d8:	2200      	movs	r2, #0
      do
        {
          d = (char)(v % r);
 80086da:	fbb1 fef0 	udiv	lr, r1, r0
 80086de:	fb00 151e 	mls	r5, r0, lr, r1
 80086e2:	b2eb      	uxtb	r3, r5
          v /= r;
          if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 80086e4:	2d09      	cmp	r5, #9
 80086e6:	bf84      	itt	hi
 80086e8:	4463      	addhi	r3, ip
 80086ea:	b2db      	uxtbhi	r3, r3
          s[i++] = d + '0';
 80086ec:	3330      	adds	r3, #48	; 0x30
        }
      i = 0;
      do
        {
          d = (char)(v % r);
          v /= r;
 80086ee:	4671      	mov	r1, lr
          if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
          s[i++] = d + '0';
 80086f0:	1c55      	adds	r5, r2, #1
 80086f2:	f80d 3002 	strb.w	r3, [sp, r2]
        }
      while (v && i < sizeof(s));
 80086f6:	f1be 0f00 	cmp.w	lr, #0
 80086fa:	d004      	beq.n	8008706 <xvprintf+0x14c>
 80086fc:	2d10      	cmp	r5, #16
 80086fe:	d001      	beq.n	8008704 <xvprintf+0x14a>
 8008700:	462a      	mov	r2, r5
 8008702:	e7ea      	b.n	80086da <xvprintf+0x120>
 8008704:	220f      	movs	r2, #15
      if (f & 8) s[i++] = '-';
 8008706:	0731      	lsls	r1, r6, #28
 8008708:	d505      	bpl.n	8008716 <xvprintf+0x15c>
 800870a:	ab04      	add	r3, sp, #16
 800870c:	441d      	add	r5, r3
 800870e:	232d      	movs	r3, #45	; 0x2d
 8008710:	f805 3c10 	strb.w	r3, [r5, #-16]
 8008714:	1c95      	adds	r5, r2, #2
      j = i;
      d = (f & 1) ? '0' : ' ';
 8008716:	f016 0f01 	tst.w	r6, #1
 800871a:	bf14      	ite	ne
 800871c:	f04f 0a30 	movne.w	sl, #48	; 0x30
 8008720:	f04f 0a20 	moveq.w	sl, #32
      while (!(f & 2) && j++ < w) xputc(d);
 8008724:	07b3      	lsls	r3, r6, #30
          if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
          s[i++] = d + '0';
        }
      while (v && i < sizeof(s));
      if (f & 8) s[i++] = '-';
      j = i;
 8008726:	46a9      	mov	r9, r5
      d = (f & 1) ? '0' : ' ';
      while (!(f & 2) && j++ < w) xputc(d);
 8008728:	d409      	bmi.n	800873e <xvprintf+0x184>
 800872a:	45c1      	cmp	r9, r8
 800872c:	f109 0601 	add.w	r6, r9, #1
 8008730:	d204      	bcs.n	800873c <xvprintf+0x182>
 8008732:	4650      	mov	r0, sl
 8008734:	f7ff ff1e 	bl	8008574 <xputc>
 8008738:	46b1      	mov	r9, r6
 800873a:	e7f6      	b.n	800872a <xvprintf+0x170>
 800873c:	46b1      	mov	r9, r6
      do xputc(s[--i]);
 800873e:	3d01      	subs	r5, #1
 8008740:	f81d 0005 	ldrb.w	r0, [sp, r5]
 8008744:	f7ff ff16 	bl	8008574 <xputc>
      while(i);
 8008748:	2d00      	cmp	r5, #0
 800874a:	d1f8      	bne.n	800873e <xvprintf+0x184>
      while (j++ < w) xputc(' ');
 800874c:	45c8      	cmp	r8, r9
 800874e:	d99c      	bls.n	800868a <xvprintf+0xd0>
 8008750:	2020      	movs	r0, #32
 8008752:	f7ff ff0f 	bl	8008574 <xputc>
 8008756:	f109 0901 	add.w	r9, r9, #1
 800875a:	e7f7      	b.n	800874c <xvprintf+0x192>
    }
}
 800875c:	b004      	add	sp, #16
 800875e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08008764 <xprintf>:

void xprintf (			/* Put a formatted string to the default device */
  const char*	fmt,	/* Pointer to the format string */
  ...					/* Optional arguments */
)
{
 8008764:	b40f      	push	{r0, r1, r2, r3}
 8008766:	b513      	push	{r0, r1, r4, lr}
  va_list arp;
  if( xSemaphoreTake( mutex, 100 ) == pdTRUE )
 8008768:	4c0c      	ldr	r4, [pc, #48]	; (800879c <xprintf+0x38>)
 800876a:	2300      	movs	r3, #0
 800876c:	2264      	movs	r2, #100	; 0x64
 800876e:	4619      	mov	r1, r3
 8008770:	6820      	ldr	r0, [r4, #0]
 8008772:	f002 fc19 	bl	800afa8 <xQueueGenericReceive>
 8008776:	2801      	cmp	r0, #1
 8008778:	d10a      	bne.n	8008790 <xprintf+0x2c>
    {

      va_start(arp, fmt);
 800877a:	a905      	add	r1, sp, #20
      xvprintf(fmt, arp);
 800877c:	9804      	ldr	r0, [sp, #16]
{
  va_list arp;
  if( xSemaphoreTake( mutex, 100 ) == pdTRUE )
    {

      va_start(arp, fmt);
 800877e:	9101      	str	r1, [sp, #4]
      xvprintf(fmt, arp);
 8008780:	f7ff ff1b 	bl	80085ba <xvprintf>
      va_end(arp);
      xSemaphoreGive(mutex);
 8008784:	2300      	movs	r3, #0
 8008786:	461a      	mov	r2, r3
 8008788:	4619      	mov	r1, r3
 800878a:	6820      	ldr	r0, [r4, #0]
 800878c:	f002 fb09 	bl	800ada2 <xQueueGenericSend>
    }
}
 8008790:	b002      	add	sp, #8
 8008792:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8008796:	b004      	add	sp, #16
 8008798:	4770      	bx	lr
 800879a:	bf00      	nop
 800879c:	2001ac28 	.word	0x2001ac28

080087a0 <xsprintf>:
void xsprintf (			/* Put a formatted string to the memory */
  char* buff,			/* Pointer to the output buffer */
  const char*	fmt,	/* Pointer to the format string */
  ...					/* Optional arguments */
)
{
 80087a0:	b40e      	push	{r1, r2, r3}
 80087a2:	b517      	push	{r0, r1, r2, r4, lr}
 80087a4:	a905      	add	r1, sp, #20
  va_list arp;


  outptr = buff;		/* Switch destination for memory */
 80087a6:	4c08      	ldr	r4, [pc, #32]	; (80087c8 <xsprintf+0x28>)
void xsprintf (			/* Put a formatted string to the memory */
  char* buff,			/* Pointer to the output buffer */
  const char*	fmt,	/* Pointer to the format string */
  ...					/* Optional arguments */
)
{
 80087a8:	f851 3b04 	ldr.w	r3, [r1], #4
  va_list arp;


  outptr = buff;		/* Switch destination for memory */
 80087ac:	6060      	str	r0, [r4, #4]

  va_start(arp, fmt);
  xvprintf(fmt, arp);
 80087ae:	4618      	mov	r0, r3
  va_list arp;


  outptr = buff;		/* Switch destination for memory */

  va_start(arp, fmt);
 80087b0:	9101      	str	r1, [sp, #4]
  xvprintf(fmt, arp);
 80087b2:	f7ff ff02 	bl	80085ba <xvprintf>
  va_end(arp);

  *outptr = 0;		/* Terminate output string with a \0 */
 80087b6:	6862      	ldr	r2, [r4, #4]
 80087b8:	2300      	movs	r3, #0
 80087ba:	7013      	strb	r3, [r2, #0]
  outptr = 0;			/* Switch destination for device */
 80087bc:	6063      	str	r3, [r4, #4]
}
 80087be:	b003      	add	sp, #12
 80087c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80087c4:	b003      	add	sp, #12
 80087c6:	4770      	bx	lr
 80087c8:	2001ac28 	.word	0x2001ac28

080087cc <messageProcessorInit>:
#define LEDBLINK(arg_diode, arg_num) LEDblink(arg_diode, arg_num, 400, 300, 200, 400)


void messageProcessorInit(void);
void messageProcessorInit(void)
{
 80087cc:	4770      	bx	lr
	...

080087d0 <msgTab>:
comm_t *msgTab(uint8_t code)
{
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
 80087d0:	4908      	ldr	r1, [pc, #32]	; (80087f4 <msgTab+0x24>)
{
}

//Get MSG_TYPES_TAB entry from message code
comm_t *msgTab(uint8_t code)
{
 80087d2:	b530      	push	{r4, r5, lr}
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
 80087d4:	2200      	movs	r2, #0
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
 80087d6:	244c      	movs	r4, #76	; 0x4c
 80087d8:	fb04 1302 	mla	r3, r4, r2, r1
 80087dc:	685d      	ldr	r5, [r3, #4]
 80087de:	b125      	cbz	r5, 80087ea <msgTab+0x1a>
      if (code == MSG_TYPES_TAB[i].code)
 80087e0:	681d      	ldr	r5, [r3, #0]
 80087e2:	42a8      	cmp	r0, r5
 80087e4:	d101      	bne.n	80087ea <msgTab+0x1a>
        return &MSG_TYPES_TAB[i];//Found message in MSG_TYPES_TAB
 80087e6:	4618      	mov	r0, r3
 80087e8:	bd30      	pop	{r4, r5, pc}

//Get MSG_TYPES_TAB entry from message code
comm_t *msgTab(uint8_t code)
{
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
 80087ea:	3201      	adds	r2, #1
 80087ec:	2a16      	cmp	r2, #22
 80087ee:	d1f3      	bne.n	80087d8 <msgTab+0x8>
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
      if (code == MSG_TYPES_TAB[i].code)
        return &MSG_TYPES_TAB[i];//Found message in MSG_TYPES_TAB
    }
  return NULL;
 80087f0:	2000      	movs	r0, #0
}
 80087f2:	bd30      	pop	{r4, r5, pc}
 80087f4:	2001a1e4 	.word	0x2001a1e4

080087f8 <expectedMsgSize>:

//Get expected message type
int expectedMsgSize(portNum_t portNum, comm_t *msgType)
{
  if (msgType) return (portNum == CEN_PORT)?msgType->size:msgType->size_RX;
 80087f8:	b121      	cbz	r1, 8008804 <expectedMsgSize+0xc>
 80087fa:	b908      	cbnz	r0, 8008800 <expectedMsgSize+0x8>
 80087fc:	6848      	ldr	r0, [r1, #4]
 80087fe:	4770      	bx	lr
 8008800:	6948      	ldr	r0, [r1, #20]
 8008802:	4770      	bx	lr
  return 0;
 8008804:	4608      	mov	r0, r1
}
 8008806:	4770      	bx	lr

08008808 <communicatorRx>:
      bits >>= 1;
    }
}

void communicatorRx(portNum_t portNum, char *buffer, int bufferSize, uint8_t gen)
{
 8008808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  //Check message type and size
  comm_t *msgType = msgTab(buffer[0]);
 800880c:	460f      	mov	r7, r1
      bits >>= 1;
    }
}

void communicatorRx(portNum_t portNum, char *buffer, int bufferSize, uint8_t gen)
{
 800880e:	b089      	sub	sp, #36	; 0x24

  //Check message type and size
  comm_t *msgType = msgTab(buffer[0]);
 8008810:	f817 a914 	ldrb.w	sl, [r7], #-20
      bits >>= 1;
    }
}

void communicatorRx(portNum_t portNum, char *buffer, int bufferSize, uint8_t gen)
{
 8008814:	4680      	mov	r8, r0

  //Check message type and size
  comm_t *msgType = msgTab(buffer[0]);
 8008816:	4650      	mov	r0, sl
      bits >>= 1;
    }
}

void communicatorRx(portNum_t portNum, char *buffer, int bufferSize, uint8_t gen)
{
 8008818:	460d      	mov	r5, r1
 800881a:	4691      	mov	r9, r2
 800881c:	461c      	mov	r4, r3

  //Check message type and size
  comm_t *msgType = msgTab(buffer[0]);
 800881e:	f7ff ffd7 	bl	80087d0 <msgTab>
  if (!msgType)
 8008822:	4606      	mov	r6, r0
 8008824:	b950      	cbnz	r0, 800883c <communicatorRx+0x34>
    {
      dprintf(LL_WARNING, "Unknown message %x received on port %d\n", buffer[0], portNum);
 8008826:	4ba7      	ldr	r3, [pc, #668]	; (8008ac4 <communicatorRx+0x2bc>)
 8008828:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800882a:	2b00      	cmp	r3, #0
 800882c:	f340 811c 	ble.w	8008a68 <communicatorRx+0x260>
 8008830:	4642      	mov	r2, r8
 8008832:	4651      	mov	r1, sl
 8008834:	48a4      	ldr	r0, [pc, #656]	; (8008ac8 <communicatorRx+0x2c0>)
 8008836:	f7ff ff95 	bl	8008764 <xprintf>
 800883a:	e115      	b.n	8008a68 <communicatorRx+0x260>
      dFree(buffer);
      return;
    }

  //Check message size
  if (expectedMsgSize(portNum, msgType) > bufferSize)
 800883c:	4601      	mov	r1, r0
 800883e:	4640      	mov	r0, r8
 8008840:	f7ff ffda 	bl	80087f8 <expectedMsgSize>
 8008844:	4548      	cmp	r0, r9
 8008846:	dd0e      	ble.n	8008866 <communicatorRx+0x5e>
    {
      dprintf(LL_WARNING, "Incomplete message %x received on port %d\n", buffer[0], portNum);
 8008848:	4b9e      	ldr	r3, [pc, #632]	; (8008ac4 <communicatorRx+0x2bc>)
 800884a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800884c:	2b00      	cmp	r3, #0
 800884e:	dd04      	ble.n	800885a <communicatorRx+0x52>
 8008850:	4642      	mov	r2, r8
 8008852:	4651      	mov	r1, sl
 8008854:	489d      	ldr	r0, [pc, #628]	; (8008acc <communicatorRx+0x2c4>)
 8008856:	f7ff ff85 	bl	8008764 <xprintf>
      //Timeout on receive. Message too short
      Timeout_Data(portNum, buffer, bufferSize);
 800885a:	464a      	mov	r2, r9
 800885c:	4629      	mov	r1, r5
 800885e:	4640      	mov	r0, r8
 8008860:	f000 fdce 	bl	8009400 <Timeout_Data>
 8008864:	e100      	b.n	8008a68 <communicatorRx+0x260>
      dFree(buffer);
      return;
    }

  bBuffer_t *bBuffer = bBufferFromData(buffer);
  bBuffer->size = bufferSize;
 8008866:	f825 9c14 	strh.w	r9, [r5, #-20]
  bBuffer->timestamp = xTaskGetTickCount() + msgType->timeout;
 800886a:	f001 ff1b 	bl	800a6a4 <xTaskGetTickCount>
 800886e:	6a33      	ldr	r3, [r6, #32]
 8008870:	eb06 0288 	add.w	r2, r6, r8, lsl #2
 8008874:	4418      	add	r0, r3
  bBuffer->privateData = 0;
 8008876:	2300      	movs	r3, #0
      return;
    }

  bBuffer_t *bBuffer = bBufferFromData(buffer);
  bBuffer->size = bufferSize;
  bBuffer->timestamp = xTaskGetTickCount() + msgType->timeout;
 8008878:	f845 0c0c 	str.w	r0, [r5, #-12]
  bBuffer->privateData = 0;
 800887c:	f845 3c08 	str.w	r3, [r5, #-8]
  msgType->received[portNum]++;
 8008880:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8008882:	3301      	adds	r3, #1
 8008884:	6293      	str	r3, [r2, #40]	; 0x28

  if(msgType->blocked)
 8008886:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8008888:	2b00      	cmp	r3, #0
 800888a:	f040 80ed 	bne.w	8008a68 <communicatorRx+0x260>
    {
      dFree(buffer);
      return;
    }

  if(cfg.trace_messages)
 800888e:	4b8d      	ldr	r3, [pc, #564]	; (8008ac4 <communicatorRx+0x2bc>)
 8008890:	69da      	ldr	r2, [r3, #28]
 8008892:	4699      	mov	r9, r3
 8008894:	2a00      	cmp	r2, #0
 8008896:	d045      	beq.n	8008924 <communicatorRx+0x11c>
    {
      switch(buffer[0])
 8008898:	782b      	ldrb	r3, [r5, #0]
 800889a:	2bb1      	cmp	r3, #177	; 0xb1
 800889c:	d805      	bhi.n	80088aa <communicatorRx+0xa2>
 800889e:	2bb0      	cmp	r3, #176	; 0xb0
 80088a0:	d209      	bcs.n	80088b6 <communicatorRx+0xae>
 80088a2:	2b55      	cmp	r3, #85	; 0x55
 80088a4:	d003      	beq.n	80088ae <communicatorRx+0xa6>
 80088a6:	2ba2      	cmp	r3, #162	; 0xa2
 80088a8:	e000      	b.n	80088ac <communicatorRx+0xa4>
 80088aa:	2bcc      	cmp	r3, #204	; 0xcc
 80088ac:	d107      	bne.n	80088be <communicatorRx+0xb6>
        {
        case 0xA2:
        case 0xCC:
        case 0x55:
          if(cfg.trace_messages < 3)
 80088ae:	f8d9 201c 	ldr.w	r2, [r9, #28]
 80088b2:	2a02      	cmp	r2, #2
 80088b4:	dd36      	ble.n	8008924 <communicatorRx+0x11c>
            break;
        case 0xB0:
        case 0xB1:
          if(cfg.trace_messages < 2)
 80088b6:	f8d9 201c 	ldr.w	r2, [r9, #28]
 80088ba:	2a01      	cmp	r2, #1
 80088bc:	dd32      	ble.n	8008924 <communicatorRx+0x11c>
            break;
        default:
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == buffer[0])
 80088be:	f8d9 201c 	ldr.w	r2, [r9, #28]
 80088c2:	2a03      	cmp	r2, #3
 80088c4:	dd03      	ble.n	80088ce <communicatorRx+0xc6>
 80088c6:	4a7f      	ldr	r2, [pc, #508]	; (8008ac4 <communicatorRx+0x2bc>)
 80088c8:	69d2      	ldr	r2, [r2, #28]
 80088ca:	429a      	cmp	r2, r3
 80088cc:	d12a      	bne.n	8008924 <communicatorRx+0x11c>
            {
              dprintf(LL_INFO, "(%010d)Msg %x %s from %s(size %d): ", xTaskGetTickCount(), buffer[0], gen?"gen":"rcvd", portStr[portNum], bBuffer->size);
 80088ce:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
 80088d2:	2b01      	cmp	r3, #1
 80088d4:	dd12      	ble.n	80088fc <communicatorRx+0xf4>
 80088d6:	f001 fee5 	bl	800a6a4 <xTaskGetTickCount>
 80088da:	f835 3c14 	ldrh.w	r3, [r5, #-20]
 80088de:	9301      	str	r3, [sp, #4]
 80088e0:	4b7b      	ldr	r3, [pc, #492]	; (8008ad0 <communicatorRx+0x2c8>)
 80088e2:	497c      	ldr	r1, [pc, #496]	; (8008ad4 <communicatorRx+0x2cc>)
 80088e4:	f853 3028 	ldr.w	r3, [r3, r8, lsl #2]
 80088e8:	9300      	str	r3, [sp, #0]
 80088ea:	4b7b      	ldr	r3, [pc, #492]	; (8008ad8 <communicatorRx+0x2d0>)
 80088ec:	782a      	ldrb	r2, [r5, #0]
 80088ee:	2c00      	cmp	r4, #0
 80088f0:	bf18      	it	ne
 80088f2:	460b      	movne	r3, r1
 80088f4:	4601      	mov	r1, r0
 80088f6:	4879      	ldr	r0, [pc, #484]	; (8008adc <communicatorRx+0x2d4>)
 80088f8:	f7ff ff34 	bl	8008764 <xprintf>
 80088fc:	2400      	movs	r4, #0
              int i;
              for(i = 0; i < bBuffer->size; i++)
 80088fe:	f835 3c14 	ldrh.w	r3, [r5, #-20]
 8008902:	429c      	cmp	r4, r3
                dprintf(LL_INFO, "%02x ", buffer[i]);
 8008904:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == buffer[0])
            {
              dprintf(LL_INFO, "(%010d)Msg %x %s from %s(size %d): ", xTaskGetTickCount(), buffer[0], gen?"gen":"rcvd", portStr[portNum], bBuffer->size);
              int i;
              for(i = 0; i < bBuffer->size; i++)
 8008908:	da07      	bge.n	800891a <communicatorRx+0x112>
                dprintf(LL_INFO, "%02x ", buffer[i]);
 800890a:	2b01      	cmp	r3, #1
 800890c:	dd03      	ble.n	8008916 <communicatorRx+0x10e>
 800890e:	5d29      	ldrb	r1, [r5, r4]
 8008910:	4873      	ldr	r0, [pc, #460]	; (8008ae0 <communicatorRx+0x2d8>)
 8008912:	f7ff ff27 	bl	8008764 <xprintf>
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == buffer[0])
            {
              dprintf(LL_INFO, "(%010d)Msg %x %s from %s(size %d): ", xTaskGetTickCount(), buffer[0], gen?"gen":"rcvd", portStr[portNum], bBuffer->size);
              int i;
              for(i = 0; i < bBuffer->size; i++)
 8008916:	3401      	adds	r4, #1
 8008918:	e7f1      	b.n	80088fe <communicatorRx+0xf6>
                dprintf(LL_INFO, "%02x ", buffer[i]);
              dprintf(LL_INFO, "\n");
 800891a:	2b01      	cmp	r3, #1
 800891c:	dd02      	ble.n	8008924 <communicatorRx+0x11c>
 800891e:	4871      	ldr	r0, [pc, #452]	; (8008ae4 <communicatorRx+0x2dc>)
 8008920:	f7ff ff20 	bl	8008764 <xprintf>
        break;
        }
    }

  int processLocally = 0;
  if (portNum == CEN_PORT)
 8008924:	f1b8 0f00 	cmp.w	r8, #0
 8008928:	d050      	beq.n	80089cc <communicatorRx+0x1c4>
      processLocally = 1;
    }
  else
    {
      //from PER
      if (msgType->type == NEG_CONFIRMATION)
 800892a:	68b4      	ldr	r4, [r6, #8]
 800892c:	2c01      	cmp	r4, #1
 800892e:	d124      	bne.n	800897a <communicatorRx+0x172>
        {
          //Negative confirmation
          //Find a message refered by this nACK
          comm_t *msgACK = msgTab(msgType->nackCode);
 8008930:	68f0      	ldr	r0, [r6, #12]
 8008932:	b2c0      	uxtb	r0, r0
 8008934:	f7ff ff4c 	bl	80087d0 <msgTab>
          bBuffer_t *buf = msgACK->buffers;
 8008938:	4683      	mov	fp, r0
      //from PER
      if (msgType->type == NEG_CONFIRMATION)
        {
          //Negative confirmation
          //Find a message refered by this nACK
          comm_t *msgACK = msgTab(msgType->nackCode);
 800893a:	9003      	str	r0, [sp, #12]
          bBuffer_t *buf = msgACK->buffers;
          while(buf)
            {
              bBuffer_t *next = buf->next;
              if (!memcmp(&buf->data[1], &bBuffer->data[1], msgACK->size_RX-1))
 800893c:	1c6b      	adds	r3, r5, #1
      if (msgType->type == NEG_CONFIRMATION)
        {
          //Negative confirmation
          //Find a message refered by this nACK
          comm_t *msgACK = msgTab(msgType->nackCode);
          bBuffer_t *buf = msgACK->buffers;
 800893e:	f85b af48 	ldr.w	sl, [fp, #72]!
          while(buf)
            {
              bBuffer_t *next = buf->next;
              if (!memcmp(&buf->data[1], &bBuffer->data[1], msgACK->size_RX-1))
 8008942:	9305      	str	r3, [sp, #20]
        }
        break;
        }
    }

  int processLocally = 0;
 8008944:	2400      	movs	r4, #0
        {
          //Negative confirmation
          //Find a message refered by this nACK
          comm_t *msgACK = msgTab(msgType->nackCode);
          bBuffer_t *buf = msgACK->buffers;
          while(buf)
 8008946:	f1ba 0f00 	cmp.w	sl, #0
 800894a:	d042      	beq.n	80089d2 <communicatorRx+0x1ca>
            {
              bBuffer_t *next = buf->next;
 800894c:	f8da 3010 	ldr.w	r3, [sl, #16]
 8008950:	9304      	str	r3, [sp, #16]
              if (!memcmp(&buf->data[1], &bBuffer->data[1], msgACK->size_RX-1))
 8008952:	9b03      	ldr	r3, [sp, #12]
 8008954:	9905      	ldr	r1, [sp, #20]
 8008956:	695a      	ldr	r2, [r3, #20]
 8008958:	f10a 0015 	add.w	r0, sl, #21
 800895c:	3a01      	subs	r2, #1
 800895e:	f00b fd45 	bl	80143ec <memcmp>
 8008962:	b938      	cbnz	r0, 8008974 <communicatorRx+0x16c>
                {
                  //Message found. Delete it
                  bRemove(&(msgACK->buffers), buf);
 8008964:	4651      	mov	r1, sl
 8008966:	4658      	mov	r0, fp
 8008968:	f004 fe4e 	bl	800d608 <bRemove>
                  bFree(buf);
 800896c:	4650      	mov	r0, sl
 800896e:	f005 f8b9 	bl	800dae4 <bFree>
                  processLocally = 1;
 8008972:	2401      	movs	r4, #1
 8008974:	f8dd a010 	ldr.w	sl, [sp, #16]
 8008978:	e7e5      	b.n	8008946 <communicatorRx+0x13e>
 800897a:	2201      	movs	r2, #1
              buf = next;
            }
        }
      else
        {
          if(msgType->type == CONF_TIMEOUT)
 800897c:	bb44      	cbnz	r4, 80089d0 <communicatorRx+0x1c8>
                  bBuffer_t *next = buf->next;
                  if (!memcmp(buf->data, bBuffer->data, msgType->size_RX))
                    {
                      //Message found.
                      //Clear flag
                      buf->privateData &= ~(1<<(portNum - PER1_PORT));
 800897e:	f108 31ff 	add.w	r1, r8, #4294967295
        {
          if(msgType->type == CONF_TIMEOUT)
            {
              //Positive confirmation
              //Find a message refered by this ACK
              bBuffer_t *buf = msgType->buffers;
 8008982:	46b3      	mov	fp, r6
                  bBuffer_t *next = buf->next;
                  if (!memcmp(buf->data, bBuffer->data, msgType->size_RX))
                    {
                      //Message found.
                      //Clear flag
                      buf->privateData &= ~(1<<(portNum - PER1_PORT));
 8008984:	408a      	lsls	r2, r1
 8008986:	43d3      	mvns	r3, r2
        {
          if(msgType->type == CONF_TIMEOUT)
            {
              //Positive confirmation
              //Find a message refered by this ACK
              bBuffer_t *buf = msgType->buffers;
 8008988:	f85b af48 	ldr.w	sl, [fp, #72]!
                  bBuffer_t *next = buf->next;
                  if (!memcmp(buf->data, bBuffer->data, msgType->size_RX))
                    {
                      //Message found.
                      //Clear flag
                      buf->privateData &= ~(1<<(portNum - PER1_PORT));
 800898c:	9304      	str	r3, [sp, #16]
          if(msgType->type == CONF_TIMEOUT)
            {
              //Positive confirmation
              //Find a message refered by this ACK
              bBuffer_t *buf = msgType->buffers;
              while(buf)
 800898e:	f1ba 0f00 	cmp.w	sl, #0
 8008992:	d01e      	beq.n	80089d2 <communicatorRx+0x1ca>
                {
                  bBuffer_t *next = buf->next;
 8008994:	f8da 3010 	ldr.w	r3, [sl, #16]
 8008998:	9303      	str	r3, [sp, #12]
                  if (!memcmp(buf->data, bBuffer->data, msgType->size_RX))
 800899a:	6972      	ldr	r2, [r6, #20]
 800899c:	4629      	mov	r1, r5
 800899e:	f10a 0014 	add.w	r0, sl, #20
 80089a2:	f00b fd23 	bl	80143ec <memcmp>
 80089a6:	b970      	cbnz	r0, 80089c6 <communicatorRx+0x1be>
                    {
                      //Message found.
                      //Clear flag
                      buf->privateData &= ~(1<<(portNum - PER1_PORT));
 80089a8:	f8da 200c 	ldr.w	r2, [sl, #12]
 80089ac:	9b04      	ldr	r3, [sp, #16]
 80089ae:	401a      	ands	r2, r3
 80089b0:	f8ca 200c 	str.w	r2, [sl, #12]
                      if(!buf->privateData)
 80089b4:	b93a      	cbnz	r2, 80089c6 <communicatorRx+0x1be>
                        {
                          //No more confirmations needed
                          bRemove(&(msgType->buffers), buf);
 80089b6:	4651      	mov	r1, sl
 80089b8:	4658      	mov	r0, fp
 80089ba:	f004 fe25 	bl	800d608 <bRemove>
                          bFree(buf);
 80089be:	4650      	mov	r0, sl
 80089c0:	f005 f890 	bl	800dae4 <bFree>

                          processLocally = 1;
 80089c4:	2401      	movs	r4, #1
 80089c6:	f8dd a00c 	ldr.w	sl, [sp, #12]
 80089ca:	e7e0      	b.n	800898e <communicatorRx+0x186>
  if (portNum == CEN_PORT)
    {
      //from CEN

      //Process locally if necessary
      processLocally = 1;
 80089cc:	2401      	movs	r4, #1
 80089ce:	e000      	b.n	80089d2 <communicatorRx+0x1ca>
 80089d0:	4614      	mov	r4, r2
        }
    }

  int send = 0;

  uint8_t forwardMask = msgType->spk_flags;
 80089d2:	6933      	ldr	r3, [r6, #16]
 80089d4:	f88d 301f 	strb.w	r3, [sp, #31]
  if(processLocally)
 80089d8:	b34c      	cbz	r4, 8008a2e <communicatorRx+0x226>
    {
      if(msgType->type == NEG_CONFIRMATION) send |= CB_RET_nACK;
 80089da:	68b4      	ldr	r4, [r6, #8]
      if(msgType->type == CONF_TIMEOUT) send |= CB_RET_ACK;
      if(msgType->callback)
 80089dc:	f8d6 a040 	ldr.w	sl, [r6, #64]	; 0x40
  int send = 0;

  uint8_t forwardMask = msgType->spk_flags;
  if(processLocally)
    {
      if(msgType->type == NEG_CONFIRMATION) send |= CB_RET_nACK;
 80089e0:	2c01      	cmp	r4, #1
              processLocally = 1;
            }
        }
    }

  int send = 0;
 80089e2:	bf1a      	itte	ne
 80089e4:	fab4 f484 	clzne	r4, r4
 80089e8:	0964      	lsrne	r4, r4, #5

  uint8_t forwardMask = msgType->spk_flags;
  if(processLocally)
    {
      if(msgType->type == NEG_CONFIRMATION) send |= CB_RET_nACK;
 80089ea:	2402      	moveq	r4, #2
      if(msgType->type == CONF_TIMEOUT) send |= CB_RET_ACK;
      if(msgType->callback)
 80089ec:	f1ba 0f00 	cmp.w	sl, #0
 80089f0:	d006      	beq.n	8008a00 <communicatorRx+0x1f8>
        send = msgType->callback(portNum, msgType, bBuffer, &forwardMask);
 80089f2:	f10d 031f 	add.w	r3, sp, #31
 80089f6:	463a      	mov	r2, r7
 80089f8:	4631      	mov	r1, r6
 80089fa:	4640      	mov	r0, r8
 80089fc:	47d0      	blx	sl
 80089fe:	4604      	mov	r4, r0

      if(((send & CB_RET_nACK) && msgType->type == CONF_TIMEOUT)
 8008a00:	07a1      	lsls	r1, r4, #30
 8008a02:	d501      	bpl.n	8008a08 <communicatorRx+0x200>
 8008a04:	68b3      	ldr	r3, [r6, #8]
 8008a06:	b123      	cbz	r3, 8008a12 <communicatorRx+0x20a>
          || ((send & CB_RET_ACK) && msgType->type == NEG_CONFIRMATION))
 8008a08:	07e2      	lsls	r2, r4, #31
 8008a0a:	d504      	bpl.n	8008a16 <communicatorRx+0x20e>
 8008a0c:	68b3      	ldr	r3, [r6, #8]
 8008a0e:	2b01      	cmp	r3, #1
 8008a10:	d101      	bne.n	8008a16 <communicatorRx+0x20e>
        bBuffer->data[0] = msgType->nackCode;
 8008a12:	68f3      	ldr	r3, [r6, #12]
 8008a14:	702b      	strb	r3, [r5, #0]

      if(send&(CB_RET_nACK | CB_RET_ACK))
 8008a16:	07a3      	lsls	r3, r4, #30
 8008a18:	d009      	beq.n	8008a2e <communicatorRx+0x226>
        {
          bRef(bBuffer);
 8008a1a:	4638      	mov	r0, r7
 8008a1c:	f005 f9a0 	bl	800dd60 <bRef>
          messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
 8008a20:	463b      	mov	r3, r7
 8008a22:	f835 2c14 	ldrh.w	r2, [r5, #-20]
 8008a26:	4629      	mov	r1, r5
 8008a28:	2000      	movs	r0, #0
 8008a2a:	f003 f8bf 	bl	800bbac <messageTx>
        }
    }
#ifdef SMOK
  if(cfg.flags & FLAGS_FAKE_FORWARD_MASK)
 8008a2e:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38
 8008a32:	05d8      	lsls	r0, r3, #23
 8008a34:	d513      	bpl.n	8008a5e <communicatorRx+0x256>
    {
      //Fake forward. Respond with ACK
      if(forwardMask && DIRECTION(portNum) && (send & CB_RET_nACK) == 0)
 8008a36:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8008a3a:	b183      	cbz	r3, 8008a5e <communicatorRx+0x256>
 8008a3c:	f1b8 0f00 	cmp.w	r8, #0
 8008a40:	d10d      	bne.n	8008a5e <communicatorRx+0x256>
 8008a42:	07a1      	lsls	r1, r4, #30
 8008a44:	d40b      	bmi.n	8008a5e <communicatorRx+0x256>
        {
          //Send ACK
          bRef(bBuffer);
 8008a46:	4638      	mov	r0, r7
 8008a48:	f005 f98a 	bl	800dd60 <bRef>
          messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
 8008a4c:	463b      	mov	r3, r7
 8008a4e:	f835 2c14 	ldrh.w	r2, [r5, #-20]
 8008a52:	4629      	mov	r1, r5
 8008a54:	4640      	mov	r0, r8
 8008a56:	f003 f8a9 	bl	800bbac <messageTx>
          forwardMask = 0;
 8008a5a:	f88d 801f 	strb.w	r8, [sp, #31]
        }
    }
#endif
  //Send further?
  if(forwardMask && DIRECTION(portNum) && (send & CB_RET_nACK) == 0)
 8008a5e:	f89d 901f 	ldrb.w	r9, [sp, #31]
 8008a62:	f1b9 0f00 	cmp.w	r9, #0
 8008a66:	d105      	bne.n	8008a74 <communicatorRx+0x26c>
    forwardMessage(bBuffer, msgType, forwardMask);


  //Release the incoming buffer
  bFree(bBuffer);
 8008a68:	4638      	mov	r0, r7
 8008a6a:	f005 f83b 	bl	800dae4 <bFree>
}
 8008a6e:	b009      	add	sp, #36	; 0x24
 8008a70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          forwardMask = 0;
        }
    }
#endif
  //Send further?
  if(forwardMask && DIRECTION(portNum) && (send & CB_RET_nACK) == 0)
 8008a74:	f1b8 0f00 	cmp.w	r8, #0
 8008a78:	d1f6      	bne.n	8008a68 <communicatorRx+0x260>
 8008a7a:	07a2      	lsls	r2, r4, #30
 8008a7c:	d4f4      	bmi.n	8008a68 <communicatorRx+0x260>
}

static void forwardMessage(bBuffer_t *bBuffer, comm_t *msgType, uint8_t forwardMask)
{
  //Store the message
  bBuffer->timestamp = xTaskGetTickCount() + msgType->timeout;
 8008a7e:	f001 fe11 	bl	800a6a4 <xTaskGetTickCount>
 8008a82:	6a33      	ldr	r3, [r6, #32]
  bBuffer->privateData = forwardMask;
 8008a84:	f845 9c08 	str.w	r9, [r5, #-8]
}

static void forwardMessage(bBuffer_t *bBuffer, comm_t *msgType, uint8_t forwardMask)
{
  //Store the message
  bBuffer->timestamp = xTaskGetTickCount() + msgType->timeout;
 8008a88:	4418      	add	r0, r3
 8008a8a:	f845 0c0c 	str.w	r0, [r5, #-12]
  bBuffer->privateData = forwardMask;
  bAdd(&(msgType->buffers), bBuffer);
 8008a8e:	4639      	mov	r1, r7
 8008a90:	f106 0048 	add.w	r0, r6, #72	; 0x48
 8008a94:	f004 fdb4 	bl	800d600 <bAdd>
  bRef(bBuffer);
 8008a98:	4638      	mov	r0, r7
 8008a9a:	f005 f961 	bl	800dd60 <bRef>
  int bits = forwardMask;
 8008a9e:	464c      	mov	r4, r9
  portNum_t sendPort = PER1_PORT;
 8008aa0:	2601      	movs	r6, #1
  while(bits)
    {
      if(bits & 1)
 8008aa2:	07e3      	lsls	r3, r4, #31
 8008aa4:	d509      	bpl.n	8008aba <communicatorRx+0x2b2>
        {
          //Send to the port
          bRef(bBuffer);
 8008aa6:	4638      	mov	r0, r7
 8008aa8:	f005 f95a 	bl	800dd60 <bRef>
          messageTx(sendPort, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
 8008aac:	463b      	mov	r3, r7
 8008aae:	f835 2c14 	ldrh.w	r2, [r5, #-20]
 8008ab2:	4629      	mov	r1, r5
 8008ab4:	4630      	mov	r0, r6
 8008ab6:	f003 f879 	bl	800bbac <messageTx>
        }
      sendPort++;
 8008aba:	3601      	adds	r6, #1
  bBuffer->privateData = forwardMask;
  bAdd(&(msgType->buffers), bBuffer);
  bRef(bBuffer);
  int bits = forwardMask;
  portNum_t sendPort = PER1_PORT;
  while(bits)
 8008abc:	1064      	asrs	r4, r4, #1
        {
          //Send to the port
          bRef(bBuffer);
          messageTx(sendPort, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
        }
      sendPort++;
 8008abe:	b2f6      	uxtb	r6, r6
  bBuffer->privateData = forwardMask;
  bAdd(&(msgType->buffers), bBuffer);
  bRef(bBuffer);
  int bits = forwardMask;
  portNum_t sendPort = PER1_PORT;
  while(bits)
 8008ac0:	d1ef      	bne.n	8008aa2 <communicatorRx+0x29a>
 8008ac2:	e7d1      	b.n	8008a68 <communicatorRx+0x260>
 8008ac4:	10001000 	.word	0x10001000
 8008ac8:	080147f2 	.word	0x080147f2
 8008acc:	0801481a 	.word	0x0801481a
 8008ad0:	2001abd8 	.word	0x2001abd8
 8008ad4:	080147e9 	.word	0x080147e9
 8008ad8:	080147ed 	.word	0x080147ed
 8008adc:	08014845 	.word	0x08014845
 8008ae0:	08014869 	.word	0x08014869
 8008ae4:	08014a9c 	.word	0x08014a9c

08008ae8 <communicatorTxComplete>:
  //Simulate message receiving from CEN. It will be sent further
  messageRx(CEN_PORT, (void*)msg->data, msg->size, 1);
}

void communicatorTxComplete(portNum_t portNum, int status, uint32_t handle)
{
 8008ae8:	4770      	bx	lr
	...

08008aec <communicatorPeriodic>:
}

void communicatorPeriodic(void)
{
 8008aec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  communicatorPeriodicPrivate();
 8008af0:	f000 fc92 	bl	8009418 <communicatorPeriodicPrivate>
 8008af4:	4e26      	ldr	r6, [pc, #152]	; (8008b90 <communicatorPeriodic+0xa4>)
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
 8008af6:	f04f 0800 	mov.w	r8, #0
 8008afa:	46b1      	mov	r9, r6
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
 8008afc:	f04f 0a4c 	mov.w	sl, #76	; 0x4c
 8008b00:	fb0a 9508 	mla	r5, sl, r8, r9
 8008b04:	686b      	ldr	r3, [r5, #4]
 8008b06:	b943      	cbnz	r3, 8008b1a <communicatorPeriodic+0x2e>

void communicatorPeriodic(void)
{
  communicatorPeriodicPrivate();
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
 8008b08:	f108 0801 	add.w	r8, r8, #1
 8008b0c:	f1b8 0f16 	cmp.w	r8, #22
 8008b10:	f106 064c 	add.w	r6, r6, #76	; 0x4c
 8008b14:	d1f4      	bne.n	8008b00 <communicatorPeriodic+0x14>
 8008b16:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
      if(MSG_TYPES_TAB[i].type == CONF_TIMEOUT)
 8008b1a:	68ab      	ldr	r3, [r5, #8]
 8008b1c:	2b00      	cmp	r3, #0
 8008b1e:	d1f3      	bne.n	8008b08 <communicatorPeriodic+0x1c>
        {
          bBuffer_t *buf = MSG_TYPES_TAB[i].buffers;
 8008b20:	6cac      	ldr	r4, [r5, #72]	; 0x48
          while(buf)
 8008b22:	2c00      	cmp	r4, #0
 8008b24:	d0f0      	beq.n	8008b08 <communicatorPeriodic+0x1c>
            {
              bBuffer_t *next = buf->next;

              //Now check timeout expiry
              if (buf->timestamp < xTaskGetTickCount())
 8008b26:	68a7      	ldr	r7, [r4, #8]
      if(MSG_TYPES_TAB[i].type == CONF_TIMEOUT)
        {
          bBuffer_t *buf = MSG_TYPES_TAB[i].buffers;
          while(buf)
            {
              bBuffer_t *next = buf->next;
 8008b28:	f8d4 b010 	ldr.w	fp, [r4, #16]

              //Now check timeout expiry
              if (buf->timestamp < xTaskGetTickCount())
 8008b2c:	f001 fdba 	bl	800a6a4 <xTaskGetTickCount>
 8008b30:	4287      	cmp	r7, r0
 8008b32:	d22b      	bcs.n	8008b8c <communicatorPeriodic+0xa0>
                  //Check which speakers did not repond. Restart link.
                  portNum_t portNum;
                  int send = CB_RET_nACK;//assume nACK
                  for(portNum = PER1_PORT; portNum < PORTS_NUM; portNum++)
                    {
                      if((buf->privateData & (1<<(portNum-1))))
 8008b34:	68e3      	ldr	r3, [r4, #12]
 8008b36:	07d8      	lsls	r0, r3, #31
 8008b38:	d506      	bpl.n	8008b48 <communicatorPeriodic+0x5c>
                        {

#ifdef MADO
                          //                          SPIevent(portNum, SPI_EV_TYPE_LINK_ERROR);
#endif
                          if(MSG_TYPES_TAB[i].timeoutCallback)
 8008b3a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8008b3c:	b123      	cbz	r3, 8008b48 <communicatorPeriodic+0x5c>
                            send = MSG_TYPES_TAB[i].timeoutCallback(portNum,  &MSG_TYPES_TAB[i]);
 8008b3e:	4631      	mov	r1, r6
 8008b40:	2001      	movs	r0, #1
 8008b42:	4798      	blx	r3
 8008b44:	4607      	mov	r7, r0
 8008b46:	e000      	b.n	8008b4a <communicatorPeriodic+0x5e>
                        {

#ifdef MADO
                          //                          SPIevent(portNum, SPI_EV_TYPE_LINK_ERROR);
#endif
                          if(MSG_TYPES_TAB[i].timeoutCallback)
 8008b48:	2702      	movs	r7, #2
                  //Check which speakers did not repond. Restart link.
                  portNum_t portNum;
                  int send = CB_RET_nACK;//assume nACK
                  for(portNum = PER1_PORT; portNum < PORTS_NUM; portNum++)
                    {
                      if((buf->privateData & (1<<(portNum-1))))
 8008b4a:	68e3      	ldr	r3, [r4, #12]
 8008b4c:	0799      	lsls	r1, r3, #30
 8008b4e:	d505      	bpl.n	8008b5c <communicatorPeriodic+0x70>
                        {

#ifdef MADO
                          //                          SPIevent(portNum, SPI_EV_TYPE_LINK_ERROR);
#endif
                          if(MSG_TYPES_TAB[i].timeoutCallback)
 8008b50:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8008b52:	b11b      	cbz	r3, 8008b5c <communicatorPeriodic+0x70>
                            send = MSG_TYPES_TAB[i].timeoutCallback(portNum,  &MSG_TYPES_TAB[i]);
 8008b54:	4631      	mov	r1, r6
 8008b56:	2002      	movs	r0, #2
 8008b58:	4798      	blx	r3
 8008b5a:	4607      	mov	r7, r0
                        }
                    }

                  if(buf->privateData)
 8008b5c:	68e3      	ldr	r3, [r4, #12]
 8008b5e:	b1ab      	cbz	r3, 8008b8c <communicatorPeriodic+0xa0>
                    {
                      //No confirmation came
                      //Remove message from table and send it as nACK
                      bRemove(&(MSG_TYPES_TAB[i].buffers), buf);
 8008b60:	4621      	mov	r1, r4
 8008b62:	f106 0048 	add.w	r0, r6, #72	; 0x48
 8008b66:	f004 fd4f 	bl	800d608 <bRemove>

                      if(MSG_TYPES_TAB[i].nackCode && send)
 8008b6a:	68eb      	ldr	r3, [r5, #12]
 8008b6c:	b15b      	cbz	r3, 8008b86 <communicatorPeriodic+0x9a>
 8008b6e:	b157      	cbz	r7, 8008b86 <communicatorPeriodic+0x9a>
                        {
                          //Send nACK/ACK to CEN
                          if(send &CB_RET_nACK)
 8008b70:	07ba      	lsls	r2, r7, #30
                            buf->data[0] = MSG_TYPES_TAB[i].nackCode;
                          messageTx(CEN_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
 8008b72:	4621      	mov	r1, r4

                      if(MSG_TYPES_TAB[i].nackCode && send)
                        {
                          //Send nACK/ACK to CEN
                          if(send &CB_RET_nACK)
                            buf->data[0] = MSG_TYPES_TAB[i].nackCode;
 8008b74:	bf48      	it	mi
 8008b76:	7523      	strbmi	r3, [r4, #20]
                          messageTx(CEN_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
 8008b78:	f831 2b14 	ldrh.w	r2, [r1], #20
 8008b7c:	4623      	mov	r3, r4
 8008b7e:	2000      	movs	r0, #0
 8008b80:	f003 f814 	bl	800bbac <messageTx>
 8008b84:	e002      	b.n	8008b8c <communicatorPeriodic+0xa0>
                        }
                      else
                        bFree(buf);
 8008b86:	4620      	mov	r0, r4
 8008b88:	f004 ffac 	bl	800dae4 <bFree>
                        {

#ifdef MADO
                          //                          SPIevent(portNum, SPI_EV_TYPE_LINK_ERROR);
#endif
                          if(MSG_TYPES_TAB[i].timeoutCallback)
 8008b8c:	465c      	mov	r4, fp
 8008b8e:	e7c8      	b.n	8008b22 <communicatorPeriodic+0x36>
 8008b90:	2001a1e4 	.word	0x2001a1e4

08008b94 <sendKANow>:

void __attribute__((weak))connectionState(netState_e state)
{
}
void __attribute__((weak))sendKANow(portNum_t portNum)
{
 8008b94:	4770      	bx	lr
	...

08008b98 <lockNonFlashMessages>:
void lockNonFlashMessages(uint8_t lock)
{
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
 8008b98:	490d      	ldr	r1, [pc, #52]	; (8008bd0 <lockNonFlashMessages+0x38>)
    }
  return CEN_PORT;
}

void lockNonFlashMessages(uint8_t lock)
{
 8008b9a:	b570      	push	{r4, r5, r6, lr}
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
 8008b9c:	2300      	movs	r3, #0
    {
      if(MSG_TYPES_TAB[i].size == 0) continue;
 8008b9e:	244c      	movs	r4, #76	; 0x4c
 8008ba0:	460d      	mov	r5, r1
 8008ba2:	fb04 1203 	mla	r2, r4, r3, r1
 8008ba6:	6856      	ldr	r6, [r2, #4]
 8008ba8:	b16e      	cbz	r6, 8008bc6 <lockNonFlashMessages+0x2e>
      switch(MSG_TYPES_TAB[i].code)
 8008baa:	6812      	ldr	r2, [r2, #0]
 8008bac:	2ac2      	cmp	r2, #194	; 0xc2
 8008bae:	dc05      	bgt.n	8008bbc <lockNonFlashMessages+0x24>
 8008bb0:	2ac1      	cmp	r2, #193	; 0xc1
 8008bb2:	da08      	bge.n	8008bc6 <lockNonFlashMessages+0x2e>
 8008bb4:	2a55      	cmp	r2, #85	; 0x55
 8008bb6:	d006      	beq.n	8008bc6 <lockNonFlashMessages+0x2e>
 8008bb8:	2aa2      	cmp	r2, #162	; 0xa2
 8008bba:	e000      	b.n	8008bbe <lockNonFlashMessages+0x26>
 8008bbc:	2acc      	cmp	r2, #204	; 0xcc
        case 0xC1:
        case 0xC2:
          //Do not block
          break;
        default:
          MSG_TYPES_TAB[i].blocked = lock;
 8008bbe:	bf1c      	itt	ne
 8008bc0:	fb04 5203 	mlane	r2, r4, r3, r5
 8008bc4:	6250      	strne	r0, [r2, #36]	; 0x24
}

void lockNonFlashMessages(uint8_t lock)
{
  int i;
  for (i = 0; i < sizeof(MSG_TYPES_TAB) / sizeof(MSG_TYPES_TAB[0]); i++)
 8008bc6:	3301      	adds	r3, #1
 8008bc8:	2b16      	cmp	r3, #22
 8008bca:	d1ea      	bne.n	8008ba2 <lockNonFlashMessages+0xa>
          break;

        }
    }

}
 8008bcc:	bd70      	pop	{r4, r5, r6, pc}
 8008bce:	bf00      	nop
 8008bd0:	2001a1e4 	.word	0x2001a1e4

08008bd4 <msgnACK>:
  return CB_RET_ACK;
}

static int msgnACK(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
  if(DIRECTION(portNum)) return 0;
 8008bd4:	2800      	cmp	r0, #0
  return CB_RET_nACK;
}
 8008bd6:	bf14      	ite	ne
 8008bd8:	2002      	movne	r0, #2
 8008bda:	2000      	moveq	r0, #0
 8008bdc:	4770      	bx	lr
	...

08008be0 <msgNegOn>:
}

static int msgNegOn(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
  //  msg_51_t *data = (void *)bBuffer->data;
  if(cfg.ack50)
 8008be0:	4b03      	ldr	r3, [pc, #12]	; (8008bf0 <msgNegOn+0x10>)
 8008be2:	689b      	ldr	r3, [r3, #8]
 8008be4:	2b00      	cmp	r3, #0
    {
      return CB_RET_nACK;
    }
  //Send ACK instead of nACK
  return CB_RET_ACK;
}
 8008be6:	bf14      	ite	ne
 8008be8:	2002      	movne	r0, #2
 8008bea:	2001      	moveq	r0, #1
 8008bec:	4770      	bx	lr
 8008bee:	bf00      	nop
 8008bf0:	10001000 	.word	0x10001000

08008bf4 <msgFlash>:
    }
  return 0;
}

static int msgFlash(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008bf4:	b570      	push	{r4, r5, r6, lr}
 8008bf6:	4614      	mov	r4, r2
  msg_A2_t *data = (void*)bBuffer->data;
  if(DIRECTION(portNum))
 8008bf8:	2800      	cmp	r0, #0
 8008bfa:	f040 80aa 	bne.w	8008d52 <msgFlash+0x15e>
    {
      A2Data_t *buf = (A2Data_t *)data;
      bBuffer->size = sizeof(msg_A2r_t);
 8008bfe:	2206      	movs	r2, #6
 8008c00:	8022      	strh	r2, [r4, #0]
      *forwardMask = 0;
 8008c02:	7018      	strb	r0, [r3, #0]
      switch(buf->subCode)
 8008c04:	7d63      	ldrb	r3, [r4, #21]
 8008c06:	3b01      	subs	r3, #1
 8008c08:	2b03      	cmp	r3, #3
 8008c0a:	f200 80a4 	bhi.w	8008d56 <msgFlash+0x162>
 8008c0e:	e8df f003 	tbb	[pc, r3]
 8008c12:	624d      	.short	0x624d
 8008c14:	022c      	.short	0x022c
        {
        case FILE_INIT:
        {
          dprintf(LL_INFO, "Inicjalizacja flashowania \n");
 8008c16:	4b51      	ldr	r3, [pc, #324]	; (8008d5c <msgFlash+0x168>)
 8008c18:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008c1a:	2b01      	cmp	r3, #1
 8008c1c:	dd02      	ble.n	8008c24 <msgFlash+0x30>
 8008c1e:	4850      	ldr	r0, [pc, #320]	; (8008d60 <msgFlash+0x16c>)
 8008c20:	f7ff fda0 	bl	8008764 <xprintf>
          lockNonFlashMessages(1);
 8008c24:	2001      	movs	r0, #1
 8008c26:	f7ff ffb7 	bl	8008b98 <lockNonFlashMessages>

          //Erase FLASH
          FLASH_ClearFlag(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR );
 8008c2a:	20f2      	movs	r0, #242	; 0xf2
 8008c2c:	f7f7 fe74 	bl	8000918 <FLASH_ClearFlag>
          FLASH_Unlock();
 8008c30:	f7f7 fe64 	bl	80008fc <FLASH_Unlock>
          IWDG_ReloadCounter();
 8008c34:	f00a fb56 	bl	80132e4 <IWDG_ReloadCounter>
          FLASH_EraseSector(FLASH_Sector_8, VoltageRange_3);
 8008c38:	2102      	movs	r1, #2
 8008c3a:	2040      	movs	r0, #64	; 0x40
 8008c3c:	f7f7 feb2 	bl	80009a4 <FLASH_EraseSector>
          IWDG_ReloadCounter();
 8008c40:	f00a fb50 	bl	80132e4 <IWDG_ReloadCounter>
          FLASH_EraseSector(FLASH_Sector_9, VoltageRange_3);
 8008c44:	2102      	movs	r1, #2
 8008c46:	2048      	movs	r0, #72	; 0x48
 8008c48:	f7f7 feac 	bl	80009a4 <FLASH_EraseSector>
          IWDG_ReloadCounter();
 8008c4c:	f00a fb4a 	bl	80132e4 <IWDG_ReloadCounter>
          FLASH_EraseSector(FLASH_Sector_10, VoltageRange_3);
 8008c50:	2102      	movs	r1, #2
 8008c52:	2050      	movs	r0, #80	; 0x50
 8008c54:	f7f7 fea6 	bl	80009a4 <FLASH_EraseSector>
          IWDG_ReloadCounter();
 8008c58:	f00a fb44 	bl	80132e4 <IWDG_ReloadCounter>
          FLASH_EraseSector(FLASH_Sector_11, VoltageRange_3);
 8008c5c:	2102      	movs	r1, #2
 8008c5e:	2058      	movs	r0, #88	; 0x58
 8008c60:	f7f7 fea0 	bl	80009a4 <FLASH_EraseSector>
          IWDG_ReloadCounter();
 8008c64:	f00a fb3e 	bl	80132e4 <IWDG_ReloadCounter>
 8008c68:	e05c      	b.n	8008d24 <msgFlash+0x130>
          return CB_RET_ACK;
        }
        case FILE_BUFFER:
        {
          int crc = buf->cmd_buffer.crc;
          buf->cmd_buffer.crc = 0;
 8008c6a:	2000      	movs	r0, #0
          //Send ACK od nACK
          return CB_RET_ACK;
        }
        case FILE_BUFFER:
        {
          int crc = buf->cmd_buffer.crc;
 8008c6c:	8e65      	ldrh	r5, [r4, #50]	; 0x32
          buf->cmd_buffer.crc = 0;
 8008c6e:	f884 0032 	strb.w	r0, [r4, #50]	; 0x32
 8008c72:	f884 0033 	strb.w	r0, [r4, #51]	; 0x33
          if(crc != crc16(0, buf, sizeof(A2Data_t)))
 8008c76:	2220      	movs	r2, #32
 8008c78:	f104 0114 	add.w	r1, r4, #20
 8008c7c:	f7f7 fb2a 	bl	80002d4 <crc16>
 8008c80:	4285      	cmp	r5, r0
 8008c82:	d168      	bne.n	8008d56 <msgFlash+0x162>
            return CB_RET_nACK;

          //Store in flash
          int offset = buf->cmd_buffer.chunkIdx*sizeof(buf->cmd_buffer.data);
          uint32_t *src = (uint32_t*)buf->cmd_buffer.data;
          uint32_t addr = (uint32_t)(&flashStorage[offset]);
 8008c84:	8b23      	ldrh	r3, [r4, #24]
 8008c86:	4a37      	ldr	r2, [pc, #220]	; (8008d64 <msgFlash+0x170>)
          if(crc != crc16(0, buf, sizeof(A2Data_t)))
            return CB_RET_nACK;

          //Store in flash
          int offset = buf->cmd_buffer.chunkIdx*sizeof(buf->cmd_buffer.data);
          uint32_t *src = (uint32_t*)buf->cmd_buffer.data;
 8008c88:	f104 051a 	add.w	r5, r4, #26
          uint32_t addr = (uint32_t)(&flashStorage[offset]);
 8008c8c:	2418      	movs	r4, #24
 8008c8e:	fb04 2403 	mla	r4, r4, r3, r2
 8008c92:	f104 0618 	add.w	r6, r4, #24
          int num =  sizeof(buf->cmd_buffer.data)/4;
          while(num--)
 8008c96:	42b4      	cmp	r4, r6
 8008c98:	d044      	beq.n	8008d24 <msgFlash+0x130>
            {
              if(FLASH_ProgramWord(addr, *(src++)) != FLASH_COMPLETE)
 8008c9a:	f855 1b04 	ldr.w	r1, [r5], #4
 8008c9e:	4620      	mov	r0, r4
 8008ca0:	f7f7 fed4 	bl	8000a4c <FLASH_ProgramWord>
 8008ca4:	2809      	cmp	r0, #9
 8008ca6:	d156      	bne.n	8008d56 <msgFlash+0x162>
                return CB_RET_nACK;
              addr+=4;
 8008ca8:	3404      	adds	r4, #4
 8008caa:	e7f4      	b.n	8008c96 <msgFlash+0xa2>
          //Send ACK
          return CB_RET_ACK;
        }
        case FILE_STM:
        {
          dprintf(LL_INFO, "Flashowanie STMa \n");
 8008cac:	4d2b      	ldr	r5, [pc, #172]	; (8008d5c <msgFlash+0x168>)
 8008cae:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8008cb0:	2b01      	cmp	r3, #1
 8008cb2:	dd02      	ble.n	8008cba <msgFlash+0xc6>
 8008cb4:	482c      	ldr	r0, [pc, #176]	; (8008d68 <msgFlash+0x174>)
 8008cb6:	f7ff fd55 	bl	8008764 <xprintf>
          //Calculate checksum and prepare for update
          uint32_t crc = crc32(0, flashStorage, buf->cmd_finish.size);
 8008cba:	69a2      	ldr	r2, [r4, #24]
 8008cbc:	4929      	ldr	r1, [pc, #164]	; (8008d64 <msgFlash+0x170>)
 8008cbe:	2000      	movs	r0, #0
 8008cc0:	f7f7 faf4 	bl	80002ac <crc32>
          if(crc != buf->cmd_finish.crc32)
 8008cc4:	69e3      	ldr	r3, [r4, #28]
 8008cc6:	4298      	cmp	r0, r3
 8008cc8:	d145      	bne.n	8008d56 <msgFlash+0x162>
            return CB_RET_nACK;

          //Update by bootloader
          cfg.fSize = buf->cmd_finish.size;
 8008cca:	69a3      	ldr	r3, [r4, #24]
 8008ccc:	602b      	str	r3, [r5, #0]
          cfg.fCRC = buf->cmd_finish.crc32;
 8008cce:	6068      	str	r0, [r5, #4]
          cfgFlush();
 8008cd0:	f7f7 fa82 	bl	80001d8 <cfgFlush>
 8008cd4:	e024      	b.n	8008d20 <msgFlash+0x12c>
          //Send ACK od nACK
          return CB_RET_ACK;
        }
        case FILE_SHARC:
        {
          dprintf(LL_INFO, "Flashowanie SHARCa\n");
 8008cd6:	4d21      	ldr	r5, [pc, #132]	; (8008d5c <msgFlash+0x168>)
 8008cd8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8008cda:	2b01      	cmp	r3, #1
 8008cdc:	dd02      	ble.n	8008ce4 <msgFlash+0xf0>
 8008cde:	4823      	ldr	r0, [pc, #140]	; (8008d6c <msgFlash+0x178>)
 8008ce0:	f7ff fd40 	bl	8008764 <xprintf>

          //Calculate checksum and update SHARC
          uint32_t crc = crc32(0, flashStorage, buf->cmd_finish.size);
 8008ce4:	69a2      	ldr	r2, [r4, #24]
 8008ce6:	491f      	ldr	r1, [pc, #124]	; (8008d64 <msgFlash+0x170>)
 8008ce8:	2000      	movs	r0, #0
 8008cea:	f7f7 fadf 	bl	80002ac <crc32>
          if(crc != buf->cmd_finish.crc32)
 8008cee:	69e3      	ldr	r3, [r4, #28]
 8008cf0:	4298      	cmp	r0, r3
 8008cf2:	d130      	bne.n	8008d56 <msgFlash+0x162>
            return CB_RET_nACK;

          //SPK SW
          GPIO_WriteBit(GPIOA, GPIO_Pin_9, 0);
 8008cf4:	2200      	movs	r2, #0
 8008cf6:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008cfa:	481d      	ldr	r0, [pc, #116]	; (8008d70 <msgFlash+0x17c>)
 8008cfc:	f008 f94a 	bl	8010f94 <GPIO_WriteBit>
          //RST_AMP
          GPIO_WriteBit(GPIOA, GPIO_Pin_11, 0);
 8008d00:	2200      	movs	r2, #0
 8008d02:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8008d06:	481a      	ldr	r0, [pc, #104]	; (8008d70 <msgFlash+0x17c>)
 8008d08:	f008 f944 	bl	8010f94 <GPIO_WriteBit>

          //wait after setting shark
          mdelay(10);
 8008d0c:	200a      	movs	r0, #10
 8008d0e:	f001 fdbf 	bl	800a890 <vTaskDelay>

          //Initialize SPI for sharc
          sharc_spi_init();
 8008d12:	f006 fd51 	bl	800f7b8 <sharc_spi_init>
          mdelay(10);
 8008d16:	200a      	movs	r0, #10
 8008d18:	f001 fdba 	bl	800a890 <vTaskDelay>

          int programRetry = cfg.sharcProgramRetry;
 8008d1c:	6dae      	ldr	r6, [r5, #88]	; 0x58
          while(programRetry--)
 8008d1e:	e00d      	b.n	8008d3c <msgFlash+0x148>
            {
              if(m25p20Program(flashStorage, buf->cmd_finish.size) == 0)
                {
                  watchdogReset();//Delayed reset
 8008d20:	f006 f86c 	bl	800edfc <watchdogReset>
                  //Send ACK
                  return CB_RET_ACK;
 8008d24:	2001      	movs	r0, #1
 8008d26:	bd70      	pop	{r4, r5, r6, pc}
          mdelay(10);

          int programRetry = cfg.sharcProgramRetry;
          while(programRetry--)
            {
              if(m25p20Program(flashStorage, buf->cmd_finish.size) == 0)
 8008d28:	69a1      	ldr	r1, [r4, #24]
 8008d2a:	480e      	ldr	r0, [pc, #56]	; (8008d64 <msgFlash+0x170>)
 8008d2c:	f006 fa6e 	bl	800f20c <m25p20Program>
 8008d30:	3e01      	subs	r6, #1
 8008d32:	2800      	cmp	r0, #0
 8008d34:	d0f4      	beq.n	8008d20 <msgFlash+0x12c>
                  watchdogReset();//Delayed reset
                  //Send ACK
                  return CB_RET_ACK;
                }
#ifdef WATCHDOG_COMM
              wdogFeed(WATCHDOG_COMM(0));
 8008d36:	2008      	movs	r0, #8
 8008d38:	f006 f852 	bl	800ede0 <wdogFeed>
          //Initialize SPI for sharc
          sharc_spi_init();
          mdelay(10);

          int programRetry = cfg.sharcProgramRetry;
          while(programRetry--)
 8008d3c:	2e00      	cmp	r6, #0
 8008d3e:	d1f3      	bne.n	8008d28 <msgFlash+0x134>
                }
#ifdef WATCHDOG_COMM
              wdogFeed(WATCHDOG_COMM(0));
#endif
            }
          dprintf(LL_INFO, "Flashowanie SHARCa zakonczone\n");
 8008d40:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8008d42:	2b01      	cmp	r3, #1
 8008d44:	dd02      	ble.n	8008d4c <msgFlash+0x158>
 8008d46:	480b      	ldr	r0, [pc, #44]	; (8008d74 <msgFlash+0x180>)
 8008d48:	f7ff fd0c 	bl	8008764 <xprintf>

          watchdogReset();//Delayed reset
 8008d4c:	f006 f856 	bl	800edfc <watchdogReset>
 8008d50:	e001      	b.n	8008d56 <msgFlash+0x162>
        }
        default:
          return CB_RET_nACK;
        }
    }
  return 0;
 8008d52:	2000      	movs	r0, #0
 8008d54:	bd70      	pop	{r4, r5, r6, pc}
          watchdogReset();//Delayed reset
          //Send nACK
          return CB_RET_nACK;
        }
        default:
          return CB_RET_nACK;
 8008d56:	2002      	movs	r0, #2
        }
    }
  return 0;
}
 8008d58:	bd70      	pop	{r4, r5, r6, pc}
 8008d5a:	bf00      	nop
 8008d5c:	10001000 	.word	0x10001000
 8008d60:	0801488e 	.word	0x0801488e
 8008d64:	08080000 	.word	0x08080000
 8008d68:	080148aa 	.word	0x080148aa
 8008d6c:	080148bd 	.word	0x080148bd
 8008d70:	40020000 	.word	0x40020000
 8008d74:	080148d1 	.word	0x080148d1

08008d78 <sendKACC>:
      timestamp = 0xFFFFFFFF;
    }
}

static void sendKACC(void)
{
 8008d78:	b573      	push	{r0, r1, r4, r5, r6, lr}
  //Keep alive to PWM and Sharc
  bBuffer_t *buf = bAlloc(MSG_LEN);
 8008d7a:	2020      	movs	r0, #32
 8008d7c:	f004 fc58 	bl	800d630 <bAlloc>
  massert(buf);
 8008d80:	4604      	mov	r4, r0
 8008d82:	b1d0      	cbz	r0, 8008dba <sendKACC+0x42>
  buf->size = sizeof(msg_CC_t);
 8008d84:	4625      	mov	r5, r4
 8008d86:	2601      	movs	r6, #1
  msg_CC_t *msg = (void*)buf->data;
  memset(msg, 0, sizeof(msg_CC_t));
 8008d88:	2300      	movs	r3, #0
static void sendKACC(void)
{
  //Keep alive to PWM and Sharc
  bBuffer_t *buf = bAlloc(MSG_LEN);
  massert(buf);
  buf->size = sizeof(msg_CC_t);
 8008d8a:	f825 6b14 	strh.w	r6, [r5], #20
  msg_CC_t *msg = (void*)buf->data;
  memset(msg, 0, sizeof(msg_CC_t));
 8008d8e:	7523      	strb	r3, [r4, #20]
  msg->kod = 0xC0 + portData[CEN_PORT].urzadzenie;
 8008d90:	4b10      	ldr	r3, [pc, #64]	; (8008dd4 <sendKACC+0x5c>)
 8008d92:	7e9b      	ldrb	r3, [r3, #26]
 8008d94:	3b40      	subs	r3, #64	; 0x40
 8008d96:	7523      	strb	r3, [r4, #20]

  bRef(buf);
 8008d98:	4620      	mov	r0, r4
 8008d9a:	f004 ffe1 	bl	800dd60 <bRef>
  messageTx(PER1_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
 8008d9e:	4623      	mov	r3, r4
 8008da0:	8822      	ldrh	r2, [r4, #0]
 8008da2:	4629      	mov	r1, r5
 8008da4:	4630      	mov	r0, r6
 8008da6:	f002 ff01 	bl	800bbac <messageTx>
  messageTx(PER2_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
 8008daa:	4623      	mov	r3, r4
 8008dac:	8822      	ldrh	r2, [r4, #0]
 8008dae:	4629      	mov	r1, r5
 8008db0:	2002      	movs	r0, #2
 8008db2:	f002 fefb 	bl	800bbac <messageTx>
}
 8008db6:	b002      	add	sp, #8
 8008db8:	bd70      	pop	{r4, r5, r6, pc}

static void sendKACC(void)
{
  //Keep alive to PWM and Sharc
  bBuffer_t *buf = bAlloc(MSG_LEN);
  massert(buf);
 8008dba:	4b07      	ldr	r3, [pc, #28]	; (8008dd8 <sendKACC+0x60>)
 8008dbc:	4907      	ldr	r1, [pc, #28]	; (8008ddc <sendKACC+0x64>)
 8008dbe:	4808      	ldr	r0, [pc, #32]	; (8008de0 <sendKACC+0x68>)
 8008dc0:	f240 229b 	movw	r2, #667	; 0x29b
 8008dc4:	f7ff fcce 	bl	8008764 <xprintf>
 8008dc8:	2301      	movs	r3, #1
 8008dca:	9301      	str	r3, [sp, #4]
 8008dcc:	9b01      	ldr	r3, [sp, #4]
 8008dce:	2b00      	cmp	r3, #0
 8008dd0:	d1fc      	bne.n	8008dcc <sendKACC+0x54>
 8008dd2:	e7d7      	b.n	8008d84 <sendKACC+0xc>
 8008dd4:	2001aabc 	.word	0x2001aabc
 8008dd8:	080148f0 	.word	0x080148f0
 8008ddc:	0801486f 	.word	0x0801486f
 8008de0:	080148f4 	.word	0x080148f4

08008de4 <msgProgram>:
    }
  return 0;
}

static int msgProgram(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008de4:	b508      	push	{r3, lr}
  msg_9C_t *data = (void*)bBuffer->data;
  if(DIRECTION(portNum))
 8008de6:	b9e8      	cbnz	r0, 8008e24 <msgProgram+0x40>
    {
      cfg.manId = (((uint32_t)data->man_id3) << 24) | (((uint32_t)data->man_id2) << 16) | (((uint32_t)data->man_id1) << 8);
 8008de8:	7dd3      	ldrb	r3, [r2, #23]
 8008dea:	7d91      	ldrb	r1, [r2, #22]
 8008dec:	041b      	lsls	r3, r3, #16
 8008dee:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8008df2:	7e11      	ldrb	r1, [r2, #24]
 8008df4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8008df8:	490b      	ldr	r1, [pc, #44]	; (8008e28 <msgProgram+0x44>)
 8008dfa:	630b      	str	r3, [r1, #48]	; 0x30
      cfg.kondPom = data->kondPom;
 8008dfc:	7d53      	ldrb	r3, [r2, #21]
 8008dfe:	634b      	str	r3, [r1, #52]	; 0x34
      cfg.flags = (((data->flags&MSG9C_FLAGS_PIPE_MASK)?1:0)<<2) | (((data->flags&MSG9C_FLAGS_LEFT_MASK)?1:0)<<0) | (1<<1);
 8008e00:	7e53      	ldrb	r3, [r2, #25]
 8008e02:	f013 0f01 	tst.w	r3, #1
 8008e06:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8008e0a:	bf14      	ite	ne
 8008e0c:	2204      	movne	r2, #4
 8008e0e:	2200      	moveq	r2, #0
 8008e10:	f043 0302 	orr.w	r3, r3, #2
 8008e14:	4313      	orrs	r3, r2
 8008e16:	638b      	str	r3, [r1, #56]	; 0x38
      //Program master
      cfgFlush();
 8008e18:	f7f7 f9de 	bl	80001d8 <cfgFlush>
      watchdogReset();//Delayed reset
 8008e1c:	f005 ffee 	bl	800edfc <watchdogReset>
 8008e20:	2001      	movs	r0, #1
 8008e22:	bd08      	pop	{r3, pc}
      return CB_RET_ACK;
    }
  return 0;
 8008e24:	2000      	movs	r0, #0
}
 8008e26:	bd08      	pop	{r3, pc}
 8008e28:	10001000 	.word	0x10001000

08008e2c <kaOk>:
  messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
  return 0;
}

static int kaOk(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008e2c:	b510      	push	{r4, lr}
  if(!DIRECTION(portNum))
 8008e2e:	4604      	mov	r4, r0
 8008e30:	b140      	cbz	r0, 8008e44 <kaOk+0x18>
    {
      uitOk(portNum);
 8008e32:	f000 fcbf 	bl	80097b4 <uitOk>
      portData[portNum].keepAlive = xTaskGetTickCount();
 8008e36:	f001 fc35 	bl	800a6a4 <xTaskGetTickCount>
 8008e3a:	4b03      	ldr	r3, [pc, #12]	; (8008e48 <kaOk+0x1c>)
 8008e3c:	2250      	movs	r2, #80	; 0x50
 8008e3e:	fb02 3404 	mla	r4, r2, r4, r3
 8008e42:	6260      	str	r0, [r4, #36]	; 0x24
    }
  return 0;
}
 8008e44:	2000      	movs	r0, #0
 8008e46:	bd10      	pop	{r4, pc}
 8008e48:	2001aabc 	.word	0x2001aabc

08008e4c <msgVolume>:
  return 0;
}


static int msgVolume(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008e4c:	b538      	push	{r3, r4, r5, lr}
 8008e4e:	461d      	mov	r5, r3
  msg_80_t *data = (void *)bBuffer->data;
  if(DIRECTION(portNum))
 8008e50:	4604      	mov	r4, r0
 8008e52:	b930      	cbnz	r0, 8008e62 <msgVolume+0x16>
    {
      spkSet.volume = data->volume;
 8008e54:	4b05      	ldr	r3, [pc, #20]	; (8008e6c <msgVolume+0x20>)
 8008e56:	7dd2      	ldrb	r2, [r2, #23]
 8008e58:	701a      	strb	r2, [r3, #0]
      if(!isOn())
 8008e5a:	f000 fc0b 	bl	8009674 <isOn>
 8008e5e:	b910      	cbnz	r0, 8008e66 <msgVolume+0x1a>
        {
          //If not ON state then respond on the message for PWM and SHARC
          *forwardMask = 0;
 8008e60:	7028      	strb	r0, [r5, #0]
          return CB_RET_ACK;
        }
      return 0;
    }
  return CB_RET_ACK;
 8008e62:	2001      	movs	r0, #1
 8008e64:	bd38      	pop	{r3, r4, r5, pc}
        {
          //If not ON state then respond on the message for PWM and SHARC
          *forwardMask = 0;
          return CB_RET_ACK;
        }
      return 0;
 8008e66:	4620      	mov	r0, r4
    }
  return CB_RET_ACK;
}
 8008e68:	bd38      	pop	{r3, r4, r5, pc}
 8008e6a:	bf00      	nop
 8008e6c:	2001ac30 	.word	0x2001ac30

08008e70 <msgACK>:
static int outputType = -1;
int myPipeNum = 0;
int amIStereo = 0;
#define isHD (signalType >= 0xA)
static int msgACK(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008e70:	b538      	push	{r3, r4, r5, lr}
 8008e72:	461d      	mov	r5, r3
  if(DIRECTION(portNum))
 8008e74:	4604      	mov	r4, r0
 8008e76:	b918      	cbnz	r0, 8008e80 <msgACK+0x10>
    {
      if(!isOn())
 8008e78:	f000 fbfc 	bl	8009674 <isOn>
 8008e7c:	b910      	cbnz	r0, 8008e84 <msgACK+0x14>
        {
          //If not ON state then respond on the message for PWM and SHARC
          *forwardMask = 0;
 8008e7e:	7028      	strb	r0, [r5, #0]
          return CB_RET_ACK;
        }
      return 0;
    }
  return CB_RET_ACK;
 8008e80:	2001      	movs	r0, #1
 8008e82:	bd38      	pop	{r3, r4, r5, pc}
        {
          //If not ON state then respond on the message for PWM and SHARC
          *forwardMask = 0;
          return CB_RET_ACK;
        }
      return 0;
 8008e84:	4620      	mov	r0, r4
    }
  return CB_RET_ACK;
}
 8008e86:	bd38      	pop	{r3, r4, r5, pc}

08008e88 <msgnACKamp>:
    }
  return CB_RET_ACK;
}

static int msgnACKamp(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008e88:	b508      	push	{r3, lr}
  if(DIRECTION(portNum)) return 0;
 8008e8a:	b158      	cbz	r0, 8008ea4 <msgnACKamp+0x1c>
  if(isOn())
 8008e8c:	f000 fbf2 	bl	8009674 <isOn>
 8008e90:	b138      	cbz	r0, 8008ea2 <msgnACKamp+0x1a>
    {
      mdelay(cfg.ampEnableDelay58);
 8008e92:	4b05      	ldr	r3, [pc, #20]	; (8008ea8 <msgnACKamp+0x20>)
 8008e94:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
 8008e98:	f001 fcfa 	bl	800a890 <vTaskDelay>
      ampEnable(1);
 8008e9c:	2001      	movs	r0, #1
 8008e9e:	f006 fe77 	bl	800fb90 <ampEnable>
    }
  return CB_RET_nACK;
 8008ea2:	2002      	movs	r0, #2
}
 8008ea4:	bd08      	pop	{r3, pc}
 8008ea6:	bf00      	nop
 8008ea8:	10001000 	.word	0x10001000

08008eac <msg585Atimeout>:

static int msg585Atimeout(portNum_t portNum, comm_t *comm)
{
 8008eac:	b508      	push	{r3, lr}
  if(isOn())
 8008eae:	f000 fbe1 	bl	8009674 <isOn>
 8008eb2:	b138      	cbz	r0, 8008ec4 <msg585Atimeout+0x18>
    {
      mdelay(cfg.ampEnableDelay58);
 8008eb4:	4b04      	ldr	r3, [pc, #16]	; (8008ec8 <msg585Atimeout+0x1c>)
 8008eb6:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
 8008eba:	f001 fce9 	bl	800a890 <vTaskDelay>
      ampEnable(1);
 8008ebe:	2001      	movs	r0, #1
 8008ec0:	f006 fe66 	bl	800fb90 <ampEnable>
    }
  return CB_RET_nACK;
}
 8008ec4:	2002      	movs	r0, #2
 8008ec6:	bd08      	pop	{r3, pc}
 8008ec8:	10001000 	.word	0x10001000

08008ecc <msgACKamp58>:
  if(DIRECTION(portNum)) return 0;
  return CB_RET_nACK;
}

static int msgACKamp58(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008ecc:	b570      	push	{r4, r5, r6, lr}
 8008ece:	4615      	mov	r5, r2
 8008ed0:	461e      	mov	r6, r3
  msg_58_t *data = (void*)bBuffer->data;
  if(DIRECTION(portNum))
 8008ed2:	4604      	mov	r4, r0
 8008ed4:	b958      	cbnz	r0, 8008eee <msgACKamp58+0x22>
    {
      if(!isOn())
 8008ed6:	f000 fbcd 	bl	8009674 <isOn>
 8008eda:	b908      	cbnz	r0, 8008ee0 <msgACKamp58+0x14>
        {
          //If not ON state then respond on the message for PWM and SHARC
          *forwardMask = 0;
 8008edc:	7030      	strb	r0, [r6, #0]
 8008ede:	e013      	b.n	8008f08 <msgACKamp58+0x3c>
          return CB_RET_ACK;
        }
      if(data->guiTp != 0)
 8008ee0:	7e68      	ldrb	r0, [r5, #25]
 8008ee2:	b190      	cbz	r0, 8008f0a <msgACKamp58+0x3e>
        ampEnable(0);
 8008ee4:	4620      	mov	r0, r4
 8008ee6:	f006 fe53 	bl	800fb90 <ampEnable>
      return 0;
 8008eea:	4620      	mov	r0, r4
 8008eec:	bd70      	pop	{r4, r5, r6, pc}
    }
  if(isOn() && data->guiTp != 0)
 8008eee:	f000 fbc1 	bl	8009674 <isOn>
 8008ef2:	b148      	cbz	r0, 8008f08 <msgACKamp58+0x3c>
 8008ef4:	7e6b      	ldrb	r3, [r5, #25]
 8008ef6:	b13b      	cbz	r3, 8008f08 <msgACKamp58+0x3c>
    {
      mdelay(cfg.ampEnableDelay58);
 8008ef8:	4b04      	ldr	r3, [pc, #16]	; (8008f0c <msgACKamp58+0x40>)
 8008efa:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
 8008efe:	f001 fcc7 	bl	800a890 <vTaskDelay>
      ampEnable(1);
 8008f02:	2001      	movs	r0, #1
 8008f04:	f006 fe44 	bl	800fb90 <ampEnable>
    }
  return CB_RET_ACK;
 8008f08:	2001      	movs	r0, #1
}
 8008f0a:	bd70      	pop	{r4, r5, r6, pc}
 8008f0c:	10001000 	.word	0x10001000

08008f10 <msgReconnect>:
    }
  return 0;
}

static int msgReconnect(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008f10:	b570      	push	{r4, r5, r6, lr}
 8008f12:	4d1f      	ldr	r5, [pc, #124]	; (8008f90 <msgReconnect+0x80>)
 8008f14:	4614      	mov	r4, r2
 8008f16:	461e      	mov	r6, r3
 8008f18:	7d93      	ldrb	r3, [r2, #22]
  msg_92_t *data = (void*)bBuffer->data;
  if(!DIRECTION(portNum))
    {
      if(signalType != data->signalType || outputType != data->outputType)
 8008f1a:	682a      	ldr	r2, [r5, #0]
}

static int msgReconnect(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
  msg_92_t *data = (void*)bBuffer->data;
  if(!DIRECTION(portNum))
 8008f1c:	b308      	cbz	r0, 8008f62 <msgReconnect+0x52>
    {
      if(signalType != data->signalType || outputType != data->outputType)
 8008f1e:	4293      	cmp	r3, r2
 8008f20:	d103      	bne.n	8008f2a <msgReconnect+0x1a>
 8008f22:	7de2      	ldrb	r2, [r4, #23]
 8008f24:	686b      	ldr	r3, [r5, #4]
 8008f26:	429a      	cmp	r2, r3
 8008f28:	d004      	beq.n	8008f34 <msgReconnect+0x24>
        mdelay(cfg.ampEnableDelay92);
 8008f2a:	4b1a      	ldr	r3, [pc, #104]	; (8008f94 <msgReconnect+0x84>)
 8008f2c:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0
 8008f30:	f001 fcae 	bl	800a890 <vTaskDelay>
      ampEnable(1);
 8008f34:	2001      	movs	r0, #1
 8008f36:	f006 fe2b 	bl	800fb90 <ampEnable>
      //Remenber signal and output types
      signalType = data->signalType;
 8008f3a:	7da3      	ldrb	r3, [r4, #22]
 8008f3c:	602b      	str	r3, [r5, #0]
      outputType = data->outputType;
 8008f3e:	7de3      	ldrb	r3, [r4, #23]
 8008f40:	606b      	str	r3, [r5, #4]
      if(isOn())
 8008f42:	f000 fb97 	bl	8009674 <isOn>
 8008f46:	b300      	cbz	r0, 8008f8a <msgReconnect+0x7a>
        SmokLEDsState(1, -1, SET_OTHER, isHD);
 8008f48:	4b11      	ldr	r3, [pc, #68]	; (8008f90 <msgReconnect+0x80>)
 8008f4a:	681b      	ldr	r3, [r3, #0]
 8008f4c:	2b09      	cmp	r3, #9
 8008f4e:	bfd4      	ite	le
 8008f50:	2300      	movle	r3, #0
 8008f52:	2301      	movgt	r3, #1
 8008f54:	2203      	movs	r2, #3
 8008f56:	f04f 31ff 	mov.w	r1, #4294967295
 8008f5a:	2001      	movs	r0, #1
 8008f5c:	f000 fc98 	bl	8009890 <SmokLEDsState>
 8008f60:	e013      	b.n	8008f8a <msgReconnect+0x7a>

      return CB_RET_ACK;
    }

  if(signalType != data->signalType || outputType != data->outputType)
 8008f62:	4293      	cmp	r3, r2
 8008f64:	d103      	bne.n	8008f6e <msgReconnect+0x5e>
 8008f66:	7de2      	ldrb	r2, [r4, #23]
 8008f68:	686b      	ldr	r3, [r5, #4]
 8008f6a:	429a      	cmp	r2, r3
 8008f6c:	d002      	beq.n	8008f74 <msgReconnect+0x64>
    ampEnable(0);
 8008f6e:	2000      	movs	r0, #0
 8008f70:	f006 fe0e 	bl	800fb90 <ampEnable>

  if(isOn())
 8008f74:	f000 fb7e 	bl	8009674 <isOn>
 8008f78:	b130      	cbz	r0, 8008f88 <msgReconnect+0x78>
    {
      //set PLL (only when ON)
      pll_set_retry(data->signalType, 0, 2);
 8008f7a:	2202      	movs	r2, #2
 8008f7c:	2100      	movs	r1, #0
 8008f7e:	7da0      	ldrb	r0, [r4, #22]
 8008f80:	f006 fde4 	bl	800fb4c <pll_set_retry>
    {
      //If not ON state then respond on the message for PWM and SHARC
      *forwardMask = 0;
      return CB_RET_ACK;
    }
  return 0;
 8008f84:	2000      	movs	r0, #0
 8008f86:	bd70      	pop	{r4, r5, r6, pc}
      pll_set_retry(data->signalType, 0, 2);
    }
  else
    {
      //If not ON state then respond on the message for PWM and SHARC
      *forwardMask = 0;
 8008f88:	7030      	strb	r0, [r6, #0]
        mdelay(cfg.ampEnableDelay92);
      ampEnable(1);
      //Remenber signal and output types
      signalType = data->signalType;
      outputType = data->outputType;
      if(isOn())
 8008f8a:	2001      	movs	r0, #1
      //If not ON state then respond on the message for PWM and SHARC
      *forwardMask = 0;
      return CB_RET_ACK;
    }
  return 0;
}
 8008f8c:	bd70      	pop	{r4, r5, r6, pc}
 8008f8e:	bf00      	nop
 8008f90:	2001a1d8 	.word	0x2001a1d8
 8008f94:	10001000 	.word	0x10001000

08008f98 <msgOff>:
    }
  return CB_RET_nACK;
}

static int msgOff(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008f98:	b538      	push	{r3, r4, r5, lr}
  if(DIRECTION(portNum))
 8008f9a:	4604      	mov	r4, r0
 8008f9c:	b108      	cbz	r0, 8008fa2 <msgOff+0xa>
          return CB_RET_ACK;
        }
      return CB_RET_nACK;
    }

  return CB_RET_nACK;
 8008f9e:	2002      	movs	r0, #2
 8008fa0:	bd38      	pop	{r3, r4, r5, pc}
static int msgOff(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
  if(DIRECTION(portNum))
    {
      //Already OFF?
      if(!isOn())
 8008fa2:	f000 fb67 	bl	8009674 <isOn>
 8008fa6:	b1a0      	cbz	r0, 8008fd2 <msgOff+0x3a>
        return CB_RET_ACK;

      int ret = SmokChangeState(Smok_OFF, "52 received");
 8008fa8:	490b      	ldr	r1, [pc, #44]	; (8008fd8 <msgOff+0x40>)
 8008faa:	2001      	movs	r0, #1
 8008fac:	f000 fc4c 	bl	8009848 <SmokChangeState>
      SmokLEDsState(0, -1, SET_NONE, -1);
 8008fb0:	f04f 33ff 	mov.w	r3, #4294967295
    {
      //Already OFF?
      if(!isOn())
        return CB_RET_ACK;

      int ret = SmokChangeState(Smok_OFF, "52 received");
 8008fb4:	4605      	mov	r5, r0
      SmokLEDsState(0, -1, SET_NONE, -1);
 8008fb6:	4622      	mov	r2, r4
 8008fb8:	4619      	mov	r1, r3
 8008fba:	4620      	mov	r0, r4
 8008fbc:	f000 fc68 	bl	8009890 <SmokLEDsState>
      /* LEDset(0, ~0, 0); */
      /* LEDset(0, LED_GREEN, 1); */

      if(ret >= 0)
 8008fc0:	2d00      	cmp	r5, #0
 8008fc2:	dbec      	blt.n	8008f9e <msgOff+0x6>
        {
          dprintf(LL_INFO, "Wylaczam zasilanie\n");
 8008fc4:	4b05      	ldr	r3, [pc, #20]	; (8008fdc <msgOff+0x44>)
 8008fc6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008fc8:	2b01      	cmp	r3, #1
 8008fca:	dd02      	ble.n	8008fd2 <msgOff+0x3a>
 8008fcc:	4804      	ldr	r0, [pc, #16]	; (8008fe0 <msgOff+0x48>)
 8008fce:	f7ff fbc9 	bl	8008764 <xprintf>
 8008fd2:	2001      	movs	r0, #1
        }
      return CB_RET_nACK;
    }

  return CB_RET_nACK;
}
 8008fd4:	bd38      	pop	{r3, r4, r5, pc}
 8008fd6:	bf00      	nop
 8008fd8:	0801490a 	.word	0x0801490a
 8008fdc:	10001000 	.word	0x10001000
 8008fe0:	08014916 	.word	0x08014916

08008fe4 <msgKeepAlive>:

static int msgKeepAlive(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 8008fe4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008fe6:	4614      	mov	r4, r2
  if(!DIRECTION(portNum)) return 0;
 8008fe8:	4606      	mov	r6, r0
 8008fea:	2800      	cmp	r0, #0
 8008fec:	f040 809b 	bne.w	8009126 <msgKeepAlive+0x142>
  msg_55_t *data = (void*)bBuffer->data;
  portData[portNum].tsLastSeen = xTaskGetTickCount();
 8008ff0:	f001 fb58 	bl	800a6a4 <xTaskGetTickCount>
 8008ff4:	4d4d      	ldr	r5, [pc, #308]	; (800912c <msgKeepAlive+0x148>)
 8008ff6:	63a8      	str	r0, [r5, #56]	; 0x38
  portData[portNum].keepAlive = xTaskGetTickCount();
 8008ff8:	f001 fb54 	bl	800a6a4 <xTaskGetTickCount>
  portData[portNum].ka++;
 8008ffc:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
static int msgKeepAlive(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
  if(!DIRECTION(portNum)) return 0;
  msg_55_t *data = (void*)bBuffer->data;
  portData[portNum].tsLastSeen = xTaskGetTickCount();
  portData[portNum].keepAlive = xTaskGetTickCount();
 8009000:	6268      	str	r0, [r5, #36]	; 0x24
  portData[portNum].ka++;
 8009002:	3301      	adds	r3, #1
 8009004:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
  if(data->flags55&FLAGS55_CONNECTION_ACTIVE)
 8009008:	7de3      	ldrb	r3, [r4, #23]
 800900a:	f003 0310 	and.w	r3, r3, #16
 800900e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8009012:	b113      	cbz	r3, 800901a <msgKeepAlive+0x36>
    SPIevent(portNum, SPI_EV_TYPE_LINK_ESTABLISHED);
 8009014:	2103      	movs	r1, #3
 8009016:	4630      	mov	r0, r6
 8009018:	e000      	b.n	800901c <msgKeepAlive+0x38>
  else
    SPIevent(portNum, SPI_EV_TYPE_DLINK_ERROR);
 800901a:	2102      	movs	r1, #2
 800901c:	f003 f81e 	bl	800c05c <SPIevent>

  //Get peer uptime
  uint32_t upTime;
  uint8_t *upTime8 = (uint8_t*) &upTime;
  upTime8[3] = data->uptime3;
 8009020:	7e23      	ldrb	r3, [r4, #24]
 8009022:	f88d 3007 	strb.w	r3, [sp, #7]
  upTime8[2] = data->uptime2;
 8009026:	7e63      	ldrb	r3, [r4, #25]
 8009028:	f88d 3006 	strb.w	r3, [sp, #6]
  upTime8[1] = data->uptime1;
 800902c:	7ea3      	ldrb	r3, [r4, #26]
 800902e:	f88d 3005 	strb.w	r3, [sp, #5]
  upTime8[0] = data->uptime0;
 8009032:	7ee3      	ldrb	r3, [r4, #27]
 8009034:	f88d 3004 	strb.w	r3, [sp, #4]
  portData[portNum].uptime = upTime;
 8009038:	9b01      	ldr	r3, [sp, #4]
 800903a:	636b      	str	r3, [r5, #52]	; 0x34

  upTime = xTaskGetTickCount();
 800903c:	f001 fb32 	bl	800a6a4 <xTaskGetTickCount>
  data->uptime3 = upTime8[3];
 8009040:	0e03      	lsrs	r3, r0, #24
 8009042:	7623      	strb	r3, [r4, #24]
  data->uptime2 = upTime8[2];
 8009044:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8009048:	7663      	strb	r3, [r4, #25]
  data->uptime1 = upTime8[1];
 800904a:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800904e:	76a3      	strb	r3, [r4, #26]
  data->uptime0 = upTime8[0];
 8009050:	76e0      	strb	r0, [r4, #27]
  upTime8[2] = data->uptime2;
  upTime8[1] = data->uptime1;
  upTime8[0] = data->uptime0;
  portData[portNum].uptime = upTime;

  upTime = xTaskGetTickCount();
 8009052:	9001      	str	r0, [sp, #4]
  data->uptime3 = upTime8[3];
  data->uptime2 = upTime8[2];
  data->uptime1 = upTime8[1];
  data->uptime0 = upTime8[0];
  if(isOn())
 8009054:	f000 fb0e 	bl	8009674 <isOn>
 8009058:	4e35      	ldr	r6, [pc, #212]	; (8009130 <msgKeepAlive+0x14c>)
 800905a:	7de3      	ldrb	r3, [r4, #23]
 800905c:	b1b8      	cbz	r0, 800908e <msgKeepAlive+0xaa>
    {
      if((data->flags55&FLAGS55_SMOK_ON) == 0)
 800905e:	f003 0104 	and.w	r1, r3, #4
 8009062:	f001 07ff 	and.w	r7, r1, #255	; 0xff
 8009066:	b971      	cbnz	r1, 8009086 <msgKeepAlive+0xa2>
        {
          //Off request
          SmokChangeState(Smok_OFF, "0x55 reqOn=0 - MADO ordered all SMOK's off");
 8009068:	4932      	ldr	r1, [pc, #200]	; (8009134 <msgKeepAlive+0x150>)
 800906a:	2001      	movs	r0, #1
 800906c:	f000 fbec 	bl	8009848 <SmokChangeState>
          SmokLEDsState(0, -1, SET_NONE, -1);
 8009070:	f04f 33ff 	mov.w	r3, #4294967295
 8009074:	4619      	mov	r1, r3
 8009076:	463a      	mov	r2, r7
 8009078:	4638      	mov	r0, r7
 800907a:	f000 fc09 	bl	8009890 <SmokLEDsState>
          data->flags55 &= ~FLAGS55_SMOK_ON;
 800907e:	7de3      	ldrb	r3, [r4, #23]
 8009080:	f023 0304 	bic.w	r3, r3, #4
 8009084:	e001      	b.n	800908a <msgKeepAlive+0xa6>
        }
      else
        data->flags55 |= FLAGS55_SMOK_ON;
 8009086:	f043 0304 	orr.w	r3, r3, #4
 800908a:	75e3      	strb	r3, [r4, #23]
 800908c:	e003      	b.n	8009096 <msgKeepAlive+0xb2>
    }
  else
    {
      data->flags55 &= ~FLAGS55_SMOK_ON;
 800908e:	f023 0304 	bic.w	r3, r3, #4
 8009092:	75e3      	strb	r3, [r4, #23]
      if(cfg.flags & FLAGS_AUTO_ON_MASK)
 8009094:	6bb3      	ldr	r3, [r6, #56]	; 0x38
          else
            data->flags55 &= ~FLAGS55_SMOK_ON;
        }
    }

  if(cfg.flags&FLAGS_PRIMARY_STREAM_MASK)
 8009096:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8009098:	f013 0f04 	tst.w	r3, #4
 800909c:	7de3      	ldrb	r3, [r4, #23]
    data->flags55 |= FLAGS55_DEFAULT_PIPE;
 800909e:	bf14      	ite	ne
 80090a0:	f043 0308 	orrne.w	r3, r3, #8
  else
    data->flags55 &= ~FLAGS55_DEFAULT_PIPE;
 80090a4:	f023 0308 	biceq.w	r3, r3, #8
 80090a8:	75e3      	strb	r3, [r4, #23]

  data->cSharc     = spkSet.cSharc;
 80090aa:	4b23      	ldr	r3, [pc, #140]	; (8009138 <msgKeepAlive+0x154>)
 80090ac:	785a      	ldrb	r2, [r3, #1]
 80090ae:	7722      	strb	r2, [r4, #28]
  data->cPWM       = spkSet.cPWM;
 80090b0:	789a      	ldrb	r2, [r3, #2]
 80090b2:	7762      	strb	r2, [r4, #29]
  data->signalType = signalType;
 80090b4:	4a21      	ldr	r2, [pc, #132]	; (800913c <msgKeepAlive+0x158>)
 80090b6:	6811      	ldr	r1, [r2, #0]
  data->outputType = outputType;
 80090b8:	6852      	ldr	r2, [r2, #4]
 80090ba:	77e2      	strb	r2, [r4, #31]
  data->volume     = spkSet.volume;
 80090bc:	781a      	ldrb	r2, [r3, #0]
 80090be:	f884 2020 	strb.w	r2, [r4, #32]


  //  if(data->pipeNum != 0xFF)
  {
    if(portData[portNum].portType == PORT_TYPE_SPI)
 80090c2:	7e2a      	ldrb	r2, [r5, #24]
  else
    data->flags55 &= ~FLAGS55_DEFAULT_PIPE;

  data->cSharc     = spkSet.cSharc;
  data->cPWM       = spkSet.cPWM;
  data->signalType = signalType;
 80090c4:	77a1      	strb	r1, [r4, #30]
  data->volume     = spkSet.volume;


  //  if(data->pipeNum != 0xFF)
  {
    if(portData[portNum].portType == PORT_TYPE_SPI)
 80090c6:	2a01      	cmp	r2, #1
 80090c8:	461f      	mov	r7, r3
 80090ca:	d12a      	bne.n	8009122 <msgKeepAlive+0x13e>
      {
        int pipeNum = data->pipeNum?1:0;
 80090cc:	7da5      	ldrb	r5, [r4, #22]
        int twoOutputs =   ((data->flags55&FLAGS55_IS_TWO_OUTPUS) != 0);
        int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
 80090ce:	6bb3      	ldr	r3, [r6, #56]	; 0x38
  //  if(data->pipeNum != 0xFF)
  {
    if(portData[portNum].portType == PORT_TYPE_SPI)
      {
        int pipeNum = data->pipeNum?1:0;
        int twoOutputs =   ((data->flags55&FLAGS55_IS_TWO_OUTPUS) != 0);
 80090d0:	7de2      	ldrb	r2, [r4, #23]
        int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
        spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
        int remoteNum = (int)masterMap[channel][pipeNum][twoOutputs];
 80090d2:	4e1b      	ldr	r6, [pc, #108]	; (8009140 <msgKeepAlive+0x15c>)
    if(portData[portNum].portType == PORT_TYPE_SPI)
      {
        int pipeNum = data->pipeNum?1:0;
        int twoOutputs =   ((data->flags55&FLAGS55_IS_TWO_OUTPUS) != 0);
        int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
        spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 80090d4:	4915      	ldr	r1, [pc, #84]	; (800912c <msgKeepAlive+0x148>)

  //  if(data->pipeNum != 0xFF)
  {
    if(portData[portNum].portType == PORT_TYPE_SPI)
      {
        int pipeNum = data->pipeNum?1:0;
 80090d6:	3500      	adds	r5, #0
 80090d8:	bf18      	it	ne
 80090da:	2501      	movne	r5, #1
        int twoOutputs =   ((data->flags55&FLAGS55_IS_TWO_OUTPUS) != 0);
        int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
        spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
        int remoteNum = (int)masterMap[channel][pipeNum][twoOutputs];
 80090dc:	f003 0301 	and.w	r3, r3, #1
 80090e0:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 80090e4:	f002 0001 	and.w	r0, r2, #1
 80090e8:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 80090ec:	4403      	add	r3, r0
    if(portData[portNum].portType == PORT_TYPE_SPI)
      {
        int pipeNum = data->pipeNum?1:0;
        int twoOutputs =   ((data->flags55&FLAGS55_IS_TWO_OUTPUS) != 0);
        int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
        spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 80090ee:	6909      	ldr	r1, [r1, #16]
        int remoteNum = (int)masterMap[channel][pipeNum][twoOutputs];
 80090f0:	7a5b      	ldrb	r3, [r3, #9]

        if(helper->currentRemote != remoteNum || amIStereo != ((data->flags55&FLAGS55_AM_I_STEREO) != 0))
 80090f2:	f8d1 013f 	ldr.w	r0, [r1, #319]	; 0x13f
 80090f6:	4283      	cmp	r3, r0
 80090f8:	d104      	bne.n	8009104 <msgKeepAlive+0x120>
 80090fa:	6878      	ldr	r0, [r7, #4]
 80090fc:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8009100:	4282      	cmp	r2, r0
 8009102:	d00e      	beq.n	8009122 <msgKeepAlive+0x13e>
          {
            helper->currentRemote = remoteNum;
 8009104:	f8c1 313f 	str.w	r3, [r1, #319]	; 0x13f
            ehifStart(&(helper->radioModule->spi));
 8009108:	f8d1 010c 	ldr.w	r0, [r1, #268]	; 0x10c
 800910c:	f003 f836 	bl	800c17c <ehifStart>
            slaveDisconnect();
 8009110:	f003 f948 	bl	800c3a4 <slaveDisconnect>
            myPipeNum = pipeNum;
            amIStereo = ((data->flags55&FLAGS55_AM_I_STEREO) != 0);
 8009114:	7de3      	ldrb	r3, [r4, #23]
        if(helper->currentRemote != remoteNum || amIStereo != ((data->flags55&FLAGS55_AM_I_STEREO) != 0))
          {
            helper->currentRemote = remoteNum;
            ehifStart(&(helper->radioModule->spi));
            slaveDisconnect();
            myPipeNum = pipeNum;
 8009116:	60bd      	str	r5, [r7, #8]
            amIStereo = ((data->flags55&FLAGS55_AM_I_STEREO) != 0);
 8009118:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800911c:	607b      	str	r3, [r7, #4]
            ehifStop();
 800911e:	f003 f857 	bl	800c1d0 <ehifStop>
 8009122:	2001      	movs	r0, #1
 8009124:	e000      	b.n	8009128 <msgKeepAlive+0x144>
  return CB_RET_nACK;
}

static int msgKeepAlive(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
  if(!DIRECTION(portNum)) return 0;
 8009126:	2000      	movs	r0, #0
          }
      }
  }

  return CB_RET_ACK;
}
 8009128:	b003      	add	sp, #12
 800912a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800912c:	2001aabc 	.word	0x2001aabc
 8009130:	10001000 	.word	0x10001000
 8009134:	0801492a 	.word	0x0801492a
 8009138:	2001ac30 	.word	0x2001ac30
 800913c:	2001a1d8 	.word	0x2001a1d8
 8009140:	0801486f 	.word	0x0801486f

08009144 <kaCCEnable.part.11>:
{
}


static uint32_t timestamp = 0xFFFFFFFF;
void kaCCEnable(int enable)
 8009144:	b510      	push	{r4, lr}
{
  if(enable)
    {
      timestamp = xTaskGetTickCount() ;
 8009146:	f001 faad 	bl	800a6a4 <xTaskGetTickCount>
 800914a:	4b05      	ldr	r3, [pc, #20]	; (8009160 <kaCCEnable.part.11+0x1c>)
      portData[PER1_PORT].keepAlive = xTaskGetTickCount();
 800914c:	4c05      	ldr	r4, [pc, #20]	; (8009164 <kaCCEnable.part.11+0x20>)
static uint32_t timestamp = 0xFFFFFFFF;
void kaCCEnable(int enable)
{
  if(enable)
    {
      timestamp = xTaskGetTickCount() ;
 800914e:	6098      	str	r0, [r3, #8]
      portData[PER1_PORT].keepAlive = xTaskGetTickCount();
 8009150:	f001 faa8 	bl	800a6a4 <xTaskGetTickCount>
 8009154:	6760      	str	r0, [r4, #116]	; 0x74
      portData[PER2_PORT].keepAlive = xTaskGetTickCount();
 8009156:	f001 faa5 	bl	800a6a4 <xTaskGetTickCount>
 800915a:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
 800915e:	bd10      	pop	{r4, pc}
 8009160:	2001a1d8 	.word	0x2001a1d8
 8009164:	2001aabc 	.word	0x2001aabc

08009168 <onFailed>:

}


static int onFailed(portNum_t portNum, comm_t *comm)
{
 8009168:	b538      	push	{r3, r4, r5, lr}
  //Power off when Shark or PWM did not respond or responded with nACK
  if(cfg.ack50)
 800916a:	4b13      	ldr	r3, [pc, #76]	; (80091b8 <onFailed+0x50>)
 800916c:	4d13      	ldr	r5, [pc, #76]	; (80091bc <onFailed+0x54>)
 800916e:	689c      	ldr	r4, [r3, #8]
 8009170:	b134      	cbz	r4, 8009180 <onFailed+0x18>
      portData[PER1_PORT].keepAlive = xTaskGetTickCount();
      portData[PER2_PORT].keepAlive = xTaskGetTickCount();
    }
  else
    {
      timestamp = 0xFFFFFFFF;
 8009172:	f04f 33ff 	mov.w	r3, #4294967295
 8009176:	60ab      	str	r3, [r5, #8]
{
  //Power off when Shark or PWM did not respond or responded with nACK
  if(cfg.ack50)
    {
      kaCCEnable(0);
      poweroffSeq();
 8009178:	f000 fb2a 	bl	80097d0 <poweroffSeq>
      Check_power4();
      SmokChangeState(Smok_ON, "0x50 timeout - ack50=0");
      SmokLEDsState(1, -1, SET_NONE, isHD);
      return CB_RET_ACK;//Send ACK emulating proper poweron
    }
  return CB_RET_nACK;
 800917c:	2002      	movs	r0, #2
 800917e:	bd38      	pop	{r3, r4, r5, pc}
      kaCCEnable(0);
      poweroffSeq();
    }
  else
    {
      powerON4();
 8009180:	f006 fd38 	bl	800fbf4 <powerON4>
      sendKACC();
 8009184:	f7ff fdf8 	bl	8008d78 <sendKACC>
      mdelay(300);
 8009188:	f44f 7096 	mov.w	r0, #300	; 0x12c
 800918c:	f001 fb80 	bl	800a890 <vTaskDelay>
      Check_power4();
 8009190:	f000 fbb4 	bl	80098fc <Check_power4>
      SmokChangeState(Smok_ON, "0x50 timeout - ack50=0");
 8009194:	490a      	ldr	r1, [pc, #40]	; (80091c0 <onFailed+0x58>)
 8009196:	2002      	movs	r0, #2
 8009198:	f000 fb56 	bl	8009848 <SmokChangeState>
      SmokLEDsState(1, -1, SET_NONE, isHD);
 800919c:	682b      	ldr	r3, [r5, #0]
 800919e:	2b09      	cmp	r3, #9
 80091a0:	bfd4      	ite	le
 80091a2:	2300      	movle	r3, #0
 80091a4:	2301      	movgt	r3, #1
 80091a6:	4622      	mov	r2, r4
 80091a8:	f04f 31ff 	mov.w	r1, #4294967295
 80091ac:	2001      	movs	r0, #1
 80091ae:	f000 fb6f 	bl	8009890 <SmokLEDsState>
 80091b2:	2001      	movs	r0, #1
      return CB_RET_ACK;//Send ACK emulating proper poweron
    }
  return CB_RET_nACK;
}
 80091b4:	bd38      	pop	{r3, r4, r5, pc}
 80091b6:	bf00      	nop
 80091b8:	10001000 	.word	0x10001000
 80091bc:	2001a1d8 	.word	0x2001a1d8
 80091c0:	08014955 	.word	0x08014955

080091c4 <msgOn>:
  return CB_RET_nACK;
}


static int msgOn(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 80091c4:	b570      	push	{r4, r5, r6, lr}
 80091c6:	4616      	mov	r6, r2
  msg_50_t *data = (void*)bBuffer->data;
  if(DIRECTION(portNum))
 80091c8:	2800      	cmp	r0, #0
 80091ca:	d140      	bne.n	800924e <msgOn+0x8a>
    {
      //Already ON?
      if(isOn())
 80091cc:	f000 fa52 	bl	8009674 <isOn>
 80091d0:	4604      	mov	r4, r0
 80091d2:	2800      	cmp	r0, #0
 80091d4:	d167      	bne.n	80092a6 <msgOn+0xe2>
        return CB_RET_ACK;

      signalType = -1;
 80091d6:	4b36      	ldr	r3, [pc, #216]	; (80092b0 <msgOn+0xec>)
      outputType = -1;
      dprintf(LL_INFO, "Wlaczam zasilanie kond %x shark %x PWM %x\n", data->kondPom, data->cSharc, data->cPWM);
 80091d8:	4d36      	ldr	r5, [pc, #216]	; (80092b4 <msgOn+0xf0>)
    {
      //Already ON?
      if(isOn())
        return CB_RET_ACK;

      signalType = -1;
 80091da:	f04f 32ff 	mov.w	r2, #4294967295
 80091de:	601a      	str	r2, [r3, #0]
      outputType = -1;
 80091e0:	605a      	str	r2, [r3, #4]
      dprintf(LL_INFO, "Wlaczam zasilanie kond %x shark %x PWM %x\n", data->kondPom, data->cSharc, data->cPWM);
 80091e2:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 80091e4:	2b01      	cmp	r3, #1
 80091e6:	dd05      	ble.n	80091f4 <msgOn+0x30>
 80091e8:	7df3      	ldrb	r3, [r6, #23]
 80091ea:	7db2      	ldrb	r2, [r6, #22]
 80091ec:	7d71      	ldrb	r1, [r6, #21]
 80091ee:	4832      	ldr	r0, [pc, #200]	; (80092b8 <msgOn+0xf4>)
 80091f0:	f7ff fab8 	bl	8008764 <xprintf>
      spkSet.cSharc = data->cSharc;
 80091f4:	4b31      	ldr	r3, [pc, #196]	; (80092bc <msgOn+0xf8>)
 80091f6:	7db2      	ldrb	r2, [r6, #22]
 80091f8:	705a      	strb	r2, [r3, #1]
      spkSet.cPWM = data->cPWM;
 80091fa:	7df2      	ldrb	r2, [r6, #23]
 80091fc:	709a      	strb	r2, [r3, #2]

      powerON1();
 80091fe:	f006 fcd5 	bl	800fbac <powerON1>
      powerON2();
 8009202:	f006 fcd9 	bl	800fbb8 <powerON2>
      if(!Check_power2())
 8009206:	f000 fa73 	bl	80096f0 <Check_power2>
 800920a:	2800      	cmp	r0, #0
 800920c:	d04d      	beq.n	80092aa <msgOn+0xe6>
        return CB_RET_nACK;

      //Wait before power on
      mdelay(100);
 800920e:	2064      	movs	r0, #100	; 0x64
 8009210:	f001 fb3e 	bl	800a890 <vTaskDelay>
      powerON3();
 8009214:	f006 fcd8 	bl	800fbc8 <powerON3>

      mdelay(200);
 8009218:	20c8      	movs	r0, #200	; 0xc8
 800921a:	f001 fb39 	bl	800a890 <vTaskDelay>
      if(!Check_power1())
 800921e:	f000 fa31 	bl	8009684 <Check_power1>
 8009222:	b340      	cbz	r0, 8009276 <msgOn+0xb2>
        {
          poweroffSeq();
          return CB_RET_nACK;
        }

      mdelay(cfg.powerOnDelay);
 8009224:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
 8009228:	f001 fb32 	bl	800a890 <vTaskDelay>

      if(pll_set_retry(0x01, 1, cfg.pllRetryNum) <= 0 && !(cfg.disable_alerts&0x1000))
 800922c:	2101      	movs	r1, #1
 800922e:	f8d5 20dc 	ldr.w	r2, [r5, #220]	; 0xdc
 8009232:	4608      	mov	r0, r1
 8009234:	f006 fc8a 	bl	800fb4c <pll_set_retry>
 8009238:	2800      	cmp	r0, #0
 800923a:	dc03      	bgt.n	8009244 <msgOn+0x80>
 800923c:	4b1d      	ldr	r3, [pc, #116]	; (80092b4 <msgOn+0xf0>)
 800923e:	695b      	ldr	r3, [r3, #20]
 8009240:	04db      	lsls	r3, r3, #19
 8009242:	d518      	bpl.n	8009276 <msgOn+0xb2>
 8009244:	f7ff ff7e 	bl	8009144 <kaCCEnable.part.11>

      /* if(!Check_power3()) */
      /* 	return CB_RET_nACK; */

      kaCCEnable(1);
      sendKACC();
 8009248:	f7ff fd96 	bl	8008d78 <sendKACC>
 800924c:	e02e      	b.n	80092ac <msgOn+0xe8>

      //Przekaz komende dalej i czekaj na potwierdzenia
      return 0;
    }
  //  LEDset(0, ~0, 0);
  mdelay(cfg.ampEnableDelay50);
 800924e:	4b19      	ldr	r3, [pc, #100]	; (80092b4 <msgOn+0xf0>)
 8009250:	4c17      	ldr	r4, [pc, #92]	; (80092b0 <msgOn+0xec>)
 8009252:	f8d3 00cc 	ldr.w	r0, [r3, #204]	; 0xcc
 8009256:	f001 fb1b 	bl	800a890 <vTaskDelay>
  powerON4();
 800925a:	f006 fccb 	bl	800fbf4 <powerON4>
  sendKACC();
 800925e:	f7ff fd8b 	bl	8008d78 <sendKACC>
  mdelay(300);
 8009262:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8009266:	f001 fb13 	bl	800a890 <vTaskDelay>
  if(!Check_power4())
 800926a:	f000 fb47 	bl	80098fc <Check_power4>
 800926e:	b928      	cbnz	r0, 800927c <msgOn+0xb8>
      portData[PER1_PORT].keepAlive = xTaskGetTickCount();
      portData[PER2_PORT].keepAlive = xTaskGetTickCount();
    }
  else
    {
      timestamp = 0xFFFFFFFF;
 8009270:	f04f 33ff 	mov.w	r3, #4294967295
 8009274:	60a3      	str	r3, [r4, #8]
  sendKACC();
  mdelay(300);
  if(!Check_power4())
    {
      kaCCEnable(0);
      poweroffSeq();
 8009276:	f000 faab 	bl	80097d0 <poweroffSeq>
 800927a:	e016      	b.n	80092aa <msgOn+0xe6>
      return CB_RET_nACK;
    }

  if(SmokChangeState(Smok_ON, "0x50 ACK")<0)
 800927c:	4910      	ldr	r1, [pc, #64]	; (80092c0 <msgOn+0xfc>)
 800927e:	2002      	movs	r0, #2
 8009280:	f000 fae2 	bl	8009848 <SmokChangeState>
 8009284:	2800      	cmp	r0, #0
 8009286:	da03      	bge.n	8009290 <msgOn+0xcc>
      portData[PER1_PORT].keepAlive = xTaskGetTickCount();
      portData[PER2_PORT].keepAlive = xTaskGetTickCount();
    }
  else
    {
      timestamp = 0xFFFFFFFF;
 8009288:	f04f 33ff 	mov.w	r3, #4294967295
 800928c:	60a3      	str	r3, [r4, #8]
 800928e:	e00c      	b.n	80092aa <msgOn+0xe6>
    {
      kaCCEnable(0);
      return CB_RET_nACK;
    }

  SmokLEDsState(1, -1, SET_NONE, isHD);
 8009290:	6823      	ldr	r3, [r4, #0]
 8009292:	2b09      	cmp	r3, #9
 8009294:	bfd4      	ite	le
 8009296:	2300      	movle	r3, #0
 8009298:	2301      	movgt	r3, #1
 800929a:	2200      	movs	r2, #0
 800929c:	f04f 31ff 	mov.w	r1, #4294967295
 80092a0:	2001      	movs	r0, #1
 80092a2:	f000 faf5 	bl	8009890 <SmokLEDsState>
  msg_50_t *data = (void*)bBuffer->data;
  if(DIRECTION(portNum))
    {
      //Already ON?
      if(isOn())
        return CB_RET_ACK;
 80092a6:	2401      	movs	r4, #1
 80092a8:	e000      	b.n	80092ac <msgOn+0xe8>
      spkSet.cPWM = data->cPWM;

      powerON1();
      powerON2();
      if(!Check_power2())
        return CB_RET_nACK;
 80092aa:	2402      	movs	r4, #2
      return CB_RET_nACK;
    }

  SmokLEDsState(1, -1, SET_NONE, isHD);
  return CB_RET_ACK;
}
 80092ac:	4620      	mov	r0, r4
 80092ae:	bd70      	pop	{r4, r5, r6, pc}
 80092b0:	2001a1d8 	.word	0x2001a1d8
 80092b4:	10001000 	.word	0x10001000
 80092b8:	0801496c 	.word	0x0801496c
 80092bc:	2001ac30 	.word	0x2001ac30
 80092c0:	08014997 	.word	0x08014997

080092c4 <msgACKamp5A>:
    }
  return CB_RET_ACK;
}

static int msgACKamp5A(portNum_t portNum, comm_t *comm, bBuffer_t *bBuffer, uint8_t *forwardMask)
{
 80092c4:	b538      	push	{r3, r4, r5, lr}
 80092c6:	461d      	mov	r5, r3
  if(DIRECTION(portNum))
 80092c8:	4604      	mov	r4, r0
 80092ca:	b948      	cbnz	r0, 80092e0 <msgACKamp5A+0x1c>
    {
      if(!isOn())
 80092cc:	f000 f9d2 	bl	8009674 <isOn>
 80092d0:	b908      	cbnz	r0, 80092d6 <msgACKamp5A+0x12>
        {
          //If not ON state then respond on the message for PWM and SHARC
          *forwardMask = 0;
 80092d2:	7028      	strb	r0, [r5, #0]
 80092d4:	e00f      	b.n	80092f6 <msgACKamp5A+0x32>
          return CB_RET_ACK;
        }
      ampEnable(0);
 80092d6:	4620      	mov	r0, r4
 80092d8:	f006 fc5a 	bl	800fb90 <ampEnable>
      return 0;
 80092dc:	4620      	mov	r0, r4
 80092de:	bd38      	pop	{r3, r4, r5, pc}
    }
  if(isOn())
 80092e0:	f000 f9c8 	bl	8009674 <isOn>
 80092e4:	b138      	cbz	r0, 80092f6 <msgACKamp5A+0x32>
        ampEnable(0);
      return 0;
    }
  if(isOn() && data->guiTp != 0)
    {
      mdelay(cfg.ampEnableDelay58);
 80092e6:	4b05      	ldr	r3, [pc, #20]	; (80092fc <msgACKamp5A+0x38>)
 80092e8:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
 80092ec:	f001 fad0 	bl	800a890 <vTaskDelay>
      ampEnable(1);
 80092f0:	2001      	movs	r0, #1
 80092f2:	f006 fc4d 	bl	800fb90 <ampEnable>
  if(isOn())
    {
      mdelay(cfg.ampEnableDelay58);
      ampEnable(1);
    }
  return CB_RET_ACK;
 80092f6:	2001      	movs	r0, #1
}
 80092f8:	bd38      	pop	{r3, r4, r5, pc}
 80092fa:	bf00      	nop
 80092fc:	10001000 	.word	0x10001000

08009300 <sendPWMoffMsg>:
  //Send ACK instead of nACK
  return CB_RET_ACK;
}

void sendPWMoffMsg(void)
{
 8009300:	b513      	push	{r0, r1, r4, lr}

  bBuffer_t *buf = bAlloc(MSG_LEN);
 8009302:	2020      	movs	r0, #32
 8009304:	f004 f994 	bl	800d630 <bAlloc>
  massert(buf);
 8009308:	4604      	mov	r4, r0
 800930a:	b158      	cbz	r0, 8009324 <sendPWMoffMsg+0x24>
  buf->size = sizeof(msg_56_t);
  msg_56_t *msg = (void*)buf->data;
  memset(msg, 0, sizeof(msg_56_t));
  msg->kod = 0x56;
 800930c:	4621      	mov	r1, r4
void sendPWMoffMsg(void)
{

  bBuffer_t *buf = bAlloc(MSG_LEN);
  massert(buf);
  buf->size = sizeof(msg_56_t);
 800930e:	2201      	movs	r2, #1
  msg_56_t *msg = (void*)buf->data;
  memset(msg, 0, sizeof(msg_56_t));
  msg->kod = 0x56;
 8009310:	2356      	movs	r3, #86	; 0x56
void sendPWMoffMsg(void)
{

  bBuffer_t *buf = bAlloc(MSG_LEN);
  massert(buf);
  buf->size = sizeof(msg_56_t);
 8009312:	8022      	strh	r2, [r4, #0]
  msg_56_t *msg = (void*)buf->data;
  memset(msg, 0, sizeof(msg_56_t));
  msg->kod = 0x56;

  messageTx(PER2_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
 8009314:	2002      	movs	r0, #2
  bBuffer_t *buf = bAlloc(MSG_LEN);
  massert(buf);
  buf->size = sizeof(msg_56_t);
  msg_56_t *msg = (void*)buf->data;
  memset(msg, 0, sizeof(msg_56_t));
  msg->kod = 0x56;
 8009316:	f801 3f14 	strb.w	r3, [r1, #20]!

  messageTx(PER2_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
 800931a:	4623      	mov	r3, r4
 800931c:	f002 fc46 	bl	800bbac <messageTx>

}
 8009320:	b002      	add	sp, #8
 8009322:	bd10      	pop	{r4, pc}

void sendPWMoffMsg(void)
{

  bBuffer_t *buf = bAlloc(MSG_LEN);
  massert(buf);
 8009324:	4b05      	ldr	r3, [pc, #20]	; (800933c <sendPWMoffMsg+0x3c>)
 8009326:	4906      	ldr	r1, [pc, #24]	; (8009340 <sendPWMoffMsg+0x40>)
 8009328:	4806      	ldr	r0, [pc, #24]	; (8009344 <sendPWMoffMsg+0x44>)
 800932a:	22eb      	movs	r2, #235	; 0xeb
 800932c:	f7ff fa1a 	bl	8008764 <xprintf>
 8009330:	2301      	movs	r3, #1
 8009332:	9301      	str	r3, [sp, #4]
 8009334:	9b01      	ldr	r3, [sp, #4]
 8009336:	2b00      	cmp	r3, #0
 8009338:	d1fc      	bne.n	8009334 <sendPWMoffMsg+0x34>
 800933a:	e7e7      	b.n	800930c <sendPWMoffMsg+0xc>
 800933c:	080148f0 	.word	0x080148f0
 8009340:	08014880 	.word	0x08014880
 8009344:	080148f4 	.word	0x080148f4

08009348 <sendStatus>:

  return CB_RET_ACK;
}

int sendStatus(int MsgCode, int val1, int val2)
{
 8009348:	b570      	push	{r4, r5, r6, lr}
  if(cfg.do_not_send_status == 1)
 800934a:	4b12      	ldr	r3, [pc, #72]	; (8009394 <sendStatus+0x4c>)

  return CB_RET_ACK;
}

int sendStatus(int MsgCode, int val1, int val2)
{
 800934c:	4615      	mov	r5, r2
  if(cfg.do_not_send_status == 1)
 800934e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009350:	2a01      	cmp	r2, #1

  return CB_RET_ACK;
}

int sendStatus(int MsgCode, int val1, int val2)
{
 8009352:	4604      	mov	r4, r0
 8009354:	460e      	mov	r6, r1
  if(cfg.do_not_send_status == 1)
 8009356:	d01b      	beq.n	8009390 <sendStatus+0x48>
    return 0;
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
 8009358:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800935a:	b122      	cbz	r2, 8009366 <sendStatus+0x1e>
 800935c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800935e:	4043      	eors	r3, r0
 8009360:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8009364:	d114      	bne.n	8009390 <sendStatus+0x48>
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
 8009366:	2020      	movs	r0, #32
 8009368:	f004 f962 	bl	800d630 <bAlloc>
  bBuffer->size = sizeof(msg_B0_t);
  msg_B0_t *data = (void*)bBuffer->data;
  data->kod = 0xB0;
 800936c:	21b0      	movs	r1, #176	; 0xb0
  if(cfg.do_not_send_status == 1)
    return 0;
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
  bBuffer->size = sizeof(msg_B0_t);
 800936e:	2206      	movs	r2, #6
{
  if(cfg.do_not_send_status == 1)
    return 0;
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
 8009370:	4603      	mov	r3, r0
  bBuffer->size = sizeof(msg_B0_t);
  msg_B0_t *data = (void*)bBuffer->data;
  data->kod = 0xB0;
 8009372:	7501      	strb	r1, [r0, #20]
  if(cfg.do_not_send_status == 1)
    return 0;
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
  bBuffer->size = sizeof(msg_B0_t);
 8009374:	8002      	strh	r2, [r0, #0]
  msg_B0_t *data = (void*)bBuffer->data;
  data->kod = 0xB0;
  data->kondPom = portData[CEN_PORT].kond_pom;
 8009376:	4808      	ldr	r0, [pc, #32]	; (8009398 <sendStatus+0x50>)
 8009378:	7e41      	ldrb	r1, [r0, #25]
 800937a:	7559      	strb	r1, [r3, #21]
  data->urzadzenie = portData[CEN_PORT].urzadzenie;
 800937c:	7e81      	ldrb	r1, [r0, #26]
 800937e:	7599      	strb	r1, [r3, #22]
  data->Smok_msgType = MsgCode;
 8009380:	75dc      	strb	r4, [r3, #23]
  data->Smok_msg1 = val1;
 8009382:	761e      	strb	r6, [r3, #24]
  data->Smok_msg2 = val2;
 8009384:	765d      	strb	r5, [r3, #25]
  messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
 8009386:	f103 0114 	add.w	r1, r3, #20
 800938a:	2000      	movs	r0, #0
 800938c:	f002 fc0e 	bl	800bbac <messageTx>
  return 0;
}
 8009390:	2000      	movs	r0, #0
 8009392:	bd70      	pop	{r4, r5, r6, pc}
 8009394:	10001000 	.word	0x10001000
 8009398:	2001aabc 	.word	0x2001aabc

0800939c <sendStatusLong>:

int sendStatusLong(int MsgCode, int val1, int val2, int val3, int val4)
{
 800939c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80093a0:	4604      	mov	r4, r0
  if(cfg.do_not_send_status == 1)
 80093a2:	4815      	ldr	r0, [pc, #84]	; (80093f8 <sendStatusLong+0x5c>)
  messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
  return 0;
}

int sendStatusLong(int MsgCode, int val1, int val2, int val3, int val4)
{
 80093a4:	461e      	mov	r6, r3
  if(cfg.do_not_send_status == 1)
 80093a6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80093a8:	2b01      	cmp	r3, #1
  messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
  return 0;
}

int sendStatusLong(int MsgCode, int val1, int val2, int val3, int val4)
{
 80093aa:	460f      	mov	r7, r1
 80093ac:	4690      	mov	r8, r2
  if(cfg.do_not_send_status == 1)
 80093ae:	d01f      	beq.n	80093f0 <sendStatusLong+0x54>
    return 0;
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
 80093b0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80093b2:	b123      	cbz	r3, 80093be <sendStatusLong+0x22>
 80093b4:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80093b6:	4060      	eors	r0, r4
 80093b8:	f010 0ff0 	tst.w	r0, #240	; 0xf0
 80093bc:	d118      	bne.n	80093f0 <sendStatusLong+0x54>
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
 80093be:	2020      	movs	r0, #32
 80093c0:	f004 f936 	bl	800d630 <bAlloc>
  bBuffer->size = sizeof(msg_B1_t);
  msg_B1_t *data = (void*)bBuffer->data;
  data->kod = 0xB1;
  data->kondPom = portData[CEN_PORT].kond_pom;
 80093c4:	4d0d      	ldr	r5, [pc, #52]	; (80093fc <sendStatusLong+0x60>)
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
  bBuffer->size = sizeof(msg_B1_t);
  msg_B1_t *data = (void*)bBuffer->data;
  data->kod = 0xB1;
 80093c6:	23b1      	movs	r3, #177	; 0xb1
  if(cfg.do_not_send_status == 1)
    return 0;
  if(cfg.do_not_send_status != 0 && (cfg.do_not_send_status & 0xF0) != (MsgCode & 0xF0))
    return 0;
  bBuffer_t *bBuffer = bAlloc(MSG_LEN);
  bBuffer->size = sizeof(msg_B1_t);
 80093c8:	2208      	movs	r2, #8
 80093ca:	8002      	strh	r2, [r0, #0]
  msg_B1_t *data = (void*)bBuffer->data;
  data->kod = 0xB1;
 80093cc:	7503      	strb	r3, [r0, #20]
  data->kondPom = portData[CEN_PORT].kond_pom;
 80093ce:	7e6b      	ldrb	r3, [r5, #25]
 80093d0:	7543      	strb	r3, [r0, #21]
  data->urzadzenie = portData[CEN_PORT].urzadzenie;
 80093d2:	7eab      	ldrb	r3, [r5, #26]
 80093d4:	7583      	strb	r3, [r0, #22]
  data->Smok_msgType = MsgCode;
  data->Smok_msgA1 = val1;
  data->Smok_msgA2 = val2;
  data->Smok_msgB1 = val3;
  data->Smok_msgB2 = val4;
 80093d6:	9b06      	ldr	r3, [sp, #24]
 80093d8:	76c3      	strb	r3, [r0, #27]
  bBuffer->size = sizeof(msg_B1_t);
  msg_B1_t *data = (void*)bBuffer->data;
  data->kod = 0xB1;
  data->kondPom = portData[CEN_PORT].kond_pom;
  data->urzadzenie = portData[CEN_PORT].urzadzenie;
  data->Smok_msgType = MsgCode;
 80093da:	75c4      	strb	r4, [r0, #23]
  data->Smok_msgA1 = val1;
 80093dc:	7607      	strb	r7, [r0, #24]
  data->Smok_msgA2 = val2;
 80093de:	f880 8019 	strb.w	r8, [r0, #25]
  data->Smok_msgB1 = val3;
 80093e2:	7686      	strb	r6, [r0, #26]
  data->Smok_msgB2 = val4;
  messageTx(CEN_PORT, (void*)bBuffer->data, bBuffer->size, (uint32_t)bBuffer);
 80093e4:	4603      	mov	r3, r0
 80093e6:	f100 0114 	add.w	r1, r0, #20
 80093ea:	2000      	movs	r0, #0
 80093ec:	f002 fbde 	bl	800bbac <messageTx>
  return 0;
}
 80093f0:	2000      	movs	r0, #0
 80093f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80093f6:	bf00      	nop
 80093f8:	10001000 	.word	0x10001000
 80093fc:	2001aabc 	.word	0x2001aabc

08009400 <Timeout_Data>:
  COMM_TBL_SET(B1, 00, SMOK_GEN,         0,    0, msgACK,       NULL),
};


void Timeout_Data(portNum_t portNum, char *buffer, int bufferSize)
{
 8009400:	4770      	bx	lr
	...

08009404 <kaCCEnable>:


static uint32_t timestamp = 0xFFFFFFFF;
void kaCCEnable(int enable)
{
  if(enable)
 8009404:	b108      	cbz	r0, 800940a <kaCCEnable+0x6>
 8009406:	f7ff be9d 	b.w	8009144 <kaCCEnable.part.11>
      portData[PER1_PORT].keepAlive = xTaskGetTickCount();
      portData[PER2_PORT].keepAlive = xTaskGetTickCount();
    }
  else
    {
      timestamp = 0xFFFFFFFF;
 800940a:	4b02      	ldr	r3, [pc, #8]	; (8009414 <kaCCEnable+0x10>)
 800940c:	f04f 32ff 	mov.w	r2, #4294967295
 8009410:	609a      	str	r2, [r3, #8]
 8009412:	4770      	bx	lr
 8009414:	2001a1d8 	.word	0x2001a1d8

08009418 <communicatorPeriodicPrivate>:
  messageTx(PER1_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
  messageTx(PER2_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
}

void communicatorPeriodicPrivate(void)
{
 8009418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(timestamp < xTaskGetTickCount())
 800941c:	4c22      	ldr	r4, [pc, #136]	; (80094a8 <communicatorPeriodicPrivate+0x90>)
 800941e:	4e23      	ldr	r6, [pc, #140]	; (80094ac <communicatorPeriodicPrivate+0x94>)
 8009420:	f001 f940 	bl	800a6a4 <xTaskGetTickCount>
 8009424:	68a3      	ldr	r3, [r4, #8]
 8009426:	4298      	cmp	r0, r3
 8009428:	d906      	bls.n	8009438 <communicatorPeriodicPrivate+0x20>
    {
      sendKACC();
 800942a:	f7ff fca5 	bl	8008d78 <sendKACC>
      timestamp = xTaskGetTickCount() + cfg.ka_period;
 800942e:	f001 f939 	bl	800a6a4 <xTaskGetTickCount>
 8009432:	6a33      	ldr	r3, [r6, #32]
 8009434:	4418      	add	r0, r3
 8009436:	60a0      	str	r0, [r4, #8]
 8009438:	4d1d      	ldr	r5, [pc, #116]	; (80094b0 <communicatorPeriodicPrivate+0x98>)
    }

  portNum_t portNum;
  for(portNum = PER1_PORT; portNum <= PER2_PORT; portNum++)
    if((int)xTaskGetTickCount() - (int)portData[portNum].keepAlive > cfg.ka_timeout)
 800943a:	f8df 8070 	ldr.w	r8, [pc, #112]	; 80094ac <communicatorPeriodicPrivate+0x94>
  messageTx(PER1_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
  messageTx(PER2_PORT, (void*)buf->data, buf->size, (uint32_t)buf);
}

void communicatorPeriodicPrivate(void)
{
 800943e:	2401      	movs	r4, #1
 8009440:	462f      	mov	r7, r5
      timestamp = xTaskGetTickCount() + cfg.ka_period;
    }

  portNum_t portNum;
  for(portNum = PER1_PORT; portNum <= PER2_PORT; portNum++)
    if((int)xTaskGetTickCount() - (int)portData[portNum].keepAlive > cfg.ka_timeout)
 8009442:	f001 f92f 	bl	800a6a4 <xTaskGetTickCount>
 8009446:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8009448:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800944a:	1ac0      	subs	r0, r0, r3
 800944c:	4290      	cmp	r0, r2
 800944e:	dd08      	ble.n	8009462 <communicatorPeriodicPrivate+0x4a>
      {
        uitTimeout(portNum);
 8009450:	4620      	mov	r0, r4
 8009452:	f000 f983 	bl	800975c <uitTimeout>
        portData[portNum].keepAlive = xTaskGetTickCount() + cfg.ka_period;
 8009456:	f001 f925 	bl	800a6a4 <xTaskGetTickCount>
 800945a:	f8d8 3020 	ldr.w	r3, [r8, #32]
 800945e:	4418      	add	r0, r3
 8009460:	6768      	str	r0, [r5, #116]	; 0x74
      sendKACC();
      timestamp = xTaskGetTickCount() + cfg.ka_period;
    }

  portNum_t portNum;
  for(portNum = PER1_PORT; portNum <= PER2_PORT; portNum++)
 8009462:	3401      	adds	r4, #1
 8009464:	b2e4      	uxtb	r4, r4
 8009466:	2c03      	cmp	r4, #3
 8009468:	f105 0550 	add.w	r5, r5, #80	; 0x50
 800946c:	d1e9      	bne.n	8009442 <communicatorPeriodicPrivate+0x2a>
      {
        uitTimeout(portNum);
        portData[portNum].keepAlive = xTaskGetTickCount() + cfg.ka_period;
      }

  if(abs(portData[CEN_PORT].keepAlive - xTaskGetTickCount()) > cfg.ka_timeout)
 800946e:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8009470:	4d0f      	ldr	r5, [pc, #60]	; (80094b0 <communicatorPeriodicPrivate+0x98>)
 8009472:	f001 f917 	bl	800a6a4 <xTaskGetTickCount>
 8009476:	1a20      	subs	r0, r4, r0
 8009478:	2800      	cmp	r0, #0
 800947a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 800947c:	da03      	bge.n	8009486 <communicatorPeriodicPrivate+0x6e>
 800947e:	f001 f911 	bl	800a6a4 <xTaskGetTickCount>
 8009482:	1b00      	subs	r0, r0, r4
 8009484:	e002      	b.n	800948c <communicatorPeriodicPrivate+0x74>
 8009486:	f001 f90d 	bl	800a6a4 <xTaskGetTickCount>
 800948a:	1a20      	subs	r0, r4, r0
 800948c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800948e:	4298      	cmp	r0, r3
 8009490:	dd08      	ble.n	80094a4 <communicatorPeriodicPrivate+0x8c>
    {
      portData[CEN_PORT].keepAlive = xTaskGetTickCount();
 8009492:	f001 f907 	bl	800a6a4 <xTaskGetTickCount>
 8009496:	6278      	str	r0, [r7, #36]	; 0x24
              slaveDisconnect();
              ehifStop();
            }
        }
#else
      SPIevent(CEN_PORT, SPI_EV_TYPE_DLINK_ERROR);
 8009498:	2102      	movs	r1, #2
 800949a:	2000      	movs	r0, #0
#endif
    }
}
 800949c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              slaveDisconnect();
              ehifStop();
            }
        }
#else
      SPIevent(CEN_PORT, SPI_EV_TYPE_DLINK_ERROR);
 80094a0:	f002 bddc 	b.w	800c05c <SPIevent>
 80094a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80094a8:	2001a1d8 	.word	0x2001a1d8
 80094ac:	10001000 	.word	0x10001000
 80094b0:	2001aabc 	.word	0x2001aabc

080094b4 <connectionState>:
    }
}

static netState_e prevState = NET_NC;
void connectionState(netState_e state)
{
 80094b4:	b570      	push	{r4, r5, r6, lr}
  if(state == prevState) return;//No change
 80094b6:	4b1e      	ldr	r3, [pc, #120]	; (8009530 <connectionState+0x7c>)
 80094b8:	7b1a      	ldrb	r2, [r3, #12]
 80094ba:	4282      	cmp	r2, r0
    }
}

static netState_e prevState = NET_NC;
void connectionState(netState_e state)
{
 80094bc:	4604      	mov	r4, r0
 80094be:	461e      	mov	r6, r3
  if(state == prevState) return;//No change
 80094c0:	d034      	beq.n	800952c <connectionState+0x78>
  signalType = -1;
 80094c2:	4b1c      	ldr	r3, [pc, #112]	; (8009534 <connectionState+0x80>)
 80094c4:	f04f 35ff 	mov.w	r5, #4294967295
  outputType = -1;
  switch(state)
 80094c8:	2801      	cmp	r0, #1

static netState_e prevState = NET_NC;
void connectionState(netState_e state)
{
  if(state == prevState) return;//No change
  signalType = -1;
 80094ca:	601d      	str	r5, [r3, #0]
  outputType = -1;
 80094cc:	605d      	str	r5, [r3, #4]
  switch(state)
 80094ce:	d00d      	beq.n	80094ec <connectionState+0x38>
 80094d0:	d31b      	bcc.n	800950a <connectionState+0x56>
 80094d2:	2802      	cmp	r0, #2
 80094d4:	d129      	bne.n	800952a <connectionState+0x76>
    {
    case NET_DATAGRAM:
      SmokChangeState(Smok_OFF, "acquired datagram connection");
 80094d6:	4918      	ldr	r1, [pc, #96]	; (8009538 <connectionState+0x84>)
 80094d8:	2001      	movs	r0, #1
 80094da:	f000 f9b5 	bl	8009848 <SmokChangeState>
      SmokLEDsState(-1, 1, SET_NONE, -1);
 80094de:	462b      	mov	r3, r5
 80094e0:	2200      	movs	r2, #0
 80094e2:	2101      	movs	r1, #1
 80094e4:	4628      	mov	r0, r5
 80094e6:	f000 f9d3 	bl	8009890 <SmokLEDsState>
      break;
 80094ea:	e01e      	b.n	800952a <connectionState+0x76>
    case NET_PARTIAL:
      if(isOn())
 80094ec:	f000 f8c2 	bl	8009674 <isOn>
 80094f0:	b128      	cbz	r0, 80094fe <connectionState+0x4a>
        SmokLEDsState(0, 0, SET_CONN, -1);
 80094f2:	2100      	movs	r1, #0
 80094f4:	462b      	mov	r3, r5
 80094f6:	4622      	mov	r2, r4
 80094f8:	4608      	mov	r0, r1
 80094fa:	f000 f9c9 	bl	8009890 <SmokLEDsState>
      SmokChangeState(Smok_NC, "lost datagram connection");
 80094fe:	490f      	ldr	r1, [pc, #60]	; (800953c <connectionState+0x88>)
 8009500:	2000      	movs	r0, #0
 8009502:	f000 f9a1 	bl	8009848 <SmokChangeState>
      power_SHD_ERR_P(DATAGRAM_CONN_LOST);
 8009506:	2091      	movs	r0, #145	; 0x91
 8009508:	e00d      	b.n	8009526 <connectionState+0x72>
      break;
    case NET_NC:
      if(isOn())
 800950a:	f000 f8b3 	bl	8009674 <isOn>
 800950e:	b128      	cbz	r0, 800951c <connectionState+0x68>
        SmokLEDsState(0, 0, SET_CONN, -1);
 8009510:	2100      	movs	r1, #0
 8009512:	462b      	mov	r3, r5
 8009514:	2201      	movs	r2, #1
 8009516:	4608      	mov	r0, r1
 8009518:	f000 f9ba 	bl	8009890 <SmokLEDsState>
      SmokChangeState(Smok_NC, "lost radio connection");
 800951c:	4908      	ldr	r1, [pc, #32]	; (8009540 <connectionState+0x8c>)
 800951e:	2000      	movs	r0, #0
 8009520:	f000 f992 	bl	8009848 <SmokChangeState>
      power_SHD_ERR_P(CONN_LOST);
 8009524:	2092      	movs	r0, #146	; 0x92
 8009526:	f000 f893 	bl	8009650 <power_SHD_ERR_P>
      break;
    }
  prevState = state;
 800952a:	7334      	strb	r4, [r6, #12]
 800952c:	bd70      	pop	{r4, r5, r6, pc}
 800952e:	bf00      	nop
 8009530:	2001ac30 	.word	0x2001ac30
 8009534:	2001a1d8 	.word	0x2001a1d8
 8009538:	080149a0 	.word	0x080149a0
 800953c:	080149bd 	.word	0x080149bd
 8009540:	080149d6 	.word	0x080149d6

08009544 <stateChangeOFF2NC>:
  kaCCEnable(1);
  return 0;
}

static int stateChangeOFF2NC(smokState_e oldState, smokState_e newState)
{
 8009544:	b508      	push	{r3, lr}
  dprintf(LL_INFO, "OFF->NC\n");
 8009546:	4b04      	ldr	r3, [pc, #16]	; (8009558 <stateChangeOFF2NC+0x14>)
 8009548:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800954a:	2b01      	cmp	r3, #1
 800954c:	dd02      	ble.n	8009554 <stateChangeOFF2NC+0x10>
 800954e:	4803      	ldr	r0, [pc, #12]	; (800955c <stateChangeOFF2NC+0x18>)
 8009550:	f7ff f908 	bl	8008764 <xprintf>
  return 0;
}
 8009554:	2000      	movs	r0, #0
 8009556:	bd08      	pop	{r3, pc}
 8009558:	10001000 	.word	0x10001000
 800955c:	08014a10 	.word	0x08014a10

08009560 <stateChangeInvalid>:
}

typedef int (*changeState_t)(smokState_e oldState, smokState_e newState);

static int stateChangeInvalid(smokState_e oldState, smokState_e newState)
{
 8009560:	b508      	push	{r3, lr}
  dprintf(LL_WARNING, "Invalid state requested.\n");
 8009562:	4b05      	ldr	r3, [pc, #20]	; (8009578 <stateChangeInvalid+0x18>)
 8009564:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009566:	2b00      	cmp	r3, #0
 8009568:	dd02      	ble.n	8009570 <stateChangeInvalid+0x10>
 800956a:	4804      	ldr	r0, [pc, #16]	; (800957c <stateChangeInvalid+0x1c>)
 800956c:	f7ff f8fa 	bl	8008764 <xprintf>
  return -1;
}
 8009570:	f04f 30ff 	mov.w	r0, #4294967295
 8009574:	bd08      	pop	{r3, pc}
 8009576:	bf00      	nop
 8009578:	10001000 	.word	0x10001000
 800957c:	08014a19 	.word	0x08014a19

08009580 <stateChangeNC2OFF>:
  dprintf(LL_WARNING, "Already in requested state.\n");
  return 1;
}

static int stateChangeNC2OFF(smokState_e oldState, smokState_e newState)
{
 8009580:	b508      	push	{r3, lr}
  //  LEDset(0, ~0, 0);
  //  LEDset(0, LED_GREEN, 1);
  dprintf(LL_INFO, "NC->OFF\n");
 8009582:	4b04      	ldr	r3, [pc, #16]	; (8009594 <stateChangeNC2OFF+0x14>)
 8009584:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009586:	2b01      	cmp	r3, #1
 8009588:	dd02      	ble.n	8009590 <stateChangeNC2OFF+0x10>
 800958a:	4803      	ldr	r0, [pc, #12]	; (8009598 <stateChangeNC2OFF+0x18>)
 800958c:	f7ff f8ea 	bl	8008764 <xprintf>
  return 0;
}
 8009590:	2000      	movs	r0, #0
 8009592:	bd08      	pop	{r3, pc}
 8009594:	10001000 	.word	0x10001000
 8009598:	08014a33 	.word	0x08014a33

0800959c <stateChangeAlreadyThere>:
  dprintf(LL_WARNING, "Invalid state requested.\n");
  return -1;
}

static int stateChangeAlreadyThere(smokState_e oldState, smokState_e newState)
{
 800959c:	b508      	push	{r3, lr}
  dprintf(LL_WARNING, "Already in requested state.\n");
 800959e:	4b04      	ldr	r3, [pc, #16]	; (80095b0 <stateChangeAlreadyThere+0x14>)
 80095a0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80095a2:	2b00      	cmp	r3, #0
 80095a4:	dd02      	ble.n	80095ac <stateChangeAlreadyThere+0x10>
 80095a6:	4803      	ldr	r0, [pc, #12]	; (80095b4 <stateChangeAlreadyThere+0x18>)
 80095a8:	f7ff f8dc 	bl	8008764 <xprintf>
  return 1;
}
 80095ac:	2001      	movs	r0, #1
 80095ae:	bd08      	pop	{r3, pc}
 80095b0:	10001000 	.word	0x10001000
 80095b4:	08014a3c 	.word	0x08014a3c

080095b8 <stateChangeOFF2ON>:
  poweroffSeq();
  return 0;
}

static int stateChangeOFF2ON(smokState_e oldState, smokState_e newState)
{
 80095b8:	b508      	push	{r3, lr}
  dprintf(LL_INFO, "OFF->ON\n");
 80095ba:	4b06      	ldr	r3, [pc, #24]	; (80095d4 <stateChangeOFF2ON+0x1c>)
 80095bc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80095be:	2b01      	cmp	r3, #1
 80095c0:	dd02      	ble.n	80095c8 <stateChangeOFF2ON+0x10>
 80095c2:	4805      	ldr	r0, [pc, #20]	; (80095d8 <stateChangeOFF2ON+0x20>)
 80095c4:	f7ff f8ce 	bl	8008764 <xprintf>
  kaCCEnable(1);
 80095c8:	2001      	movs	r0, #1
 80095ca:	f7ff ff1b 	bl	8009404 <kaCCEnable>
  return 0;
}
 80095ce:	2000      	movs	r0, #0
 80095d0:	bd08      	pop	{r3, pc}
 80095d2:	bf00      	nop
 80095d4:	10001000 	.word	0x10001000
 80095d8:	08014a59 	.word	0x08014a59

080095dc <getVoltages>:
{
  return (smokState == Smok_ON);
}

static void getVoltages(void)
{
 80095dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  //clear measures
  CLRADC(Uwe_val);
 80095de:	f000 fda9 	bl	800a134 <vPortEnterCritical>
 80095e2:	4d15      	ldr	r5, [pc, #84]	; (8009638 <getVoltages+0x5c>)
 80095e4:	4b15      	ldr	r3, [pc, #84]	; (800963c <getVoltages+0x60>)
 80095e6:	2600      	movs	r6, #0
 80095e8:	2400      	movs	r4, #0
 80095ea:	2700      	movs	r7, #0
 80095ec:	e9c3 6700 	strd	r6, r7, [r3]
 80095f0:	602c      	str	r4, [r5, #0]
 80095f2:	f000 fdb1 	bl	800a158 <vPortExitCritical>
  CLRADC(Uwy_val);
 80095f6:	f000 fd9d 	bl	800a134 <vPortEnterCritical>
 80095fa:	4b11      	ldr	r3, [pc, #68]	; (8009640 <getVoltages+0x64>)
 80095fc:	e9c3 6700 	strd	r6, r7, [r3]
 8009600:	4e10      	ldr	r6, [pc, #64]	; (8009644 <getVoltages+0x68>)
 8009602:	6034      	str	r4, [r6, #0]
 8009604:	f000 fda8 	bl	800a158 <vPortExitCritical>

  //Wait until at least one measure is done
  int retry = 100;
 8009608:	2464      	movs	r4, #100	; 0x64
  while((Uwe_val_smpl == 0 || Uwy_val_smpl == 0) && retry--)
 800960a:	682b      	ldr	r3, [r5, #0]
 800960c:	b10b      	cbz	r3, 8009612 <getVoltages+0x36>
 800960e:	6833      	ldr	r3, [r6, #0]
 8009610:	b933      	cbnz	r3, 8009620 <getVoltages+0x44>
 8009612:	f114 34ff 	adds.w	r4, r4, #4294967295
 8009616:	d304      	bcc.n	8009622 <getVoltages+0x46>
    mdelay(1);
 8009618:	2001      	movs	r0, #1
 800961a:	f001 f939 	bl	800a890 <vTaskDelay>
 800961e:	e7f4      	b.n	800960a <getVoltages+0x2e>

  if(retry <= 0)
 8009620:	b944      	cbnz	r4, 8009634 <getVoltages+0x58>
    dprintf(LL_ERROR, "Uwy or Uwe measure failed!!!\n");
 8009622:	4b09      	ldr	r3, [pc, #36]	; (8009648 <getVoltages+0x6c>)
 8009624:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009626:	2b00      	cmp	r3, #0
 8009628:	db04      	blt.n	8009634 <getVoltages+0x58>
 800962a:	4808      	ldr	r0, [pc, #32]	; (800964c <getVoltages+0x70>)
}
 800962c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  int retry = 100;
  while((Uwe_val_smpl == 0 || Uwy_val_smpl == 0) && retry--)
    mdelay(1);

  if(retry <= 0)
    dprintf(LL_ERROR, "Uwy or Uwe measure failed!!!\n");
 8009630:	f7ff b898 	b.w	8008764 <xprintf>
 8009634:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009636:	bf00      	nop
 8009638:	2001ae38 	.word	0x2001ae38
 800963c:	2001ae40 	.word	0x2001ae40
 8009640:	2001ae70 	.word	0x2001ae70
 8009644:	2001ae60 	.word	0x2001ae60
 8009648:	10001000 	.word	0x10001000
 800964c:	08014a62 	.word	0x08014a62

08009650 <power_SHD_ERR_P>:

// Wartosci pradu/napiecia wyliczane w odpowiedniej funkcji
int temp1, temp2;
#define TEMP2C(arg) ((arg)>>7)
void power_SHD_ERR_P(uint8_t errorCode)
{
 8009650:	4770      	bx	lr
	...

08009654 <wdogFail>:
      break;
    }
}

void wdogFail(void)
{
 8009654:	b508      	push	{r3, lr}
  if(!(cfg.disable_alerts&0x02))
 8009656:	4b06      	ldr	r3, [pc, #24]	; (8009670 <wdogFail+0x1c>)
 8009658:	695b      	ldr	r3, [r3, #20]
 800965a:	079b      	lsls	r3, r3, #30
 800965c:	d406      	bmi.n	800966c <wdogFail+0x18>
    {
      powerOFF1();
 800965e:	f006 fad1 	bl	800fc04 <powerOFF1>
      mdelay(200);
 8009662:	20c8      	movs	r0, #200	; 0xc8
 8009664:	f001 f914 	bl	800a890 <vTaskDelay>
      powerOFF2();
 8009668:	f006 fad0 	bl	800fc0c <powerOFF2>
 800966c:	e7fe      	b.n	800966c <wdogFail+0x18>
 800966e:	bf00      	nop
 8009670:	10001000 	.word	0x10001000

08009674 <isOn>:
  while(1);
}

int isOn(void)
{
  return (smokState == Smok_ON);
 8009674:	4b02      	ldr	r3, [pc, #8]	; (8009680 <isOn+0xc>)
 8009676:	7818      	ldrb	r0, [r3, #0]
}
 8009678:	1e83      	subs	r3, r0, #2
 800967a:	4258      	negs	r0, r3
 800967c:	4158      	adcs	r0, r3
 800967e:	4770      	bx	lr
 8009680:	2001ac40 	.word	0x2001ac40

08009684 <Check_power1>:
  if(retry <= 0)
    dprintf(LL_ERROR, "Uwy or Uwe measure failed!!!\n");
}

int Check_power1(void)
{
 8009684:	b538      	push	{r3, r4, r5, lr}
  int ok = 1;
  getVoltages();
  //Check Uve
  dprintf(LL_INFO, "Check Uwe_val %d (alarm %d) \n", Uwe_val, cfg.uwe_alarm);
 8009686:	4c16      	ldr	r4, [pc, #88]	; (80096e0 <Check_power1+0x5c>)
 8009688:	4d16      	ldr	r5, [pc, #88]	; (80096e4 <Check_power1+0x60>)
}

int Check_power1(void)
{
  int ok = 1;
  getVoltages();
 800968a:	f7ff ffa7 	bl	80095dc <getVoltages>
  //Check Uve
  dprintf(LL_INFO, "Check Uwe_val %d (alarm %d) \n", Uwe_val, cfg.uwe_alarm);
 800968e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009690:	2b01      	cmp	r3, #1
 8009692:	dd05      	ble.n	80096a0 <Check_power1+0x1c>
 8009694:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8009698:	6829      	ldr	r1, [r5, #0]
 800969a:	4813      	ldr	r0, [pc, #76]	; (80096e8 <Check_power1+0x64>)
 800969c:	f7ff f862 	bl	8008764 <xprintf>
  if(Uwe_val >= cfg.uwe_alarm)
 80096a0:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 80096a4:	6829      	ldr	r1, [r5, #0]
 80096a6:	4b0e      	ldr	r3, [pc, #56]	; (80096e0 <Check_power1+0x5c>)
 80096a8:	428a      	cmp	r2, r1
 80096aa:	dd01      	ble.n	80096b0 <Check_power1+0x2c>
    dprintf(LL_ERROR, "Uwy or Uwe measure failed!!!\n");
}

int Check_power1(void)
{
  int ok = 1;
 80096ac:	2001      	movs	r0, #1
 80096ae:	bd38      	pop	{r3, r4, r5, pc}
  getVoltages();
  //Check Uve
  dprintf(LL_INFO, "Check Uwe_val %d (alarm %d) \n", Uwe_val, cfg.uwe_alarm);
  if(Uwe_val >= cfg.uwe_alarm)
    {
      dprintf(LL_WARNING, "Uwe_val to high %d >= %d \n", Uwe_val, cfg.uwe_alarm);
 80096b0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80096b2:	2a00      	cmp	r2, #0
 80096b4:	dd04      	ble.n	80096c0 <Check_power1+0x3c>
 80096b6:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 80096ba:	480c      	ldr	r0, [pc, #48]	; (80096ec <Check_power1+0x68>)
 80096bc:	f7ff f852 	bl	8008764 <xprintf>
      power_SHD_ERR_P(UWE_H_ERROR);
      if(!(cfg.disable_alerts&0x04))
 80096c0:	6962      	ldr	r2, [r4, #20]
 80096c2:	f012 0204 	ands.w	r2, r2, #4
 80096c6:	d1f1      	bne.n	80096ac <Check_power1+0x28>
        {
          sendStatus(Uwe_High_MsgCode, SNDROUND(Uwe_val));
 80096c8:	682b      	ldr	r3, [r5, #0]
 80096ca:	2b00      	cmp	r3, #0
 80096cc:	bfa6      	itte	ge
 80096ce:	f3c3 2107 	ubfxge	r1, r3, #8, #8
 80096d2:	b2da      	uxtbge	r2, r3
 80096d4:	4611      	movlt	r1, r2
 80096d6:	20b4      	movs	r0, #180	; 0xb4
 80096d8:	f7ff fe36 	bl	8009348 <sendStatus>
 80096dc:	2000      	movs	r0, #0
          ok = 0;
          //SmokChangeState(Smok_OFF);
        }
    }
  return ok;
}
 80096de:	bd38      	pop	{r3, r4, r5, pc}
 80096e0:	10001000 	.word	0x10001000
 80096e4:	2001ae68 	.word	0x2001ae68
 80096e8:	08014a80 	.word	0x08014a80
 80096ec:	08014a9e 	.word	0x08014a9e

080096f0 <Check_power2>:

int Check_power2(void)
{
 80096f0:	b538      	push	{r3, r4, r5, lr}
  int ok = 1;
  getVoltages();
  //Check Uvy
  dprintf(LL_INFO, "Check Uwy_val %d (alarm %d) \n", Uwy_val, cfg.uwy_alarm);
 80096f2:	4c16      	ldr	r4, [pc, #88]	; (800974c <Check_power2+0x5c>)
 80096f4:	4d16      	ldr	r5, [pc, #88]	; (8009750 <Check_power2+0x60>)
}

int Check_power2(void)
{
  int ok = 1;
  getVoltages();
 80096f6:	f7ff ff71 	bl	80095dc <getVoltages>
  //Check Uvy
  dprintf(LL_INFO, "Check Uwy_val %d (alarm %d) \n", Uwy_val, cfg.uwy_alarm);
 80096fa:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80096fc:	2b01      	cmp	r3, #1
 80096fe:	dd05      	ble.n	800970c <Check_power2+0x1c>
 8009700:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
 8009704:	6829      	ldr	r1, [r5, #0]
 8009706:	4813      	ldr	r0, [pc, #76]	; (8009754 <Check_power2+0x64>)
 8009708:	f7ff f82c 	bl	8008764 <xprintf>
  if(Uwy_val >= cfg.uwy_alarm)
 800970c:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
 8009710:	6829      	ldr	r1, [r5, #0]
 8009712:	4b0e      	ldr	r3, [pc, #56]	; (800974c <Check_power2+0x5c>)
 8009714:	428a      	cmp	r2, r1
 8009716:	dd01      	ble.n	800971c <Check_power2+0x2c>
  return ok;
}

int Check_power2(void)
{
  int ok = 1;
 8009718:	2001      	movs	r0, #1
 800971a:	bd38      	pop	{r3, r4, r5, pc}
  getVoltages();
  //Check Uvy
  dprintf(LL_INFO, "Check Uwy_val %d (alarm %d) \n", Uwy_val, cfg.uwy_alarm);
  if(Uwy_val >= cfg.uwy_alarm)
    {
      dprintf(LL_WARNING, "Uwy_val to high %d >= %d \n", Uwy_val, cfg.uwy_alarm);
 800971c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800971e:	2a00      	cmp	r2, #0
 8009720:	dd04      	ble.n	800972c <Check_power2+0x3c>
 8009722:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8009726:	480c      	ldr	r0, [pc, #48]	; (8009758 <Check_power2+0x68>)
 8009728:	f7ff f81c 	bl	8008764 <xprintf>
      power_SHD_ERR_P(UWY_H_ERROR);
      if(!(cfg.disable_alerts&0x08))
 800972c:	6962      	ldr	r2, [r4, #20]
 800972e:	f012 0208 	ands.w	r2, r2, #8
 8009732:	d1f1      	bne.n	8009718 <Check_power2+0x28>
        {
          sendStatus(Uwy_High_MsgCode, SNDROUND(Uwy_val));
 8009734:	682b      	ldr	r3, [r5, #0]
 8009736:	2b00      	cmp	r3, #0
 8009738:	bfa6      	itte	ge
 800973a:	f3c3 2107 	ubfxge	r1, r3, #8, #8
 800973e:	b2da      	uxtbge	r2, r3
 8009740:	4611      	movlt	r1, r2
 8009742:	20b8      	movs	r0, #184	; 0xb8
 8009744:	f7ff fe00 	bl	8009348 <sendStatus>
          ok = 0;
 8009748:	2000      	movs	r0, #0
          //SmokChangeState(Smok_OFF);
        }
    }
  return ok;
}
 800974a:	bd38      	pop	{r3, r4, r5, pc}
 800974c:	10001000 	.word	0x10001000
 8009750:	2001ae48 	.word	0x2001ae48
 8009754:	08014ab9 	.word	0x08014ab9
 8009758:	08014ad7 	.word	0x08014ad7

0800975c <uitTimeout>:
        }
    }
}

void uitTimeout(portNum_t portNum)
{
 800975c:	b508      	push	{r3, lr}
  if(smokState == Smok_ON)
 800975e:	4b11      	ldr	r3, [pc, #68]	; (80097a4 <uitTimeout+0x48>)
 8009760:	781b      	ldrb	r3, [r3, #0]
 8009762:	2b02      	cmp	r3, #2
 8009764:	d11c      	bne.n	80097a0 <uitTimeout+0x44>
    {
      if(portNum == PER1_PORT)
 8009766:	2801      	cmp	r0, #1
 8009768:	d10a      	bne.n	8009780 <uitTimeout+0x24>
        {
          sendStatus(Sharc_NC_MsgCode, 0,0);
 800976a:	2200      	movs	r2, #0
 800976c:	4611      	mov	r1, r2
 800976e:	20a1      	movs	r0, #161	; 0xa1
 8009770:	f7ff fdea 	bl	8009348 <sendStatus>
          //          LEDblink(0, LED_GREEN, 1, 200, 1, 1, 200, 0);
          dprintf(LL_WARNING, "Sharc did not respond on keepalive message\n");
 8009774:	4b0c      	ldr	r3, [pc, #48]	; (80097a8 <uitTimeout+0x4c>)
 8009776:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009778:	2b00      	cmp	r3, #0
 800977a:	dd11      	ble.n	80097a0 <uitTimeout+0x44>
 800977c:	480b      	ldr	r0, [pc, #44]	; (80097ac <uitTimeout+0x50>)
 800977e:	e00b      	b.n	8009798 <uitTimeout+0x3c>
        }
      if(portNum == PER2_PORT)
 8009780:	2802      	cmp	r0, #2
 8009782:	d10d      	bne.n	80097a0 <uitTimeout+0x44>
        {
          sendStatus(PWM_NC_MsgCode, 0,0);
 8009784:	2200      	movs	r2, #0
 8009786:	4611      	mov	r1, r2
 8009788:	20a2      	movs	r0, #162	; 0xa2
 800978a:	f7ff fddd 	bl	8009348 <sendStatus>
          //          LEDblink(0, LED_ORANGE, 1, 200, 1, 1, 200, 0);
          dprintf(LL_WARNING, "PWM did not respond on keepalive message\n");
 800978e:	4b06      	ldr	r3, [pc, #24]	; (80097a8 <uitTimeout+0x4c>)
 8009790:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009792:	2b00      	cmp	r3, #0
 8009794:	dd04      	ble.n	80097a0 <uitTimeout+0x44>
 8009796:	4806      	ldr	r0, [pc, #24]	; (80097b0 <uitTimeout+0x54>)
        }
    }
}
 8009798:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        }
      if(portNum == PER2_PORT)
        {
          sendStatus(PWM_NC_MsgCode, 0,0);
          //          LEDblink(0, LED_ORANGE, 1, 200, 1, 1, 200, 0);
          dprintf(LL_WARNING, "PWM did not respond on keepalive message\n");
 800979c:	f7fe bfe2 	b.w	8008764 <xprintf>
 80097a0:	bd08      	pop	{r3, pc}
 80097a2:	bf00      	nop
 80097a4:	2001ac40 	.word	0x2001ac40
 80097a8:	10001000 	.word	0x10001000
 80097ac:	08014af2 	.word	0x08014af2
 80097b0:	08014b1e 	.word	0x08014b1e

080097b4 <uitOk>:
    }
}

void uitOk(portNum_t portNum)
{
  if(portNum == PER1_PORT)
 80097b4:	2801      	cmp	r0, #1
 80097b6:	d103      	bne.n	80097c0 <uitOk+0xc>
    {
      sendStatus(Sharc_C_MsgCode, 0,0);
 80097b8:	2200      	movs	r2, #0
 80097ba:	4611      	mov	r1, r2
 80097bc:	20a3      	movs	r0, #163	; 0xa3
 80097be:	e004      	b.n	80097ca <uitOk+0x16>
    }

  if(portNum == PER2_PORT)
 80097c0:	2802      	cmp	r0, #2
 80097c2:	d104      	bne.n	80097ce <uitOk+0x1a>
    {
      sendStatus(PWM_C_MsgCode, 0,0);
 80097c4:	2200      	movs	r2, #0
 80097c6:	4611      	mov	r1, r2
 80097c8:	20a4      	movs	r0, #164	; 0xa4
 80097ca:	f7ff bdbd 	b.w	8009348 <sendStatus>
 80097ce:	4770      	bx	lr

080097d0 <poweroffSeq>:

  UIT_Monitor(ADCtime);
}

void poweroffSeq(void)
{
 80097d0:	b508      	push	{r3, lr}
  //reset PLL
  pll_set(0, 1);
 80097d2:	2101      	movs	r1, #1
 80097d4:	2000      	movs	r0, #0
 80097d6:	f006 f8e1 	bl	800f99c <pll_set>

  //disable keepalivest
  kaCCEnable(0);
 80097da:	2000      	movs	r0, #0
 80097dc:	f7ff fe12 	bl	8009404 <kaCCEnable>
  //turn off RST_AMP
  powerOFF1();
 80097e0:	f006 fa10 	bl	800fc04 <powerOFF1>
  //Send off info to PWM
  sendPWMoffMsg();
 80097e4:	f7ff fd8c 	bl	8009300 <sendPWMoffMsg>
  mdelay(100);
 80097e8:	2064      	movs	r0, #100	; 0x64
 80097ea:	f001 f851 	bl	800a890 <vTaskDelay>
  //disable power_on
  powerOFF2();
 80097ee:	f006 fa0d 	bl	800fc0c <powerOFF2>
  mdelay(500);
 80097f2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80097f6:	f001 f84b 	bl	800a890 <vTaskDelay>

  //Disable PWM_STAT
  powerOFF3();
 80097fa:	f006 fa0d 	bl	800fc18 <powerOFF3>
  Check_power1();

}
 80097fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  powerOFF2();
  mdelay(500);

  //Disable PWM_STAT
  powerOFF3();
  Check_power1();
 8009802:	f7ff bf3f 	b.w	8009684 <Check_power1>
	...

08009808 <stateChangeON2OFF>:
  dprintf(LL_INFO, "NC->OFF\n");
  return 0;
}

static int stateChangeON2OFF(smokState_e oldState, smokState_e newState)
{
 8009808:	b508      	push	{r3, lr}
  dprintf(LL_INFO, "ON->OFF\n");
 800980a:	4b05      	ldr	r3, [pc, #20]	; (8009820 <stateChangeON2OFF+0x18>)
 800980c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800980e:	2b01      	cmp	r3, #1
 8009810:	dd02      	ble.n	8009818 <stateChangeON2OFF+0x10>
 8009812:	4804      	ldr	r0, [pc, #16]	; (8009824 <stateChangeON2OFF+0x1c>)
 8009814:	f7fe ffa6 	bl	8008764 <xprintf>
  poweroffSeq();
 8009818:	f7ff ffda 	bl	80097d0 <poweroffSeq>
  return 0;
}
 800981c:	2000      	movs	r0, #0
 800981e:	bd08      	pop	{r3, pc}
 8009820:	10001000 	.word	0x10001000
 8009824:	08014b48 	.word	0x08014b48

08009828 <stateChangeON2NC>:
  dprintf(LL_INFO, "OFF->NC\n");
  return 0;
}

static int stateChangeON2NC(smokState_e oldState, smokState_e newState)
{
 8009828:	b508      	push	{r3, lr}
  dprintf(LL_INFO, "ON->NC\n");
 800982a:	4b05      	ldr	r3, [pc, #20]	; (8009840 <stateChangeON2NC+0x18>)
 800982c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800982e:	2b01      	cmp	r3, #1
 8009830:	dd02      	ble.n	8009838 <stateChangeON2NC+0x10>
 8009832:	4804      	ldr	r0, [pc, #16]	; (8009844 <stateChangeON2NC+0x1c>)
 8009834:	f7fe ff96 	bl	8008764 <xprintf>
  poweroffSeq();
 8009838:	f7ff ffca 	bl	80097d0 <poweroffSeq>
  return 0;
}
 800983c:	2000      	movs	r0, #0
 800983e:	bd08      	pop	{r3, pc}
 8009840:	10001000 	.word	0x10001000
 8009844:	08014b51 	.word	0x08014b51

08009848 <SmokChangeState>:
    [Smok_ON]  = stateChangeAlreadyThere,
  },
};

int SmokChangeState(smokState_e newState, const char *reason)
{
 8009848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int ret = 0;

  //Call a proper action for the state change
  ret = changeStateMatrix[smokState][newState](smokState, newState);
 800984a:	4c0d      	ldr	r4, [pc, #52]	; (8009880 <SmokChangeState+0x38>)
 800984c:	4a0d      	ldr	r2, [pc, #52]	; (8009884 <SmokChangeState+0x3c>)
    [Smok_ON]  = stateChangeAlreadyThere,
  },
};

int SmokChangeState(smokState_e newState, const char *reason)
{
 800984e:	4605      	mov	r5, r0
  int ret = 0;

  //Call a proper action for the state change
  ret = changeStateMatrix[smokState][newState](smokState, newState);
 8009850:	7820      	ldrb	r0, [r4, #0]
 8009852:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 8009856:	442b      	add	r3, r5
    [Smok_ON]  = stateChangeAlreadyThere,
  },
};

int SmokChangeState(smokState_e newState, const char *reason)
{
 8009858:	460f      	mov	r7, r1
  int ret = 0;

  //Call a proper action for the state change
  ret = changeStateMatrix[smokState][newState](smokState, newState);
 800985a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800985e:	4629      	mov	r1, r5
 8009860:	4798      	blx	r3

  //Set new state
  if(ret >= 0)
 8009862:	1e06      	subs	r6, r0, #0
 8009864:	db0a      	blt.n	800987c <SmokChangeState+0x34>
    {
      smokState = newState;
      UIT_MsgRound = 0;
 8009866:	2300      	movs	r3, #0
 8009868:	6063      	str	r3, [r4, #4]
      dprintf(LL_INFO, "power state change reason: %s\n", reason);
 800986a:	4b07      	ldr	r3, [pc, #28]	; (8009888 <SmokChangeState+0x40>)
  ret = changeStateMatrix[smokState][newState](smokState, newState);

  //Set new state
  if(ret >= 0)
    {
      smokState = newState;
 800986c:	7025      	strb	r5, [r4, #0]
      UIT_MsgRound = 0;
      dprintf(LL_INFO, "power state change reason: %s\n", reason);
 800986e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009870:	2b01      	cmp	r3, #1
 8009872:	dd03      	ble.n	800987c <SmokChangeState+0x34>
 8009874:	4639      	mov	r1, r7
 8009876:	4805      	ldr	r0, [pc, #20]	; (800988c <SmokChangeState+0x44>)
 8009878:	f7fe ff74 	bl	8008764 <xprintf>
    }

  return ret;
}
 800987c:	4630      	mov	r0, r6
 800987e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009880:	2001ac40 	.word	0x2001ac40
 8009884:	080149ec 	.word	0x080149ec
 8009888:	10001000 	.word	0x10001000
 800988c:	08014b59 	.word	0x08014b59

08009890 <SmokLEDsState>:


void SmokLEDsState(int on, int conn, smokErrType_t err, int hd)
{
 8009890:	b410      	push	{r4}
 8009892:	4614      	mov	r4, r2
  int ledsMaskOn = 0;
  int ledsMaskOff = 0;
#define SET_DIODE(arg_diode) {ledsMaskOff &= ~(arg_diode);ledsMaskOn  |= (arg_diode);}
#define CLR_DIODE(arg_diode) {ledsMaskOn  &= ~(arg_diode);ledsMaskOff |= (arg_diode);}

  if(conn == 0)
 8009894:	b129      	cbz	r1, 80098a2 <SmokLEDsState+0x12>
    {
      CLR_DIODE(LED_WHITE);
    }

  if(conn == 1)
 8009896:	2901      	cmp	r1, #1
    {
      SET_DIODE(LED_WHITE);
 8009898:	f04f 0200 	mov.w	r2, #0
  if(conn == 0)
    {
      CLR_DIODE(LED_WHITE);
    }

  if(conn == 1)
 800989c:	d103      	bne.n	80098a6 <SmokLEDsState+0x16>
    {
      SET_DIODE(LED_WHITE);
 800989e:	2103      	movs	r1, #3
 80098a0:	e002      	b.n	80098a8 <SmokLEDsState+0x18>
#define SET_DIODE(arg_diode) {ledsMaskOff &= ~(arg_diode);ledsMaskOn  |= (arg_diode);}
#define CLR_DIODE(arg_diode) {ledsMaskOn  &= ~(arg_diode);ledsMaskOff |= (arg_diode);}

  if(conn == 0)
    {
      CLR_DIODE(LED_WHITE);
 80098a2:	2203      	movs	r2, #3
 80098a4:	e000      	b.n	80098a8 <SmokLEDsState+0x18>
 80098a6:	4611      	mov	r1, r2
    {
      SET_DIODE(LED_WHITE);
    }

  //Turn on
  if(on == 1)
 80098a8:	2801      	cmp	r0, #1
 80098aa:	d10a      	bne.n	80098c2 <SmokLEDsState+0x32>
    {
      CLR_DIODE(LED_RED | LED_YELLOW);
      if(hd == 1)
 80098ac:	2b01      	cmp	r3, #1
    }

  //Turn on
  if(on == 1)
    {
      CLR_DIODE(LED_RED | LED_YELLOW);
 80098ae:	f042 0014 	orr.w	r0, r2, #20
      if(hd == 1)
 80098b2:	d102      	bne.n	80098ba <SmokLEDsState+0x2a>
        SET_DIODE(LED_BLUE);
 80098b4:	f041 0108 	orr.w	r1, r1, #8
 80098b8:	e01e      	b.n	80098f8 <SmokLEDsState+0x68>
      if(hd == 0)
 80098ba:	b9eb      	cbnz	r3, 80098f8 <SmokLEDsState+0x68>
        CLR_DIODE(LED_BLUE);
 80098bc:	f042 001c 	orr.w	r0, r2, #28
 80098c0:	e01a      	b.n	80098f8 <SmokLEDsState+0x68>
    }

  //Turn off
  if(on == 0)
 80098c2:	b9a8      	cbnz	r0, 80098f0 <SmokLEDsState+0x60>
    {
      SET_DIODE(LED_YELLOW);
      switch(err)
 80098c4:	2c03      	cmp	r4, #3
 80098c6:	d806      	bhi.n	80098d6 <SmokLEDsState+0x46>
 80098c8:	e8df f004 	tbb	[pc, r4]
 80098cc:	100b0208 	.word	0x100b0208
        case SET_NONE:
          CLR_DIODE(LED_BLUE);
          break;
        case SET_CONN:
          SET_DIODE(LED_RED);
          CLR_DIODE(LED_WHITE | LED_BLUE);
 80098d0:	220b      	movs	r2, #11
 80098d2:	2114      	movs	r1, #20
 80098d4:	e00c      	b.n	80098f0 <SmokLEDsState+0x60>
    }

  //Turn off
  if(on == 0)
    {
      SET_DIODE(LED_YELLOW);
 80098d6:	f041 0104 	orr.w	r1, r1, #4
 80098da:	e009      	b.n	80098f0 <SmokLEDsState+0x60>
      switch(err)
        {
        case SET_NONE:
          CLR_DIODE(LED_BLUE);
 80098dc:	f041 0104 	orr.w	r1, r1, #4
 80098e0:	e001      	b.n	80098e6 <SmokLEDsState+0x56>
          SET_DIODE(LED_RED);
          CLR_DIODE(LED_WHITE | LED_BLUE);
          break;
        case SET_TEMP:
          SET_DIODE(LED_RED);
          CLR_DIODE(LED_BLUE);
 80098e2:	f041 0114 	orr.w	r1, r1, #20
 80098e6:	f042 0208 	orr.w	r2, r2, #8
          break;
 80098ea:	e001      	b.n	80098f0 <SmokLEDsState+0x60>
        case SET_OTHER:
          SET_DIODE(LED_RED | LED_BLUE | LED_WHITE);
 80098ec:	2200      	movs	r2, #0
 80098ee:	211f      	movs	r1, #31
          break;
        }
    }

  LEDset(0, ledsMaskOn, ledsMaskOff);
 80098f0:	2000      	movs	r0, #0
}
 80098f2:	bc10      	pop	{r4}
          SET_DIODE(LED_RED | LED_BLUE | LED_WHITE);
          break;
        }
    }

  LEDset(0, ledsMaskOn, ledsMaskOff);
 80098f4:	f003 bab6 	b.w	800ce64 <LEDset>
        case SET_TEMP:
          SET_DIODE(LED_RED);
          CLR_DIODE(LED_BLUE);
          break;
        case SET_OTHER:
          SET_DIODE(LED_RED | LED_BLUE | LED_WHITE);
 80098f8:	4602      	mov	r2, r0
 80098fa:	e7f9      	b.n	80098f0 <SmokLEDsState+0x60>

080098fc <Check_power4>:
    }
  return ok;
}

int Check_power4(void)
{
 80098fc:	b570      	push	{r4, r5, r6, lr}
  int ok = 1;
  getVoltages();

  dprintf(LL_INFO, "Check Uwy=10%WUwe Uwy = %dmV Uwe = %dmV\n", Uwy_val, Uwe_val);
 80098fe:	4c1f      	ldr	r4, [pc, #124]	; (800997c <Check_power4+0x80>)
 8009900:	4e1f      	ldr	r6, [pc, #124]	; (8009980 <Check_power4+0x84>)
 8009902:	4d20      	ldr	r5, [pc, #128]	; (8009984 <Check_power4+0x88>)
}

int Check_power4(void)
{
  int ok = 1;
  getVoltages();
 8009904:	f7ff fe6a 	bl	80095dc <getVoltages>

  dprintf(LL_INFO, "Check Uwy=10%WUwe Uwy = %dmV Uwe = %dmV\n", Uwy_val, Uwe_val);
 8009908:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800990a:	2b01      	cmp	r3, #1
 800990c:	dd04      	ble.n	8009918 <Check_power4+0x1c>
 800990e:	6832      	ldr	r2, [r6, #0]
 8009910:	6829      	ldr	r1, [r5, #0]
 8009912:	481d      	ldr	r0, [pc, #116]	; (8009988 <Check_power4+0x8c>)
 8009914:	f7fe ff26 	bl	8008764 <xprintf>

  //Check Uve/Uwy
  if(Uwy_val < ((Uwe_val*7)/100) || Uwy_val > ((Uwe_val*13)/100))
 8009918:	6832      	ldr	r2, [r6, #0]
 800991a:	6829      	ldr	r1, [r5, #0]
 800991c:	ebc2 00c2 	rsb	r0, r2, r2, lsl #3
 8009920:	2664      	movs	r6, #100	; 0x64
 8009922:	fb90 f0f6 	sdiv	r0, r0, r6
 8009926:	4288      	cmp	r0, r1
 8009928:	dc07      	bgt.n	800993a <Check_power4+0x3e>
 800992a:	230d      	movs	r3, #13
 800992c:	4353      	muls	r3, r2
 800992e:	fb93 f3f6 	sdiv	r3, r3, r6
 8009932:	4299      	cmp	r1, r3
 8009934:	dc01      	bgt.n	800993a <Check_power4+0x3e>
  return ok;
}

int Check_power4(void)
{
  int ok = 1;
 8009936:	2001      	movs	r0, #1
 8009938:	bd70      	pop	{r4, r5, r6, pc}
  dprintf(LL_INFO, "Check Uwy=10%WUwe Uwy = %dmV Uwe = %dmV\n", Uwy_val, Uwe_val);

  //Check Uve/Uwy
  if(Uwy_val < ((Uwe_val*7)/100) || Uwy_val > ((Uwe_val*13)/100))
    {
      dprintf(LL_WARNING, "Uwy_val(%dmV) outside of allowed range compared to Uwe(%dmV)  0.07*Uwe<Uwy<0.13*Uwe \n", Uwy_val, Uwe_val);
 800993a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800993c:	2b00      	cmp	r3, #0
 800993e:	dd02      	ble.n	8009946 <Check_power4+0x4a>
 8009940:	4812      	ldr	r0, [pc, #72]	; (800998c <Check_power4+0x90>)
 8009942:	f7fe ff0f 	bl	8008764 <xprintf>
      if(!(cfg.disable_alerts&0x01))
 8009946:	6961      	ldr	r1, [r4, #20]
 8009948:	f011 0101 	ands.w	r1, r1, #1
 800994c:	d1f3      	bne.n	8009936 <Check_power4+0x3a>
        {
          sendStatus(0xB5, SNDROUND(Uwy_val));
 800994e:	682a      	ldr	r2, [r5, #0]
 8009950:	2a00      	cmp	r2, #0
 8009952:	bfaa      	itet	ge
 8009954:	f3c2 2107 	ubfxge	r1, r2, #8, #8
 8009958:	460a      	movlt	r2, r1
 800995a:	b2d2      	uxtbge	r2, r2
 800995c:	20b5      	movs	r0, #181	; 0xb5
 800995e:	f7ff fcf3 	bl	8009348 <sendStatus>
          ok = 0;
          SmokChangeState(Smok_OFF, "Uwy vs Uwe failed");
 8009962:	490b      	ldr	r1, [pc, #44]	; (8009990 <Check_power4+0x94>)
 8009964:	2001      	movs	r0, #1
 8009966:	f7ff ff6f 	bl	8009848 <SmokChangeState>
          SmokLEDsState(0, -1, SET_OTHER, -1);
 800996a:	f04f 33ff 	mov.w	r3, #4294967295
 800996e:	2203      	movs	r2, #3
 8009970:	4619      	mov	r1, r3
 8009972:	2000      	movs	r0, #0
 8009974:	f7ff ff8c 	bl	8009890 <SmokLEDsState>
    {
      dprintf(LL_WARNING, "Uwy_val(%dmV) outside of allowed range compared to Uwe(%dmV)  0.07*Uwe<Uwy<0.13*Uwe \n", Uwy_val, Uwe_val);
      if(!(cfg.disable_alerts&0x01))
        {
          sendStatus(0xB5, SNDROUND(Uwy_val));
          ok = 0;
 8009978:	2000      	movs	r0, #0
          SmokChangeState(Smok_OFF, "Uwy vs Uwe failed");
          SmokLEDsState(0, -1, SET_OTHER, -1);
        }
    }
  return ok;
}
 800997a:	bd70      	pop	{r4, r5, r6, pc}
 800997c:	10001000 	.word	0x10001000
 8009980:	2001ae68 	.word	0x2001ae68
 8009984:	2001ae48 	.word	0x2001ae48
 8009988:	08014ba2 	.word	0x08014ba2
 800998c:	08014bcb 	.word	0x08014bcb
 8009990:	08014c21 	.word	0x08014c21

08009994 <communicatorADCMeasure>:

static int ADCtime = 0;
void communicatorADCMeasure(int samplesNum, int sampleSensADC,
                            int V1accu, int V2accu,
                            int I1max, int V2I1max, int I1accu, int I2accu)
{
 8009994:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  //Function is called every ADC_WINDOW [ms]
  ADCtime += ADC_WINDOW;
 8009998:	4d37      	ldr	r5, [pc, #220]	; (8009a78 <communicatorADCMeasure+0xe4>)
static int nextTempMeasure = 0;
static void UIT_Monitor(int adcTime)
{

  int diff = nextTempMeasure - adcTime;
  if(diff < 0 || diff > 100000)
 800999a:	4a38      	ldr	r2, [pc, #224]	; (8009a7c <communicatorADCMeasure+0xe8>)
void communicatorADCMeasure(int samplesNum, int sampleSensADC,
                            int V1accu, int V2accu,
                            int I1max, int V2I1max, int I1accu, int I2accu)
{
  //Function is called every ADC_WINDOW [ms]
  ADCtime += ADC_WINDOW;
 800999c:	68ae      	ldr	r6, [r5, #8]
static int nextTempMeasure = 0;
static void UIT_Monitor(int adcTime)
{

  int diff = nextTempMeasure - adcTime;
  if(diff < 0 || diff > 100000)
 800999e:	68eb      	ldr	r3, [r5, #12]
 80099a0:	4c37      	ldr	r4, [pc, #220]	; (8009a80 <communicatorADCMeasure+0xec>)
void communicatorADCMeasure(int samplesNum, int sampleSensADC,
                            int V1accu, int V2accu,
                            int I1max, int V2I1max, int I1accu, int I2accu)
{
  //Function is called every ADC_WINDOW [ms]
  ADCtime += ADC_WINDOW;
 80099a2:	360a      	adds	r6, #10
static int nextTempMeasure = 0;
static void UIT_Monitor(int adcTime)
{

  int diff = nextTempMeasure - adcTime;
  if(diff < 0 || diff > 100000)
 80099a4:	1b9b      	subs	r3, r3, r6
 80099a6:	4293      	cmp	r3, r2

static int ADCtime = 0;
void communicatorADCMeasure(int samplesNum, int sampleSensADC,
                            int V1accu, int V2accu,
                            int I1max, int V2I1max, int I1accu, int I2accu)
{
 80099a8:	b085      	sub	sp, #20
  //Function is called every ADC_WINDOW [ms]
  ADCtime += ADC_WINDOW;
 80099aa:	60ae      	str	r6, [r5, #8]
static int nextTempMeasure = 0;
static void UIT_Monitor(int adcTime)
{

  int diff = nextTempMeasure - adcTime;
  if(diff < 0 || diff > 100000)
 80099ac:	d936      	bls.n	8009a1c <communicatorADCMeasure+0x88>
    {
      nextTempMeasure = adcTime + cfg.temp_time;
 80099ae:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80099b2:	4433      	add	r3, r6
 80099b4:	60eb      	str	r3, [r5, #12]
      uint8_t buffer[2] = {0};
 80099b6:	2300      	movs	r3, #0
 80099b8:	f8ad 300c 	strh.w	r3, [sp, #12]
      if(cfg.term1Addr >= 0 && i2cTransfer(I2C1, cfg.term1Addr, buffer, 1, buffer, 2)>=2)
 80099bc:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80099be:	2b00      	cmp	r3, #0
 80099c0:	db11      	blt.n	80099e6 <communicatorADCMeasure+0x52>
 80099c2:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80099c4:	482f      	ldr	r0, [pc, #188]	; (8009a84 <communicatorADCMeasure+0xf0>)
 80099c6:	aa03      	add	r2, sp, #12
 80099c8:	2302      	movs	r3, #2
 80099ca:	e88d 000c 	stmia.w	sp, {r2, r3}
 80099ce:	b2c9      	uxtb	r1, r1
 80099d0:	2301      	movs	r3, #1
 80099d2:	f005 fbfd 	bl	800f1d0 <i2cTransfer>
 80099d6:	2801      	cmp	r0, #1
 80099d8:	dd05      	ble.n	80099e6 <communicatorADCMeasure+0x52>
        temp1 = ((int)(buffer[0])<<8) | buffer[1];
 80099da:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80099de:	4a2a      	ldr	r2, [pc, #168]	; (8009a88 <communicatorADCMeasure+0xf4>)
 80099e0:	ba5b      	rev16	r3, r3
 80099e2:	b29b      	uxth	r3, r3
 80099e4:	6013      	str	r3, [r2, #0]
      buffer[0] = 0;
 80099e6:	2300      	movs	r3, #0
 80099e8:	f88d 300c 	strb.w	r3, [sp, #12]
      buffer[1] = 0;
 80099ec:	f88d 300d 	strb.w	r3, [sp, #13]
      if(cfg.term2Addr >= 0 && i2cTransfer(I2C1, cfg.term2Addr, buffer, 1, buffer, 2)>=2)
 80099f0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80099f2:	2b00      	cmp	r3, #0
 80099f4:	db12      	blt.n	8009a1c <communicatorADCMeasure+0x88>
 80099f6:	4b22      	ldr	r3, [pc, #136]	; (8009a80 <communicatorADCMeasure+0xec>)
 80099f8:	4822      	ldr	r0, [pc, #136]	; (8009a84 <communicatorADCMeasure+0xf0>)
 80099fa:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80099fc:	aa03      	add	r2, sp, #12
 80099fe:	2302      	movs	r3, #2
 8009a00:	e88d 000c 	stmia.w	sp, {r2, r3}
 8009a04:	b2c9      	uxtb	r1, r1
 8009a06:	2301      	movs	r3, #1
 8009a08:	f005 fbe2 	bl	800f1d0 <i2cTransfer>
 8009a0c:	2801      	cmp	r0, #1
 8009a0e:	dd05      	ble.n	8009a1c <communicatorADCMeasure+0x88>
        temp2 = ((int)(buffer[0])<<8) | buffer[1];
 8009a10:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8009a14:	4a1d      	ldr	r2, [pc, #116]	; (8009a8c <communicatorADCMeasure+0xf8>)
 8009a16:	ba5b      	rev16	r3, r3
 8009a18:	b29b      	uxth	r3, r3
 8009a1a:	6013      	str	r3, [r2, #0]
}

static uint32_t nextPossibleSend = 0;
static void Check_UIT_Alarms(void)
{
  if(nextPossibleSend > xTaskGetTickCount())
 8009a1c:	f000 fe42 	bl	800a6a4 <xTaskGetTickCount>
 8009a20:	692b      	ldr	r3, [r5, #16]
 8009a22:	4298      	cmp	r0, r3
 8009a24:	f0c0 81c5 	bcc.w	8009db2 <communicatorADCMeasure+0x41e>
    return;

  if(smokState == Smok_ON)
 8009a28:	4b13      	ldr	r3, [pc, #76]	; (8009a78 <communicatorADCMeasure+0xe4>)
 8009a2a:	781b      	ldrb	r3, [r3, #0]
 8009a2c:	2b02      	cmp	r3, #2
 8009a2e:	f040 81c0 	bne.w	8009db2 <communicatorADCMeasure+0x41e>
    {
      int sent = 0;;
      int pwm = pwmStatus();
 8009a32:	f007 f8c9 	bl	8010bc8 <pwmStatus>
      if(!(pwm&(1<<0)))
 8009a36:	f010 0f01 	tst.w	r0, #1
    return;

  if(smokState == Smok_ON)
    {
      int sent = 0;;
      int pwm = pwmStatus();
 8009a3a:	4680      	mov	r8, r0
      if(!(pwm&(1<<0)))
 8009a3c:	d11a      	bne.n	8009a74 <communicatorADCMeasure+0xe0>
        {
          dprintf(LL_WARNING, "PWM_STAT error \n");
 8009a3e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009a40:	2b00      	cmp	r3, #0
 8009a42:	dd02      	ble.n	8009a4a <communicatorADCMeasure+0xb6>
 8009a44:	4812      	ldr	r0, [pc, #72]	; (8009a90 <communicatorADCMeasure+0xfc>)
 8009a46:	f7fe fe8d 	bl	8008764 <xprintf>
          if(!(cfg.disable_alerts&0x10))
 8009a4a:	6967      	ldr	r7, [r4, #20]
 8009a4c:	f017 0710 	ands.w	r7, r7, #16
 8009a50:	d122      	bne.n	8009a98 <communicatorADCMeasure+0x104>
            {
              sendStatus(0xB9, 0, 0);
 8009a52:	463a      	mov	r2, r7
 8009a54:	4639      	mov	r1, r7
 8009a56:	20b9      	movs	r0, #185	; 0xb9
 8009a58:	f7ff fc76 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "PWM_STAT error - alert");
 8009a5c:	490d      	ldr	r1, [pc, #52]	; (8009a94 <communicatorADCMeasure+0x100>)
 8009a5e:	2001      	movs	r0, #1
 8009a60:	f7ff fef2 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009a64:	f04f 33ff 	mov.w	r3, #4294967295
 8009a68:	2203      	movs	r2, #3
 8009a6a:	4619      	mov	r1, r3
 8009a6c:	4638      	mov	r0, r7
 8009a6e:	f7ff ff0f 	bl	8009890 <SmokLEDsState>
 8009a72:	e011      	b.n	8009a98 <communicatorADCMeasure+0x104>
  if(nextPossibleSend > xTaskGetTickCount())
    return;

  if(smokState == Smok_ON)
    {
      int sent = 0;;
 8009a74:	2300      	movs	r3, #0
 8009a76:	e010      	b.n	8009a9a <communicatorADCMeasure+0x106>
 8009a78:	2001ac40 	.word	0x2001ac40
 8009a7c:	000186a0 	.word	0x000186a0
 8009a80:	10001000 	.word	0x10001000
 8009a84:	40005400 	.word	0x40005400
 8009a88:	2001add0 	.word	0x2001add0
 8009a8c:	2001adcc 	.word	0x2001adcc
 8009a90:	08014b78 	.word	0x08014b78
 8009a94:	08014c33 	.word	0x08014c33
            {
              sendStatus(0xB9, 0, 0);
              SmokChangeState(Smok_OFF, "PWM_STAT error - alert");
              SmokLEDsState(0, -1, SET_OTHER, -1);
            }
          sent = 1;
 8009a98:	2301      	movs	r3, #1
        }
      if(!(pwm&(1<<1)))
 8009a9a:	f018 0f02 	tst.w	r8, #2
 8009a9e:	d11a      	bne.n	8009ad6 <communicatorADCMeasure+0x142>
        {
          dprintf(LL_WARNING, "PWM PB3 error \n");
 8009aa0:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009aa2:	2b00      	cmp	r3, #0
 8009aa4:	dd02      	ble.n	8009aac <communicatorADCMeasure+0x118>
 8009aa6:	48ab      	ldr	r0, [pc, #684]	; (8009d54 <communicatorADCMeasure+0x3c0>)
 8009aa8:	f7fe fe5c 	bl	8008764 <xprintf>
          if(!(cfg.disable_alerts&0x20))
 8009aac:	6967      	ldr	r7, [r4, #20]
 8009aae:	f017 0720 	ands.w	r7, r7, #32
 8009ab2:	d10f      	bne.n	8009ad4 <communicatorADCMeasure+0x140>
            {
              sendStatus(0xBA, 0xA, 0);
 8009ab4:	463a      	mov	r2, r7
 8009ab6:	210a      	movs	r1, #10
 8009ab8:	20ba      	movs	r0, #186	; 0xba
 8009aba:	f7ff fc45 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "PWM PB3 error");
 8009abe:	49a6      	ldr	r1, [pc, #664]	; (8009d58 <communicatorADCMeasure+0x3c4>)
 8009ac0:	2001      	movs	r0, #1
 8009ac2:	f7ff fec1 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009ac6:	f04f 33ff 	mov.w	r3, #4294967295
 8009aca:	2203      	movs	r2, #3
 8009acc:	4619      	mov	r1, r3
 8009ace:	4638      	mov	r0, r7
 8009ad0:	f7ff fede 	bl	8009890 <SmokLEDsState>
            }

          sent = 1;
 8009ad4:	2301      	movs	r3, #1
        }
      if(!(pwm&(1<<2)))
 8009ad6:	f018 0f04 	tst.w	r8, #4
 8009ada:	d11a      	bne.n	8009b12 <communicatorADCMeasure+0x17e>
        {
          dprintf(LL_WARNING, "PWM PB4 error \n");
 8009adc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009ade:	2b00      	cmp	r3, #0
 8009ae0:	dd02      	ble.n	8009ae8 <communicatorADCMeasure+0x154>
 8009ae2:	489e      	ldr	r0, [pc, #632]	; (8009d5c <communicatorADCMeasure+0x3c8>)
 8009ae4:	f7fe fe3e 	bl	8008764 <xprintf>
          if(!(cfg.disable_alerts&0x40))
 8009ae8:	6967      	ldr	r7, [r4, #20]
 8009aea:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8009aee:	d10f      	bne.n	8009b10 <communicatorADCMeasure+0x17c>
            {
              sendStatus(0xBA, 0xB, 0);
 8009af0:	463a      	mov	r2, r7
 8009af2:	210b      	movs	r1, #11
 8009af4:	20ba      	movs	r0, #186	; 0xba
 8009af6:	f7ff fc27 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "PWM PB4 error");
 8009afa:	4999      	ldr	r1, [pc, #612]	; (8009d60 <communicatorADCMeasure+0x3cc>)
 8009afc:	2001      	movs	r0, #1
 8009afe:	f7ff fea3 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009b02:	f04f 33ff 	mov.w	r3, #4294967295
 8009b06:	2203      	movs	r2, #3
 8009b08:	4619      	mov	r1, r3
 8009b0a:	4638      	mov	r0, r7
 8009b0c:	f7ff fec0 	bl	8009890 <SmokLEDsState>
            }
          sent = 1;
 8009b10:	2301      	movs	r3, #1
        }
      if(!(pwm&(1<<3)))
 8009b12:	f018 0f08 	tst.w	r8, #8
 8009b16:	d11a      	bne.n	8009b4e <communicatorADCMeasure+0x1ba>
        {
          dprintf(LL_WARNING, "PWM PC14 error \n");
 8009b18:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009b1a:	2b00      	cmp	r3, #0
 8009b1c:	dd02      	ble.n	8009b24 <communicatorADCMeasure+0x190>
 8009b1e:	4891      	ldr	r0, [pc, #580]	; (8009d64 <communicatorADCMeasure+0x3d0>)
 8009b20:	f7fe fe20 	bl	8008764 <xprintf>
          if(!(cfg.disable_alerts&0x80))
 8009b24:	6967      	ldr	r7, [r4, #20]
 8009b26:	f017 0780 	ands.w	r7, r7, #128	; 0x80
 8009b2a:	d10f      	bne.n	8009b4c <communicatorADCMeasure+0x1b8>
            {
              sendStatus(0xBB, 0xA, 0);
 8009b2c:	463a      	mov	r2, r7
 8009b2e:	210a      	movs	r1, #10
 8009b30:	20bb      	movs	r0, #187	; 0xbb
 8009b32:	f7ff fc09 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "PWM PC14 error");
 8009b36:	498c      	ldr	r1, [pc, #560]	; (8009d68 <communicatorADCMeasure+0x3d4>)
 8009b38:	2001      	movs	r0, #1
 8009b3a:	f7ff fe85 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009b3e:	f04f 33ff 	mov.w	r3, #4294967295
 8009b42:	2203      	movs	r2, #3
 8009b44:	4619      	mov	r1, r3
 8009b46:	4638      	mov	r0, r7
 8009b48:	f7ff fea2 	bl	8009890 <SmokLEDsState>
            }
          sent = 1;
 8009b4c:	2301      	movs	r3, #1
        }
      if(!(pwm&(1<<4)))
 8009b4e:	f018 0f10 	tst.w	r8, #16
 8009b52:	d11a      	bne.n	8009b8a <communicatorADCMeasure+0x1f6>
        {
          dprintf(LL_WARNING, "PWM PC15 error \n");
 8009b54:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009b56:	2b00      	cmp	r3, #0
 8009b58:	dd02      	ble.n	8009b60 <communicatorADCMeasure+0x1cc>
 8009b5a:	4884      	ldr	r0, [pc, #528]	; (8009d6c <communicatorADCMeasure+0x3d8>)
 8009b5c:	f7fe fe02 	bl	8008764 <xprintf>
          if(!(cfg.disable_alerts&0x100))
 8009b60:	6967      	ldr	r7, [r4, #20]
 8009b62:	f417 7780 	ands.w	r7, r7, #256	; 0x100
 8009b66:	d10f      	bne.n	8009b88 <communicatorADCMeasure+0x1f4>
            {
              sendStatus(0xBB, 0xB, 0);
 8009b68:	463a      	mov	r2, r7
 8009b6a:	210b      	movs	r1, #11
 8009b6c:	20bb      	movs	r0, #187	; 0xbb
 8009b6e:	f7ff fbeb 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "PWM PC15 error");
 8009b72:	497f      	ldr	r1, [pc, #508]	; (8009d70 <communicatorADCMeasure+0x3dc>)
 8009b74:	2001      	movs	r0, #1
 8009b76:	f7ff fe67 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009b7a:	f04f 33ff 	mov.w	r3, #4294967295
 8009b7e:	2203      	movs	r2, #3
 8009b80:	4619      	mov	r1, r3
 8009b82:	4638      	mov	r0, r7
 8009b84:	f7ff fe84 	bl	8009890 <SmokLEDsState>
            }
          sent = 1;
 8009b88:	2301      	movs	r3, #1
        }
      if(!(pwm&(1<<5)))
 8009b8a:	f018 0f20 	tst.w	r8, #32
 8009b8e:	d11a      	bne.n	8009bc6 <communicatorADCMeasure+0x232>
        {
          dprintf(LL_WARNING, "PWM PE13 error \n");
 8009b90:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8009b92:	2b00      	cmp	r3, #0
 8009b94:	dd02      	ble.n	8009b9c <communicatorADCMeasure+0x208>
 8009b96:	4877      	ldr	r0, [pc, #476]	; (8009d74 <communicatorADCMeasure+0x3e0>)
 8009b98:	f7fe fde4 	bl	8008764 <xprintf>
          if(!(cfg.disable_alerts&0x2000))
 8009b9c:	6967      	ldr	r7, [r4, #20]
 8009b9e:	f417 5700 	ands.w	r7, r7, #8192	; 0x2000
 8009ba2:	d10f      	bne.n	8009bc4 <communicatorADCMeasure+0x230>
            {
              sendStatus(0xBB, 0xC, 0);
 8009ba4:	463a      	mov	r2, r7
 8009ba6:	210c      	movs	r1, #12
 8009ba8:	20bb      	movs	r0, #187	; 0xbb
 8009baa:	f7ff fbcd 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "PWM PE13 error");
 8009bae:	4972      	ldr	r1, [pc, #456]	; (8009d78 <communicatorADCMeasure+0x3e4>)
 8009bb0:	2001      	movs	r0, #1
 8009bb2:	f7ff fe49 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009bb6:	f04f 33ff 	mov.w	r3, #4294967295
 8009bba:	2203      	movs	r2, #3
 8009bbc:	4619      	mov	r1, r3
 8009bbe:	4638      	mov	r0, r7
 8009bc0:	f7ff fe66 	bl	8009890 <SmokLEDsState>
            }
          sent = 1;
 8009bc4:	2301      	movs	r3, #1
      /*     if(!cfg.disable_alerts) SmokChangeState(Smok_OFF); */
      /*     sent = 1; */
      /*   } */

      //Check IL
      if(meaniL >= cfg.imax_alarm)
 8009bc6:	486d      	ldr	r0, [pc, #436]	; (8009d7c <communicatorADCMeasure+0x3e8>)
 8009bc8:	f8d4 709c 	ldr.w	r7, [r4, #156]	; 0x9c
 8009bcc:	6801      	ldr	r1, [r0, #0]
 8009bce:	4a6c      	ldr	r2, [pc, #432]	; (8009d80 <communicatorADCMeasure+0x3ec>)
 8009bd0:	428f      	cmp	r7, r1
 8009bd2:	4607      	mov	r7, r0
 8009bd4:	dc2b      	bgt.n	8009c2e <communicatorADCMeasure+0x29a>
        {
          dprintf(LL_WARNING, "meaniL to high %d >= %d \n", meaniL, cfg.imax_alarm);
 8009bd6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009bd8:	2b00      	cmp	r3, #0
 8009bda:	dd04      	ble.n	8009be6 <communicatorADCMeasure+0x252>
 8009bdc:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
 8009be0:	4868      	ldr	r0, [pc, #416]	; (8009d84 <communicatorADCMeasure+0x3f0>)
 8009be2:	f7fe fdbf 	bl	8008764 <xprintf>
          power_SHD_ERR_P(IL_ERROR);
          if(!(cfg.disable_alerts&0x200))
 8009be6:	6960      	ldr	r0, [r4, #20]
 8009be8:	f410 7000 	ands.w	r0, r0, #512	; 0x200
 8009bec:	d11e      	bne.n	8009c2c <communicatorADCMeasure+0x298>
            {
              sendStatusLong(IL_High_MsgCode, SNDROUND(meaniL), SNDROUND(sMaxvL));
 8009bee:	4b66      	ldr	r3, [pc, #408]	; (8009d88 <communicatorADCMeasure+0x3f4>)
 8009bf0:	683a      	ldr	r2, [r7, #0]
 8009bf2:	681f      	ldr	r7, [r3, #0]
 8009bf4:	2a00      	cmp	r2, #0
 8009bf6:	bfab      	itete	ge
 8009bf8:	f3c2 2107 	ubfxge	r1, r2, #8, #8
 8009bfc:	4602      	movlt	r2, r0
 8009bfe:	b2d2      	uxtbge	r2, r2
 8009c00:	4601      	movlt	r1, r0
 8009c02:	2f00      	cmp	r7, #0
 8009c04:	bfa6      	itte	ge
 8009c06:	b2f8      	uxtbge	r0, r7
 8009c08:	f3c7 2307 	ubfxge	r3, r7, #8, #8
 8009c0c:	2300      	movlt	r3, #0
 8009c0e:	9000      	str	r0, [sp, #0]
 8009c10:	20b5      	movs	r0, #181	; 0xb5
 8009c12:	f7ff fbc3 	bl	800939c <sendStatusLong>
              SmokChangeState(Smok_OFF, "meaniL to high");
 8009c16:	495d      	ldr	r1, [pc, #372]	; (8009d8c <communicatorADCMeasure+0x3f8>)
 8009c18:	2001      	movs	r0, #1
 8009c1a:	f7ff fe15 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_OTHER, -1);
 8009c1e:	f04f 33ff 	mov.w	r3, #4294967295
 8009c22:	2203      	movs	r2, #3
 8009c24:	4619      	mov	r1, r3
 8009c26:	2000      	movs	r0, #0
 8009c28:	f7ff fe32 	bl	8009890 <SmokLEDsState>
            }
          sent = 1;
 8009c2c:	2301      	movs	r3, #1
        }

      //Check Temperature AIR
      if(TEMP2C(temp1) >= cfg.t_air_max)
 8009c2e:	4f58      	ldr	r7, [pc, #352]	; (8009d90 <communicatorADCMeasure+0x3fc>)
 8009c30:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 8009c34:	6839      	ldr	r1, [r7, #0]
 8009c36:	4a52      	ldr	r2, [pc, #328]	; (8009d80 <communicatorADCMeasure+0x3ec>)
 8009c38:	11c9      	asrs	r1, r1, #7
 8009c3a:	4281      	cmp	r1, r0
 8009c3c:	db40      	blt.n	8009cc0 <communicatorADCMeasure+0x32c>
        {
          dprintf(LL_WARNING, "tAir to high %d.%d >= %d.%d \n", TEMP2C(temp1)/2, 5*(TEMP2C(temp1)%2), cfg.t_air_max/2, 5*(cfg.t_air_max%2));
 8009c3e:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009c40:	2b00      	cmp	r3, #0
 8009c42:	dd26      	ble.n	8009c92 <communicatorADCMeasure+0x2fe>
 8009c44:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
 8009c48:	f8d2 e0a0 	ldr.w	lr, [r2, #160]	; 0xa0
 8009c4c:	2202      	movs	r2, #2
 8009c4e:	fb93 f3f2 	sdiv	r3, r3, r2
 8009c52:	4a50      	ldr	r2, [pc, #320]	; (8009d94 <communicatorADCMeasure+0x400>)
 8009c54:	400a      	ands	r2, r1
 8009c56:	2a00      	cmp	r2, #0
 8009c58:	f04f 0002 	mov.w	r0, #2
 8009c5c:	fb91 f1f0 	sdiv	r1, r1, r0
 8009c60:	484c      	ldr	r0, [pc, #304]	; (8009d94 <communicatorADCMeasure+0x400>)
 8009c62:	bfb8      	it	lt
 8009c64:	f102 32ff 	addlt.w	r2, r2, #4294967295
 8009c68:	ea0e 0000 	and.w	r0, lr, r0
 8009c6c:	bfbc      	itt	lt
 8009c6e:	f062 0201 	ornlt	r2, r2, #1
 8009c72:	3201      	addlt	r2, #1
 8009c74:	2800      	cmp	r0, #0
 8009c76:	bfbe      	ittt	lt
 8009c78:	f100 30ff 	addlt.w	r0, r0, #4294967295
 8009c7c:	f060 0001 	ornlt	r0, r0, #1
 8009c80:	3001      	addlt	r0, #1
 8009c82:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009c86:	9000      	str	r0, [sp, #0]
 8009c88:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8009c8c:	4842      	ldr	r0, [pc, #264]	; (8009d98 <communicatorADCMeasure+0x404>)
 8009c8e:	f7fe fd69 	bl	8008764 <xprintf>
          power_SHD_ERR_P(TEMP_AIR_ERROR);
          if(!(cfg.disable_alerts&0x400))
 8009c92:	f8d4 8014 	ldr.w	r8, [r4, #20]
 8009c96:	f418 6880 	ands.w	r8, r8, #1024	; 0x400
 8009c9a:	d110      	bne.n	8009cbe <communicatorADCMeasure+0x32a>
            {
              sendStatus(AIR_ERR_MsgCode, TEMP2C(temp1), 0);
 8009c9c:	6839      	ldr	r1, [r7, #0]
 8009c9e:	4642      	mov	r2, r8
 8009ca0:	11c9      	asrs	r1, r1, #7
 8009ca2:	20b2      	movs	r0, #178	; 0xb2
 8009ca4:	f7ff fb50 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "tAir to high");
 8009ca8:	493c      	ldr	r1, [pc, #240]	; (8009d9c <communicatorADCMeasure+0x408>)
 8009caa:	2001      	movs	r0, #1
 8009cac:	f7ff fdcc 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_TEMP, -1);
 8009cb0:	f04f 33ff 	mov.w	r3, #4294967295
 8009cb4:	2202      	movs	r2, #2
 8009cb6:	4619      	mov	r1, r3
 8009cb8:	4640      	mov	r0, r8
 8009cba:	f7ff fde9 	bl	8009890 <SmokLEDsState>
            }
          sent = 1;
 8009cbe:	2301      	movs	r3, #1
        }

      //Check temperature FET
      if(TEMP2C(temp2) >= cfg.t_fet_max)
 8009cc0:	4f37      	ldr	r7, [pc, #220]	; (8009da0 <communicatorADCMeasure+0x40c>)
 8009cc2:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 8009cc6:	6839      	ldr	r1, [r7, #0]
 8009cc8:	4a2d      	ldr	r2, [pc, #180]	; (8009d80 <communicatorADCMeasure+0x3ec>)
 8009cca:	11c9      	asrs	r1, r1, #7
 8009ccc:	4281      	cmp	r1, r0
 8009cce:	db6d      	blt.n	8009dac <communicatorADCMeasure+0x418>
        {
          dprintf(LL_WARNING, "tFET to high %d.%d >= %d.%d \n", TEMP2C(temp2)/2, 5*(TEMP2C(temp2)%2), cfg.t_fet_max/2, 5*(cfg.t_fet_max%2));
 8009cd0:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8009cd2:	2b00      	cmp	r3, #0
 8009cd4:	dd26      	ble.n	8009d24 <communicatorADCMeasure+0x390>
 8009cd6:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
 8009cda:	f8d2 e0a4 	ldr.w	lr, [r2, #164]	; 0xa4
 8009cde:	2202      	movs	r2, #2
 8009ce0:	fb93 f3f2 	sdiv	r3, r3, r2
 8009ce4:	4a2b      	ldr	r2, [pc, #172]	; (8009d94 <communicatorADCMeasure+0x400>)
 8009ce6:	400a      	ands	r2, r1
 8009ce8:	2a00      	cmp	r2, #0
 8009cea:	f04f 0002 	mov.w	r0, #2
 8009cee:	fb91 f1f0 	sdiv	r1, r1, r0
 8009cf2:	4828      	ldr	r0, [pc, #160]	; (8009d94 <communicatorADCMeasure+0x400>)
 8009cf4:	bfb8      	it	lt
 8009cf6:	f102 32ff 	addlt.w	r2, r2, #4294967295
 8009cfa:	ea0e 0000 	and.w	r0, lr, r0
 8009cfe:	bfbc      	itt	lt
 8009d00:	f062 0201 	ornlt	r2, r2, #1
 8009d04:	3201      	addlt	r2, #1
 8009d06:	2800      	cmp	r0, #0
 8009d08:	bfbe      	ittt	lt
 8009d0a:	f100 30ff 	addlt.w	r0, r0, #4294967295
 8009d0e:	f060 0001 	ornlt	r0, r0, #1
 8009d12:	3001      	addlt	r0, #1
 8009d14:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009d18:	9000      	str	r0, [sp, #0]
 8009d1a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8009d1e:	4821      	ldr	r0, [pc, #132]	; (8009da4 <communicatorADCMeasure+0x410>)
 8009d20:	f7fe fd20 	bl	8008764 <xprintf>
          power_SHD_ERR_P(TEMP_FET_ERROR);
          if(!(cfg.disable_alerts&0x800))
 8009d24:	f8d4 8014 	ldr.w	r8, [r4, #20]
 8009d28:	f418 6800 	ands.w	r8, r8, #2048	; 0x800
 8009d2c:	f040 8176 	bne.w	800a01c <communicatorADCMeasure+0x688>
            {
              sendStatus(FET_ERR_MsgCode, TEMP2C(temp2),0);
 8009d30:	6839      	ldr	r1, [r7, #0]
 8009d32:	4642      	mov	r2, r8
 8009d34:	11c9      	asrs	r1, r1, #7
 8009d36:	20b1      	movs	r0, #177	; 0xb1
 8009d38:	f7ff fb06 	bl	8009348 <sendStatus>
              SmokChangeState(Smok_OFF, "tFET to high");
 8009d3c:	491a      	ldr	r1, [pc, #104]	; (8009da8 <communicatorADCMeasure+0x414>)
 8009d3e:	2001      	movs	r0, #1
 8009d40:	f7ff fd82 	bl	8009848 <SmokChangeState>
              SmokLEDsState(0, -1, SET_TEMP, -1);
 8009d44:	f04f 33ff 	mov.w	r3, #4294967295
 8009d48:	2202      	movs	r2, #2
 8009d4a:	4619      	mov	r1, r3
 8009d4c:	4640      	mov	r0, r8
 8009d4e:	f7ff fd9f 	bl	8009890 <SmokLEDsState>
 8009d52:	e163      	b.n	800a01c <communicatorADCMeasure+0x688>
 8009d54:	08014c4a 	.word	0x08014c4a
 8009d58:	08014c5a 	.word	0x08014c5a
 8009d5c:	08014c68 	.word	0x08014c68
 8009d60:	08014c78 	.word	0x08014c78
 8009d64:	08014c86 	.word	0x08014c86
 8009d68:	08014c97 	.word	0x08014c97
 8009d6c:	08014ca6 	.word	0x08014ca6
 8009d70:	08014cb7 	.word	0x08014cb7
 8009d74:	08014cc6 	.word	0x08014cc6
 8009d78:	08014cd7 	.word	0x08014cd7
 8009d7c:	2001ae58 	.word	0x2001ae58
 8009d80:	10001000 	.word	0x10001000
 8009d84:	08014ce6 	.word	0x08014ce6
 8009d88:	2001ae54 	.word	0x2001ae54
 8009d8c:	08014d00 	.word	0x08014d00
 8009d90:	2001add0 	.word	0x2001add0
 8009d94:	80000001 	.word	0x80000001
 8009d98:	08014d0f 	.word	0x08014d0f
 8009d9c:	08014d2d 	.word	0x08014d2d
 8009da0:	2001adcc 	.word	0x2001adcc
 8009da4:	08014d3a 	.word	0x08014d3a
 8009da8:	08014d58 	.word	0x08014d58
            }
          sent = 1;
        }
      if(sent)
 8009dac:	2b00      	cmp	r3, #0
 8009dae:	f040 8135 	bne.w	800a01c <communicatorADCMeasure+0x688>
    }

  Check_UIT_Alarms();

  {
    if(Uwy_k > cfg.uwyRange && kSensADC == 1) sensADCnew = 0;
 8009db2:	4b9f      	ldr	r3, [pc, #636]	; (800a030 <communicatorADCMeasure+0x69c>)
 8009db4:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8009db8:	681b      	ldr	r3, [r3, #0]
 8009dba:	429a      	cmp	r2, r3
 8009dbc:	da06      	bge.n	8009dcc <communicatorADCMeasure+0x438>
 8009dbe:	4a9d      	ldr	r2, [pc, #628]	; (800a034 <communicatorADCMeasure+0x6a0>)
 8009dc0:	6812      	ldr	r2, [r2, #0]
 8009dc2:	2a01      	cmp	r2, #1
 8009dc4:	bf02      	ittt	eq
 8009dc6:	4a9c      	ldreq	r2, [pc, #624]	; (800a038 <communicatorADCMeasure+0x6a4>)
 8009dc8:	2100      	moveq	r1, #0
 8009dca:	6011      	streq	r1, [r2, #0]
    if(Uwy_k <= cfg.uwyRange && kSensADC == 0) sensADCnew = 1;
 8009dcc:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8009dd0:	4293      	cmp	r3, r2
 8009dd2:	dc05      	bgt.n	8009de0 <communicatorADCMeasure+0x44c>
 8009dd4:	4b97      	ldr	r3, [pc, #604]	; (800a034 <communicatorADCMeasure+0x6a0>)
 8009dd6:	681b      	ldr	r3, [r3, #0]
 8009dd8:	b913      	cbnz	r3, 8009de0 <communicatorADCMeasure+0x44c>
 8009dda:	4b97      	ldr	r3, [pc, #604]	; (800a038 <communicatorADCMeasure+0x6a4>)
 8009ddc:	2201      	movs	r2, #1
 8009dde:	601a      	str	r2, [r3, #0]
    CLRADC(Uwy_k);
 8009de0:	f000 f9a8 	bl	800a134 <vPortEnterCritical>
 8009de4:	4b95      	ldr	r3, [pc, #596]	; (800a03c <communicatorADCMeasure+0x6a8>)
 8009de6:	2000      	movs	r0, #0
 8009de8:	2100      	movs	r1, #0
 8009dea:	e9c3 0100 	strd	r0, r1, [r3]
 8009dee:	4b94      	ldr	r3, [pc, #592]	; (800a040 <communicatorADCMeasure+0x6ac>)
 8009df0:	2200      	movs	r2, #0
 8009df2:	601a      	str	r2, [r3, #0]
 8009df4:	f000 f9b0 	bl	800a158 <vPortExitCritical>
  }

  diff = nextTimestamp - adcTime;
#define IDX ((smokState == Smok_ON)?1:0)
  if(diff < 0 || diff > 10000)
 8009df8:	696b      	ldr	r3, [r5, #20]
    if(Uwy_k > cfg.uwyRange && kSensADC == 1) sensADCnew = 0;
    if(Uwy_k <= cfg.uwyRange && kSensADC == 0) sensADCnew = 1;
    CLRADC(Uwy_k);
  }

  diff = nextTimestamp - adcTime;
 8009dfa:	4892      	ldr	r0, [pc, #584]	; (800a044 <communicatorADCMeasure+0x6b0>)
#define IDX ((smokState == Smok_ON)?1:0)
  if(diff < 0 || diff > 10000)
 8009dfc:	1b9b      	subs	r3, r3, r6
 8009dfe:	f242 7210 	movw	r2, #10000	; 0x2710
 8009e02:	4293      	cmp	r3, r2
 8009e04:	f240 8110 	bls.w	800a028 <communicatorADCMeasure+0x694>
    {
      nextTimestamp = adcTime + cfg.msgRoundTime[IDX];
 8009e08:	7803      	ldrb	r3, [r0, #0]
 8009e0a:	1e9f      	subs	r7, r3, #2
 8009e0c:	427b      	negs	r3, r7
 8009e0e:	417b      	adcs	r3, r7
 8009e10:	f103 021a 	add.w	r2, r3, #26
 8009e14:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8009e18:	6852      	ldr	r2, [r2, #4]
 8009e1a:	4416      	add	r6, r2

      //Next round
      UIT_MsgRound = (UIT_MsgRound + 1)%(cfg.msgRoundMax[IDX]+1);
 8009e1c:	f103 0218 	add.w	r2, r3, #24
 8009e20:	eb04 0282 	add.w	r2, r4, r2, lsl #2

  diff = nextTimestamp - adcTime;
#define IDX ((smokState == Smok_ON)?1:0)
  if(diff < 0 || diff > 10000)
    {
      nextTimestamp = adcTime + cfg.msgRoundTime[IDX];
 8009e24:	6146      	str	r6, [r0, #20]

      //Next round
      UIT_MsgRound = (UIT_MsgRound + 1)%(cfg.msgRoundMax[IDX]+1);
 8009e26:	6852      	ldr	r2, [r2, #4]
 8009e28:	6846      	ldr	r6, [r0, #4]
 8009e2a:	3201      	adds	r2, #1
 8009e2c:	3601      	adds	r6, #1

      //Send actual current, voltage and temperature output values
      // -------  Uwe -----------
      SENDSTS(cfg.msgUwe[IDX],
 8009e2e:	331c      	adds	r3, #28
  if(diff < 0 || diff > 10000)
    {
      nextTimestamp = adcTime + cfg.msgRoundTime[IDX];

      //Next round
      UIT_MsgRound = (UIT_MsgRound + 1)%(cfg.msgRoundMax[IDX]+1);
 8009e30:	fb96 f1f2 	sdiv	r1, r6, r2

      //Send actual current, voltage and temperature output values
      // -------  Uwe -----------
      SENDSTS(cfg.msgUwe[IDX],
 8009e34:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  if(diff < 0 || diff > 10000)
    {
      nextTimestamp = adcTime + cfg.msgRoundTime[IDX];

      //Next round
      UIT_MsgRound = (UIT_MsgRound + 1)%(cfg.msgRoundMax[IDX]+1);
 8009e38:	fb02 6211 	mls	r2, r2, r1, r6
 8009e3c:	6042      	str	r2, [r0, #4]

      //Send actual current, voltage and temperature output values
      // -------  Uwe -----------
      SENDSTS(cfg.msgUwe[IDX],
 8009e3e:	685e      	ldr	r6, [r3, #4]
 8009e40:	685b      	ldr	r3, [r3, #4]
 8009e42:	fa43 f202 	asr.w	r2, r3, r2
 8009e46:	07d3      	lsls	r3, r2, #31
 8009e48:	bf5a      	itte	pl
 8009e4a:	fab6 f686 	clzpl	r6, r6
 8009e4e:	0976      	lsrpl	r6, r6, #5
 8009e50:	2603      	movmi	r6, #3
 8009e52:	07b1      	lsls	r1, r6, #30
 8009e54:	d50b      	bpl.n	8009e6e <communicatorADCMeasure+0x4da>
 8009e56:	4b7c      	ldr	r3, [pc, #496]	; (800a048 <communicatorADCMeasure+0x6b4>)
 8009e58:	681a      	ldr	r2, [r3, #0]
 8009e5a:	2a00      	cmp	r2, #0
 8009e5c:	bfb5      	itete	lt
 8009e5e:	2100      	movlt	r1, #0
 8009e60:	f3c2 2107 	ubfxge	r1, r2, #8, #8
 8009e64:	460a      	movlt	r2, r1
 8009e66:	b2d2      	uxtbge	r2, r2
 8009e68:	2021      	movs	r0, #33	; 0x21
 8009e6a:	f7ff fa6d 	bl	8009348 <sendStatus>
 8009e6e:	07f2      	lsls	r2, r6, #31
 8009e70:	d50b      	bpl.n	8009e8a <communicatorADCMeasure+0x4f6>
 8009e72:	f000 f95f 	bl	800a134 <vPortEnterCritical>
 8009e76:	4b75      	ldr	r3, [pc, #468]	; (800a04c <communicatorADCMeasure+0x6b8>)
 8009e78:	2000      	movs	r0, #0
 8009e7a:	2100      	movs	r1, #0
 8009e7c:	e9c3 0100 	strd	r0, r1, [r3]
 8009e80:	4b73      	ldr	r3, [pc, #460]	; (800a050 <communicatorADCMeasure+0x6bc>)
 8009e82:	2200      	movs	r2, #0
 8009e84:	601a      	str	r2, [r3, #0]
 8009e86:	f000 f967 	bl	800a158 <vPortExitCritical>
              sendStatus(Uwe_MsgCode, SNDROUND(Uwe_val)),
              CLRADC(Uwe_val));

      // -------  Uwy -----------
      SENDSTS(cfg.msgUwy[IDX],
 8009e8a:	782b      	ldrb	r3, [r5, #0]
 8009e8c:	686a      	ldr	r2, [r5, #4]
 8009e8e:	2b02      	cmp	r3, #2
 8009e90:	bf0c      	ite	eq
 8009e92:	237c      	moveq	r3, #124	; 0x7c
 8009e94:	2378      	movne	r3, #120	; 0x78
 8009e96:	4423      	add	r3, r4
 8009e98:	685e      	ldr	r6, [r3, #4]
 8009e9a:	685b      	ldr	r3, [r3, #4]
 8009e9c:	4113      	asrs	r3, r2
 8009e9e:	07db      	lsls	r3, r3, #31
 8009ea0:	bf5a      	itte	pl
 8009ea2:	fab6 f686 	clzpl	r6, r6
 8009ea6:	0976      	lsrpl	r6, r6, #5
 8009ea8:	2603      	movmi	r6, #3
 8009eaa:	07b7      	lsls	r7, r6, #30
 8009eac:	d50b      	bpl.n	8009ec6 <communicatorADCMeasure+0x532>
 8009eae:	4b69      	ldr	r3, [pc, #420]	; (800a054 <communicatorADCMeasure+0x6c0>)
 8009eb0:	681a      	ldr	r2, [r3, #0]
 8009eb2:	2a00      	cmp	r2, #0
 8009eb4:	bfb5      	itete	lt
 8009eb6:	2100      	movlt	r1, #0
 8009eb8:	f3c2 2107 	ubfxge	r1, r2, #8, #8
 8009ebc:	460a      	movlt	r2, r1
 8009ebe:	b2d2      	uxtbge	r2, r2
 8009ec0:	2022      	movs	r0, #34	; 0x22
 8009ec2:	f7ff fa41 	bl	8009348 <sendStatus>
 8009ec6:	07f0      	lsls	r0, r6, #31
 8009ec8:	d50b      	bpl.n	8009ee2 <communicatorADCMeasure+0x54e>
 8009eca:	f000 f933 	bl	800a134 <vPortEnterCritical>
 8009ece:	4b62      	ldr	r3, [pc, #392]	; (800a058 <communicatorADCMeasure+0x6c4>)
 8009ed0:	2000      	movs	r0, #0
 8009ed2:	2100      	movs	r1, #0
 8009ed4:	e9c3 0100 	strd	r0, r1, [r3]
 8009ed8:	4b60      	ldr	r3, [pc, #384]	; (800a05c <communicatorADCMeasure+0x6c8>)
 8009eda:	2200      	movs	r2, #0
 8009edc:	601a      	str	r2, [r3, #0]
 8009ede:	f000 f93b 	bl	800a158 <vPortExitCritical>
              sendStatus(Uwy_MsgCode, SNDROUND(Uwy_val)),
              CLRADC(Uwy_val);
             );

      // -------  Iavg -----------
      SENDSTS(cfg.msgIavg[IDX],
 8009ee2:	782b      	ldrb	r3, [r5, #0]
 8009ee4:	686a      	ldr	r2, [r5, #4]
 8009ee6:	2b02      	cmp	r3, #2
 8009ee8:	bf0c      	ite	eq
 8009eea:	2384      	moveq	r3, #132	; 0x84
 8009eec:	2380      	movne	r3, #128	; 0x80
 8009eee:	4423      	add	r3, r4
 8009ef0:	685e      	ldr	r6, [r3, #4]
 8009ef2:	685b      	ldr	r3, [r3, #4]
 8009ef4:	4113      	asrs	r3, r2
 8009ef6:	07d9      	lsls	r1, r3, #31
 8009ef8:	bf5a      	itte	pl
 8009efa:	fab6 f686 	clzpl	r6, r6
 8009efe:	0976      	lsrpl	r6, r6, #5
 8009f00:	2603      	movmi	r6, #3
 8009f02:	07b2      	lsls	r2, r6, #30
 8009f04:	d515      	bpl.n	8009f32 <communicatorADCMeasure+0x59e>
 8009f06:	4b56      	ldr	r3, [pc, #344]	; (800a060 <communicatorADCMeasure+0x6cc>)
 8009f08:	681a      	ldr	r2, [r3, #0]
 8009f0a:	4b56      	ldr	r3, [pc, #344]	; (800a064 <communicatorADCMeasure+0x6d0>)
 8009f0c:	2a00      	cmp	r2, #0
 8009f0e:	6818      	ldr	r0, [r3, #0]
 8009f10:	bfb5      	itete	lt
 8009f12:	2100      	movlt	r1, #0
 8009f14:	f3c2 2107 	ubfxge	r1, r2, #8, #8
 8009f18:	460a      	movlt	r2, r1
 8009f1a:	b2d2      	uxtbge	r2, r2
 8009f1c:	2800      	cmp	r0, #0
 8009f1e:	bfb5      	itete	lt
 8009f20:	2300      	movlt	r3, #0
 8009f22:	f3c0 2307 	ubfxge	r3, r0, #8, #8
 8009f26:	4618      	movlt	r0, r3
 8009f28:	b2c0      	uxtbge	r0, r0
 8009f2a:	9000      	str	r0, [sp, #0]
 8009f2c:	2023      	movs	r0, #35	; 0x23
 8009f2e:	f7ff fa35 	bl	800939c <sendStatusLong>
 8009f32:	07f3      	lsls	r3, r6, #31
 8009f34:	d528      	bpl.n	8009f88 <communicatorADCMeasure+0x5f4>
 8009f36:	f000 f8fd 	bl	800a134 <vPortEnterCritical>
 8009f3a:	4b4b      	ldr	r3, [pc, #300]	; (800a068 <communicatorADCMeasure+0x6d4>)
 8009f3c:	f04f 0800 	mov.w	r8, #0
 8009f40:	f04f 0900 	mov.w	r9, #0
 8009f44:	e9c3 8900 	strd	r8, r9, [r3]
 8009f48:	4b48      	ldr	r3, [pc, #288]	; (800a06c <communicatorADCMeasure+0x6d8>)
 8009f4a:	2600      	movs	r6, #0
 8009f4c:	601e      	str	r6, [r3, #0]
 8009f4e:	f000 f903 	bl	800a158 <vPortExitCritical>
 8009f52:	f000 f8ef 	bl	800a134 <vPortEnterCritical>
 8009f56:	4b46      	ldr	r3, [pc, #280]	; (800a070 <communicatorADCMeasure+0x6dc>)
 8009f58:	e9c3 8900 	strd	r8, r9, [r3]
 8009f5c:	4b45      	ldr	r3, [pc, #276]	; (800a074 <communicatorADCMeasure+0x6e0>)
 8009f5e:	601e      	str	r6, [r3, #0]
 8009f60:	f000 f8fa 	bl	800a158 <vPortExitCritical>
 8009f64:	f000 f8e6 	bl	800a134 <vPortEnterCritical>
 8009f68:	4b43      	ldr	r3, [pc, #268]	; (800a078 <communicatorADCMeasure+0x6e4>)
 8009f6a:	e9c3 8900 	strd	r8, r9, [r3]
 8009f6e:	4b43      	ldr	r3, [pc, #268]	; (800a07c <communicatorADCMeasure+0x6e8>)
 8009f70:	601e      	str	r6, [r3, #0]
 8009f72:	f000 f8f1 	bl	800a158 <vPortExitCritical>
 8009f76:	f000 f8dd 	bl	800a134 <vPortEnterCritical>
 8009f7a:	4b41      	ldr	r3, [pc, #260]	; (800a080 <communicatorADCMeasure+0x6ec>)
 8009f7c:	e9c3 8900 	strd	r8, r9, [r3]
 8009f80:	4b40      	ldr	r3, [pc, #256]	; (800a084 <communicatorADCMeasure+0x6f0>)
 8009f82:	601e      	str	r6, [r3, #0]
 8009f84:	f000 f8e8 	bl	800a158 <vPortExitCritical>
        CLRADC(meaniL);
        CLRADC(meaniH);
      });

      // -------  Imax -----------
      SENDSTS(cfg.msgImax[IDX],
 8009f88:	782b      	ldrb	r3, [r5, #0]
 8009f8a:	686a      	ldr	r2, [r5, #4]
 8009f8c:	2b02      	cmp	r3, #2
 8009f8e:	bf0c      	ite	eq
 8009f90:	238c      	moveq	r3, #140	; 0x8c
 8009f92:	2388      	movne	r3, #136	; 0x88
 8009f94:	4423      	add	r3, r4
 8009f96:	685e      	ldr	r6, [r3, #4]
 8009f98:	685b      	ldr	r3, [r3, #4]
 8009f9a:	4113      	asrs	r3, r2
 8009f9c:	07df      	lsls	r7, r3, #31
 8009f9e:	bf5a      	itte	pl
 8009fa0:	fab6 f686 	clzpl	r6, r6
 8009fa4:	0976      	lsrpl	r6, r6, #5
 8009fa6:	2603      	movmi	r6, #3
 8009fa8:	07b0      	lsls	r0, r6, #30
 8009faa:	d515      	bpl.n	8009fd8 <communicatorADCMeasure+0x644>
 8009fac:	4b36      	ldr	r3, [pc, #216]	; (800a088 <communicatorADCMeasure+0x6f4>)
 8009fae:	681a      	ldr	r2, [r3, #0]
 8009fb0:	4b36      	ldr	r3, [pc, #216]	; (800a08c <communicatorADCMeasure+0x6f8>)
 8009fb2:	2a00      	cmp	r2, #0
 8009fb4:	6818      	ldr	r0, [r3, #0]
 8009fb6:	bfb5      	itete	lt
 8009fb8:	2100      	movlt	r1, #0
 8009fba:	f3c2 2107 	ubfxge	r1, r2, #8, #8
 8009fbe:	460a      	movlt	r2, r1
 8009fc0:	b2d2      	uxtbge	r2, r2
 8009fc2:	2800      	cmp	r0, #0
 8009fc4:	bfb5      	itete	lt
 8009fc6:	2300      	movlt	r3, #0
 8009fc8:	f3c0 2307 	ubfxge	r3, r0, #8, #8
 8009fcc:	4618      	movlt	r0, r3
 8009fce:	b2c0      	uxtbge	r0, r0
 8009fd0:	9000      	str	r0, [sp, #0]
 8009fd2:	2024      	movs	r0, #36	; 0x24
 8009fd4:	f7ff f9e2 	bl	800939c <sendStatusLong>
 8009fd8:	07f1      	lsls	r1, r6, #31
 8009fda:	bf48      	it	mi
 8009fdc:	4b2a      	ldrmi	r3, [pc, #168]	; (800a088 <communicatorADCMeasure+0x6f4>)
              sendStatusLong(Imax_MsgCode, SNDROUND(sMaxiL), SNDROUND(sMaxvL)); ,
              sMaxiL = 0;
             );

      // -------  Temperature AIR & FET -----------
      SENDSTS(cfg.msgTemp[IDX],
 8009fde:	6869      	ldr	r1, [r5, #4]
        CLRADC(meaniL);
        CLRADC(meaniH);
      });

      // -------  Imax -----------
      SENDSTS(cfg.msgImax[IDX],
 8009fe0:	bf44      	itt	mi
 8009fe2:	2200      	movmi	r2, #0
 8009fe4:	601a      	strmi	r2, [r3, #0]
              sendStatusLong(Imax_MsgCode, SNDROUND(sMaxiL), SNDROUND(sMaxvL)); ,
              sMaxiL = 0;
             );

      // -------  Temperature AIR & FET -----------
      SENDSTS(cfg.msgTemp[IDX],
 8009fe6:	782b      	ldrb	r3, [r5, #0]
 8009fe8:	2b02      	cmp	r3, #2
 8009fea:	bf0c      	ite	eq
 8009fec:	2394      	moveq	r3, #148	; 0x94
 8009fee:	2390      	movne	r3, #144	; 0x90
 8009ff0:	441c      	add	r4, r3
 8009ff2:	6863      	ldr	r3, [r4, #4]
 8009ff4:	6862      	ldr	r2, [r4, #4]
 8009ff6:	410a      	asrs	r2, r1
 8009ff8:	07d2      	lsls	r2, r2, #31
 8009ffa:	bf5a      	itte	pl
 8009ffc:	fab3 f383 	clzpl	r3, r3
 800a000:	095b      	lsrpl	r3, r3, #5
 800a002:	2303      	movmi	r3, #3
 800a004:	079b      	lsls	r3, r3, #30
 800a006:	d50f      	bpl.n	800a028 <communicatorADCMeasure+0x694>
 800a008:	4b21      	ldr	r3, [pc, #132]	; (800a090 <communicatorADCMeasure+0x6fc>)
 800a00a:	681a      	ldr	r2, [r3, #0]
 800a00c:	4b21      	ldr	r3, [pc, #132]	; (800a094 <communicatorADCMeasure+0x700>)
 800a00e:	6819      	ldr	r1, [r3, #0]
 800a010:	11d2      	asrs	r2, r2, #7
 800a012:	11c9      	asrs	r1, r1, #7
 800a014:	2030      	movs	r0, #48	; 0x30
 800a016:	f7ff f997 	bl	8009348 <sendStatus>
{
  //Function is called every ADC_WINDOW [ms]
  ADCtime += ADC_WINDOW;

  UIT_Monitor(ADCtime);
}
 800a01a:	e005      	b.n	800a028 <communicatorADCMeasure+0x694>
          sent = 1;
        }
      if(sent)
        {
          //Next send slot calculate
          nextPossibleSend = xTaskGetTickCount() + cfg.ka_period;
 800a01c:	f000 fb42 	bl	800a6a4 <xTaskGetTickCount>
 800a020:	6a23      	ldr	r3, [r4, #32]
 800a022:	4418      	add	r0, r3
 800a024:	6128      	str	r0, [r5, #16]
 800a026:	e6c4      	b.n	8009db2 <communicatorADCMeasure+0x41e>
{
  //Function is called every ADC_WINDOW [ms]
  ADCtime += ADC_WINDOW;

  UIT_Monitor(ADCtime);
}
 800a028:	b005      	add	sp, #20
 800a02a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a02e:	bf00      	nop
 800a030:	2001ae64 	.word	0x2001ae64
 800a034:	2001ad6c 	.word	0x2001ad6c
 800a038:	2001ad70 	.word	0x2001ad70
 800a03c:	2001ae10 	.word	0x2001ae10
 800a040:	2001ae28 	.word	0x2001ae28
 800a044:	2001ac40 	.word	0x2001ac40
 800a048:	2001ae68 	.word	0x2001ae68
 800a04c:	2001ae40 	.word	0x2001ae40
 800a050:	2001ae38 	.word	0x2001ae38
 800a054:	2001ae48 	.word	0x2001ae48
 800a058:	2001ae70 	.word	0x2001ae70
 800a05c:	2001ae60 	.word	0x2001ae60
 800a060:	2001ae58 	.word	0x2001ae58
 800a064:	2001ae4c 	.word	0x2001ae4c
 800a068:	2001ae20 	.word	0x2001ae20
 800a06c:	2001ae18 	.word	0x2001ae18
 800a070:	2001ae78 	.word	0x2001ae78
 800a074:	2001ae5c 	.word	0x2001ae5c
 800a078:	2001ae30 	.word	0x2001ae30
 800a07c:	2001ae3c 	.word	0x2001ae3c
 800a080:	2001ae88 	.word	0x2001ae88
 800a084:	2001ae90 	.word	0x2001ae90
 800a088:	2001ae1c 	.word	0x2001ae1c
 800a08c:	2001ae54 	.word	0x2001ae54
 800a090:	2001add0 	.word	0x2001add0
 800a094:	2001adcc 	.word	0x2001adcc

0800a098 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 800a098:	4803      	ldr	r0, [pc, #12]	; (800a0a8 <prvPortStartFirstTask+0x10>)
 800a09a:	6800      	ldr	r0, [r0, #0]
 800a09c:	6800      	ldr	r0, [r0, #0]
 800a09e:	f380 8808 	msr	MSP, r0
 800a0a2:	b662      	cpsie	i
 800a0a4:	df00      	svc	0
 800a0a6:	bf00      	nop
 800a0a8:	e000ed08 	.word	0xe000ed08

0800a0ac <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800a0ac:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 800a0b0:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
 800a0b4:	4b03      	ldr	r3, [pc, #12]	; (800a0c4 <pxPortInitialiseStack+0x18>)
 800a0b6:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 800a0ba:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 800a0be:	3840      	subs	r0, #64	; 0x40
 800a0c0:	4770      	bx	lr
 800a0c2:	bf00      	nop
 800a0c4:	0800a111 	.word	0x0800a111

0800a0c8 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 800a0c8:	4b06      	ldr	r3, [pc, #24]	; (800a0e4 <pxCurrentTCBConst2>)
 800a0ca:	6819      	ldr	r1, [r3, #0]
 800a0cc:	6808      	ldr	r0, [r1, #0]
 800a0ce:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800a0d2:	f380 8809 	msr	PSP, r0
 800a0d6:	f04f 0000 	mov.w	r0, #0
 800a0da:	f380 8811 	msr	BASEPRI, r0
 800a0de:	f04e 0e0d 	orr.w	lr, lr, #13
 800a0e2:	4770      	bx	lr

0800a0e4 <pxCurrentTCBConst2>:
 800a0e4:	2001acd4 	.word	0x2001acd4

0800a0e8 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800a0e8:	4b04      	ldr	r3, [pc, #16]	; (800a0fc <vPortYield+0x14>)
 800a0ea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a0ee:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800a0f0:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800a0f4:	f3bf 8f6f 	isb	sy
 800a0f8:	4770      	bx	lr
 800a0fa:	bf00      	nop
 800a0fc:	e000ed04 	.word	0xe000ed04

0800a100 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
 800a100:	f3ef 8011 	mrs	r0, BASEPRI
 800a104:	f04f 01bf 	mov.w	r1, #191	; 0xbf
 800a108:	f381 8811 	msr	BASEPRI, r1
 800a10c:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 800a10e:	2000      	movs	r0, #0

0800a110 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 800a110:	b507      	push	{r0, r1, r2, lr}
	its caller as there is nothing to return to.  If a task wants to exit it 
	should instead call vTaskDelete( NULL ).
	
	Artificially force an assert() to be triggered if configASSERT() is 
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800a112:	4b07      	ldr	r3, [pc, #28]	; (800a130 <prvTaskExitError+0x20>)
 800a114:	681b      	ldr	r3, [r3, #0]
 800a116:	3301      	adds	r3, #1
 800a118:	d102      	bne.n	800a120 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();	
 800a11a:	f7ff fff1 	bl	800a100 <ulPortSetInterruptMask>
 800a11e:	e005      	b.n	800a12c <prvTaskExitError+0x1c>
	its caller as there is nothing to return to.  If a task wants to exit it 
	should instead call vTaskDelete( NULL ).
	
	Artificially force an assert() to be triggered if configASSERT() is 
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800a120:	2301      	movs	r3, #1
 800a122:	9301      	str	r3, [sp, #4]
 800a124:	9b01      	ldr	r3, [sp, #4]
 800a126:	2b00      	cmp	r3, #0
 800a128:	d1fc      	bne.n	800a124 <prvTaskExitError+0x14>
 800a12a:	e7f6      	b.n	800a11a <prvTaskExitError+0xa>
 800a12c:	e7fe      	b.n	800a12c <prvTaskExitError+0x1c>
 800a12e:	bf00      	nop
 800a130:	2001a86c 	.word	0x2001a86c

0800a134 <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800a134:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 800a136:	f7ff ffe3 	bl	800a100 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 800a13a:	4a04      	ldr	r2, [pc, #16]	; (800a14c <vPortEnterCritical+0x18>)
 800a13c:	6813      	ldr	r3, [r2, #0]
 800a13e:	3301      	adds	r3, #1
 800a140:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800a142:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800a146:	f3bf 8f6f 	isb	sy
 800a14a:	bd08      	pop	{r3, pc}
 800a14c:	2001a86c 	.word	0x2001a86c

0800a150 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
 800a150:	f380 8811 	msr	BASEPRI, r0
 800a154:	4770      	bx	lr
	...

0800a158 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 800a158:	4b03      	ldr	r3, [pc, #12]	; (800a168 <vPortExitCritical+0x10>)
 800a15a:	6818      	ldr	r0, [r3, #0]
 800a15c:	3801      	subs	r0, #1
 800a15e:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 800a160:	b908      	cbnz	r0, 800a166 <vPortExitCritical+0xe>
	{
		portENABLE_INTERRUPTS();
 800a162:	f7ff bff5 	b.w	800a150 <vPortClearInterruptMask>
 800a166:	4770      	bx	lr
 800a168:	2001a86c 	.word	0x2001a86c

0800a16c <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800a16c:	f3ef 8009 	mrs	r0, PSP
 800a170:	4b0c      	ldr	r3, [pc, #48]	; (800a1a4 <pxCurrentTCBConst>)
 800a172:	681a      	ldr	r2, [r3, #0]
 800a174:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800a178:	6010      	str	r0, [r2, #0]
 800a17a:	e92d 4008 	stmdb	sp!, {r3, lr}
 800a17e:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800a182:	f380 8811 	msr	BASEPRI, r0
 800a186:	f000 fb9d 	bl	800a8c4 <vTaskSwitchContext>
 800a18a:	f04f 0000 	mov.w	r0, #0
 800a18e:	f380 8811 	msr	BASEPRI, r0
 800a192:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800a196:	6819      	ldr	r1, [r3, #0]
 800a198:	6808      	ldr	r0, [r1, #0]
 800a19a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800a19e:	f380 8809 	msr	PSP, r0
 800a1a2:	4770      	bx	lr

0800a1a4 <pxCurrentTCBConst>:
 800a1a4:	2001acd4 	.word	0x2001acd4

0800a1a8 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800a1a8:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 800a1aa:	f7ff ffa9 	bl	800a100 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800a1ae:	f000 fa85 	bl	800a6bc <xTaskIncrementTick>
 800a1b2:	b118      	cbz	r0, 800a1bc <xPortSysTickHandler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800a1b4:	4b04      	ldr	r3, [pc, #16]	; (800a1c8 <xPortSysTickHandler+0x20>)
 800a1b6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a1ba:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 800a1bc:	2000      	movs	r0, #0
}
 800a1be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 800a1c2:	f7ff bfc5 	b.w	800a150 <vPortClearInterruptMask>
 800a1c6:	bf00      	nop
 800a1c8:	e000ed04 	.word	0xe000ed04

0800a1cc <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 800a1cc:	4b06      	ldr	r3, [pc, #24]	; (800a1e8 <vPortSetupTimerInterrupt+0x1c>)
 800a1ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800a1d2:	681b      	ldr	r3, [r3, #0]
 800a1d4:	fbb3 f3f2 	udiv	r3, r3, r2
 800a1d8:	4a04      	ldr	r2, [pc, #16]	; (800a1ec <vPortSetupTimerInterrupt+0x20>)
 800a1da:	3b01      	subs	r3, #1
 800a1dc:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 800a1de:	4b04      	ldr	r3, [pc, #16]	; (800a1f0 <vPortSetupTimerInterrupt+0x24>)
 800a1e0:	2207      	movs	r2, #7
 800a1e2:	601a      	str	r2, [r3, #0]
 800a1e4:	4770      	bx	lr
 800a1e6:	bf00      	nop
 800a1e8:	2001abe4 	.word	0x2001abe4
 800a1ec:	e000e014 	.word	0xe000e014
 800a1f0:	e000e010 	.word	0xe000e010

0800a1f4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 800a1f4:	b513      	push	{r0, r1, r4, lr}
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pcFirstUserPriorityRegister;
 800a1f6:	4b1f      	ldr	r3, [pc, #124]	; (800a274 <xPortStartScheduler+0x80>)
 800a1f8:	781a      	ldrb	r2, [r3, #0]
 800a1fa:	b2d2      	uxtb	r2, r2
 800a1fc:	9201      	str	r2, [sp, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800a1fe:	22ff      	movs	r2, #255	; 0xff
 800a200:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
 800a202:	781b      	ldrb	r3, [r3, #0]
 800a204:	b2db      	uxtb	r3, r3
 800a206:	f88d 3003 	strb.w	r3, [sp, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800a20a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800a20e:	4b1a      	ldr	r3, [pc, #104]	; (800a278 <xPortStartScheduler+0x84>)
 800a210:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
 800a214:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800a216:	2207      	movs	r2, #7
 800a218:	605a      	str	r2, [r3, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800a21a:	2100      	movs	r1, #0
 800a21c:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800a220:	0600      	lsls	r0, r0, #24
 800a222:	f102 34ff 	add.w	r4, r2, #4294967295
 800a226:	d508      	bpl.n	800a23a <xPortStartScheduler+0x46>
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
 800a228:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800a22c:	0052      	lsls	r2, r2, #1
 800a22e:	b2d2      	uxtb	r2, r2
 800a230:	f88d 2003 	strb.w	r2, [sp, #3]
 800a234:	2101      	movs	r1, #1
 800a236:	4622      	mov	r2, r4
 800a238:	e7f0      	b.n	800a21c <xPortStartScheduler+0x28>
 800a23a:	b101      	cbz	r1, 800a23e <xPortStartScheduler+0x4a>
 800a23c:	605a      	str	r2, [r3, #4]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800a23e:	685a      	ldr	r2, [r3, #4]
 800a240:	0212      	lsls	r2, r2, #8
 800a242:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800a246:	605a      	str	r2, [r3, #4]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pcFirstUserPriorityRegister = ulOriginalPriority;
 800a248:	9b01      	ldr	r3, [sp, #4]
 800a24a:	4a0a      	ldr	r2, [pc, #40]	; (800a274 <xPortStartScheduler+0x80>)
 800a24c:	b2db      	uxtb	r3, r3
 800a24e:	7013      	strb	r3, [r2, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800a250:	4b0a      	ldr	r3, [pc, #40]	; (800a27c <xPortStartScheduler+0x88>)
 800a252:	681a      	ldr	r2, [r3, #0]
 800a254:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 800a258:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800a25a:	681a      	ldr	r2, [r3, #0]
 800a25c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 800a260:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800a262:	f7ff ffb3 	bl	800a1cc <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800a266:	4b06      	ldr	r3, [pc, #24]	; (800a280 <xPortStartScheduler+0x8c>)
 800a268:	2000      	movs	r0, #0
 800a26a:	6018      	str	r0, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 800a26c:	f7ff ff14 	bl	800a098 <prvPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 800a270:	b002      	add	sp, #8
 800a272:	bd10      	pop	{r4, pc}
 800a274:	e000e400 	.word	0xe000e400
 800a278:	2001ac58 	.word	0x2001ac58
 800a27c:	e000ed20 	.word	0xe000ed20
 800a280:	2001a86c 	.word	0x2001a86c

0800a284 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 800a284:	b082      	sub	sp, #8
	unsigned long ulCurrentInterrupt;
	unsigned char ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 800a286:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 800a28a:	2b0f      	cmp	r3, #15
 800a28c:	4a0d      	ldr	r2, [pc, #52]	; (800a2c4 <vPortValidateInterruptPriority+0x40>)
 800a28e:	d809      	bhi.n	800a2a4 <vPortValidateInterruptPriority+0x20>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800a290:	4b0d      	ldr	r3, [pc, #52]	; (800a2c8 <vPortValidateInterruptPriority+0x44>)
 800a292:	6852      	ldr	r2, [r2, #4]
 800a294:	681b      	ldr	r3, [r3, #0]
 800a296:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800a29a:	4293      	cmp	r3, r2
 800a29c:	d910      	bls.n	800a2c0 <vPortValidateInterruptPriority+0x3c>
 800a29e:	2301      	movs	r3, #1
 800a2a0:	9301      	str	r3, [sp, #4]
 800a2a2:	e00a      	b.n	800a2ba <vPortValidateInterruptPriority+0x36>

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800a2a4:	4909      	ldr	r1, [pc, #36]	; (800a2cc <vPortValidateInterruptPriority+0x48>)
 800a2a6:	5c5b      	ldrb	r3, [r3, r1]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800a2a8:	7811      	ldrb	r1, [r2, #0]
 800a2aa:	4299      	cmp	r1, r3
 800a2ac:	d9f0      	bls.n	800a290 <vPortValidateInterruptPriority+0xc>
 800a2ae:	2301      	movs	r3, #1
 800a2b0:	9300      	str	r3, [sp, #0]
 800a2b2:	9b00      	ldr	r3, [sp, #0]
 800a2b4:	2b00      	cmp	r3, #0
 800a2b6:	d1fc      	bne.n	800a2b2 <vPortValidateInterruptPriority+0x2e>
 800a2b8:	e7ea      	b.n	800a290 <vPortValidateInterruptPriority+0xc>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800a2ba:	9b01      	ldr	r3, [sp, #4]
 800a2bc:	2b00      	cmp	r3, #0
 800a2be:	d1fc      	bne.n	800a2ba <vPortValidateInterruptPriority+0x36>
	}
 800a2c0:	b002      	add	sp, #8
 800a2c2:	4770      	bx	lr
 800a2c4:	2001ac58 	.word	0x2001ac58
 800a2c8:	e000ed0c 	.word	0xe000ed0c
 800a2cc:	e000e3f0 	.word	0xe000e3f0

0800a2d0 <prvInsertBlockIntoFreeList>:
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800a2d0:	4b10      	ldr	r3, [pc, #64]	; (800a314 <prvInsertBlockIntoFreeList+0x44>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
 800a2d2:	b530      	push	{r4, r5, lr}
 800a2d4:	461c      	mov	r4, r3
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800a2d6:	681a      	ldr	r2, [r3, #0]
 800a2d8:	4282      	cmp	r2, r0
 800a2da:	d201      	bcs.n	800a2e0 <prvInsertBlockIntoFreeList+0x10>
 800a2dc:	4613      	mov	r3, r2
 800a2de:	e7fa      	b.n	800a2d6 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
 800a2e0:	6859      	ldr	r1, [r3, #4]
 800a2e2:	185d      	adds	r5, r3, r1
 800a2e4:	42a8      	cmp	r0, r5
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800a2e6:	bf01      	itttt	eq
 800a2e8:	6840      	ldreq	r0, [r0, #4]
 800a2ea:	1809      	addeq	r1, r1, r0
 800a2ec:	4618      	moveq	r0, r3
 800a2ee:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
 800a2f0:	6841      	ldr	r1, [r0, #4]
 800a2f2:	1845      	adds	r5, r0, r1
 800a2f4:	42aa      	cmp	r2, r5
 800a2f6:	d107      	bne.n	800a308 <prvInsertBlockIntoFreeList+0x38>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800a2f8:	68a4      	ldr	r4, [r4, #8]
 800a2fa:	42a2      	cmp	r2, r4
 800a2fc:	d004      	beq.n	800a308 <prvInsertBlockIntoFreeList+0x38>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800a2fe:	6852      	ldr	r2, [r2, #4]
 800a300:	4411      	add	r1, r2
 800a302:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800a304:	681a      	ldr	r2, [r3, #0]
 800a306:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
 800a308:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800a30a:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800a30c:	bf18      	it	ne
 800a30e:	6018      	strne	r0, [r3, #0]
 800a310:	bd30      	pop	{r4, r5, pc}
 800a312:	bf00      	nop
 800a314:	2001ac60 	.word	0x2001ac60

0800a318 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800a318:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a31c:	4604      	mov	r4, r0
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 800a31e:	f000 f9b7 	bl	800a690 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 800a322:	492f      	ldr	r1, [pc, #188]	; (800a3e0 <pvPortMalloc+0xc8>)
 800a324:	688b      	ldr	r3, [r1, #8]
 800a326:	b9bb      	cbnz	r3, 800a358 <pvPortMalloc+0x40>
{
xBlockLink *pxFirstFreeBlock;
unsigned char *pucHeapEnd, *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 800a328:	4a2e      	ldr	r2, [pc, #184]	; (800a3e4 <pvPortMalloc+0xcc>)
 800a32a:	f022 0207 	bic.w	r2, r2, #7
	xStart.xBlockSize = ( size_t ) 0;

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
 800a32e:	f502 35bf 	add.w	r5, r2, #97792	; 0x17e00
	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;
 800a332:	e881 000c 	stmia.w	r1, {r2, r3}
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
 800a336:	f8c5 31f4 	str.w	r3, [r5, #500]	; 0x1f4
	pxEnd->pxNextFreeBlock = NULL;
 800a33a:	f8c5 31f0 	str.w	r3, [r5, #496]	; 0x1f0

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
 800a33e:	4b2a      	ldr	r3, [pc, #168]	; (800a3e8 <pvPortMalloc+0xd0>)
	xStart.xBlockSize = ( size_t ) 0;

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
 800a340:	f505 70f8 	add.w	r0, r5, #496	; 0x1f0

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800a344:	e882 0009 	stmia.w	r2, {r0, r3}

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
 800a348:	4a28      	ldr	r2, [pc, #160]	; (800a3ec <pvPortMalloc+0xd4>)

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
 800a34a:	6088      	str	r0, [r1, #8]
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
 800a34c:	6813      	ldr	r3, [r2, #0]
 800a34e:	3b08      	subs	r3, #8
 800a350:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800a352:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800a356:	60cb      	str	r3, [r1, #12]

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the xBlockLink structure 
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800a358:	f8d1 800c 	ldr.w	r8, [r1, #12]
 800a35c:	ea18 0f04 	tst.w	r8, r4
 800a360:	d135      	bne.n	800a3ce <pvPortMalloc+0xb6>
		{
			/* The wanted size is increased so it can contain a xBlockLink
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 800a362:	2c00      	cmp	r4, #0
 800a364:	d034      	beq.n	800a3d0 <pvPortMalloc+0xb8>
			{
				xWantedSize += heapSTRUCT_SIZE;
 800a366:	f104 0308 	add.w	r3, r4, #8

				/* Ensure that blocks are always aligned to the required number 
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800a36a:	075a      	lsls	r2, r3, #29
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800a36c:	bf1c      	itt	ne
 800a36e:	f023 0307 	bicne.w	r3, r3, #7
 800a372:	3308      	addne	r3, #8
				}
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800a374:	b34b      	cbz	r3, 800a3ca <pvPortMalloc+0xb2>
 800a376:	4e1d      	ldr	r6, [pc, #116]	; (800a3ec <pvPortMalloc+0xd4>)
 800a378:	6837      	ldr	r7, [r6, #0]
 800a37a:	42bb      	cmp	r3, r7
 800a37c:	d827      	bhi.n	800a3ce <pvPortMalloc+0xb6>
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 800a37e:	680d      	ldr	r5, [r1, #0]

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 800a380:	4a17      	ldr	r2, [pc, #92]	; (800a3e0 <pvPortMalloc+0xc8>)
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800a382:	6868      	ldr	r0, [r5, #4]
 800a384:	4283      	cmp	r3, r0
 800a386:	d803      	bhi.n	800a390 <pvPortMalloc+0x78>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size 
				was	not found. */
				if( pxBlock != pxEnd )
 800a388:	6889      	ldr	r1, [r1, #8]
 800a38a:	428d      	cmp	r5, r1
 800a38c:	d106      	bne.n	800a39c <pvPortMalloc+0x84>
 800a38e:	e01e      	b.n	800a3ce <pvPortMalloc+0xb6>
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800a390:	6828      	ldr	r0, [r5, #0]
 800a392:	2800      	cmp	r0, #0
 800a394:	d0f8      	beq.n	800a388 <pvPortMalloc+0x70>
 800a396:	462a      	mov	r2, r5
 800a398:	4605      	mov	r5, r0
 800a39a:	e7f2      	b.n	800a382 <pvPortMalloc+0x6a>
					xBlockLink structure at its start. */
					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );

					/* This block is being returned for use so must be taken out 
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800a39c:	6829      	ldr	r1, [r5, #0]
				was	not found. */
				if( pxBlock != pxEnd )
				{
					/* Return the memory space pointed to - jumping over the 
					xBlockLink structure at its start. */
					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 800a39e:	6814      	ldr	r4, [r2, #0]

					/* This block is being returned for use so must be taken out 
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800a3a0:	6011      	str	r1, [r2, #0]

					/* If the block is larger than required it can be split into 
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800a3a2:	686a      	ldr	r2, [r5, #4]
 800a3a4:	1ad2      	subs	r2, r2, r3
 800a3a6:	2a10      	cmp	r2, #16
				was	not found. */
				if( pxBlock != pxEnd )
				{
					/* Return the memory space pointed to - jumping over the 
					xBlockLink structure at its start. */
					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 800a3a8:	f104 0408 	add.w	r4, r4, #8
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

					/* If the block is larger than required it can be split into 
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800a3ac:	d904      	bls.n	800a3b8 <pvPortMalloc+0xa0>
					{
						/* This block is to be split into two.  Create a new 
						block following the number of bytes requested. The void 
						cast is used to prevent byte alignment warnings from the 
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 800a3ae:	18e8      	adds	r0, r5, r3

						/* Calculate the sizes of two blocks split from the 
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800a3b0:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800a3b2:	606b      	str	r3, [r5, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 800a3b4:	f7ff ff8c 	bl	800a2d0 <prvInsertBlockIntoFreeList>
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800a3b8:	686b      	ldr	r3, [r5, #4]
 800a3ba:	1aff      	subs	r7, r7, r3

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800a3bc:	ea48 0303 	orr.w	r3, r8, r3
 800a3c0:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 800a3c2:	2300      	movs	r3, #0

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800a3c4:	6037      	str	r7, [r6, #0]

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
					pxBlock->pxNextFreeBlock = NULL;
 800a3c6:	602b      	str	r3, [r5, #0]
 800a3c8:	e002      	b.n	800a3d0 <pvPortMalloc+0xb8>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 800a3ca:	461c      	mov	r4, r3
 800a3cc:	e000      	b.n	800a3d0 <pvPortMalloc+0xb8>
 800a3ce:	2400      	movs	r4, #0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	xTaskResumeAll();
 800a3d0:	f000 f9f6 	bl	800a7c0 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 800a3d4:	b90c      	cbnz	r4, 800a3da <pvPortMalloc+0xc2>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 800a3d6:	f7fd ffd1 	bl	800837c <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
 800a3da:	4620      	mov	r0, r4
 800a3dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a3e0:	2001ac60 	.word	0x2001ac60
 800a3e4:	20000008 	.word	0x20000008
 800a3e8:	00017ff0 	.word	0x00017ff0
 800a3ec:	2001a870 	.word	0x2001a870

0800a3f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800a3f0:	b513      	push	{r0, r1, r4, lr}
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv != NULL )
 800a3f2:	4604      	mov	r4, r0
 800a3f4:	b348      	cbz	r0, 800a44a <vPortFree+0x5a>

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800a3f6:	4a16      	ldr	r2, [pc, #88]	; (800a450 <vPortFree+0x60>)
 800a3f8:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800a3fc:	68d2      	ldr	r2, [r2, #12]
 800a3fe:	ea13 0102 	ands.w	r1, r3, r2
 800a402:	d005      	beq.n	800a410 <vPortFree+0x20>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800a404:	f854 0c08 	ldr.w	r0, [r4, #-8]
 800a408:	b160      	cbz	r0, 800a424 <vPortFree+0x34>
 800a40a:	2301      	movs	r3, #1
 800a40c:	9301      	str	r3, [sp, #4]
 800a40e:	e005      	b.n	800a41c <vPortFree+0x2c>

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800a410:	2001      	movs	r0, #1
 800a412:	9000      	str	r0, [sp, #0]
 800a414:	9800      	ldr	r0, [sp, #0]
 800a416:	2800      	cmp	r0, #0
 800a418:	d1fc      	bne.n	800a414 <vPortFree+0x24>
 800a41a:	e7f3      	b.n	800a404 <vPortFree+0x14>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800a41c:	9b01      	ldr	r3, [sp, #4]
 800a41e:	2b00      	cmp	r3, #0
 800a420:	d1fc      	bne.n	800a41c <vPortFree+0x2c>
 800a422:	e012      	b.n	800a44a <vPortFree+0x5a>
		
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 800a424:	b189      	cbz	r1, 800a44a <vPortFree+0x5a>
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800a426:	ea23 0302 	bic.w	r3, r3, r2
 800a42a:	f844 3c04 	str.w	r3, [r4, #-4]

				vTaskSuspendAll();
 800a42e:	f000 f92f 	bl	800a690 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 800a432:	4a08      	ldr	r2, [pc, #32]	; (800a454 <vPortFree+0x64>)
 800a434:	f854 1c04 	ldr.w	r1, [r4, #-4]
 800a438:	6813      	ldr	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 800a43a:	f1a4 0008 	sub.w	r0, r4, #8
				pxLink->xBlockSize &= ~xBlockAllocatedBit;

				vTaskSuspendAll();
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 800a43e:	440b      	add	r3, r1
 800a440:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 800a442:	f7ff ff45 	bl	800a2d0 <prvInsertBlockIntoFreeList>
					traceFREE( pv, pxLink->xBlockSize );
				}
				xTaskResumeAll();
 800a446:	f000 f9bb 	bl	800a7c0 <xTaskResumeAll>
			}
		}
	}
}
 800a44a:	b002      	add	sp, #8
 800a44c:	bd10      	pop	{r4, pc}
 800a44e:	bf00      	nop
 800a450:	2001ac60 	.word	0x2001ac60
 800a454:	2001a870 	.word	0x2001a870

0800a458 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 800a458:	b508      	push	{r3, lr}

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 800a45a:	4c03      	ldr	r4, [pc, #12]	; (800a468 <prvIdleTask+0x10>)
 800a45c:	6823      	ldr	r3, [r4, #0]
 800a45e:	2b01      	cmp	r3, #1
 800a460:	d9fd      	bls.n	800a45e <prvIdleTask+0x6>
			{
				taskYIELD();
 800a462:	f7ff fe41 	bl	800a0e8 <vPortYield>
 800a466:	e7f9      	b.n	800a45c <prvIdleTask+0x4>
 800a468:	2001ac70 	.word	0x2001ac70

0800a46c <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 800a46c:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800a46e:	4b0c      	ldr	r3, [pc, #48]	; (800a4a0 <prvAddCurrentTaskToDelayedList+0x34>)
 800a470:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800a472:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 800a474:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800a476:	4290      	cmp	r0, r2
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 800a478:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 800a47a:	d206      	bcs.n	800a48a <prvAddCurrentTaskToDelayedList+0x1e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800a47c:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 800a47e:	6e59      	ldr	r1, [r3, #100]	; 0x64
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
 800a480:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800a484:	3104      	adds	r1, #4
 800a486:	f000 bb8d 	b.w	800aba4 <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800a48a:	6f18      	ldr	r0, [r3, #112]	; 0x70
 800a48c:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800a48e:	3104      	adds	r1, #4
 800a490:	f000 fb88 	bl	800aba4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 800a494:	4b03      	ldr	r3, [pc, #12]	; (800a4a4 <prvAddCurrentTaskToDelayedList+0x38>)
 800a496:	681a      	ldr	r2, [r3, #0]
 800a498:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 800a49a:	bf38      	it	cc
 800a49c:	601c      	strcc	r4, [r3, #0]
 800a49e:	bd10      	pop	{r4, pc}
 800a4a0:	2001ac70 	.word	0x2001ac70
 800a4a4:	2001a874 	.word	0x2001a874

0800a4a8 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 800a4a8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a4ac:	ae0c      	add	r6, sp, #48	; 0x30
 800a4ae:	460f      	mov	r7, r1
 800a4b0:	4615      	mov	r5, r2
 800a4b2:	469a      	mov	sl, r3
 800a4b4:	e896 0940 	ldmia.w	r6, {r6, r8, fp}
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
 800a4b8:	4681      	mov	r9, r0
 800a4ba:	b110      	cbz	r0, 800a4c2 <xTaskGenericCreate+0x1a>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 800a4bc:	2e04      	cmp	r6, #4
 800a4be:	d806      	bhi.n	800a4ce <xTaskGenericCreate+0x26>
 800a4c0:	e00a      	b.n	800a4d8 <xTaskGenericCreate+0x30>
signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
 800a4c2:	2301      	movs	r3, #1
 800a4c4:	9300      	str	r3, [sp, #0]
 800a4c6:	9b00      	ldr	r3, [sp, #0]
 800a4c8:	2b00      	cmp	r3, #0
 800a4ca:	d1fc      	bne.n	800a4c6 <xTaskGenericCreate+0x1e>
 800a4cc:	e7f6      	b.n	800a4bc <xTaskGenericCreate+0x14>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 800a4ce:	2301      	movs	r3, #1
 800a4d0:	9301      	str	r3, [sp, #4]
 800a4d2:	9b01      	ldr	r3, [sp, #4]
 800a4d4:	2b00      	cmp	r3, #0
 800a4d6:	d1fc      	bne.n	800a4d2 <xTaskGenericCreate+0x2a>
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 800a4d8:	2050      	movs	r0, #80	; 0x50
 800a4da:	f7ff ff1d 	bl	800a318 <pvPortMalloc>

	if( pxNewTCB != NULL )
 800a4de:	4604      	mov	r4, r0
 800a4e0:	2800      	cmp	r0, #0
 800a4e2:	f000 80a6 	beq.w	800a632 <xTaskGenericCreate+0x18a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a4e6:	f1bb 0f00 	cmp.w	fp, #0
 800a4ea:	d103      	bne.n	800a4f4 <xTaskGenericCreate+0x4c>
 800a4ec:	00a8      	lsls	r0, r5, #2
 800a4ee:	f7ff ff13 	bl	800a318 <pvPortMalloc>
 800a4f2:	e000      	b.n	800a4f6 <xTaskGenericCreate+0x4e>
 800a4f4:	4658      	mov	r0, fp
 800a4f6:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 800a4f8:	b918      	cbnz	r0, 800a502 <xTaskGenericCreate+0x5a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 800a4fa:	4620      	mov	r0, r4
 800a4fc:	f7ff ff78 	bl	800a3f0 <vPortFree>
 800a500:	e097      	b.n	800a632 <xTaskGenericCreate+0x18a>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 800a502:	00ad      	lsls	r5, r5, #2
 800a504:	462a      	mov	r2, r5
 800a506:	21a5      	movs	r1, #165	; 0xa5
 800a508:	f00a f83c 	bl	8014584 <memset>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800a50c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a50e:	3d04      	subs	r5, #4
 800a510:	441d      	add	r5, r3
 800a512:	f025 0507 	bic.w	r5, r5, #7
 800a516:	1e7b      	subs	r3, r7, #1
 800a518:	f104 0233 	add.w	r2, r4, #51	; 0x33
 800a51c:	370f      	adds	r7, #15
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 800a51e:	f913 1f01 	ldrsb.w	r1, [r3, #1]!
 800a522:	f802 1f01 	strb.w	r1, [r2, #1]!

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 800a526:	f993 1000 	ldrsb.w	r1, [r3]
 800a52a:	b109      	cbz	r1, 800a530 <xTaskGenericCreate+0x88>
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
 800a52c:	42bb      	cmp	r3, r7
 800a52e:	d1f6      	bne.n	800a51e <xTaskGenericCreate+0x76>
 800a530:	2e04      	cmp	r6, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 800a532:	f04f 0300 	mov.w	r3, #0
 800a536:	46b3      	mov	fp, r6
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800a538:	f104 0704 	add.w	r7, r4, #4
 800a53c:	bf28      	it	cs
 800a53e:	f04f 0b04 	movcs.w	fp, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 800a542:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800a546:	4638      	mov	r0, r7
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
 800a548:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 800a54c:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800a550:	f000 fb19 	bl	800ab86 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 800a554:	f104 0018 	add.w	r0, r4, #24
 800a558:	f000 fb15 	bl	800ab86 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a55c:	f1cb 0305 	rsb	r3, fp, #5
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 800a560:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a562:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800a564:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800a566:	4652      	mov	r2, sl
 800a568:	4649      	mov	r1, r9
 800a56a:	4628      	mov	r0, r5
 800a56c:	f7ff fd9e 	bl	800a0ac <pxPortInitialiseStack>
 800a570:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 800a572:	f1b8 0f00 	cmp.w	r8, #0
 800a576:	d001      	beq.n	800a57c <xTaskGenericCreate+0xd4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 800a578:	f8c8 4000 	str.w	r4, [r8]

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 800a57c:	4d2f      	ldr	r5, [pc, #188]	; (800a63c <xTaskGenericCreate+0x194>)
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 800a57e:	f7ff fdd9 	bl	800a134 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 800a582:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800a584:	3301      	adds	r3, #1
 800a586:	676b      	str	r3, [r5, #116]	; 0x74
			if( pxCurrentTCB == NULL )
 800a588:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800a58a:	bb33      	cbnz	r3, 800a5da <xTaskGenericCreate+0x132>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 800a58c:	666c      	str	r4, [r5, #100]	; 0x64

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800a58e:	6f6a      	ldr	r2, [r5, #116]	; 0x74
 800a590:	2a01      	cmp	r2, #1
 800a592:	d12a      	bne.n	800a5ea <xTaskGenericCreate+0x142>
 800a594:	4698      	mov	r8, r3
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800a596:	eb05 0008 	add.w	r0, r5, r8
 800a59a:	f108 0814 	add.w	r8, r8, #20
 800a59e:	f000 fae7 	bl	800ab70 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
 800a5a2:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800a5a6:	f8df 9094 	ldr.w	r9, [pc, #148]	; 800a63c <xTaskGenericCreate+0x194>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
 800a5aa:	d1f4      	bne.n	800a596 <xTaskGenericCreate+0xee>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 800a5ac:	f109 0a78 	add.w	sl, r9, #120	; 0x78
 800a5b0:	4650      	mov	r0, sl
	vListInitialise( &xDelayedTaskList2 );
 800a5b2:	f109 088c 	add.w	r8, r9, #140	; 0x8c
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 800a5b6:	f000 fadb 	bl	800ab70 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800a5ba:	4640      	mov	r0, r8
 800a5bc:	f000 fad8 	bl	800ab70 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800a5c0:	f109 00a0 	add.w	r0, r9, #160	; 0xa0
 800a5c4:	f000 fad4 	bl	800ab70 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800a5c8:	f109 00b4 	add.w	r0, r9, #180	; 0xb4
 800a5cc:	f000 fad0 	bl	800ab70 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800a5d0:	f8c9 a070 	str.w	sl, [r9, #112]	; 0x70
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800a5d4:	f8c9 806c 	str.w	r8, [r9, #108]	; 0x6c
 800a5d8:	e007      	b.n	800a5ea <xTaskGenericCreate+0x142>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800a5da:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 800a5de:	b923      	cbnz	r3, 800a5ea <xTaskGenericCreate+0x142>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 800a5e0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800a5e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a5e4:	429e      	cmp	r6, r3
					{
						pxCurrentTCB = pxNewTCB;
 800a5e6:	bf28      	it	cs
 800a5e8:	666c      	strcs	r4, [r5, #100]	; 0x64
					}
				}
			}

			uxTaskNumber++;
 800a5ea:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 800a5ee:	f8d5 20d0 	ldr.w	r2, [r5, #208]	; 0xd0
						pxCurrentTCB = pxNewTCB;
					}
				}
			}

			uxTaskNumber++;
 800a5f2:	3301      	adds	r3, #1
 800a5f4:	f8c5 30cc 	str.w	r3, [r5, #204]	; 0xcc

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 800a5f8:	6463      	str	r3, [r4, #68]	; 0x44
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 800a5fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a5fc:	4293      	cmp	r3, r2
 800a5fe:	bf88      	it	hi
 800a600:	4a0e      	ldrhi	r2, [pc, #56]	; (800a63c <xTaskGenericCreate+0x194>)
 800a602:	f04f 0014 	mov.w	r0, #20
 800a606:	fb00 5003 	mla	r0, r0, r3, r5
 800a60a:	4639      	mov	r1, r7
 800a60c:	bf88      	it	hi
 800a60e:	f8c2 30d0 	strhi.w	r3, [r2, #208]	; 0xd0
 800a612:	f000 fabb 	bl	800ab8c <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 800a616:	f7ff fd9f 	bl	800a158 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 800a61a:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 800a61e:	b133      	cbz	r3, 800a62e <xTaskGenericCreate+0x186>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800a620:	4b06      	ldr	r3, [pc, #24]	; (800a63c <xTaskGenericCreate+0x194>)
 800a622:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a624:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a626:	429e      	cmp	r6, r3
 800a628:	d901      	bls.n	800a62e <xTaskGenericCreate+0x186>
			{
				portYIELD_WITHIN_API();
 800a62a:	f7ff fd5d 	bl	800a0e8 <vPortYield>
 800a62e:	2001      	movs	r0, #1
 800a630:	e001      	b.n	800a636 <xTaskGenericCreate+0x18e>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800a632:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
 800a636:	b003      	add	sp, #12
 800a638:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a63c:	2001ac70 	.word	0x2001ac70

0800a640 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800a640:	b530      	push	{r4, r5, lr}
 800a642:	b087      	sub	sp, #28
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 800a644:	2400      	movs	r4, #0
 800a646:	9403      	str	r4, [sp, #12]
 800a648:	9402      	str	r4, [sp, #8]
 800a64a:	9401      	str	r4, [sp, #4]
 800a64c:	9400      	str	r4, [sp, #0]
 800a64e:	4623      	mov	r3, r4
 800a650:	2278      	movs	r2, #120	; 0x78
 800a652:	490c      	ldr	r1, [pc, #48]	; (800a684 <vTaskStartScheduler+0x44>)
 800a654:	480c      	ldr	r0, [pc, #48]	; (800a688 <vTaskStartScheduler+0x48>)
 800a656:	f7ff ff27 	bl	800a4a8 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 800a65a:	2801      	cmp	r0, #1
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 800a65c:	4605      	mov	r5, r0
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 800a65e:	d108      	bne.n	800a672 <vTaskStartScheduler+0x32>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 800a660:	f7ff fd4e 	bl	800a100 <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 800a664:	4b09      	ldr	r3, [pc, #36]	; (800a68c <vTaskStartScheduler+0x4c>)
 800a666:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
		xTickCount = ( portTickType ) 0U;
 800a66a:	669c      	str	r4, [r3, #104]	; 0x68
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800a66c:	f7ff fdc2 	bl	800a1f4 <xPortStartScheduler>
 800a670:	e005      	b.n	800a67e <vTaskStartScheduler+0x3e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 800a672:	b920      	cbnz	r0, 800a67e <vTaskStartScheduler+0x3e>
 800a674:	2301      	movs	r3, #1
 800a676:	9305      	str	r3, [sp, #20]
 800a678:	9b05      	ldr	r3, [sp, #20]
 800a67a:	2b00      	cmp	r3, #0
 800a67c:	d1fc      	bne.n	800a678 <vTaskStartScheduler+0x38>
	}
}
 800a67e:	b007      	add	sp, #28
 800a680:	bd30      	pop	{r4, r5, pc}
 800a682:	bf00      	nop
 800a684:	08014d79 	.word	0x08014d79
 800a688:	0800a459 	.word	0x0800a459
 800a68c:	2001ac70 	.word	0x2001ac70

0800a690 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 800a690:	4a03      	ldr	r2, [pc, #12]	; (800a6a0 <vTaskSuspendAll+0x10>)
 800a692:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
 800a696:	3301      	adds	r3, #1
 800a698:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
 800a69c:	4770      	bx	lr
 800a69e:	bf00      	nop
 800a6a0:	2001ac70 	.word	0x2001ac70

0800a6a4 <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
 800a6a4:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800a6a6:	f7ff fd45 	bl	800a134 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 800a6aa:	4b03      	ldr	r3, [pc, #12]	; (800a6b8 <xTaskGetTickCount+0x14>)
 800a6ac:	6e9c      	ldr	r4, [r3, #104]	; 0x68
	}
	taskEXIT_CRITICAL();
 800a6ae:	f7ff fd53 	bl	800a158 <vPortExitCritical>

	return xTicks;
}
 800a6b2:	4620      	mov	r0, r4
 800a6b4:	bd10      	pop	{r4, pc}
 800a6b6:	bf00      	nop
 800a6b8:	2001ac70 	.word	0x2001ac70

0800a6bc <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
 800a6bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800a6c0:	4c3d      	ldr	r4, [pc, #244]	; (800a7b8 <xTaskIncrementTick+0xfc>)
 800a6c2:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800a6c6:	2b00      	cmp	r3, #0
 800a6c8:	d147      	bne.n	800a75a <xTaskIncrementTick+0x9e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 800a6ca:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800a6cc:	3301      	adds	r3, #1
 800a6ce:	66a3      	str	r3, [r4, #104]	; 0x68

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
 800a6d0:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68

			if( xConstTickCount == ( portTickType ) 0U )
 800a6d4:	f1b8 0f00 	cmp.w	r8, #0
 800a6d8:	d11e      	bne.n	800a718 <xTaskIncrementTick+0x5c>
			{
				taskSWITCH_DELAYED_LISTS();
 800a6da:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800a6dc:	681b      	ldr	r3, [r3, #0]
 800a6de:	b97b      	cbnz	r3, 800a700 <xTaskIncrementTick+0x44>
 800a6e0:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800a6e2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800a6e4:	6722      	str	r2, [r4, #112]	; 0x70
 800a6e6:	66e3      	str	r3, [r4, #108]	; 0x6c
 800a6e8:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 800a6ec:	3301      	adds	r3, #1
 800a6ee:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
 800a6f2:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800a6f4:	681a      	ldr	r2, [r3, #0]
 800a6f6:	4b31      	ldr	r3, [pc, #196]	; (800a7bc <xTaskIncrementTick+0x100>)
 800a6f8:	b942      	cbnz	r2, 800a70c <xTaskIncrementTick+0x50>
 800a6fa:	f04f 32ff 	mov.w	r2, #4294967295
 800a6fe:	e00a      	b.n	800a716 <xTaskIncrementTick+0x5a>
 800a700:	2301      	movs	r3, #1
 800a702:	9301      	str	r3, [sp, #4]
 800a704:	9b01      	ldr	r3, [sp, #4]
 800a706:	2b00      	cmp	r3, #0
 800a708:	d1fc      	bne.n	800a704 <xTaskIncrementTick+0x48>
 800a70a:	e7e9      	b.n	800a6e0 <xTaskIncrementTick+0x24>
 800a70c:	4a2a      	ldr	r2, [pc, #168]	; (800a7b8 <xTaskIncrementTick+0xfc>)
 800a70e:	6f12      	ldr	r2, [r2, #112]	; 0x70
 800a710:	68d2      	ldr	r2, [r2, #12]
 800a712:	68d2      	ldr	r2, [r2, #12]
 800a714:	6852      	ldr	r2, [r2, #4]
 800a716:	601a      	str	r2, [r3, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 800a718:	4f28      	ldr	r7, [pc, #160]	; (800a7bc <xTaskIncrementTick+0x100>)
 800a71a:	683b      	ldr	r3, [r7, #0]
 800a71c:	4598      	cmp	r8, r3
 800a71e:	f04f 0500 	mov.w	r5, #0
 800a722:	d311      	bcc.n	800a748 <xTaskIncrementTick+0x8c>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800a724:	f8df 9090 	ldr.w	r9, [pc, #144]	; 800a7b8 <xTaskIncrementTick+0xfc>
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800a728:	f04f 0b14 	mov.w	fp, #20
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800a72c:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800a72e:	681b      	ldr	r3, [r3, #0]
 800a730:	b913      	cbnz	r3, 800a738 <xTaskIncrementTick+0x7c>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 800a732:	f04f 33ff 	mov.w	r3, #4294967295
 800a736:	e006      	b.n	800a746 <xTaskIncrementTick+0x8a>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800a738:	f8d9 3070 	ldr.w	r3, [r9, #112]	; 0x70
 800a73c:	68db      	ldr	r3, [r3, #12]
 800a73e:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800a740:	6873      	ldr	r3, [r6, #4]

						if( xConstTickCount < xItemValue )
 800a742:	4598      	cmp	r8, r3
 800a744:	d210      	bcs.n	800a768 <xTaskIncrementTick+0xac>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 800a746:	603b      	str	r3, [r7, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 800a748:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a74a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a74c:	2314      	movs	r3, #20
 800a74e:	4353      	muls	r3, r2
 800a750:	58e3      	ldr	r3, [r4, r3]
			{
				xSwitchRequired = pdTRUE;
 800a752:	2b02      	cmp	r3, #2
 800a754:	bf28      	it	cs
 800a756:	2501      	movcs	r5, #1
 800a758:	e024      	b.n	800a7a4 <xTaskIncrementTick+0xe8>
		}
		#endif /* configUSE_TICK_HOOK */		
	}
	else
	{
		++uxPendedTicks;
 800a75a:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800a75e:	3301      	adds	r3, #1
 800a760:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
 800a764:	2500      	movs	r5, #0
 800a766:	e01d      	b.n	800a7a4 <xTaskIncrementTick+0xe8>
							xNextTaskUnblockTime = xItemValue;
							break;
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800a768:	f106 0a04 	add.w	sl, r6, #4
 800a76c:	4650      	mov	r0, sl
 800a76e:	f000 fa31 	bl	800abd4 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800a772:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800a774:	b11b      	cbz	r3, 800a77e <xTaskIncrementTick+0xc2>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800a776:	f106 0018 	add.w	r0, r6, #24
 800a77a:	f000 fa2b 	bl	800abd4 <uxListRemove>
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800a77e:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 800a780:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 800a784:	4298      	cmp	r0, r3
 800a786:	bf88      	it	hi
 800a788:	f8c9 00d0 	strhi.w	r0, [r9, #208]	; 0xd0
 800a78c:	4651      	mov	r1, sl
 800a78e:	fb0b 4000 	mla	r0, fp, r0, r4
 800a792:	f000 f9fb 	bl	800ab8c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800a796:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a798:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800a79a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 800a79c:	429a      	cmp	r2, r3
 800a79e:	bf28      	it	cs
 800a7a0:	2501      	movcs	r5, #1
 800a7a2:	e7c3      	b.n	800a72c <xTaskIncrementTick+0x70>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 800a7a4:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
		{
			xSwitchRequired = pdTRUE;
 800a7a8:	2b00      	cmp	r3, #0
 800a7aa:	bf18      	it	ne
 800a7ac:	2501      	movne	r5, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 800a7ae:	4628      	mov	r0, r5
 800a7b0:	b003      	add	sp, #12
 800a7b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a7b6:	bf00      	nop
 800a7b8:	2001ac70 	.word	0x2001ac70
 800a7bc:	2001a874 	.word	0x2001a874

0800a7c0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 800a7c0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 800a7c4:	4c31      	ldr	r4, [pc, #196]	; (800a88c <xTaskResumeAll+0xcc>)
 800a7c6:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800a7ca:	b15b      	cbz	r3, 800a7e4 <xTaskResumeAll+0x24>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 800a7cc:	f7ff fcb2 	bl	800a134 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 800a7d0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800a7d4:	4d2d      	ldr	r5, [pc, #180]	; (800a88c <xTaskResumeAll+0xcc>)
 800a7d6:	3b01      	subs	r3, #1
 800a7d8:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800a7dc:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800a7e0:	b143      	cbz	r3, 800a7f4 <xTaskResumeAll+0x34>
 800a7e2:	e005      	b.n	800a7f0 <xTaskResumeAll+0x30>
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 800a7e4:	2301      	movs	r3, #1
 800a7e6:	9301      	str	r3, [sp, #4]
 800a7e8:	9b01      	ldr	r3, [sp, #4]
 800a7ea:	2b00      	cmp	r3, #0
 800a7ec:	d1fc      	bne.n	800a7e8 <xTaskResumeAll+0x28>
 800a7ee:	e7ed      	b.n	800a7cc <xTaskResumeAll+0xc>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
 800a7f0:	2400      	movs	r4, #0
 800a7f2:	e044      	b.n	800a87e <xTaskResumeAll+0xbe>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 800a7f4:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800a7f6:	2b00      	cmp	r3, #0
 800a7f8:	d0fa      	beq.n	800a7f0 <xTaskResumeAll+0x30>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 800a7fa:	f04f 0814 	mov.w	r8, #20
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800a7fe:	46a9      	mov	r9, r5
 800a800:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 800a804:	4b21      	ldr	r3, [pc, #132]	; (800a88c <xTaskResumeAll+0xcc>)
 800a806:	b1fa      	cbz	r2, 800a848 <xTaskResumeAll+0x88>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800a808:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
 800a80c:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800a80e:	1d37      	adds	r7, r6, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800a810:	f106 0018 	add.w	r0, r6, #24
 800a814:	f000 f9de 	bl	800abd4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800a818:	4638      	mov	r0, r7
 800a81a:	f000 f9db 	bl	800abd4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800a81e:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 800a820:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 800a824:	4298      	cmp	r0, r3
 800a826:	bf88      	it	hi
 800a828:	f8c5 00d0 	strhi.w	r0, [r5, #208]	; 0xd0
 800a82c:	4639      	mov	r1, r7
 800a82e:	fb08 4000 	mla	r0, r8, r0, r4
 800a832:	f000 f9ab 	bl	800ab8c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800a836:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a838:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800a83a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a83c:	429a      	cmp	r2, r3
 800a83e:	d3df      	bcc.n	800a800 <xTaskResumeAll+0x40>
					{
						xYieldPending = pdTRUE;
 800a840:	2301      	movs	r3, #1
 800a842:	f8c9 30e0 	str.w	r3, [r9, #224]	; 0xe0
 800a846:	e7db      	b.n	800a800 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 800a848:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 800a84c:	b932      	cbnz	r2, 800a85c <xTaskResumeAll+0x9c>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
 800a84e:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
 800a852:	2c01      	cmp	r4, #1
 800a854:	d1cc      	bne.n	800a7f0 <xTaskResumeAll+0x30>
				{
					xAlreadyYielded = pdTRUE;
					portYIELD_WITHIN_API();
 800a856:	f7ff fc47 	bl	800a0e8 <vPortYield>
 800a85a:	e010      	b.n	800a87e <xTaskResumeAll+0xbe>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 800a85c:	461d      	mov	r5, r3
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 800a85e:	2601      	movs	r6, #1
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 800a860:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800a864:	2b00      	cmp	r3, #0
 800a866:	d0f2      	beq.n	800a84e <xTaskResumeAll+0x8e>
					{
						if( xTaskIncrementTick() != pdFALSE )
 800a868:	f7ff ff28 	bl	800a6bc <xTaskIncrementTick>
 800a86c:	b108      	cbz	r0, 800a872 <xTaskResumeAll+0xb2>
						{
							xYieldPending = pdTRUE;
 800a86e:	f8c5 60e0 	str.w	r6, [r5, #224]	; 0xe0
						}
						--uxPendedTicks;
 800a872:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800a876:	3b01      	subs	r3, #1
 800a878:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
 800a87c:	e7f0      	b.n	800a860 <xTaskResumeAll+0xa0>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 800a87e:	f7ff fc6b 	bl	800a158 <vPortExitCritical>

	return xAlreadyYielded;
}
 800a882:	4620      	mov	r0, r4
 800a884:	b003      	add	sp, #12
 800a886:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a88a:	bf00      	nop
 800a88c:	2001ac70 	.word	0x2001ac70

0800a890 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 800a890:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 800a892:	b918      	cbnz	r0, 800a89c <vTaskDelay+0xc>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 800a894:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 800a898:	f7ff bc26 	b.w	800a0e8 <vPortYield>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
 800a89c:	f7ff fef8 	bl	800a690 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800a8a0:	4a07      	ldr	r2, [pc, #28]	; (800a8c0 <vTaskDelay+0x30>)
 800a8a2:	6e93      	ldr	r3, [r2, #104]	; 0x68
 800a8a4:	18c4      	adds	r4, r0, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800a8a6:	6e50      	ldr	r0, [r2, #100]	; 0x64
 800a8a8:	3004      	adds	r0, #4
 800a8aa:	f000 f993 	bl	800abd4 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 800a8ae:	4620      	mov	r0, r4
 800a8b0:	f7ff fddc 	bl	800a46c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 800a8b4:	f7ff ff84 	bl	800a7c0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 800a8b8:	2800      	cmp	r0, #0
 800a8ba:	d0eb      	beq.n	800a894 <vTaskDelay+0x4>
		{
			portYIELD_WITHIN_API();
		}
	}
 800a8bc:	bd10      	pop	{r4, pc}
 800a8be:	bf00      	nop
 800a8c0:	2001ac70 	.word	0x2001ac70

0800a8c4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800a8c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 800a8c6:	4b28      	ldr	r3, [pc, #160]	; (800a968 <vTaskSwitchContext+0xa4>)
 800a8c8:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 800a8cc:	461c      	mov	r4, r3
 800a8ce:	b11a      	cbz	r2, 800a8d8 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 800a8d0:	2201      	movs	r2, #1
 800a8d2:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800a8d6:	e045      	b.n	800a964 <vTaskSwitchContext+0xa0>
	}
	else
	{
		xYieldPending = pdFALSE;
 800a8d8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 800a8dc:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800a8de:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a8e0:	6812      	ldr	r2, [r2, #0]
 800a8e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a8e4:	429a      	cmp	r2, r3
 800a8e6:	d804      	bhi.n	800a8f2 <vTaskSwitchContext+0x2e>
 800a8e8:	6e60      	ldr	r0, [r4, #100]	; 0x64
 800a8ea:	6e61      	ldr	r1, [r4, #100]	; 0x64
 800a8ec:	3134      	adds	r1, #52	; 0x34
 800a8ee:	f7fd fd3c 	bl	800836a <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 800a8f2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a8f4:	491d      	ldr	r1, [pc, #116]	; (800a96c <vTaskSwitchContext+0xa8>)
 800a8f6:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800a8f8:	4d1b      	ldr	r5, [pc, #108]	; (800a968 <vTaskSwitchContext+0xa4>)
 800a8fa:	2214      	movs	r2, #20
 800a8fc:	f009 fd76 	bl	80143ec <memcmp>
 800a900:	b120      	cbz	r0, 800a90c <vTaskSwitchContext+0x48>
 800a902:	6e68      	ldr	r0, [r5, #100]	; 0x64
 800a904:	6e69      	ldr	r1, [r5, #100]	; 0x64
 800a906:	3134      	adds	r1, #52	; 0x34
 800a908:	f7fd fd2f 	bl	800836a <vApplicationStackOverflowHook>

		taskSELECT_HIGHEST_PRIORITY_TASK();
 800a90c:	4916      	ldr	r1, [pc, #88]	; (800a968 <vTaskSwitchContext+0xa4>)
 800a90e:	2214      	movs	r2, #20
 800a910:	2001      	movs	r0, #1
 800a912:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 800a916:	4d14      	ldr	r5, [pc, #80]	; (800a968 <vTaskSwitchContext+0xa4>)
 800a918:	4353      	muls	r3, r2
 800a91a:	58e3      	ldr	r3, [r4, r3]
 800a91c:	b96b      	cbnz	r3, 800a93a <vTaskSwitchContext+0x76>
 800a91e:	f8d1 30d0 	ldr.w	r3, [r1, #208]	; 0xd0
 800a922:	b12b      	cbz	r3, 800a930 <vTaskSwitchContext+0x6c>
 800a924:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 800a928:	3b01      	subs	r3, #1
 800a92a:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
 800a92e:	e7f0      	b.n	800a912 <vTaskSwitchContext+0x4e>
 800a930:	9001      	str	r0, [sp, #4]
 800a932:	9b01      	ldr	r3, [sp, #4]
 800a934:	2b00      	cmp	r3, #0
 800a936:	d1fc      	bne.n	800a932 <vTaskSwitchContext+0x6e>
 800a938:	e7f4      	b.n	800a924 <vTaskSwitchContext+0x60>
 800a93a:	f8d5 10d0 	ldr.w	r1, [r5, #208]	; 0xd0
 800a93e:	2214      	movs	r2, #20
 800a940:	fb02 f301 	mul.w	r3, r2, r1
 800a944:	18ea      	adds	r2, r5, r3
 800a946:	3308      	adds	r3, #8
 800a948:	6850      	ldr	r0, [r2, #4]
 800a94a:	6840      	ldr	r0, [r0, #4]
 800a94c:	6050      	str	r0, [r2, #4]
 800a94e:	442b      	add	r3, r5
 800a950:	4298      	cmp	r0, r3
 800a952:	bf04      	itt	eq
 800a954:	6843      	ldreq	r3, [r0, #4]
 800a956:	6053      	streq	r3, [r2, #4]
 800a958:	2314      	movs	r3, #20
 800a95a:	fb03 4101 	mla	r1, r3, r1, r4
 800a95e:	684b      	ldr	r3, [r1, #4]
 800a960:	68db      	ldr	r3, [r3, #12]
 800a962:	6663      	str	r3, [r4, #100]	; 0x64
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 800a964:	b003      	add	sp, #12
 800a966:	bd30      	pop	{r4, r5, pc}
 800a968:	2001ac70 	.word	0x2001ac70
 800a96c:	08014d65 	.word	0x08014d65

0800a970 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
 800a970:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800a972:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
 800a974:	b188      	cbz	r0, 800a99a <vTaskPlaceOnEventList+0x2a>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800a976:	4c0f      	ldr	r4, [pc, #60]	; (800a9b4 <vTaskPlaceOnEventList+0x44>)
 800a978:	6e61      	ldr	r1, [r4, #100]	; 0x64
 800a97a:	3118      	adds	r1, #24
 800a97c:	f000 f912 	bl	800aba4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800a980:	6e60      	ldr	r0, [r4, #100]	; 0x64
 800a982:	3004      	adds	r0, #4
 800a984:	f000 f926 	bl	800abd4 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 800a988:	1c6b      	adds	r3, r5, #1
 800a98a:	d10c      	bne.n	800a9a6 <vTaskPlaceOnEventList+0x36>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800a98c:	6e61      	ldr	r1, [r4, #100]	; 0x64
 800a98e:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
 800a992:	3104      	adds	r1, #4
 800a994:	f000 f8fa 	bl	800ab8c <vListInsertEnd>
 800a998:	e009      	b.n	800a9ae <vTaskPlaceOnEventList+0x3e>

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
portTickType xTimeToWake;

	configASSERT( pxEventList );
 800a99a:	2301      	movs	r3, #1
 800a99c:	9301      	str	r3, [sp, #4]
 800a99e:	9b01      	ldr	r3, [sp, #4]
 800a9a0:	2b00      	cmp	r3, #0
 800a9a2:	d1fc      	bne.n	800a99e <vTaskPlaceOnEventList+0x2e>
 800a9a4:	e7e7      	b.n	800a976 <vTaskPlaceOnEventList+0x6>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 800a9a6:	6ea0      	ldr	r0, [r4, #104]	; 0x68
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 800a9a8:	4428      	add	r0, r5
 800a9aa:	f7ff fd5f 	bl	800a46c <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800a9ae:	b003      	add	sp, #12
 800a9b0:	bd30      	pop	{r4, r5, pc}
 800a9b2:	bf00      	nop
 800a9b4:	2001ac70 	.word	0x2001ac70

0800a9b8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 800a9b8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800a9ba:	68c3      	ldr	r3, [r0, #12]
 800a9bc:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800a9be:	b1c5      	cbz	r5, 800a9f2 <xTaskRemoveFromEventList+0x3a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800a9c0:	f105 0618 	add.w	r6, r5, #24

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800a9c4:	4c16      	ldr	r4, [pc, #88]	; (800aa20 <xTaskRemoveFromEventList+0x68>)

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800a9c6:	4630      	mov	r0, r6
 800a9c8:	f000 f904 	bl	800abd4 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800a9cc:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800a9d0:	b9ab      	cbnz	r3, 800a9fe <xTaskRemoveFromEventList+0x46>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 800a9d2:	1d2e      	adds	r6, r5, #4
 800a9d4:	4630      	mov	r0, r6
 800a9d6:	f000 f8fd 	bl	800abd4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800a9da:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a9dc:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
 800a9e0:	2014      	movs	r0, #20
 800a9e2:	4293      	cmp	r3, r2
 800a9e4:	bf88      	it	hi
 800a9e6:	f8c4 30d0 	strhi.w	r3, [r4, #208]	; 0xd0
 800a9ea:	4631      	mov	r1, r6
 800a9ec:	fb00 4003 	mla	r0, r0, r3, r4
 800a9f0:	e008      	b.n	800aa04 <xTaskRemoveFromEventList+0x4c>
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
 800a9f2:	2301      	movs	r3, #1
 800a9f4:	9301      	str	r3, [sp, #4]
 800a9f6:	9b01      	ldr	r3, [sp, #4]
 800a9f8:	2b00      	cmp	r3, #0
 800a9fa:	d1fc      	bne.n	800a9f6 <xTaskRemoveFromEventList+0x3e>
 800a9fc:	e7e0      	b.n	800a9c0 <xTaskRemoveFromEventList+0x8>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800a9fe:	4631      	mov	r1, r6
 800aa00:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 800aa04:	f000 f8c2 	bl	800ab8c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800aa08:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800aa0a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800aa0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa0e:	429a      	cmp	r2, r3
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 800aa10:	bf25      	ittet	cs
 800aa12:	4b03      	ldrcs	r3, [pc, #12]	; (800aa20 <xTaskRemoveFromEventList+0x68>)
 800aa14:	2001      	movcs	r0, #1
	}
	else
	{
		xReturn = pdFALSE;
 800aa16:	2000      	movcc	r0, #0
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 800aa18:	f8c3 00e0 	strcs.w	r0, [r3, #224]	; 0xe0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 800aa1c:	b002      	add	sp, #8
 800aa1e:	bd70      	pop	{r4, r5, r6, pc}
 800aa20:	2001ac70 	.word	0x2001ac70

0800aa24 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 800aa24:	b082      	sub	sp, #8
	configASSERT( pxTimeOut );
 800aa26:	b138      	cbz	r0, 800aa38 <vTaskSetTimeOutState+0x14>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800aa28:	4b06      	ldr	r3, [pc, #24]	; (800aa44 <vTaskSetTimeOutState+0x20>)
 800aa2a:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
	pxTimeOut->xTimeOnEntering = xTickCount;
 800aa2e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800aa30:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800aa32:	6043      	str	r3, [r0, #4]
}
 800aa34:	b002      	add	sp, #8
 800aa36:	4770      	bx	lr
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
 800aa38:	2301      	movs	r3, #1
 800aa3a:	9301      	str	r3, [sp, #4]
 800aa3c:	9b01      	ldr	r3, [sp, #4]
 800aa3e:	2b00      	cmp	r3, #0
 800aa40:	d1fc      	bne.n	800aa3c <vTaskSetTimeOutState+0x18>
 800aa42:	e7f1      	b.n	800aa28 <vTaskSetTimeOutState+0x4>
 800aa44:	2001ac70 	.word	0x2001ac70

0800aa48 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 800aa48:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800aa4a:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
 800aa4c:	4604      	mov	r4, r0
 800aa4e:	b108      	cbz	r0, 800aa54 <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 800aa50:	b95d      	cbnz	r5, 800aa6a <xTaskCheckForTimeOut+0x22>
 800aa52:	e005      	b.n	800aa60 <xTaskCheckForTimeOut+0x18>

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
 800aa54:	2301      	movs	r3, #1
 800aa56:	9300      	str	r3, [sp, #0]
 800aa58:	9b00      	ldr	r3, [sp, #0]
 800aa5a:	2b00      	cmp	r3, #0
 800aa5c:	d1fc      	bne.n	800aa58 <xTaskCheckForTimeOut+0x10>
 800aa5e:	e7f7      	b.n	800aa50 <xTaskCheckForTimeOut+0x8>
	configASSERT( pxTicksToWait );
 800aa60:	2301      	movs	r3, #1
 800aa62:	9301      	str	r3, [sp, #4]
 800aa64:	9b01      	ldr	r3, [sp, #4]
 800aa66:	2b00      	cmp	r3, #0
 800aa68:	d1fc      	bne.n	800aa64 <xTaskCheckForTimeOut+0x1c>

	taskENTER_CRITICAL();
 800aa6a:	f7ff fb63 	bl	800a134 <vPortEnterCritical>

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800aa6e:	682b      	ldr	r3, [r5, #0]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
 800aa70:	4a0e      	ldr	r2, [pc, #56]	; (800aaac <xTaskCheckForTimeOut+0x64>)

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800aa72:	1c58      	adds	r0, r3, #1
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
 800aa74:	6e91      	ldr	r1, [r2, #104]	; 0x68

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800aa76:	d010      	beq.n	800aa9a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800aa78:	f8d2 20d8 	ldr.w	r2, [r2, #216]	; 0xd8
 800aa7c:	6820      	ldr	r0, [r4, #0]
 800aa7e:	4290      	cmp	r0, r2
 800aa80:	6862      	ldr	r2, [r4, #4]
 800aa82:	d001      	beq.n	800aa88 <xTaskCheckForTimeOut+0x40>
 800aa84:	4291      	cmp	r1, r2
 800aa86:	d20a      	bcs.n	800aa9e <xTaskCheckForTimeOut+0x56>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 800aa88:	1a88      	subs	r0, r1, r2
 800aa8a:	4283      	cmp	r3, r0
 800aa8c:	d907      	bls.n	800aa9e <xTaskCheckForTimeOut+0x56>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 800aa8e:	1a52      	subs	r2, r2, r1
 800aa90:	4413      	add	r3, r2
 800aa92:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800aa94:	4620      	mov	r0, r4
 800aa96:	f7ff ffc5 	bl	800aa24 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 800aa9a:	2400      	movs	r4, #0
 800aa9c:	e000      	b.n	800aaa0 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 800aa9e:	2401      	movs	r4, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 800aaa0:	f7ff fb5a 	bl	800a158 <vPortExitCritical>

	return xReturn;
}
 800aaa4:	4620      	mov	r0, r4
 800aaa6:	b003      	add	sp, #12
 800aaa8:	bd30      	pop	{r4, r5, pc}
 800aaaa:	bf00      	nop
 800aaac:	2001ac70 	.word	0x2001ac70

0800aab0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 800aab0:	4b02      	ldr	r3, [pc, #8]	; (800aabc <vTaskMissedYield+0xc>)
 800aab2:	2201      	movs	r2, #1
 800aab4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800aab8:	4770      	bx	lr
 800aaba:	bf00      	nop
 800aabc:	2001ac70 	.word	0x2001ac70

0800aac0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 800aac0:	4b01      	ldr	r3, [pc, #4]	; (800aac8 <xTaskGetCurrentTaskHandle+0x8>)
 800aac2:	6e58      	ldr	r0, [r3, #100]	; 0x64

		return xReturn;
	}
 800aac4:	4770      	bx	lr
 800aac6:	bf00      	nop
 800aac8:	2001ac70 	.word	0x2001ac70

0800aacc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
	{
 800aacc:	b570      	push	{r4, r5, r6, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 800aace:	4604      	mov	r4, r0
 800aad0:	b348      	cbz	r0, 800ab26 <vTaskPriorityInherit+0x5a>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800aad2:	4b15      	ldr	r3, [pc, #84]	; (800ab28 <vTaskPriorityInherit+0x5c>)
 800aad4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800aad6:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800aad8:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800aada:	428a      	cmp	r2, r1
 800aadc:	461d      	mov	r5, r3
 800aade:	d222      	bcs.n	800ab26 <vTaskPriorityInherit+0x5a>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800aae0:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800aae2:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800aae4:	f1c1 0105 	rsb	r1, r1, #5
 800aae8:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 800aaea:	2114      	movs	r1, #20
 800aaec:	fb01 3202 	mla	r2, r1, r2, r3
 800aaf0:	6941      	ldr	r1, [r0, #20]
 800aaf2:	4291      	cmp	r1, r2
 800aaf4:	d114      	bne.n	800ab20 <vTaskPriorityInherit+0x54>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800aaf6:	1d06      	adds	r6, r0, #4
 800aaf8:	4630      	mov	r0, r6
 800aafa:	f000 f86b 	bl	800abd4 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800aafe:	6e6b      	ldr	r3, [r5, #100]	; 0x64
					prvAddTaskToReadyList( pxTCB );
 800ab00:	f8d5 20d0 	ldr.w	r2, [r5, #208]	; 0xd0
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ab04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ab06:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 800ab08:	4293      	cmp	r3, r2
 800ab0a:	d901      	bls.n	800ab10 <vTaskPriorityInherit+0x44>
 800ab0c:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
 800ab10:	2014      	movs	r0, #20
 800ab12:	4631      	mov	r1, r6
 800ab14:	fb00 5003 	mla	r0, r0, r3, r5
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
 800ab18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
 800ab1c:	f000 b836 	b.w	800ab8c <vListInsertEnd>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ab20:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800ab22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ab24:	62c3      	str	r3, [r0, #44]	; 0x2c
 800ab26:	bd70      	pop	{r4, r5, r6, pc}
 800ab28:	2001ac70 	.word	0x2001ac70

0800ab2c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
	{
 800ab2c:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
 800ab2e:	4604      	mov	r4, r0
 800ab30:	b1d8      	cbz	r0, 800ab6a <vTaskPriorityDisinherit+0x3e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800ab32:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800ab34:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800ab36:	429a      	cmp	r2, r3
 800ab38:	d017      	beq.n	800ab6a <vTaskPriorityDisinherit+0x3e>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800ab3a:	1d05      	adds	r5, r0, #4
 800ab3c:	4628      	mov	r0, r5
 800ab3e:	f000 f849 	bl	800abd4 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 800ab42:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800ab44:	62e2      	str	r2, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ab46:	f1c2 0305 	rsb	r3, r2, #5
 800ab4a:	61a3      	str	r3, [r4, #24]
				prvAddTaskToReadyList( pxTCB );
 800ab4c:	4b07      	ldr	r3, [pc, #28]	; (800ab6c <vTaskPriorityDisinherit+0x40>)
 800ab4e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
 800ab52:	428a      	cmp	r2, r1
 800ab54:	bf88      	it	hi
 800ab56:	f8c3 20d0 	strhi.w	r2, [r3, #208]	; 0xd0
 800ab5a:	2014      	movs	r0, #20
 800ab5c:	4629      	mov	r1, r5
 800ab5e:	fb00 3002 	mla	r0, r0, r2, r3
			}
		}
	}
 800ab62:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				prvAddTaskToReadyList( pxTCB );
 800ab66:	f000 b811 	b.w	800ab8c <vListInsertEnd>
 800ab6a:	bd38      	pop	{r3, r4, r5, pc}
 800ab6c:	2001ac70 	.word	0x2001ac70

0800ab70 <vListInitialise>:
void vListInitialise( xList * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ab70:	f100 0308 	add.w	r3, r0, #8
 800ab74:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800ab76:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ab7a:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ab7c:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 800ab7e:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800ab80:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 800ab82:	6003      	str	r3, [r0, #0]
 800ab84:	4770      	bx	lr

0800ab86 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800ab86:	2300      	movs	r3, #0
 800ab88:	6103      	str	r3, [r0, #16]
 800ab8a:	4770      	bx	lr

0800ab8c <vListInsertEnd>:
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
 800ab8c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex;
 800ab8e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800ab90:	689a      	ldr	r2, [r3, #8]
 800ab92:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800ab94:	689a      	ldr	r2, [r3, #8]
 800ab96:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800ab98:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800ab9a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800ab9c:	6803      	ldr	r3, [r0, #0]
 800ab9e:	3301      	adds	r3, #1
 800aba0:	6003      	str	r3, [r0, #0]
 800aba2:	4770      	bx	lr

0800aba4 <vListInsert>:
{
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 800aba4:	680a      	ldr	r2, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800aba6:	1c53      	adds	r3, r2, #1
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
 800aba8:	b530      	push	{r4, r5, lr}
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800abaa:	d101      	bne.n	800abb0 <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800abac:	6903      	ldr	r3, [r0, #16]
 800abae:	e007      	b.n	800abc0 <vListInsert+0x1c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800abb0:	f100 0308 	add.w	r3, r0, #8
 800abb4:	685c      	ldr	r4, [r3, #4]
 800abb6:	6825      	ldr	r5, [r4, #0]
 800abb8:	42aa      	cmp	r2, r5
 800abba:	d301      	bcc.n	800abc0 <vListInsert+0x1c>
 800abbc:	4623      	mov	r3, r4
 800abbe:	e7f9      	b.n	800abb4 <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800abc0:	685a      	ldr	r2, [r3, #4]
 800abc2:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800abc4:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800abc6:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800abc8:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800abca:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800abcc:	6803      	ldr	r3, [r0, #0]
 800abce:	3301      	adds	r3, #1
 800abd0:	6003      	str	r3, [r0, #0]
 800abd2:	bd30      	pop	{r4, r5, pc}

0800abd4 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800abd4:	6843      	ldr	r3, [r0, #4]
 800abd6:	6882      	ldr	r2, [r0, #8]
 800abd8:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800abda:	6883      	ldr	r3, [r0, #8]
 800abdc:	6842      	ldr	r2, [r0, #4]
 800abde:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 800abe0:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800abe2:	685a      	ldr	r2, [r3, #4]
 800abe4:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800abe6:	bf04      	itt	eq
 800abe8:	6882      	ldreq	r2, [r0, #8]
 800abea:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 800abec:	2200      	movs	r2, #0
 800abee:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800abf0:	6818      	ldr	r0, [r3, #0]
 800abf2:	3801      	subs	r0, #1
 800abf4:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800abf6:	4770      	bx	lr

0800abf8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 800abf8:	b538      	push	{r3, r4, r5, lr}
 800abfa:	4615      	mov	r5, r2
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 800abfc:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 800abfe:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 800ac00:	b932      	cbnz	r2, 800ac10 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800ac02:	6805      	ldr	r5, [r0, #0]
 800ac04:	bb3d      	cbnz	r5, 800ac56 <prvCopyDataToQueue+0x5e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 800ac06:	6840      	ldr	r0, [r0, #4]
 800ac08:	f7ff ff90 	bl	800ab2c <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 800ac0c:	6065      	str	r5, [r4, #4]
 800ac0e:	e022      	b.n	800ac56 <prvCopyDataToQueue+0x5e>
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800ac10:	b965      	cbnz	r5, 800ac2c <prvCopyDataToQueue+0x34>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800ac12:	6880      	ldr	r0, [r0, #8]
 800ac14:	f009 fc1c 	bl	8014450 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800ac18:	68a2      	ldr	r2, [r4, #8]
 800ac1a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800ac1c:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800ac1e:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800ac20:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800ac22:	4293      	cmp	r3, r2
 800ac24:	d317      	bcc.n	800ac56 <prvCopyDataToQueue+0x5e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800ac26:	6823      	ldr	r3, [r4, #0]
 800ac28:	60a3      	str	r3, [r4, #8]
 800ac2a:	e014      	b.n	800ac56 <prvCopyDataToQueue+0x5e>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ac2c:	68c0      	ldr	r0, [r0, #12]
 800ac2e:	f009 fc0f 	bl	8014450 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800ac32:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800ac34:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800ac36:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800ac38:	425b      	negs	r3, r3
 800ac3a:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800ac3c:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800ac3e:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800ac40:	bf3e      	ittt	cc
 800ac42:	6862      	ldrcc	r2, [r4, #4]
 800ac44:	189b      	addcc	r3, r3, r2
 800ac46:	60e3      	strcc	r3, [r4, #12]
		}

		if( xPosition == queueOVERWRITE )
 800ac48:	2d02      	cmp	r5, #2
 800ac4a:	d104      	bne.n	800ac56 <prvCopyDataToQueue+0x5e>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800ac4c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ac4e:	b113      	cbz	r3, 800ac56 <prvCopyDataToQueue+0x5e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 800ac50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ac52:	3b01      	subs	r3, #1
 800ac54:	63a3      	str	r3, [r4, #56]	; 0x38
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800ac56:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ac58:	3301      	adds	r3, #1
 800ac5a:	63a3      	str	r3, [r4, #56]	; 0x38
 800ac5c:	bd38      	pop	{r3, r4, r5, pc}

0800ac5e <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
 800ac5e:	4603      	mov	r3, r0
 800ac60:	b430      	push	{r4, r5}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 800ac62:	681c      	ldr	r4, [r3, #0]
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
 800ac64:	4608      	mov	r0, r1
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 800ac66:	b15c      	cbz	r4, 800ac80 <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800ac68:	68d9      	ldr	r1, [r3, #12]
 800ac6a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800ac6c:	685d      	ldr	r5, [r3, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800ac6e:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800ac70:	42a9      	cmp	r1, r5

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800ac72:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800ac74:	bf28      	it	cs
 800ac76:	60dc      	strcs	r4, [r3, #12]
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800ac78:	68d9      	ldr	r1, [r3, #12]
	}
}
 800ac7a:	bc30      	pop	{r4, r5}
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800ac7c:	f009 bbe8 	b.w	8014450 <memcpy>
	}
}
 800ac80:	bc30      	pop	{r4, r5}
 800ac82:	4770      	bx	lr

0800ac84 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
 800ac84:	b538      	push	{r3, r4, r5, lr}
 800ac86:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800ac88:	f7ff fa54 	bl	800a134 <vPortEnterCritical>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ac8c:	f104 0524 	add.w	r5, r4, #36	; 0x24
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800ac90:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ac92:	2b00      	cmp	r3, #0
 800ac94:	dd0b      	ble.n	800acae <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ac96:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ac98:	b14b      	cbz	r3, 800acae <prvUnlockQueue+0x2a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ac9a:	4628      	mov	r0, r5
 800ac9c:	f7ff fe8c 	bl	800a9b8 <xTaskRemoveFromEventList>
 800aca0:	b108      	cbz	r0, 800aca6 <prvUnlockQueue+0x22>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 800aca2:	f7ff ff05 	bl	800aab0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 800aca6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800aca8:	3b01      	subs	r3, #1
 800acaa:	64a3      	str	r3, [r4, #72]	; 0x48
 800acac:	e7f0      	b.n	800ac90 <prvUnlockQueue+0xc>
		}

		pxQueue->xTxLock = queueUNLOCKED;
 800acae:	f04f 33ff 	mov.w	r3, #4294967295
 800acb2:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 800acb4:	f7ff fa50 	bl	800a158 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800acb8:	f7ff fa3c 	bl	800a134 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800acbc:	f104 0510 	add.w	r5, r4, #16
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800acc0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800acc2:	2b00      	cmp	r3, #0
 800acc4:	dd0b      	ble.n	800acde <prvUnlockQueue+0x5a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800acc6:	6923      	ldr	r3, [r4, #16]
 800acc8:	b14b      	cbz	r3, 800acde <prvUnlockQueue+0x5a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800acca:	4628      	mov	r0, r5
 800accc:	f7ff fe74 	bl	800a9b8 <xTaskRemoveFromEventList>
 800acd0:	b108      	cbz	r0, 800acd6 <prvUnlockQueue+0x52>
				{
					vTaskMissedYield();
 800acd2:	f7ff feed 	bl	800aab0 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 800acd6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800acd8:	3b01      	subs	r3, #1
 800acda:	6463      	str	r3, [r4, #68]	; 0x44
 800acdc:	e7f0      	b.n	800acc0 <prvUnlockQueue+0x3c>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800acde:	f04f 33ff 	mov.w	r3, #4294967295
 800ace2:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 800ace4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 800ace8:	f7ff ba36 	b.w	800a158 <vPortExitCritical>

0800acec <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
 800acec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800acee:	460d      	mov	r5, r1
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800acf0:	4604      	mov	r4, r0
 800acf2:	b198      	cbz	r0, 800ad1c <xQueueGenericReset+0x30>

	taskENTER_CRITICAL();
 800acf4:	f7ff fa1e 	bl	800a134 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800acf8:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800acfa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800acfc:	6822      	ldr	r2, [r4, #0]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800acfe:	60a2      	str	r2, [r4, #8]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800ad00:	4343      	muls	r3, r0
 800ad02:	18d1      	adds	r1, r2, r3
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 800ad04:	1a1b      	subs	r3, r3, r0
 800ad06:	4413      	add	r3, r2

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800ad08:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 800ad0a:	60e3      	str	r3, [r4, #12]
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 800ad0c:	2100      	movs	r1, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 800ad0e:	f04f 33ff 	mov.w	r3, #4294967295
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 800ad12:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 800ad14:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 800ad16:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 800ad18:	b135      	cbz	r5, 800ad28 <xQueueGenericReset+0x3c>
 800ad1a:	e010      	b.n	800ad3e <xQueueGenericReset+0x52>

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800ad1c:	2301      	movs	r3, #1
 800ad1e:	9301      	str	r3, [sp, #4]
 800ad20:	9b01      	ldr	r3, [sp, #4]
 800ad22:	2b00      	cmp	r3, #0
 800ad24:	d1fc      	bne.n	800ad20 <xQueueGenericReset+0x34>
 800ad26:	e7e5      	b.n	800acf4 <xQueueGenericReset+0x8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800ad28:	6923      	ldr	r3, [r4, #16]
 800ad2a:	b183      	cbz	r3, 800ad4e <xQueueGenericReset+0x62>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 800ad2c:	f104 0010 	add.w	r0, r4, #16
 800ad30:	f7ff fe42 	bl	800a9b8 <xTaskRemoveFromEventList>
 800ad34:	2801      	cmp	r0, #1
 800ad36:	d10a      	bne.n	800ad4e <xQueueGenericReset+0x62>
				{
					portYIELD_WITHIN_API();
 800ad38:	f7ff f9d6 	bl	800a0e8 <vPortYield>
 800ad3c:	e007      	b.n	800ad4e <xQueueGenericReset+0x62>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800ad3e:	f104 0010 	add.w	r0, r4, #16
 800ad42:	f7ff ff15 	bl	800ab70 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800ad46:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ad4a:	f7ff ff11 	bl	800ab70 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 800ad4e:	f7ff fa03 	bl	800a158 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 800ad52:	2001      	movs	r0, #1
 800ad54:	b003      	add	sp, #12
 800ad56:	bd30      	pop	{r4, r5, pc}

0800ad58 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
 800ad58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ad5a:	460e      	mov	r6, r1
 800ad5c:	4617      	mov	r7, r2
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 800ad5e:	4605      	mov	r5, r0
 800ad60:	b1b8      	cbz	r0, 800ad92 <xQueueGenericCreate+0x3a>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 800ad62:	2050      	movs	r0, #80	; 0x50
 800ad64:	f7ff fad8 	bl	800a318 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800ad68:	4604      	mov	r4, r0
 800ad6a:	b190      	cbz	r0, 800ad92 <xQueueGenericCreate+0x3a>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 800ad6c:	fb06 f005 	mul.w	r0, r6, r5
 800ad70:	3001      	adds	r0, #1
 800ad72:	f7ff fad1 	bl	800a318 <pvPortMalloc>
 800ad76:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
 800ad78:	b140      	cbz	r0, 800ad8c <xQueueGenericCreate+0x34>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 800ad7a:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 800ad7c:	6426      	str	r6, [r4, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800ad7e:	2101      	movs	r1, #1
 800ad80:	4620      	mov	r0, r4
 800ad82:	f7ff ffb3 	bl	800acec <xQueueGenericReset>

				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
 800ad86:	f884 704d 	strb.w	r7, [r4, #77]	; 0x4d
 800ad8a:	e007      	b.n	800ad9c <xQueueGenericCreate+0x44>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 800ad8c:	4620      	mov	r0, r4
 800ad8e:	f7ff fb2f 	bl	800a3f0 <vPortFree>
			}
		}
	}

	configASSERT( xReturn );
 800ad92:	2301      	movs	r3, #1
 800ad94:	9301      	str	r3, [sp, #4]
 800ad96:	9c01      	ldr	r4, [sp, #4]
 800ad98:	2c00      	cmp	r4, #0
 800ad9a:	d1fc      	bne.n	800ad96 <xQueueGenericCreate+0x3e>

	return xReturn;
}
 800ad9c:	4620      	mov	r0, r4
 800ad9e:	b003      	add	sp, #12
 800ada0:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800ada2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 800ada2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ada6:	b089      	sub	sp, #36	; 0x24
 800ada8:	4688      	mov	r8, r1
 800adaa:	9201      	str	r2, [sp, #4]
 800adac:	461e      	mov	r6, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800adae:	4604      	mov	r4, r0
 800adb0:	b118      	cbz	r0, 800adba <xQueueGenericSend+0x18>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800adb2:	f1b8 0f00 	cmp.w	r8, #0
 800adb6:	d10d      	bne.n	800add4 <xQueueGenericSend+0x32>
 800adb8:	e005      	b.n	800adc6 <xQueueGenericSend+0x24>
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800adba:	2301      	movs	r3, #1
 800adbc:	9303      	str	r3, [sp, #12]
 800adbe:	9b03      	ldr	r3, [sp, #12]
 800adc0:	2b00      	cmp	r3, #0
 800adc2:	d1fc      	bne.n	800adbe <xQueueGenericSend+0x1c>
 800adc4:	e7f5      	b.n	800adb2 <xQueueGenericSend+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800adc6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800adc8:	b123      	cbz	r3, 800add4 <xQueueGenericSend+0x32>
 800adca:	2301      	movs	r3, #1
 800adcc:	9304      	str	r3, [sp, #16]
 800adce:	9b04      	ldr	r3, [sp, #16]
 800add0:	2b00      	cmp	r3, #0
 800add2:	d1fc      	bne.n	800adce <xQueueGenericSend+0x2c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800add4:	2e02      	cmp	r6, #2
 800add6:	d107      	bne.n	800ade8 <xQueueGenericSend+0x46>
 800add8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800adda:	2b01      	cmp	r3, #1
 800addc:	d004      	beq.n	800ade8 <xQueueGenericSend+0x46>
 800adde:	2301      	movs	r3, #1
 800ade0:	9305      	str	r3, [sp, #20]
 800ade2:	9b05      	ldr	r3, [sp, #20]
 800ade4:	2b00      	cmp	r3, #0
 800ade6:	d1fc      	bne.n	800ade2 <xQueueGenericSend+0x40>

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 800ade8:	2700      	movs	r7, #0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 800adea:	46b9      	mov	r9, r7
 800adec:	e02f      	b.n	800ae4e <xQueueGenericSend+0xac>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 800adee:	b917      	cbnz	r7, 800adf6 <xQueueGenericSend+0x54>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800adf0:	a806      	add	r0, sp, #24
 800adf2:	f7ff fe17 	bl	800aa24 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
 800adf6:	f7ff f9af 	bl	800a158 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800adfa:	f7ff fc49 	bl	800a690 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800adfe:	f7ff f999 	bl	800a134 <vPortEnterCritical>
 800ae02:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ae04:	3301      	adds	r3, #1
 800ae06:	bf08      	it	eq
 800ae08:	f8c4 9044 	streq.w	r9, [r4, #68]	; 0x44
 800ae0c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ae0e:	3301      	adds	r3, #1
 800ae10:	bf08      	it	eq
 800ae12:	f8c4 9048 	streq.w	r9, [r4, #72]	; 0x48
 800ae16:	f7ff f99f 	bl	800a158 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800ae1a:	a901      	add	r1, sp, #4
 800ae1c:	a806      	add	r0, sp, #24
 800ae1e:	f7ff fe13 	bl	800aa48 <xTaskCheckForTimeOut>
 800ae22:	2800      	cmp	r0, #0
 800ae24:	d13e      	bne.n	800aea4 <xQueueGenericSend+0x102>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 800ae26:	f7ff f985 	bl	800a134 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800ae2a:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 800ae2c:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800ae2e:	f7ff f993 	bl	800a158 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800ae32:	42af      	cmp	r7, r5
 800ae34:	d130      	bne.n	800ae98 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800ae36:	9901      	ldr	r1, [sp, #4]
 800ae38:	f104 0010 	add.w	r0, r4, #16
 800ae3c:	f7ff fd98 	bl	800a970 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 800ae40:	4620      	mov	r0, r4
 800ae42:	f7ff ff1f 	bl	800ac84 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 800ae46:	f7ff fcbb 	bl	800a7c0 <xTaskResumeAll>
 800ae4a:	b310      	cbz	r0, 800ae92 <xQueueGenericSend+0xf0>
 800ae4c:	2701      	movs	r7, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800ae4e:	f7ff f971 	bl	800a134 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800ae52:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800ae54:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800ae56:	429a      	cmp	r2, r3
 800ae58:	d301      	bcc.n	800ae5e <xQueueGenericSend+0xbc>
 800ae5a:	2e02      	cmp	r6, #2
 800ae5c:	d112      	bne.n	800ae84 <xQueueGenericSend+0xe2>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800ae5e:	4632      	mov	r2, r6
 800ae60:	4641      	mov	r1, r8
 800ae62:	4620      	mov	r0, r4
 800ae64:	f7ff fec8 	bl	800abf8 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ae68:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ae6a:	b13b      	cbz	r3, 800ae7c <xQueueGenericSend+0xda>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800ae6c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ae70:	f7ff fda2 	bl	800a9b8 <xTaskRemoveFromEventList>
 800ae74:	2801      	cmp	r0, #1
 800ae76:	d101      	bne.n	800ae7c <xQueueGenericSend+0xda>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
 800ae78:	f7ff f936 	bl	800a0e8 <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 800ae7c:	f7ff f96c 	bl	800a158 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 800ae80:	2001      	movs	r0, #1
 800ae82:	e015      	b.n	800aeb0 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800ae84:	9d01      	ldr	r5, [sp, #4]
 800ae86:	2d00      	cmp	r5, #0
 800ae88:	d1b1      	bne.n	800adee <xQueueGenericSend+0x4c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800ae8a:	f7ff f965 	bl	800a158 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 800ae8e:	4628      	mov	r0, r5
 800ae90:	e00e      	b.n	800aeb0 <xQueueGenericSend+0x10e>
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
 800ae92:	f7ff f929 	bl	800a0e8 <vPortYield>
 800ae96:	e7d9      	b.n	800ae4c <xQueueGenericSend+0xaa>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800ae98:	4620      	mov	r0, r4
 800ae9a:	f7ff fef3 	bl	800ac84 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800ae9e:	f7ff fc8f 	bl	800a7c0 <xTaskResumeAll>
 800aea2:	e7d3      	b.n	800ae4c <xQueueGenericSend+0xaa>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800aea4:	4620      	mov	r0, r4
 800aea6:	f7ff feed 	bl	800ac84 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800aeaa:	f7ff fc89 	bl	800a7c0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 800aeae:	2000      	movs	r0, #0
		}
	}
}
 800aeb0:	b009      	add	sp, #36	; 0x24
 800aeb2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800aeb6 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
 800aeb6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800aeb8:	4606      	mov	r6, r0
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 800aeba:	2050      	movs	r0, #80	; 0x50
 800aebc:	f7ff fa2c 	bl	800a318 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800aec0:	4604      	mov	r4, r0
 800aec2:	b1e0      	cbz	r0, 800aefe <xQueueCreateMutex+0x48>

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 800aec4:	2301      	movs	r3, #1
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 800aec6:	2500      	movs	r5, #0

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 800aec8:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 800aeca:	f04f 33ff 	mov.w	r3, #4294967295
			pxNewQueue->u.pcReadFrom = NULL;

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 800aece:	6385      	str	r5, [r0, #56]	; 0x38
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 800aed0:	6045      	str	r5, [r0, #4]
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 800aed2:	6443      	str	r3, [r0, #68]	; 0x44
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800aed4:	6005      	str	r5, [r0, #0]
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;
 800aed6:	6483      	str	r3, [r0, #72]	; 0x48
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 800aed8:	6085      	str	r5, [r0, #8]
			pxNewQueue->u.pcReadFrom = NULL;
 800aeda:	60c5      	str	r5, [r0, #12]
			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 800aedc:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
 800aede:	f880 604d 	strb.w	r6, [r0, #77]	; 0x4d
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 800aee2:	3010      	adds	r0, #16
 800aee4:	f7ff fe44 	bl	800ab70 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 800aee8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800aeec:	f7ff fe40 	bl	800ab70 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 800aef0:	462b      	mov	r3, r5
 800aef2:	462a      	mov	r2, r5
 800aef4:	4629      	mov	r1, r5
 800aef6:	4620      	mov	r0, r4
 800aef8:	f7ff ff53 	bl	800ada2 <xQueueGenericSend>
 800aefc:	e004      	b.n	800af08 <xQueueCreateMutex+0x52>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
 800aefe:	2301      	movs	r3, #1
 800af00:	9301      	str	r3, [sp, #4]
 800af02:	9b01      	ldr	r3, [sp, #4]
 800af04:	2b00      	cmp	r3, #0
 800af06:	d1fc      	bne.n	800af02 <xQueueCreateMutex+0x4c>
		return pxNewQueue;
	}
 800af08:	4620      	mov	r0, r4
 800af0a:	b002      	add	sp, #8
 800af0c:	bd70      	pop	{r4, r5, r6, pc}

0800af0e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 800af0e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800af12:	4688      	mov	r8, r1
 800af14:	4616      	mov	r6, r2
 800af16:	461d      	mov	r5, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800af18:	4604      	mov	r4, r0
 800af1a:	b118      	cbz	r0, 800af24 <xQueueGenericSendFromISR+0x16>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800af1c:	f1b8 0f00 	cmp.w	r8, #0
 800af20:	d10d      	bne.n	800af3e <xQueueGenericSendFromISR+0x30>
 800af22:	e005      	b.n	800af30 <xQueueGenericSendFromISR+0x22>
{
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800af24:	2301      	movs	r3, #1
 800af26:	9301      	str	r3, [sp, #4]
 800af28:	9b01      	ldr	r3, [sp, #4]
 800af2a:	2b00      	cmp	r3, #0
 800af2c:	d1fc      	bne.n	800af28 <xQueueGenericSendFromISR+0x1a>
 800af2e:	e7f5      	b.n	800af1c <xQueueGenericSendFromISR+0xe>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800af30:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800af32:	b123      	cbz	r3, 800af3e <xQueueGenericSendFromISR+0x30>
 800af34:	2301      	movs	r3, #1
 800af36:	9302      	str	r3, [sp, #8]
 800af38:	9b02      	ldr	r3, [sp, #8]
 800af3a:	2b00      	cmp	r3, #0
 800af3c:	d1fc      	bne.n	800af38 <xQueueGenericSendFromISR+0x2a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800af3e:	2d02      	cmp	r5, #2
 800af40:	d107      	bne.n	800af52 <xQueueGenericSendFromISR+0x44>
 800af42:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800af44:	2b01      	cmp	r3, #1
 800af46:	d004      	beq.n	800af52 <xQueueGenericSendFromISR+0x44>
 800af48:	2301      	movs	r3, #1
 800af4a:	9303      	str	r3, [sp, #12]
 800af4c:	9b03      	ldr	r3, [sp, #12]
 800af4e:	2b00      	cmp	r3, #0
 800af50:	d1fc      	bne.n	800af4c <xQueueGenericSendFromISR+0x3e>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800af52:	f7ff f997 	bl	800a284 <vPortValidateInterruptPriority>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800af56:	f7ff f8d3 	bl	800a100 <ulPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800af5a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800af5c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800af5e:	429a      	cmp	r2, r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800af60:	4607      	mov	r7, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800af62:	d301      	bcc.n	800af68 <xQueueGenericSendFromISR+0x5a>
 800af64:	2d02      	cmp	r5, #2
 800af66:	d117      	bne.n	800af98 <xQueueGenericSendFromISR+0x8a>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800af68:	462a      	mov	r2, r5
 800af6a:	4641      	mov	r1, r8
 800af6c:	4620      	mov	r0, r4
 800af6e:	f7ff fe43 	bl	800abf8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 800af72:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800af74:	3301      	adds	r3, #1
 800af76:	d10a      	bne.n	800af8e <xQueueGenericSendFromISR+0x80>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800af78:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800af7a:	b15b      	cbz	r3, 800af94 <xQueueGenericSendFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800af7c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800af80:	f7ff fd1a 	bl	800a9b8 <xTaskRemoveFromEventList>
 800af84:	b130      	cbz	r0, 800af94 <xQueueGenericSendFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800af86:	b12e      	cbz	r6, 800af94 <xQueueGenericSendFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 800af88:	2401      	movs	r4, #1
 800af8a:	6034      	str	r4, [r6, #0]
 800af8c:	e005      	b.n	800af9a <xQueueGenericSendFromISR+0x8c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800af8e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800af90:	3301      	adds	r3, #1
 800af92:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 800af94:	2401      	movs	r4, #1
 800af96:	e000      	b.n	800af9a <xQueueGenericSendFromISR+0x8c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 800af98:	2400      	movs	r4, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800af9a:	4638      	mov	r0, r7
 800af9c:	f7ff f8d8 	bl	800a150 <vPortClearInterruptMask>

	return xReturn;
}
 800afa0:	4620      	mov	r0, r4
 800afa2:	b004      	add	sp, #16
 800afa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800afa8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 800afa8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800afac:	b087      	sub	sp, #28
 800afae:	460f      	mov	r7, r1
 800afb0:	9201      	str	r2, [sp, #4]
 800afb2:	4699      	mov	r9, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800afb4:	4604      	mov	r4, r0
 800afb6:	b108      	cbz	r0, 800afbc <xQueueGenericReceive+0x14>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800afb8:	b96f      	cbnz	r7, 800afd6 <xQueueGenericReceive+0x2e>
 800afba:	e005      	b.n	800afc8 <xQueueGenericReceive+0x20>
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 800afbc:	2301      	movs	r3, #1
 800afbe:	9302      	str	r3, [sp, #8]
 800afc0:	9b02      	ldr	r3, [sp, #8]
 800afc2:	2b00      	cmp	r3, #0
 800afc4:	d1fc      	bne.n	800afc0 <xQueueGenericReceive+0x18>
 800afc6:	e7f7      	b.n	800afb8 <xQueueGenericReceive+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800afc8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800afca:	b123      	cbz	r3, 800afd6 <xQueueGenericReceive+0x2e>
 800afcc:	2301      	movs	r3, #1
 800afce:	9303      	str	r3, [sp, #12]
 800afd0:	9b03      	ldr	r3, [sp, #12]
 800afd2:	2b00      	cmp	r3, #0
 800afd4:	d1fc      	bne.n	800afd0 <xQueueGenericReceive+0x28>
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 800afd6:	2600      	movs	r6, #0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 800afd8:	46b0      	mov	r8, r6
 800afda:	e038      	b.n	800b04e <xQueueGenericReceive+0xa6>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 800afdc:	b916      	cbnz	r6, 800afe4 <xQueueGenericReceive+0x3c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800afde:	a804      	add	r0, sp, #16
 800afe0:	f7ff fd20 	bl	800aa24 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
 800afe4:	f7ff f8b8 	bl	800a158 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800afe8:	f7ff fb52 	bl	800a690 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800afec:	f7ff f8a2 	bl	800a134 <vPortEnterCritical>
 800aff0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800aff2:	3301      	adds	r3, #1
 800aff4:	bf08      	it	eq
 800aff6:	f8c4 8044 	streq.w	r8, [r4, #68]	; 0x44
 800affa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800affc:	3301      	adds	r3, #1
 800affe:	bf08      	it	eq
 800b000:	f8c4 8048 	streq.w	r8, [r4, #72]	; 0x48
 800b004:	f7ff f8a8 	bl	800a158 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800b008:	a901      	add	r1, sp, #4
 800b00a:	a804      	add	r0, sp, #16
 800b00c:	f7ff fd1c 	bl	800aa48 <xTaskCheckForTimeOut>
 800b010:	2800      	cmp	r0, #0
 800b012:	d158      	bne.n	800b0c6 <xQueueGenericReceive+0x11e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 800b014:	f7ff f88e 	bl	800a134 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
 800b018:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800b01a:	f7ff f89d 	bl	800a158 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800b01e:	2d00      	cmp	r5, #0
 800b020:	d14b      	bne.n	800b0ba <xQueueGenericReceive+0x112>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800b022:	6823      	ldr	r3, [r4, #0]
 800b024:	b933      	cbnz	r3, 800b034 <xQueueGenericReceive+0x8c>
					{
						portENTER_CRITICAL();
 800b026:	f7ff f885 	bl	800a134 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800b02a:	6860      	ldr	r0, [r4, #4]
 800b02c:	f7ff fd4e 	bl	800aacc <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 800b030:	f7ff f892 	bl	800a158 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800b034:	9901      	ldr	r1, [sp, #4]
 800b036:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800b03a:	f7ff fc99 	bl	800a970 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800b03e:	4620      	mov	r0, r4
 800b040:	f7ff fe20 	bl	800ac84 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800b044:	f7ff fbbc 	bl	800a7c0 <xTaskResumeAll>
 800b048:	2800      	cmp	r0, #0
 800b04a:	d033      	beq.n	800b0b4 <xQueueGenericReceive+0x10c>
 800b04c:	2601      	movs	r6, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 800b04e:	f7ff f871 	bl	800a134 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800b052:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b054:	b33b      	cbz	r3, 800b0a6 <xQueueGenericReceive+0xfe>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b056:	4639      	mov	r1, r7
 800b058:	4620      	mov	r0, r4
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800b05a:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b05c:	f7ff fdff 	bl	800ac5e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 800b060:	f1b9 0f00 	cmp.w	r9, #0
 800b064:	d112      	bne.n	800b08c <xQueueGenericReceive+0xe4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 800b066:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b068:	3b01      	subs	r3, #1
 800b06a:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800b06c:	6823      	ldr	r3, [r4, #0]
 800b06e:	b913      	cbnz	r3, 800b076 <xQueueGenericReceive+0xce>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
 800b070:	f7ff fd26 	bl	800aac0 <xTaskGetCurrentTaskHandle>
 800b074:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b076:	6923      	ldr	r3, [r4, #16]
 800b078:	b18b      	cbz	r3, 800b09e <xQueueGenericReceive+0xf6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 800b07a:	f104 0010 	add.w	r0, r4, #16
 800b07e:	f7ff fc9b 	bl	800a9b8 <xTaskRemoveFromEventList>
 800b082:	2801      	cmp	r0, #1
 800b084:	d10b      	bne.n	800b09e <xQueueGenericReceive+0xf6>
						{
							portYIELD_WITHIN_API();
 800b086:	f7ff f82f 	bl	800a0e8 <vPortYield>
 800b08a:	e008      	b.n	800b09e <xQueueGenericReceive+0xf6>
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b08c:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800b08e:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b090:	b12b      	cbz	r3, 800b09e <xQueueGenericReceive+0xf6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b092:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800b096:	f7ff fc8f 	bl	800a9b8 <xTaskRemoveFromEventList>
 800b09a:	2800      	cmp	r0, #0
 800b09c:	d1f3      	bne.n	800b086 <xQueueGenericReceive+0xde>
							portYIELD_WITHIN_API();
						}
					}
				}

				taskEXIT_CRITICAL();
 800b09e:	f7ff f85b 	bl	800a158 <vPortExitCritical>
				return pdPASS;
 800b0a2:	2001      	movs	r0, #1
 800b0a4:	e015      	b.n	800b0d2 <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800b0a6:	9d01      	ldr	r5, [sp, #4]
 800b0a8:	2d00      	cmp	r5, #0
 800b0aa:	d197      	bne.n	800afdc <xQueueGenericReceive+0x34>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800b0ac:	f7ff f854 	bl	800a158 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800b0b0:	4628      	mov	r0, r5
 800b0b2:	e00e      	b.n	800b0d2 <xQueueGenericReceive+0x12a>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
 800b0b4:	f7ff f818 	bl	800a0e8 <vPortYield>
 800b0b8:	e7c8      	b.n	800b04c <xQueueGenericReceive+0xa4>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800b0ba:	4620      	mov	r0, r4
 800b0bc:	f7ff fde2 	bl	800ac84 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800b0c0:	f7ff fb7e 	bl	800a7c0 <xTaskResumeAll>
 800b0c4:	e7c2      	b.n	800b04c <xQueueGenericReceive+0xa4>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 800b0c6:	4620      	mov	r0, r4
 800b0c8:	f7ff fddc 	bl	800ac84 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800b0cc:	f7ff fb78 	bl	800a7c0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 800b0d0:	2000      	movs	r0, #0
		}
	}
}
 800b0d2:	b007      	add	sp, #28
 800b0d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800b0d8 <moduleTask>:
  taskEXIT_CRITICAL();
  return (status == pdTRUE) ? 0 : -1;
}

static void moduleTask(void *pvParameters)
{
 800b0d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800b0da:	4604      	mov	r4, r0
  // Get module data
  moduleModule_t *moduleTaskData = (moduleModule_t *) pvParameters;
  queueMessage_t message;

  taskWaitInit();
 800b0dc:	f7fd fa2a 	bl	8008534 <taskWaitInit>

  if(moduleTaskData->initCallback)
 800b0e0:	68e3      	ldr	r3, [r4, #12]
 800b0e2:	b10b      	cbz	r3, 800b0e8 <moduleTask+0x10>
    moduleTaskData->initCallback(moduleTaskData->privateData);
 800b0e4:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800b0e6:	4798      	blx	r3

  while(1)
    {
      //receive a command from the queue. Wait only a specified time.
      if (xQueueReceive(moduleTaskData->queueHandle, (void *)&message, moduleTaskData->timeout) == pdTRUE)
 800b0e8:	2300      	movs	r3, #0
 800b0ea:	6862      	ldr	r2, [r4, #4]
 800b0ec:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800b0ee:	a902      	add	r1, sp, #8
 800b0f0:	f7ff ff5a 	bl	800afa8 <xQueueGenericReceive>
 800b0f4:	2801      	cmp	r0, #1
 800b0f6:	d120      	bne.n	800b13a <moduleTask+0x62>
        {
          moduleTaskData->dequeues++;
 800b0f8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b0fa:	3301      	adds	r3, #1
 800b0fc:	63e3      	str	r3, [r4, #60]	; 0x3c
          massert(message.command >=0 && message.command < moduleTaskData->commandsNum);
 800b0fe:	9b02      	ldr	r3, [sp, #8]
 800b100:	2b00      	cmp	r3, #0
 800b102:	db07      	blt.n	800b114 <moduleTask+0x3c>
 800b104:	68a2      	ldr	r2, [r4, #8]
 800b106:	4293      	cmp	r3, r2
 800b108:	da04      	bge.n	800b114 <moduleTask+0x3c>
          if (moduleTaskData->commandsNum > message.command && moduleTaskData->commandCallback
 800b10a:	9a02      	ldr	r2, [sp, #8]
 800b10c:	68a3      	ldr	r3, [r4, #8]
 800b10e:	4293      	cmp	r3, r2
 800b110:	dc0c      	bgt.n	800b12c <moduleTask+0x54>
 800b112:	e016      	b.n	800b142 <moduleTask+0x6a>
    {
      //receive a command from the queue. Wait only a specified time.
      if (xQueueReceive(moduleTaskData->queueHandle, (void *)&message, moduleTaskData->timeout) == pdTRUE)
        {
          moduleTaskData->dequeues++;
          massert(message.command >=0 && message.command < moduleTaskData->commandsNum);
 800b114:	4b0d      	ldr	r3, [pc, #52]	; (800b14c <moduleTask+0x74>)
 800b116:	490e      	ldr	r1, [pc, #56]	; (800b150 <moduleTask+0x78>)
 800b118:	480e      	ldr	r0, [pc, #56]	; (800b154 <moduleTask+0x7c>)
 800b11a:	224b      	movs	r2, #75	; 0x4b
 800b11c:	f7fd fb22 	bl	8008764 <xprintf>
 800b120:	2301      	movs	r3, #1
 800b122:	9301      	str	r3, [sp, #4]
 800b124:	9b01      	ldr	r3, [sp, #4]
 800b126:	2b00      	cmp	r3, #0
 800b128:	d1fc      	bne.n	800b124 <moduleTask+0x4c>
 800b12a:	e7ee      	b.n	800b10a <moduleTask+0x32>
          if (moduleTaskData->commandsNum > message.command && moduleTaskData->commandCallback
 800b12c:	6923      	ldr	r3, [r4, #16]
 800b12e:	b143      	cbz	r3, 800b142 <moduleTask+0x6a>
              && moduleTaskData->commandCallback[message.command])
 800b130:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b134:	b12b      	cbz	r3, 800b142 <moduleTask+0x6a>
            moduleTaskData->commandCallback[message.command] (message.data);
 800b136:	9803      	ldr	r0, [sp, #12]
 800b138:	e002      	b.n	800b140 <moduleTask+0x68>
        }
      else
        {
          //Timeout. No command received in the specified time
          if (moduleTaskData->timeoutCallback)
 800b13a:	6963      	ldr	r3, [r4, #20]
 800b13c:	b10b      	cbz	r3, 800b142 <moduleTask+0x6a>
            moduleTaskData->timeoutCallback(moduleTaskData);
 800b13e:	4620      	mov	r0, r4
 800b140:	4798      	blx	r3
        }

      //Either timeout or command
      if (moduleTaskData->alwaysCallback)
 800b142:	69a3      	ldr	r3, [r4, #24]
 800b144:	2b00      	cmp	r3, #0
 800b146:	d0cf      	beq.n	800b0e8 <moduleTask+0x10>
        moduleTaskData->alwaysCallback(moduleTaskData);
 800b148:	4620      	mov	r0, r4
 800b14a:	e7cc      	b.n	800b0e6 <moduleTask+0xe>
 800b14c:	08014da6 	.word	0x08014da6
 800b150:	08014d7e 	.word	0x08014d7e
 800b154:	080148f4 	.word	0x080148f4

0800b158 <moduleSendCommand>:
  int command;
  void *data;
} queueMessage_t;

int moduleSendCommand(moduleModule_t * moduleTaskData, int command, void *data)
{
 800b158:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  if (moduleTaskData->queueHandle == NULL)
 800b15a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  int command;
  void *data;
} queueMessage_t;

int moduleSendCommand(moduleModule_t * moduleTaskData, int command, void *data)
{
 800b15c:	4604      	mov	r4, r0
 800b15e:	460d      	mov	r5, r1
 800b160:	4616      	mov	r6, r2
  if (moduleTaskData->queueHandle == NULL)
 800b162:	2b00      	cmp	r3, #0
 800b164:	d03f      	beq.n	800b1e6 <moduleSendCommand+0x8e>
    {
      //Queue not initialized
      //massert(0);
      return -1;
    }
  massert(command >=0 && command < moduleTaskData->commandsNum);
 800b166:	2900      	cmp	r1, #0
 800b168:	db09      	blt.n	800b17e <moduleSendCommand+0x26>
 800b16a:	6883      	ldr	r3, [r0, #8]
 800b16c:	4299      	cmp	r1, r3
 800b16e:	da06      	bge.n	800b17e <moduleSendCommand+0x26>
  queueMessage_t message =
 800b170:	9502      	str	r5, [sp, #8]
 800b172:	9603      	str	r6, [sp, #12]
    .data = data,
  };
  portBASE_TYPE status;

  //Check if this is a call from interrupt and use proper enqueue
  if (amIInIRQ())
 800b174:	f7fd f868 	bl	8008248 <amIInIRQ>
 800b178:	4603      	mov	r3, r0
 800b17a:	b960      	cbnz	r0, 800b196 <moduleSendCommand+0x3e>
 800b17c:	e01b      	b.n	800b1b6 <moduleSendCommand+0x5e>
    {
      //Queue not initialized
      //massert(0);
      return -1;
    }
  massert(command >=0 && command < moduleTaskData->commandsNum);
 800b17e:	4b1c      	ldr	r3, [pc, #112]	; (800b1f0 <moduleSendCommand+0x98>)
 800b180:	491c      	ldr	r1, [pc, #112]	; (800b1f4 <moduleSendCommand+0x9c>)
 800b182:	481d      	ldr	r0, [pc, #116]	; (800b1f8 <moduleSendCommand+0xa0>)
 800b184:	221b      	movs	r2, #27
 800b186:	f7fd faed 	bl	8008764 <xprintf>
 800b18a:	2301      	movs	r3, #1
 800b18c:	9300      	str	r3, [sp, #0]
 800b18e:	9b00      	ldr	r3, [sp, #0]
 800b190:	2b00      	cmp	r3, #0
 800b192:	d1fc      	bne.n	800b18e <moduleSendCommand+0x36>
 800b194:	e7ec      	b.n	800b170 <moduleSendCommand+0x18>
  portBASE_TYPE status;

  //Check if this is a call from interrupt and use proper enqueue
  if (amIInIRQ())
    {
      portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 800b196:	aa04      	add	r2, sp, #16
 800b198:	2300      	movs	r3, #0
 800b19a:	f842 3d0c 	str.w	r3, [r2, #-12]!

      status = xQueueSendFromISR(moduleTaskData->queueHandle, &message, &xHigherPriorityTaskWoken);
 800b19e:	a902      	add	r1, sp, #8
 800b1a0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800b1a2:	f7ff feb4 	bl	800af0e <xQueueGenericSendFromISR>

      //Switch context if necessary
      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 800b1a6:	9b01      	ldr	r3, [sp, #4]
  //Check if this is a call from interrupt and use proper enqueue
  if (amIInIRQ())
    {
      portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

      status = xQueueSendFromISR(moduleTaskData->queueHandle, &message, &xHigherPriorityTaskWoken);
 800b1a8:	4605      	mov	r5, r0

      //Switch context if necessary
      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 800b1aa:	b153      	cbz	r3, 800b1c2 <moduleSendCommand+0x6a>
 800b1ac:	4b13      	ldr	r3, [pc, #76]	; (800b1fc <moduleSendCommand+0xa4>)
 800b1ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b1b2:	601a      	str	r2, [r3, #0]
 800b1b4:	e005      	b.n	800b1c2 <moduleSendCommand+0x6a>
    }
  else
    {
      status = xQueueSend(moduleTaskData->queueHandle, &message, 0 /*Do not wait for a free entry */ );
 800b1b6:	4602      	mov	r2, r0
 800b1b8:	a902      	add	r1, sp, #8
 800b1ba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800b1bc:	f7ff fdf1 	bl	800ada2 <xQueueGenericSend>
 800b1c0:	4605      	mov	r5, r0
    }
  taskENTER_CRITICAL();
 800b1c2:	f7fe ffb7 	bl	800a134 <vPortEnterCritical>
  if(status)
 800b1c6:	b11d      	cbz	r5, 800b1d0 <moduleSendCommand+0x78>
    moduleTaskData->enqueues++;
 800b1c8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800b1ca:	3301      	adds	r3, #1
 800b1cc:	6363      	str	r3, [r4, #52]	; 0x34
 800b1ce:	e002      	b.n	800b1d6 <moduleSendCommand+0x7e>
  else
    moduleTaskData->fenqueues++;
 800b1d0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b1d2:	3301      	adds	r3, #1
 800b1d4:	63a3      	str	r3, [r4, #56]	; 0x38
  taskEXIT_CRITICAL();
 800b1d6:	f7fe ffbf 	bl	800a158 <vPortExitCritical>
  return (status == pdTRUE) ? 0 : -1;
 800b1da:	f115 30ff 	adds.w	r0, r5, #4294967295
 800b1de:	bf18      	it	ne
 800b1e0:	f04f 30ff 	movne.w	r0, #4294967295
 800b1e4:	e001      	b.n	800b1ea <moduleSendCommand+0x92>
{
  if (moduleTaskData->queueHandle == NULL)
    {
      //Queue not initialized
      //massert(0);
      return -1;
 800b1e6:	f04f 30ff 	mov.w	r0, #4294967295
    moduleTaskData->enqueues++;
  else
    moduleTaskData->fenqueues++;
  taskEXIT_CRITICAL();
  return (status == pdTRUE) ? 0 : -1;
}
 800b1ea:	b004      	add	sp, #16
 800b1ec:	bd70      	pop	{r4, r5, r6, pc}
 800b1ee:	bf00      	nop
 800b1f0:	08014deb 	.word	0x08014deb
 800b1f4:	08014d89 	.word	0x08014d89
 800b1f8:	080148f4 	.word	0x080148f4
 800b1fc:	e000ed04 	.word	0xe000ed04

0800b200 <moduleInit>:
        moduleTaskData->alwaysCallback(moduleTaskData);
    }
}

void moduleInit(moduleModule_t * moduleTaskData)
{
 800b200:	b510      	push	{r4, lr}
  //Create a queue for command reception
  massert((moduleTaskData->queueHandle = xQueueCreate(moduleTaskData->queueLength, sizeof(queueMessage_t))));
 800b202:	2200      	movs	r2, #0
        moduleTaskData->alwaysCallback(moduleTaskData);
    }
}

void moduleInit(moduleModule_t * moduleTaskData)
{
 800b204:	4604      	mov	r4, r0
 800b206:	b086      	sub	sp, #24
  //Create a queue for command reception
  massert((moduleTaskData->queueHandle = xQueueCreate(moduleTaskData->queueLength, sizeof(queueMessage_t))));
 800b208:	2108      	movs	r1, #8
 800b20a:	6800      	ldr	r0, [r0, #0]
 800b20c:	f7ff fda4 	bl	800ad58 <xQueueGenericCreate>
 800b210:	62e0      	str	r0, [r4, #44]	; 0x2c
 800b212:	b1d8      	cbz	r0, 800b24c <moduleInit+0x4c>

  //Create the task
  massert(xTaskGenericCreate(moduleTask,
 800b214:	6a23      	ldr	r3, [r4, #32]
 800b216:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800b218:	9102      	str	r1, [sp, #8]
 800b21a:	2204      	movs	r2, #4
 800b21c:	fb93 f2f2 	sdiv	r2, r3, r2
 800b220:	2300      	movs	r3, #0
 800b222:	9303      	str	r3, [sp, #12]
 800b224:	9301      	str	r3, [sp, #4]
 800b226:	69e3      	ldr	r3, [r4, #28]
 800b228:	9300      	str	r3, [sp, #0]
 800b22a:	b292      	uxth	r2, r2
 800b22c:	4623      	mov	r3, r4
 800b22e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800b230:	480f      	ldr	r0, [pc, #60]	; (800b270 <moduleInit+0x70>)
 800b232:	f7ff f939 	bl	800a4a8 <xTaskGenericCreate>
 800b236:	2801      	cmp	r0, #1
 800b238:	d017      	beq.n	800b26a <moduleInit+0x6a>
 800b23a:	4b0e      	ldr	r3, [pc, #56]	; (800b274 <moduleInit+0x74>)
 800b23c:	490e      	ldr	r1, [pc, #56]	; (800b278 <moduleInit+0x78>)
 800b23e:	480f      	ldr	r0, [pc, #60]	; (800b27c <moduleInit+0x7c>)
 800b240:	2265      	movs	r2, #101	; 0x65
 800b242:	f7fd fa8f 	bl	8008764 <xprintf>
 800b246:	2301      	movs	r3, #1
 800b248:	9305      	str	r3, [sp, #20]
 800b24a:	e00b      	b.n	800b264 <moduleInit+0x64>
}

void moduleInit(moduleModule_t * moduleTaskData)
{
  //Create a queue for command reception
  massert((moduleTaskData->queueHandle = xQueueCreate(moduleTaskData->queueLength, sizeof(queueMessage_t))));
 800b24c:	4b0c      	ldr	r3, [pc, #48]	; (800b280 <moduleInit+0x80>)
 800b24e:	490a      	ldr	r1, [pc, #40]	; (800b278 <moduleInit+0x78>)
 800b250:	480a      	ldr	r0, [pc, #40]	; (800b27c <moduleInit+0x7c>)
 800b252:	2260      	movs	r2, #96	; 0x60
 800b254:	f7fd fa86 	bl	8008764 <xprintf>
 800b258:	2301      	movs	r3, #1
 800b25a:	9304      	str	r3, [sp, #16]
 800b25c:	9b04      	ldr	r3, [sp, #16]
 800b25e:	2b00      	cmp	r3, #0
 800b260:	d1fc      	bne.n	800b25c <moduleInit+0x5c>
 800b262:	e7d7      	b.n	800b214 <moduleInit+0x14>

  //Create the task
  massert(xTaskGenericCreate(moduleTask,
 800b264:	9b05      	ldr	r3, [sp, #20]
 800b266:	2b00      	cmp	r3, #0
 800b268:	d1fc      	bne.n	800b264 <moduleInit+0x64>
                             (signed char *)moduleTaskData->name, moduleTaskData->stackSize/4, (void *)moduleTaskData, moduleTaskData->priority, NULL,
                             moduleTaskData->stack, NULL) == pdPASS);
}
 800b26a:	b006      	add	sp, #24
 800b26c:	bd10      	pop	{r4, pc}
 800b26e:	bf00      	nop
 800b270:	0800b0d9 	.word	0x0800b0d9
 800b274:	08014e82 	.word	0x08014e82
 800b278:	08014d9b 	.word	0x08014d9b
 800b27c:	080148f4 	.word	0x080148f4
 800b280:	08014e20 	.word	0x08014e20

0800b284 <timeOut>:
  dFree(message);
}

/////////////////////////////////////////////////////////////////////
static void timeOut(void *data)
{
 800b284:	b508      	push	{r3, lr}
  communicatorPeriodic();
 800b286:	f7fd fc31 	bl	8008aec <communicatorPeriodic>
#ifdef WATCHDOG_COMM
  wdogFeed(WATCHDOG_COMM(0));
 800b28a:	2008      	movs	r0, #8
#endif

}
 800b28c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/////////////////////////////////////////////////////////////////////
static void timeOut(void *data)
{
  communicatorPeriodic();
#ifdef WATCHDOG_COMM
  wdogFeed(WATCHDOG_COMM(0));
 800b290:	f003 bda6 	b.w	800ede0 <wdogFeed>

0800b294 <commNULL>:

static void commNULL(void *data)
{
  messageCommNULL_t *message = data;

  dFree(message);
 800b294:	3814      	subs	r0, #20
 800b296:	f002 bc25 	b.w	800dae4 <bFree>

0800b29a <commPortTxComplete>:
    }
  return 0;
}

static void commPortTxComplete(void *data)
{
 800b29a:	b510      	push	{r4, lr}
 800b29c:	4604      	mov	r4, r0
  messageTxCompleteData_t *message = data;

  communicatorTxComplete(message->portNum, message->status, message->handle);
 800b29e:	6882      	ldr	r2, [r0, #8]
 800b2a0:	6841      	ldr	r1, [r0, #4]
 800b2a2:	7800      	ldrb	r0, [r0, #0]
 800b2a4:	f7fd fc20 	bl	8008ae8 <communicatorTxComplete>
  dFree(message);
 800b2a8:	f1a4 0014 	sub.w	r0, r4, #20
}
 800b2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static void commPortTxComplete(void *data)
{
  messageTxCompleteData_t *message = data;

  communicatorTxComplete(message->portNum, message->status, message->handle);
  dFree(message);
 800b2b0:	f002 bc18 	b.w	800dae4 <bFree>

0800b2b4 <commPortRx>:
    }
  return 0;
}

static void commPortRx(void *data)
{
 800b2b4:	b510      	push	{r4, lr}
 800b2b6:	4604      	mov	r4, r0
  messageRxData_t *message = data;

  communicatorRx(message->portNum, message->buffer, message->bufferSize, message->gen);
 800b2b8:	7b03      	ldrb	r3, [r0, #12]
 800b2ba:	6882      	ldr	r2, [r0, #8]
 800b2bc:	6841      	ldr	r1, [r0, #4]
 800b2be:	7800      	ldrb	r0, [r0, #0]
 800b2c0:	f7fd faa2 	bl	8008808 <communicatorRx>
  dFree(message);
 800b2c4:	f1a4 0014 	sub.w	r0, r4, #20
}
 800b2c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static void commPortRx(void *data)
{
  messageRxData_t *message = data;

  communicatorRx(message->portNum, message->buffer, message->bufferSize, message->gen);
  dFree(message);
 800b2cc:	f002 bc0a 	b.w	800dae4 <bFree>

0800b2d0 <CommunicatorInit>:
};

void CommunicatorInit(void)
{
  //Initialize Communicator
  moduleInit(&moduleComm);
 800b2d0:	4801      	ldr	r0, [pc, #4]	; (800b2d8 <CommunicatorInit+0x8>)
 800b2d2:	f7ff bf95 	b.w	800b200 <moduleInit>
 800b2d6:	bf00      	nop
 800b2d8:	2001a878 	.word	0x2001a878

0800b2dc <messageRx>:
  uint8_t gen;
} messageRxData_t;

//A function for the port module to send message to the Communicator
int messageRx(portNum_t portNum, char *buffer, int bufferSize, uint8_t gen)
{
 800b2dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b2e0:	4680      	mov	r8, r0
  //Allocate resources for data transfer
  messageRxData_t *message = dAlloc(sizeof(messageRxData_t));
 800b2e2:	2010      	movs	r0, #16
  uint8_t gen;
} messageRxData_t;

//A function for the port module to send message to the Communicator
int messageRx(portNum_t portNum, char *buffer, int bufferSize, uint8_t gen)
{
 800b2e4:	460f      	mov	r7, r1
 800b2e6:	4616      	mov	r6, r2
 800b2e8:	461d      	mov	r5, r3
  //Allocate resources for data transfer
  messageRxData_t *message = dAlloc(sizeof(messageRxData_t));
 800b2ea:	f002 f9a1 	bl	800d630 <bAlloc>
 800b2ee:	4604      	mov	r4, r0
 800b2f0:	b180      	cbz	r0, 800b314 <messageRx+0x38>

  if (message == NULL)
    return -1;

  //Fill message
  message->portNum = portNum;
 800b2f2:	f880 8014 	strb.w	r8, [r0, #20]
  message->buffer = buffer;
 800b2f6:	6187      	str	r7, [r0, #24]
  message->bufferSize = bufferSize;
 800b2f8:	61c6      	str	r6, [r0, #28]
  message->gen = gen;//Locally generated message
 800b2fa:	f880 5020 	strb.w	r5, [r0, #32]

  //Send the message to communicator
  if (moduleSendCommand(&moduleComm, CMD_COMM_PORT_RX, message) < 0)
 800b2fe:	f100 0214 	add.w	r2, r0, #20
 800b302:	2100      	movs	r1, #0
 800b304:	4807      	ldr	r0, [pc, #28]	; (800b324 <messageRx+0x48>)
 800b306:	f7ff ff27 	bl	800b158 <moduleSendCommand>
 800b30a:	2800      	cmp	r0, #0
 800b30c:	da06      	bge.n	800b31c <messageRx+0x40>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800b30e:	4620      	mov	r0, r4
 800b310:	f002 fbe8 	bl	800dae4 <bFree>
{
  //Allocate resources for data transfer
  messageRxData_t *message = dAlloc(sizeof(messageRxData_t));

  if (message == NULL)
    return -1;
 800b314:	f04f 30ff 	mov.w	r0, #4294967295
 800b318:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      //Sending failed
      //Free allocated resources
      dFree(message);
      return -1;
    }
  return 0;
 800b31c:	2000      	movs	r0, #0
}
 800b31e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b322:	bf00      	nop
 800b324:	2001a878 	.word	0x2001a878

0800b328 <messageTxComplete>:
  int status;
  uint32_t handle;
} messageTxCompleteData_t;

int messageTxComplete(portNum_t portNum, int status, uint32_t handle)
{
 800b328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b32a:	4607      	mov	r7, r0
  //Allocate resources for data transfer
  messageTxCompleteData_t *message = dAlloc(sizeof(messageTxCompleteData_t));
 800b32c:	200c      	movs	r0, #12
  int status;
  uint32_t handle;
} messageTxCompleteData_t;

int messageTxComplete(portNum_t portNum, int status, uint32_t handle)
{
 800b32e:	460e      	mov	r6, r1
 800b330:	4615      	mov	r5, r2
  //Allocate resources for data transfer
  messageTxCompleteData_t *message = dAlloc(sizeof(messageTxCompleteData_t));
 800b332:	f002 f97d 	bl	800d630 <bAlloc>
 800b336:	4604      	mov	r4, r0
 800b338:	b168      	cbz	r0, 800b356 <messageTxComplete+0x2e>

  if (message == NULL)
    return -1;

  //Fill message
  message->portNum = portNum;
 800b33a:	7507      	strb	r7, [r0, #20]
  message->status = status;
 800b33c:	6186      	str	r6, [r0, #24]
  message->handle = handle;
 800b33e:	61c5      	str	r5, [r0, #28]

  //Send the message to communicator
  if (moduleSendCommand(&moduleComm, CMD_COMM_PORT_TX_COMPLETE, message) < 0)
 800b340:	f100 0214 	add.w	r2, r0, #20
 800b344:	2101      	movs	r1, #1
 800b346:	4806      	ldr	r0, [pc, #24]	; (800b360 <messageTxComplete+0x38>)
 800b348:	f7ff ff06 	bl	800b158 <moduleSendCommand>
 800b34c:	2800      	cmp	r0, #0
 800b34e:	da05      	bge.n	800b35c <messageTxComplete+0x34>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800b350:	4620      	mov	r0, r4
 800b352:	f002 fbc7 	bl	800dae4 <bFree>
{
  //Allocate resources for data transfer
  messageTxCompleteData_t *message = dAlloc(sizeof(messageTxCompleteData_t));

  if (message == NULL)
    return -1;
 800b356:	f04f 30ff 	mov.w	r0, #4294967295
 800b35a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      //Sending failed
      //Free allocated resources
      dFree(message);
      return -1;
    }
  return 0;
 800b35c:	2000      	movs	r0, #0
}
 800b35e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b360:	2001a878 	.word	0x2001a878

0800b364 <messageADCMeasure>:
} messageADCMeasureData_t;

int messageADCMeasure(int samplesNum,int sampleSensADC,
                      int V1accu, int V2accu,
                      int I1max, int V2I1max, int I1accu, int I2accu)
{
 800b364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b368:	4680      	mov	r8, r0
  //Allocate resources for data transfer
  messageADCMeasureData_t *message = dAlloc(sizeof(messageADCMeasureData_t));
 800b36a:	2020      	movs	r0, #32
} messageADCMeasureData_t;

int messageADCMeasure(int samplesNum,int sampleSensADC,
                      int V1accu, int V2accu,
                      int I1max, int V2I1max, int I1accu, int I2accu)
{
 800b36c:	460f      	mov	r7, r1
 800b36e:	4616      	mov	r6, r2
 800b370:	461d      	mov	r5, r3
  //Allocate resources for data transfer
  messageADCMeasureData_t *message = dAlloc(sizeof(messageADCMeasureData_t));
 800b372:	f002 f95d 	bl	800d630 <bAlloc>
 800b376:	4604      	mov	r4, r0
 800b378:	b1b8      	cbz	r0, 800b3aa <messageADCMeasure+0x46>
  //Fill message
  message->samplesNum = samplesNum;
  message->sampleSensADC = sampleSensADC;
  message->V1accu = V1accu;
  message->V2accu = V2accu;
  message->I1max  = I1max;
 800b37a:	9b06      	ldr	r3, [sp, #24]
 800b37c:	6243      	str	r3, [r0, #36]	; 0x24
  message->V2I1max= V2I1max;
 800b37e:	9b07      	ldr	r3, [sp, #28]
 800b380:	6283      	str	r3, [r0, #40]	; 0x28
  message->I1accu = I1accu;
 800b382:	9b08      	ldr	r3, [sp, #32]
 800b384:	62c3      	str	r3, [r0, #44]	; 0x2c
  message->I2accu = I2accu;
 800b386:	9b09      	ldr	r3, [sp, #36]	; 0x24

  if (message == NULL)
    return -1;

  //Fill message
  message->samplesNum = samplesNum;
 800b388:	f8c0 8014 	str.w	r8, [r0, #20]
  message->sampleSensADC = sampleSensADC;
 800b38c:	6187      	str	r7, [r0, #24]
  message->V1accu = V1accu;
 800b38e:	61c6      	str	r6, [r0, #28]
  message->V2accu = V2accu;
 800b390:	6205      	str	r5, [r0, #32]
  message->I1max  = I1max;
  message->V2I1max= V2I1max;
  message->I1accu = I1accu;
  message->I2accu = I2accu;
 800b392:	6303      	str	r3, [r0, #48]	; 0x30

  //Send the message to communicator
  if (moduleSendCommand(&moduleComm, CMD_ADC_MEASURE, message) < 0)
 800b394:	f100 0214 	add.w	r2, r0, #20
 800b398:	2102      	movs	r1, #2
 800b39a:	4807      	ldr	r0, [pc, #28]	; (800b3b8 <messageADCMeasure+0x54>)
 800b39c:	f7ff fedc 	bl	800b158 <moduleSendCommand>
 800b3a0:	2800      	cmp	r0, #0
 800b3a2:	da06      	bge.n	800b3b2 <messageADCMeasure+0x4e>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800b3a4:	4620      	mov	r0, r4
 800b3a6:	f002 fb9d 	bl	800dae4 <bFree>
{
  //Allocate resources for data transfer
  messageADCMeasureData_t *message = dAlloc(sizeof(messageADCMeasureData_t));

  if (message == NULL)
    return -1;
 800b3aa:	f04f 30ff 	mov.w	r0, #4294967295
 800b3ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      //Sending failed
      //Free allocated resources
      dFree(message);
      return -1;
    }
  return 0;
 800b3b2:	2000      	movs	r0, #0
}
 800b3b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b3b8:	2001a878 	.word	0x2001a878

0800b3bc <adcMeasure>:

static void adcMeasure(void *data)
{
 800b3bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  messageADCMeasureData_t *message = data;

  communicatorADCMeasure(message->samplesNum, message->sampleSensADC,
 800b3be:	69c3      	ldr	r3, [r0, #28]
 800b3c0:	9303      	str	r3, [sp, #12]
 800b3c2:	6983      	ldr	r3, [r0, #24]
 800b3c4:	9302      	str	r3, [sp, #8]
 800b3c6:	6943      	ldr	r3, [r0, #20]
 800b3c8:	9301      	str	r3, [sp, #4]
 800b3ca:	6903      	ldr	r3, [r0, #16]
 800b3cc:	9300      	str	r3, [sp, #0]
 800b3ce:	4604      	mov	r4, r0
 800b3d0:	1d01      	adds	r1, r0, #4
 800b3d2:	c90e      	ldmia	r1, {r1, r2, r3}
 800b3d4:	f854 0914 	ldr.w	r0, [r4], #-20
 800b3d8:	f7fe fadc 	bl	8009994 <communicatorADCMeasure>
                         message->V1accu, message->V2accu,
                         message->I1max, message->V2I1max, message->I1accu, message->I2accu);
  dFree(message);
 800b3dc:	4620      	mov	r0, r4
}
 800b3de:	b004      	add	sp, #16
 800b3e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  messageADCMeasureData_t *message = data;

  communicatorADCMeasure(message->samplesNum, message->sampleSensADC,
                         message->V1accu, message->V2accu,
                         message->I1max, message->V2I1max, message->I1accu, message->I2accu);
  dFree(message);
 800b3e4:	f002 bb7e 	b.w	800dae4 <bFree>

0800b3e8 <allEvents>:
}

/////////////////////////////////////////////////////////////////////
//Handle timeouts
static void allEvents(void *data)
{
 800b3e8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  (void)data;
  //This function is always called. Regardles of the event type.
#ifdef WATCHDOG_HWCOMM
  wdogFeed(WATCHDOG_HWCOMM(0));
 800b3ec:	2004      	movs	r0, #4
  //check for receive timeout
  portNum_t portNum;
  int subPortNum;
  for (portNum = 0; portNum < PORTS_NUM; portNum++)
    for (subPortNum = 0; subPortNum < 2; subPortNum++)
      if (PORT_BUFFER.rxBufferSize > 0)
 800b3ee:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 800b4cc <allEvents+0xe4>
static void allEvents(void *data)
{
  (void)data;
  //This function is always called. Regardles of the event type.
#ifdef WATCHDOG_HWCOMM
  wdogFeed(WATCHDOG_HWCOMM(0));
 800b3f2:	f003 fcf5 	bl	800ede0 <wdogFeed>
 800b3f6:	2600      	movs	r6, #0
 800b3f8:	4647      	mov	r7, r8
  //check for receive timeout
  portNum_t portNum;
  int subPortNum;
  for (portNum = 0; portNum < PORTS_NUM; portNum++)
    for (subPortNum = 0; subPortNum < 2; subPortNum++)
      if (PORT_BUFFER.rxBufferSize > 0)
 800b3fa:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
 800b3fe:	fa5f f986 	uxtb.w	r9, r6
}

/////////////////////////////////////////////////////////////////////
//Handle timeouts
static void allEvents(void *data)
{
 800b402:	2400      	movs	r4, #0
  //check for receive timeout
  portNum_t portNum;
  int subPortNum;
  for (portNum = 0; portNum < PORTS_NUM; portNum++)
    for (subPortNum = 0; subPortNum < 2; subPortNum++)
      if (PORT_BUFFER.rxBufferSize > 0)
 800b404:	4375      	muls	r5, r6
 800b406:	f04f 0ae0 	mov.w	sl, #224	; 0xe0
 800b40a:	fb0a 5a04 	mla	sl, sl, r4, r5
 800b40e:	44c2      	add	sl, r8
 800b410:	f8da 3004 	ldr.w	r3, [sl, #4]
 800b414:	2b00      	cmp	r3, #0
 800b416:	dd48      	ble.n	800b4aa <allEvents+0xc2>
        {
          if (xTaskGetTickCount() - PORT_BUFFER.timestamp > TIMEOUT_DATA_MS)
 800b418:	f7ff f944 	bl	800a6a4 <xTaskGetTickCount>
 800b41c:	f8da 300c 	ldr.w	r3, [sl, #12]
 800b420:	1ac0      	subs	r0, r0, r3
 800b422:	2814      	cmp	r0, #20
 800b424:	d941      	bls.n	800b4aa <allEvents+0xc2>
            {
              massert(PORT_BUFFER.rxBufferSize > 0);
 800b426:	f8da 3004 	ldr.w	r3, [sl, #4]
 800b42a:	2b00      	cmp	r3, #0
 800b42c:	dd0c      	ble.n	800b448 <allEvents+0x60>

              //Send the buffer to Communicator
              if (messageRx(portNum, PORT_BUFFER.rxBuffer, PORT_BUFFER.rxBufferSize, 0) >= 0)
 800b42e:	21e0      	movs	r1, #224	; 0xe0
 800b430:	fb01 5104 	mla	r1, r1, r4, r5
 800b434:	4439      	add	r1, r7
 800b436:	2300      	movs	r3, #0
 800b438:	684a      	ldr	r2, [r1, #4]
 800b43a:	6809      	ldr	r1, [r1, #0]
 800b43c:	4648      	mov	r0, r9
 800b43e:	f7ff ff4d 	bl	800b2dc <messageRx>
 800b442:	2800      	cmp	r0, #0
 800b444:	da0d      	bge.n	800b462 <allEvents+0x7a>
 800b446:	e022      	b.n	800b48e <allEvents+0xa6>
    for (subPortNum = 0; subPortNum < 2; subPortNum++)
      if (PORT_BUFFER.rxBufferSize > 0)
        {
          if (xTaskGetTickCount() - PORT_BUFFER.timestamp > TIMEOUT_DATA_MS)
            {
              massert(PORT_BUFFER.rxBufferSize > 0);
 800b448:	4b1c      	ldr	r3, [pc, #112]	; (800b4bc <allEvents+0xd4>)
 800b44a:	491d      	ldr	r1, [pc, #116]	; (800b4c0 <allEvents+0xd8>)
 800b44c:	481d      	ldr	r0, [pc, #116]	; (800b4c4 <allEvents+0xdc>)
 800b44e:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 800b452:	f7fd f987 	bl	8008764 <xprintf>
 800b456:	2301      	movs	r3, #1
 800b458:	9300      	str	r3, [sp, #0]
 800b45a:	9b00      	ldr	r3, [sp, #0]
 800b45c:	2b00      	cmp	r3, #0
 800b45e:	d1fc      	bne.n	800b45a <allEvents+0x72>
 800b460:	e7e5      	b.n	800b42e <allEvents+0x46>

              //Send the buffer to Communicator
              if (messageRx(portNum, PORT_BUFFER.rxBuffer, PORT_BUFFER.rxBufferSize, 0) >= 0)
                {
                  //Buffer is now owned by Communicator. New one needs to be allocated
                  PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
 800b462:	2020      	movs	r0, #32
 800b464:	f002 f8e4 	bl	800d630 <bAlloc>
 800b468:	b100      	cbz	r0, 800b46c <allEvents+0x84>
 800b46a:	3014      	adds	r0, #20
 800b46c:	23e0      	movs	r3, #224	; 0xe0
 800b46e:	fb03 5304 	mla	r3, r3, r4, r5
 800b472:	50f8      	str	r0, [r7, r3]
                  massert(PORT_BUFFER.rxBuffer);
 800b474:	b958      	cbnz	r0, 800b48e <allEvents+0xa6>
 800b476:	4b14      	ldr	r3, [pc, #80]	; (800b4c8 <allEvents+0xe0>)
 800b478:	4911      	ldr	r1, [pc, #68]	; (800b4c0 <allEvents+0xd8>)
 800b47a:	4812      	ldr	r0, [pc, #72]	; (800b4c4 <allEvents+0xdc>)
 800b47c:	f240 1273 	movw	r2, #371	; 0x173
 800b480:	f7fd f970 	bl	8008764 <xprintf>
 800b484:	2301      	movs	r3, #1
 800b486:	9301      	str	r3, [sp, #4]
 800b488:	9b01      	ldr	r3, [sp, #4]
 800b48a:	2b00      	cmp	r3, #0
 800b48c:	d1fc      	bne.n	800b488 <allEvents+0xa0>
                }
              PORT_BUFFER.rxBufferSize = 0;
 800b48e:	23e0      	movs	r3, #224	; 0xe0
 800b490:	fb03 5304 	mla	r3, r3, r4, r5
 800b494:	443b      	add	r3, r7
 800b496:	2200      	movs	r2, #0
              PORT_BUFFER.rxExpectedSize = MAX_DATA_SIZE;
 800b498:	2020      	movs	r0, #32
                {
                  //Buffer is now owned by Communicator. New one needs to be allocated
                  PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
                  massert(PORT_BUFFER.rxBuffer);
                }
              PORT_BUFFER.rxBufferSize = 0;
 800b49a:	711a      	strb	r2, [r3, #4]
 800b49c:	715a      	strb	r2, [r3, #5]
 800b49e:	719a      	strb	r2, [r3, #6]
 800b4a0:	71da      	strb	r2, [r3, #7]
              PORT_BUFFER.rxExpectedSize = MAX_DATA_SIZE;
 800b4a2:	7218      	strb	r0, [r3, #8]
 800b4a4:	725a      	strb	r2, [r3, #9]
 800b4a6:	729a      	strb	r2, [r3, #10]
 800b4a8:	72da      	strb	r2, [r3, #11]

  //check for receive timeout
  portNum_t portNum;
  int subPortNum;
  for (portNum = 0; portNum < PORTS_NUM; portNum++)
    for (subPortNum = 0; subPortNum < 2; subPortNum++)
 800b4aa:	3401      	adds	r4, #1
 800b4ac:	2c02      	cmp	r4, #2
 800b4ae:	d1aa      	bne.n	800b406 <allEvents+0x1e>
 800b4b0:	3601      	adds	r6, #1


  //check for receive timeout
  portNum_t portNum;
  int subPortNum;
  for (portNum = 0; portNum < PORTS_NUM; portNum++)
 800b4b2:	2e03      	cmp	r6, #3
 800b4b4:	d1a1      	bne.n	800b3fa <allEvents+0x12>
                }
              PORT_BUFFER.rxBufferSize = 0;
              PORT_BUFFER.rxExpectedSize = MAX_DATA_SIZE;
            }
        }
}
 800b4b6:	b002      	add	sp, #8
 800b4b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b4bc:	08014fc0 	.word	0x08014fc0
 800b4c0:	08014f54 	.word	0x08014f54
 800b4c4:	080148f4 	.word	0x080148f4
 800b4c8:	08014fdd 	.word	0x08014fdd
 800b4cc:	20018498 	.word	0x20018498

0800b4d0 <switchPort>:
  return 0;

}

static void switchPort(void *data)
{
 800b4d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  messageSwitchPort_t *message = data;
  portNum_t portNum = message->portNum;
 800b4d4:	7804      	ldrb	r4, [r0, #0]
  int type = message->type;
 800b4d6:	f8d0 7001 	ldr.w	r7, [r0, #1]

  massert(portNum < PORTS_NUM);
 800b4da:	2c02      	cmp	r4, #2
  return 0;

}

static void switchPort(void *data)
{
 800b4dc:	b087      	sub	sp, #28
 800b4de:	4605      	mov	r5, r0
  messageSwitchPort_t *message = data;
  portNum_t portNum = message->portNum;
  int type = message->type;

  massert(portNum < PORTS_NUM);
 800b4e0:	d814      	bhi.n	800b50c <switchPort+0x3c>
  if(type == portData[portNum].portType)
 800b4e2:	4e3c      	ldr	r6, [pc, #240]	; (800b5d4 <switchPort+0x104>)
 800b4e4:	2350      	movs	r3, #80	; 0x50
 800b4e6:	fb03 6304 	mla	r3, r3, r4, r6
 800b4ea:	7e1b      	ldrb	r3, [r3, #24]
 800b4ec:	429f      	cmp	r7, r3
 800b4ee:	f04f 0300 	mov.w	r3, #0
 800b4f2:	d06a      	beq.n	800b5ca <switchPort+0xfa>
 800b4f4:	f44f 78e0 	mov.w	r8, #448	; 0x1c0

  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
    {
      //Release all buffers
      if(PORT_BUFFER.rxBuffer)
 800b4f8:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 800b5e4 <switchPort+0x114>
 800b4fc:	fb08 f204 	mul.w	r2, r8, r4
 800b500:	9201      	str	r2, [sp, #4]
  messageSwitchPort_t *message = data;
  portNum_t portNum = message->portNum;
  int type = message->type;

  massert(portNum < PORTS_NUM);
  if(type == portData[portNum].portType)
 800b502:	4698      	mov	r8, r3

  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
    {
      //Release all buffers
      if(PORT_BUFFER.rxBuffer)
 800b504:	f04f 0be0 	mov.w	fp, #224	; 0xe0
 800b508:	46ca      	mov	sl, r9
 800b50a:	e02f      	b.n	800b56c <switchPort+0x9c>
{
  messageSwitchPort_t *message = data;
  portNum_t portNum = message->portNum;
  int type = message->type;

  massert(portNum < PORTS_NUM);
 800b50c:	4b32      	ldr	r3, [pc, #200]	; (800b5d8 <switchPort+0x108>)
 800b50e:	4933      	ldr	r1, [pc, #204]	; (800b5dc <switchPort+0x10c>)
 800b510:	4833      	ldr	r0, [pc, #204]	; (800b5e0 <switchPort+0x110>)
 800b512:	f240 12a5 	movw	r2, #421	; 0x1a5
 800b516:	f7fd f925 	bl	8008764 <xprintf>
 800b51a:	2301      	movs	r3, #1
 800b51c:	9305      	str	r3, [sp, #20]
 800b51e:	9b05      	ldr	r3, [sp, #20]
 800b520:	2b00      	cmp	r3, #0
 800b522:	d1fc      	bne.n	800b51e <switchPort+0x4e>
 800b524:	e7dd      	b.n	800b4e2 <switchPort+0x12>
          dFree(PORT_BUFFER.rxBuffer);
          PORT_BUFFER.rxBuffer=NULL;
        }
      int txQueueSize;
      for(txQueueSize = 0; txQueueSize < WAIT_QUEUE_SIZE; txQueueSize++)
        if(PORT_BUFFER.txBuffer[txQueueSize])
 800b526:	2170      	movs	r1, #112	; 0x70
 800b528:	4361      	muls	r1, r4
 800b52a:	2038      	movs	r0, #56	; 0x38
  messageSwitchPort_t *message = data;
  portNum_t portNum = message->portNum;
  int type = message->type;

  massert(portNum < PORTS_NUM);
  if(type == portData[portNum].portType)
 800b52c:	2200      	movs	r2, #0
          dFree(PORT_BUFFER.rxBuffer);
          PORT_BUFFER.rxBuffer=NULL;
        }
      int txQueueSize;
      for(txQueueSize = 0; txQueueSize < WAIT_QUEUE_SIZE; txQueueSize++)
        if(PORT_BUFFER.txBuffer[txQueueSize])
 800b52e:	fb00 1108 	mla	r1, r0, r8, r1
 800b532:	1888      	adds	r0, r1, r2
 800b534:	3006      	adds	r0, #6
 800b536:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 800b53a:	6840      	ldr	r0, [r0, #4]
 800b53c:	b130      	cbz	r0, 800b54c <switchPort+0x7c>
          {
            dFree(PORT_BUFFER.txBuffer[txQueueSize]);
 800b53e:	3814      	subs	r0, #20
 800b540:	9103      	str	r1, [sp, #12]
 800b542:	9202      	str	r2, [sp, #8]
 800b544:	f002 face 	bl	800dae4 <bFree>
 800b548:	9903      	ldr	r1, [sp, #12]
 800b54a:	9a02      	ldr	r2, [sp, #8]
        {
          dFree(PORT_BUFFER.rxBuffer);
          PORT_BUFFER.rxBuffer=NULL;
        }
      int txQueueSize;
      for(txQueueSize = 0; txQueueSize < WAIT_QUEUE_SIZE; txQueueSize++)
 800b54c:	3201      	adds	r2, #1
 800b54e:	2a10      	cmp	r2, #16
 800b550:	d1ef      	bne.n	800b532 <switchPort+0x62>
        if(PORT_BUFFER.txBuffer[txQueueSize])
          {
            dFree(PORT_BUFFER.txBuffer[txQueueSize]);
          }
      memset(&PORT_BUFFER, 0, sizeof(portBuffer[0][0]));
 800b552:	9b01      	ldr	r3, [sp, #4]
 800b554:	fb0b 3008 	mla	r0, fp, r8, r3
 800b558:	22e0      	movs	r2, #224	; 0xe0
 800b55a:	2100      	movs	r1, #0
 800b55c:	4450      	add	r0, sl
      message->wait = 0;
      return;
    }

  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
 800b55e:	f108 0801 	add.w	r8, r8, #1
      for(txQueueSize = 0; txQueueSize < WAIT_QUEUE_SIZE; txQueueSize++)
        if(PORT_BUFFER.txBuffer[txQueueSize])
          {
            dFree(PORT_BUFFER.txBuffer[txQueueSize]);
          }
      memset(&PORT_BUFFER, 0, sizeof(portBuffer[0][0]));
 800b562:	f009 f80f 	bl	8014584 <memset>
      message->wait = 0;
      return;
    }

  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
 800b566:	f1b8 0f02 	cmp.w	r8, #2
 800b56a:	d017      	beq.n	800b59c <switchPort+0xcc>
    {
      //Release all buffers
      if(PORT_BUFFER.rxBuffer)
 800b56c:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 800b570:	4362      	muls	r2, r4
 800b572:	fb0b 2208 	mla	r2, fp, r8, r2
 800b576:	eb09 0102 	add.w	r1, r9, r2
 800b57a:	9203      	str	r2, [sp, #12]
 800b57c:	6808      	ldr	r0, [r1, #0]
 800b57e:	9102      	str	r1, [sp, #8]
 800b580:	2800      	cmp	r0, #0
 800b582:	d0d0      	beq.n	800b526 <switchPort+0x56>
        {
          dFree(PORT_BUFFER.rxBuffer);
 800b584:	3814      	subs	r0, #20
 800b586:	f002 faad 	bl	800dae4 <bFree>
          PORT_BUFFER.rxBuffer=NULL;
 800b58a:	9902      	ldr	r1, [sp, #8]
 800b58c:	9a03      	ldr	r2, [sp, #12]
 800b58e:	2000      	movs	r0, #0
 800b590:	f809 0002 	strb.w	r0, [r9, r2]
 800b594:	7048      	strb	r0, [r1, #1]
 800b596:	7088      	strb	r0, [r1, #2]
 800b598:	70c8      	strb	r0, [r1, #3]
 800b59a:	e7c4      	b.n	800b526 <switchPort+0x56>
 800b59c:	2350      	movs	r3, #80	; 0x50
          {
            dFree(PORT_BUFFER.txBuffer[txQueueSize]);
          }
      memset(&PORT_BUFFER, 0, sizeof(portBuffer[0][0]));
    }
  if(type == PORT_TYPE_USART && portData[portNum].UARThelper)
 800b59e:	b937      	cbnz	r7, 800b5ae <switchPort+0xde>
 800b5a0:	fb03 6304 	mla	r3, r3, r4, r6
 800b5a4:	695a      	ldr	r2, [r3, #20]
 800b5a6:	b152      	cbz	r2, 800b5be <switchPort+0xee>
    {
      portData[portNum].portType    = PORT_TYPE_USART;
 800b5a8:	761f      	strb	r7, [r3, #24]
      message->wait = 0;
 800b5aa:	716f      	strb	r7, [r5, #5]
      return;
 800b5ac:	e00e      	b.n	800b5cc <switchPort+0xfc>
    }
  if(type == PORT_TYPE_SPI && portData[portNum].SPIhelper)
 800b5ae:	2f01      	cmp	r7, #1
 800b5b0:	d105      	bne.n	800b5be <switchPort+0xee>
 800b5b2:	fb03 6304 	mla	r3, r3, r4, r6
 800b5b6:	691a      	ldr	r2, [r3, #16]
 800b5b8:	b10a      	cbz	r2, 800b5be <switchPort+0xee>
    {
      portData[portNum].portType    = PORT_TYPE_SPI;
 800b5ba:	761f      	strb	r7, [r3, #24]
 800b5bc:	e004      	b.n	800b5c8 <switchPort+0xf8>
      message->wait = 0;
      return;
    }
  portData[portNum].portType    = PORT_TYPE_NONE;
 800b5be:	2350      	movs	r3, #80	; 0x50
 800b5c0:	fb03 6404 	mla	r4, r3, r4, r6
 800b5c4:	2302      	movs	r3, #2
 800b5c6:	7623      	strb	r3, [r4, #24]
  message->wait = 0;
 800b5c8:	2300      	movs	r3, #0
 800b5ca:	716b      	strb	r3, [r5, #5]
}
 800b5cc:	b007      	add	sp, #28
 800b5ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b5d2:	bf00      	nop
 800b5d4:	2001aabc 	.word	0x2001aabc
 800b5d8:	08014ff2 	.word	0x08014ff2
 800b5dc:	08014f5e 	.word	0x08014f5e
 800b5e0:	080148f4 	.word	0x080148f4
 800b5e4:	20018498 	.word	0x20018498

0800b5e8 <portRx>:
        }
    }
}

static void portRx(void *data)
{
 800b5e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  portSubport_t message = {.raw = (uint32_t) data};
  portNum_t portNum = message.portNum;
 800b5ec:	b2c5      	uxtb	r5, r0
        }
    }
}

static void portRx(void *data)
{
 800b5ee:	b085      	sub	sp, #20

  portSubport_t message = {.raw = (uint32_t) data};
  portNum_t portNum = message.portNum;
  int subPortNum = message.subPortNum;
  massert(portNum < PORTS_NUM);
 800b5f0:	2d02      	cmp	r5, #2
}

static void portRx(void *data)
{

  portSubport_t message = {.raw = (uint32_t) data};
 800b5f2:	9000      	str	r0, [sp, #0]
  portNum_t portNum = message.portNum;
  int subPortNum = message.subPortNum;
 800b5f4:	f3c0 2607 	ubfx	r6, r0, #8, #8
  massert(portNum < PORTS_NUM);
 800b5f8:	d80b      	bhi.n	800b612 <portRx+0x2a>

  //Get data from the port if available
  int size;

  if (PORT_BUFFER.rxBuffer == NULL)
 800b5fa:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800b5fe:	fb03 f205 	mul.w	r2, r3, r5
 800b602:	23e0      	movs	r3, #224	; 0xe0
 800b604:	4f62      	ldr	r7, [pc, #392]	; (800b790 <portRx+0x1a8>)
 800b606:	fb03 2306 	mla	r3, r3, r6, r2
 800b60a:	58fb      	ldr	r3, [r7, r3]
 800b60c:	2b00      	cmp	r3, #0
 800b60e:	d13a      	bne.n	800b686 <portRx+0x9e>
 800b610:	e00c      	b.n	800b62c <portRx+0x44>
{

  portSubport_t message = {.raw = (uint32_t) data};
  portNum_t portNum = message.portNum;
  int subPortNum = message.subPortNum;
  massert(portNum < PORTS_NUM);
 800b612:	4b60      	ldr	r3, [pc, #384]	; (800b794 <portRx+0x1ac>)
 800b614:	4960      	ldr	r1, [pc, #384]	; (800b798 <portRx+0x1b0>)
 800b616:	4861      	ldr	r0, [pc, #388]	; (800b79c <portRx+0x1b4>)
 800b618:	f240 1229 	movw	r2, #297	; 0x129
 800b61c:	f7fd f8a2 	bl	8008764 <xprintf>
 800b620:	2301      	movs	r3, #1
 800b622:	9301      	str	r3, [sp, #4]
 800b624:	9b01      	ldr	r3, [sp, #4]
 800b626:	2b00      	cmp	r3, #0
 800b628:	d1fc      	bne.n	800b624 <portRx+0x3c>
 800b62a:	e7e6      	b.n	800b5fa <portRx+0x12>
  int size;

  if (PORT_BUFFER.rxBuffer == NULL)
    {
      //Allocate a buffer for the message
      PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
 800b62c:	2020      	movs	r0, #32
 800b62e:	f001 ffff 	bl	800d630 <bAlloc>
 800b632:	b100      	cbz	r0, 800b636 <portRx+0x4e>
 800b634:	3014      	adds	r0, #20
 800b636:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800b63a:	fb03 f205 	mul.w	r2, r3, r5
 800b63e:	23e0      	movs	r3, #224	; 0xe0
 800b640:	fb03 2306 	mla	r3, r3, r6, r2
 800b644:	50f8      	str	r0, [r7, r3]
      massert(PORT_BUFFER.rxBuffer);
 800b646:	b188      	cbz	r0, 800b66c <portRx+0x84>
      PORT_BUFFER.rxBufferSize = 0;
 800b648:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800b64c:	22e0      	movs	r2, #224	; 0xe0
 800b64e:	436b      	muls	r3, r5
 800b650:	fb02 3306 	mla	r3, r2, r6, r3
 800b654:	443b      	add	r3, r7
 800b656:	2200      	movs	r2, #0
      PORT_BUFFER.rxExpectedSize = 1;
 800b658:	2001      	movs	r0, #1
  if (PORT_BUFFER.rxBuffer == NULL)
    {
      //Allocate a buffer for the message
      PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
      massert(PORT_BUFFER.rxBuffer);
      PORT_BUFFER.rxBufferSize = 0;
 800b65a:	711a      	strb	r2, [r3, #4]
 800b65c:	715a      	strb	r2, [r3, #5]
 800b65e:	719a      	strb	r2, [r3, #6]
 800b660:	71da      	strb	r2, [r3, #7]
      PORT_BUFFER.rxExpectedSize = 1;
 800b662:	7218      	strb	r0, [r3, #8]
 800b664:	725a      	strb	r2, [r3, #9]
 800b666:	729a      	strb	r2, [r3, #10]
 800b668:	72da      	strb	r2, [r3, #11]
 800b66a:	e00c      	b.n	800b686 <portRx+0x9e>

  if (PORT_BUFFER.rxBuffer == NULL)
    {
      //Allocate a buffer for the message
      PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
      massert(PORT_BUFFER.rxBuffer);
 800b66c:	4b4c      	ldr	r3, [pc, #304]	; (800b7a0 <portRx+0x1b8>)
 800b66e:	494a      	ldr	r1, [pc, #296]	; (800b798 <portRx+0x1b0>)
 800b670:	484a      	ldr	r0, [pc, #296]	; (800b79c <portRx+0x1b4>)
 800b672:	f44f 7299 	mov.w	r2, #306	; 0x132
 800b676:	f7fd f875 	bl	8008764 <xprintf>
 800b67a:	2301      	movs	r3, #1
 800b67c:	9302      	str	r3, [sp, #8]
 800b67e:	9b02      	ldr	r3, [sp, #8]
 800b680:	2b00      	cmp	r3, #0
 800b682:	d1fc      	bne.n	800b67e <portRx+0x96>
 800b684:	e7e0      	b.n	800b648 <portRx+0x60>
      PORT_BUFFER.rxBufferSize = 0;
      PORT_BUFFER.rxExpectedSize = 1;
    }
  //Get data from receiver
  while((size = portData[portNum].receiveData[subPortNum](portNum, &(PORT_BUFFER.rxBuffer[PORT_BUFFER.rxBufferSize]),
 800b686:	f04f 0814 	mov.w	r8, #20
 800b68a:	fb08 6805 	mla	r8, r8, r5, r6
 800b68e:	f44f 74e0 	mov.w	r4, #448	; 0x1c0
 800b692:	436c      	muls	r4, r5
 800b694:	23e0      	movs	r3, #224	; 0xe0
 800b696:	fb03 4406 	mla	r4, r3, r6, r4
 800b69a:	443c      	add	r4, r7
                PORT_BUFFER.rxExpectedSize - PORT_BUFFER.rxBufferSize)))
 800b69c:	46a2      	mov	sl, r4
      massert(PORT_BUFFER.rxBuffer);
      PORT_BUFFER.rxBufferSize = 0;
      PORT_BUFFER.rxExpectedSize = 1;
    }
  //Get data from receiver
  while((size = portData[portNum].receiveData[subPortNum](portNum, &(PORT_BUFFER.rxBuffer[PORT_BUFFER.rxBufferSize]),
 800b69e:	6861      	ldr	r1, [r4, #4]
 800b6a0:	6820      	ldr	r0, [r4, #0]
                PORT_BUFFER.rxExpectedSize - PORT_BUFFER.rxBufferSize)))
 800b6a2:	f85a 2f08 	ldr.w	r2, [sl, #8]!
      massert(PORT_BUFFER.rxBuffer);
      PORT_BUFFER.rxBufferSize = 0;
      PORT_BUFFER.rxExpectedSize = 1;
    }
  //Get data from receiver
  while((size = portData[portNum].receiveData[subPortNum](portNum, &(PORT_BUFFER.rxBuffer[PORT_BUFFER.rxBufferSize]),
 800b6a6:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 800b7a4 <portRx+0x1bc>
 800b6aa:	1a52      	subs	r2, r2, r1
 800b6ac:	f859 3028 	ldr.w	r3, [r9, r8, lsl #2]
 800b6b0:	4401      	add	r1, r0
 800b6b2:	4628      	mov	r0, r5
 800b6b4:	4798      	blx	r3
 800b6b6:	4683      	mov	fp, r0
 800b6b8:	2800      	cmp	r0, #0
 800b6ba:	d065      	beq.n	800b788 <portRx+0x1a0>
                PORT_BUFFER.rxExpectedSize - PORT_BUFFER.rxBufferSize)))
    {
      if (PORT_BUFFER.rxBufferSize == 0)
 800b6bc:	6863      	ldr	r3, [r4, #4]
 800b6be:	b963      	cbnz	r3, 800b6da <portRx+0xf2>
        {
          //This is a first byte of message. Get expected size and remember time for timeout.
          PORT_BUFFER.rxExpectedSize = expectedMsgSize(portNum, msgTab(PORT_BUFFER.rxBuffer[0]));
 800b6c0:	6823      	ldr	r3, [r4, #0]
 800b6c2:	7818      	ldrb	r0, [r3, #0]
 800b6c4:	f7fd f884 	bl	80087d0 <msgTab>
 800b6c8:	4601      	mov	r1, r0
 800b6ca:	4628      	mov	r0, r5
 800b6cc:	f7fd f894 	bl	80087f8 <expectedMsgSize>
 800b6d0:	60a0      	str	r0, [r4, #8]
          PORT_BUFFER.timestamp = xTaskGetTickCount();
 800b6d2:	f7fe ffe7 	bl	800a6a4 <xTaskGetTickCount>
 800b6d6:	f8ca 0004 	str.w	r0, [sl, #4]
        }
      PORT_BUFFER.rxBufferSize += size;
 800b6da:	6860      	ldr	r0, [r4, #4]

      //Is the message complete?
      if (PORT_BUFFER.rxBufferSize >= PORT_BUFFER.rxExpectedSize)
 800b6dc:	68a3      	ldr	r3, [r4, #8]
        {
          //This is a first byte of message. Get expected size and remember time for timeout.
          PORT_BUFFER.rxExpectedSize = expectedMsgSize(portNum, msgTab(PORT_BUFFER.rxBuffer[0]));
          PORT_BUFFER.timestamp = xTaskGetTickCount();
        }
      PORT_BUFFER.rxBufferSize += size;
 800b6de:	4458      	add	r0, fp

      //Is the message complete?
      if (PORT_BUFFER.rxBufferSize >= PORT_BUFFER.rxExpectedSize)
 800b6e0:	4298      	cmp	r0, r3
        {
          //This is a first byte of message. Get expected size and remember time for timeout.
          PORT_BUFFER.rxExpectedSize = expectedMsgSize(portNum, msgTab(PORT_BUFFER.rxBuffer[0]));
          PORT_BUFFER.timestamp = xTaskGetTickCount();
        }
      PORT_BUFFER.rxBufferSize += size;
 800b6e2:	6060      	str	r0, [r4, #4]

      //Is the message complete?
      if (PORT_BUFFER.rxBufferSize >= PORT_BUFFER.rxExpectedSize)
 800b6e4:	dbda      	blt.n	800b69c <portRx+0xb4>
        {
          //Connection keepalive
          if(PORT_BUFFER.rxBuffer[0] == 0x55 || (PORT_BUFFER.rxBuffer[0]&0xc0) == 0xc0)
 800b6e6:	6823      	ldr	r3, [r4, #0]
 800b6e8:	781b      	ldrb	r3, [r3, #0]
 800b6ea:	2b55      	cmp	r3, #85	; 0x55
 800b6ec:	d003      	beq.n	800b6f6 <portRx+0x10e>
 800b6ee:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800b6f2:	2bc0      	cmp	r3, #192	; 0xc0
 800b6f4:	d104      	bne.n	800b700 <portRx+0x118>
            portData[portNum].tsLastSeenSubPort[subPortNum] = xTaskGetTickCount();
 800b6f6:	f7fe ffd5 	bl	800a6a4 <xTaskGetTickCount>
 800b6fa:	eb09 0388 	add.w	r3, r9, r8, lsl #2
 800b6fe:	63d8      	str	r0, [r3, #60]	; 0x3c
          //Send the buffer to Communicator
          if(portData[portNum].portType == subPortNum)
 800b700:	2350      	movs	r3, #80	; 0x50
 800b702:	fb03 9905 	mla	r9, r3, r5, r9
 800b706:	f899 3018 	ldrb.w	r3, [r9, #24]
 800b70a:	429e      	cmp	r6, r3
 800b70c:	d011      	beq.n	800b732 <portRx+0x14a>
                  //Buffer is now owned by Communicator. New one needs to be allocated
                  PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
                  massert(PORT_BUFFER.rxBuffer);
                }
            }
          PORT_BUFFER.rxBufferSize = 0;
 800b70e:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800b712:	22e0      	movs	r2, #224	; 0xe0
 800b714:	436b      	muls	r3, r5
 800b716:	fb02 3306 	mla	r3, r2, r6, r3
 800b71a:	443b      	add	r3, r7
 800b71c:	2200      	movs	r2, #0
          PORT_BUFFER.rxExpectedSize = 1;
 800b71e:	2001      	movs	r0, #1
                  //Buffer is now owned by Communicator. New one needs to be allocated
                  PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
                  massert(PORT_BUFFER.rxBuffer);
                }
            }
          PORT_BUFFER.rxBufferSize = 0;
 800b720:	711a      	strb	r2, [r3, #4]
 800b722:	715a      	strb	r2, [r3, #5]
 800b724:	719a      	strb	r2, [r3, #6]
 800b726:	71da      	strb	r2, [r3, #7]
          PORT_BUFFER.rxExpectedSize = 1;
 800b728:	7218      	strb	r0, [r3, #8]
 800b72a:	725a      	strb	r2, [r3, #9]
 800b72c:	729a      	strb	r2, [r3, #10]
 800b72e:	72da      	strb	r2, [r3, #11]
 800b730:	e7ad      	b.n	800b68e <portRx+0xa6>
          if(PORT_BUFFER.rxBuffer[0] == 0x55 || (PORT_BUFFER.rxBuffer[0]&0xc0) == 0xc0)
            portData[portNum].tsLastSeenSubPort[subPortNum] = xTaskGetTickCount();
          //Send the buffer to Communicator
          if(portData[portNum].portType == subPortNum)
            {
              if (messageRx(portNum, PORT_BUFFER.rxBuffer, PORT_BUFFER.rxBufferSize, 0) >= 0)
 800b732:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
 800b736:	23e0      	movs	r3, #224	; 0xe0
 800b738:	4369      	muls	r1, r5
 800b73a:	fb03 1106 	mla	r1, r3, r6, r1
 800b73e:	4439      	add	r1, r7
 800b740:	2300      	movs	r3, #0
 800b742:	684a      	ldr	r2, [r1, #4]
 800b744:	6809      	ldr	r1, [r1, #0]
 800b746:	4628      	mov	r0, r5
 800b748:	f7ff fdc8 	bl	800b2dc <messageRx>
 800b74c:	2800      	cmp	r0, #0
 800b74e:	dbde      	blt.n	800b70e <portRx+0x126>
                {
                  //Buffer is now owned by Communicator. New one needs to be allocated
                  PORT_BUFFER.rxBuffer = dAlloc(MAX_DATA_SIZE);
 800b750:	2020      	movs	r0, #32
 800b752:	f001 ff6d 	bl	800d630 <bAlloc>
 800b756:	b100      	cbz	r0, 800b75a <portRx+0x172>
 800b758:	3014      	adds	r0, #20
 800b75a:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800b75e:	fb03 f205 	mul.w	r2, r3, r5
 800b762:	23e0      	movs	r3, #224	; 0xe0
 800b764:	fb03 2306 	mla	r3, r3, r6, r2
 800b768:	50f8      	str	r0, [r7, r3]
                  massert(PORT_BUFFER.rxBuffer);
 800b76a:	2800      	cmp	r0, #0
 800b76c:	d1cf      	bne.n	800b70e <portRx+0x126>
 800b76e:	4b0c      	ldr	r3, [pc, #48]	; (800b7a0 <portRx+0x1b8>)
 800b770:	4909      	ldr	r1, [pc, #36]	; (800b798 <portRx+0x1b0>)
 800b772:	480a      	ldr	r0, [pc, #40]	; (800b79c <portRx+0x1b4>)
 800b774:	f240 124f 	movw	r2, #335	; 0x14f
 800b778:	f7fc fff4 	bl	8008764 <xprintf>
 800b77c:	2301      	movs	r3, #1
 800b77e:	9303      	str	r3, [sp, #12]
 800b780:	9b03      	ldr	r3, [sp, #12]
 800b782:	2b00      	cmp	r3, #0
 800b784:	d1fc      	bne.n	800b780 <portRx+0x198>
 800b786:	e7c2      	b.n	800b70e <portRx+0x126>
            }
          PORT_BUFFER.rxBufferSize = 0;
          PORT_BUFFER.rxExpectedSize = 1;
        }
    }
}
 800b788:	b005      	add	sp, #20
 800b78a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b78e:	bf00      	nop
 800b790:	20018498 	.word	0x20018498
 800b794:	08014ff2 	.word	0x08014ff2
 800b798:	08014f69 	.word	0x08014f69
 800b79c:	080148f4 	.word	0x080148f4
 800b7a0:	08014fdd 	.word	0x08014fdd
 800b7a4:	2001aabc 	.word	0x2001aabc

0800b7a8 <portTx>:
    }
  return 0;
}

static void portTx(void *data)
{
 800b7a8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  portSubport_t message = {.raw = (uint32_t) data};
  portNum_t portNum = message.portNum;
 800b7ac:	b2c4      	uxtb	r4, r0
  massert(portNum < PORTS_NUM);
 800b7ae:	2c02      	cmp	r4, #2
  return 0;
}

static void portTx(void *data)
{
  portSubport_t message = {.raw = (uint32_t) data};
 800b7b0:	9000      	str	r0, [sp, #0]
  portNum_t portNum = message.portNum;
  massert(portNum < PORTS_NUM);
 800b7b2:	d817      	bhi.n	800b7e4 <portTx+0x3c>
  int subPortNum = message.subPortNum;
 800b7b4:	f89d 7001 	ldrb.w	r7, [sp, #1]
  if (TX_BUFFER_H)
 800b7b8:	4856      	ldr	r0, [pc, #344]	; (800b914 <portTx+0x16c>)
 800b7ba:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 800b7be:	23e0      	movs	r3, #224	; 0xe0
 800b7c0:	4362      	muls	r2, r4
 800b7c2:	fb03 2207 	mla	r2, r3, r7, r2
 800b7c6:	4402      	add	r2, r0
 800b7c8:	2170      	movs	r1, #112	; 0x70
 800b7ca:	4361      	muls	r1, r4
 800b7cc:	6913      	ldr	r3, [r2, #16]
 800b7ce:	2538      	movs	r5, #56	; 0x38
 800b7d0:	fb05 1507 	mla	r5, r5, r7, r1
 800b7d4:	442b      	add	r3, r5
 800b7d6:	1d99      	adds	r1, r3, #6
 800b7d8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800b7dc:	4680      	mov	r8, r0
 800b7de:	6849      	ldr	r1, [r1, #4]
 800b7e0:	b969      	cbnz	r1, 800b7fe <portTx+0x56>
 800b7e2:	e094      	b.n	800b90e <portTx+0x166>

static void portTx(void *data)
{
  portSubport_t message = {.raw = (uint32_t) data};
  portNum_t portNum = message.portNum;
  massert(portNum < PORTS_NUM);
 800b7e4:	4b4c      	ldr	r3, [pc, #304]	; (800b918 <portTx+0x170>)
 800b7e6:	494d      	ldr	r1, [pc, #308]	; (800b91c <portTx+0x174>)
 800b7e8:	484d      	ldr	r0, [pc, #308]	; (800b920 <portTx+0x178>)
 800b7ea:	f44f 7283 	mov.w	r2, #262	; 0x106
 800b7ee:	f7fc ffb9 	bl	8008764 <xprintf>
 800b7f2:	2301      	movs	r3, #1
 800b7f4:	9301      	str	r3, [sp, #4]
 800b7f6:	9b01      	ldr	r3, [sp, #4]
 800b7f8:	2b00      	cmp	r3, #0
 800b7fa:	d1fc      	bne.n	800b7f6 <portTx+0x4e>
 800b7fc:	e7da      	b.n	800b7b4 <portTx+0xc>
  int subPortNum = message.subPortNum;
  if (TX_BUFFER_H)
    {
      if (TX_BUFFER_SIZE_H == 0)
 800b7fe:	3316      	adds	r3, #22
 800b800:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800b804:	685b      	ldr	r3, [r3, #4]
 800b806:	2b00      	cmp	r3, #0
 800b808:	d147      	bne.n	800b89a <portTx+0xf2>
        {
          //All data transmitted. Send Tx Complete message
          while (messageTxComplete(portNum, COMM_TX_SUCCESS, TX_HANDLE_H) < 0)
 800b80a:	4616      	mov	r6, r2
 800b80c:	46b1      	mov	r9, r6
 800b80e:	2101      	movs	r1, #1
 800b810:	f859 3f10 	ldr.w	r3, [r9, #16]!
 800b814:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 800b914 <portTx+0x16c>
 800b818:	442b      	add	r3, r5
 800b81a:	3326      	adds	r3, #38	; 0x26
 800b81c:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800b820:	4620      	mov	r0, r4
 800b822:	685a      	ldr	r2, [r3, #4]
 800b824:	f7ff fd80 	bl	800b328 <messageTxComplete>
 800b828:	2800      	cmp	r0, #0
 800b82a:	da03      	bge.n	800b834 <portTx+0x8c>
            {
              //Sending failed. Try again
              vTaskDelay(1);
 800b82c:	2001      	movs	r0, #1
 800b82e:	f7ff f82f 	bl	800a890 <vTaskDelay>
 800b832:	e7eb      	b.n	800b80c <portTx+0x64>
            }
          dFree(TX_BUFFER_H);
 800b834:	f8d9 3000 	ldr.w	r3, [r9]
 800b838:	442b      	add	r3, r5
 800b83a:	3306      	adds	r3, #6
 800b83c:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 800b840:	6858      	ldr	r0, [r3, #4]
 800b842:	3814      	subs	r0, #20
 800b844:	f002 f94e 	bl	800dae4 <bFree>
          TX_BUFFER_H = NULL;
 800b848:	f8d9 1000 	ldr.w	r1, [r9]
 800b84c:	440d      	add	r5, r1
 800b84e:	3506      	adds	r5, #6
 800b850:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
 800b854:	2300      	movs	r3, #0
 800b856:	712b      	strb	r3, [r5, #4]
 800b858:	716b      	strb	r3, [r5, #5]
 800b85a:	71ab      	strb	r3, [r5, #6]
 800b85c:	71eb      	strb	r3, [r5, #7]
          TX_BUFFER_OFFSET = 0;
 800b85e:	f886 30dc 	strb.w	r3, [r6, #220]	; 0xdc
 800b862:	f886 30dd 	strb.w	r3, [r6, #221]	; 0xdd
 800b866:	f886 30de 	strb.w	r3, [r6, #222]	; 0xde
 800b86a:	f886 30df 	strb.w	r3, [r6, #223]	; 0xdf
          TX_HEAD = (TX_HEAD + 1) % WAIT_QUEUE_SIZE;
 800b86e:	4b2d      	ldr	r3, [pc, #180]	; (800b924 <portTx+0x17c>)
 800b870:	3101      	adds	r1, #1
 800b872:	400b      	ands	r3, r1
 800b874:	2b00      	cmp	r3, #0
 800b876:	bfbe      	ittt	lt
 800b878:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800b87c:	f063 030f 	ornlt	r3, r3, #15
 800b880:	3301      	addlt	r3, #1
 800b882:	f8c9 3000 	str.w	r3, [r9]
          TX_NUM--;
 800b886:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800b88a:	22e0      	movs	r2, #224	; 0xe0
 800b88c:	4363      	muls	r3, r4
 800b88e:	fb02 3307 	mla	r3, r2, r7, r3
 800b892:	4443      	add	r3, r8
 800b894:	699a      	ldr	r2, [r3, #24]
 800b896:	3a01      	subs	r2, #1
 800b898:	619a      	str	r2, [r3, #24]
        }
      if (TX_NUM)
 800b89a:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
 800b89e:	23e0      	movs	r3, #224	; 0xe0
 800b8a0:	4365      	muls	r5, r4
 800b8a2:	fb03 5507 	mla	r5, r3, r7, r5
 800b8a6:	4445      	add	r5, r8
 800b8a8:	4e1a      	ldr	r6, [pc, #104]	; (800b914 <portTx+0x16c>)
 800b8aa:	69ab      	ldr	r3, [r5, #24]
 800b8ac:	b37b      	cbz	r3, 800b90e <portTx+0x166>
        {
          //Next buffer is waiting
          int sentSize = portData[portNum].sendData[subPortNum](portNum, &(TX_BUFFER_H[TX_BUFFER_OFFSET]), TX_BUFFER_SIZE_H);
 800b8ae:	46a9      	mov	r9, r5
 800b8b0:	f04f 0870 	mov.w	r8, #112	; 0x70
 800b8b4:	f859 3f10 	ldr.w	r3, [r9, #16]!
 800b8b8:	f8d5 00dc 	ldr.w	r0, [r5, #220]	; 0xdc
 800b8bc:	fb08 f204 	mul.w	r2, r8, r4
 800b8c0:	f04f 0838 	mov.w	r8, #56	; 0x38
 800b8c4:	fb08 2807 	mla	r8, r8, r7, r2
 800b8c8:	4443      	add	r3, r8
 800b8ca:	f103 0216 	add.w	r2, r3, #22
 800b8ce:	3306      	adds	r3, #6
 800b8d0:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800b8d4:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 800b8d8:	6859      	ldr	r1, [r3, #4]
 800b8da:	6852      	ldr	r2, [r2, #4]
 800b8dc:	2314      	movs	r3, #20
 800b8de:	fb03 7704 	mla	r7, r3, r4, r7
 800b8e2:	3702      	adds	r7, #2
 800b8e4:	4b10      	ldr	r3, [pc, #64]	; (800b928 <portTx+0x180>)
 800b8e6:	4401      	add	r1, r0
 800b8e8:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 800b8ec:	4620      	mov	r0, r4
 800b8ee:	4798      	blx	r3

          TX_BUFFER_OFFSET += sentSize;
 800b8f0:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 800b8f4:	4403      	add	r3, r0
 800b8f6:	f8c5 30dc 	str.w	r3, [r5, #220]	; 0xdc
          TX_BUFFER_SIZE_H -= sentSize;
 800b8fa:	f8d9 3000 	ldr.w	r3, [r9]
 800b8fe:	4498      	add	r8, r3
 800b900:	f108 0816 	add.w	r8, r8, #22
 800b904:	eb06 0688 	add.w	r6, r6, r8, lsl #2
 800b908:	6873      	ldr	r3, [r6, #4]
 800b90a:	1a18      	subs	r0, r3, r0
 800b90c:	6070      	str	r0, [r6, #4]
        }
    }
}
 800b90e:	b002      	add	sp, #8
 800b910:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b914:	20018498 	.word	0x20018498
 800b918:	08014ff2 	.word	0x08014ff2
 800b91c:	08014f70 	.word	0x08014f70
 800b920:	080148f4 	.word	0x080148f4
 800b924:	8000000f 	.word	0x8000000f
 800b928:	2001aabc 	.word	0x2001aabc

0800b92c <commTx>:
#define TX_BUFFER_SIZE_T PORT_BUFFER.txBufferSize[TX_TAIL]
#define TX_HANDLE_T      PORT_BUFFER.handle[TX_TAIL]

#define TX_BUFFER_OFFSET PORT_BUFFER.txBufferOffset
static void commTx(void *data)
{
 800b92c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  messageTxData_t *message = data;
  portNum_t portNum = message->portNum;
 800b930:	7805      	ldrb	r5, [r0, #0]

  massert(portNum < PORTS_NUM);
 800b932:	2d02      	cmp	r5, #2
#define TX_BUFFER_SIZE_T PORT_BUFFER.txBufferSize[TX_TAIL]
#define TX_HANDLE_T      PORT_BUFFER.handle[TX_TAIL]

#define TX_BUFFER_OFFSET PORT_BUFFER.txBufferOffset
static void commTx(void *data)
{
 800b934:	b085      	sub	sp, #20
 800b936:	4604      	mov	r4, r0
  messageTxData_t *message = data;
  portNum_t portNum = message->portNum;

  massert(portNum < PORTS_NUM);
 800b938:	d806      	bhi.n	800b948 <commTx+0x1c>

  comm_t *msgType = msgTab(message->buffer[0]);
 800b93a:	f8d4 3001 	ldr.w	r3, [r4, #1]
 800b93e:	7818      	ldrb	r0, [r3, #0]
 800b940:	f7fc ff46 	bl	80087d0 <msgTab>
  if(msgType)
 800b944:	b960      	cbnz	r0, 800b960 <commTx+0x34>
 800b946:	e014      	b.n	800b972 <commTx+0x46>
static void commTx(void *data)
{
  messageTxData_t *message = data;
  portNum_t portNum = message->portNum;

  massert(portNum < PORTS_NUM);
 800b948:	4b84      	ldr	r3, [pc, #528]	; (800bb5c <commTx+0x230>)
 800b94a:	4985      	ldr	r1, [pc, #532]	; (800bb60 <commTx+0x234>)
 800b94c:	4885      	ldr	r0, [pc, #532]	; (800bb64 <commTx+0x238>)
 800b94e:	229b      	movs	r2, #155	; 0x9b
 800b950:	f7fc ff08 	bl	8008764 <xprintf>
 800b954:	2301      	movs	r3, #1
 800b956:	9302      	str	r3, [sp, #8]
 800b958:	9b02      	ldr	r3, [sp, #8]
 800b95a:	2b00      	cmp	r3, #0
 800b95c:	d1fc      	bne.n	800b958 <commTx+0x2c>
 800b95e:	e7ec      	b.n	800b93a <commTx+0xe>
 800b960:	eb00 0285 	add.w	r2, r0, r5, lsl #2

  comm_t *msgType = msgTab(message->buffer[0]);
  if(msgType)
    {
      msgType->sent[portNum]++;
 800b964:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800b966:	3301      	adds	r3, #1
 800b968:	6353      	str	r3, [r2, #52]	; 0x34
      if(msgType->blocked)
 800b96a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800b96c:	2b00      	cmp	r3, #0
 800b96e:	f040 80e9 	bne.w	800bb44 <commTx+0x218>
          dFree(message->buffer);
          dFree(message);
          return;
        }
    }
  if(cfg.trace_messages)
 800b972:	4e7d      	ldr	r6, [pc, #500]	; (800bb68 <commTx+0x23c>)
 800b974:	69f3      	ldr	r3, [r6, #28]
 800b976:	2b00      	cmp	r3, #0
 800b978:	d03d      	beq.n	800b9f6 <commTx+0xca>
    {
      switch(message->buffer[0])
 800b97a:	f8d4 3001 	ldr.w	r3, [r4, #1]
 800b97e:	781b      	ldrb	r3, [r3, #0]
 800b980:	2bb1      	cmp	r3, #177	; 0xb1
 800b982:	d805      	bhi.n	800b990 <commTx+0x64>
 800b984:	2bb0      	cmp	r3, #176	; 0xb0
 800b986:	d208      	bcs.n	800b99a <commTx+0x6e>
 800b988:	2b55      	cmp	r3, #85	; 0x55
 800b98a:	d003      	beq.n	800b994 <commTx+0x68>
 800b98c:	2ba2      	cmp	r3, #162	; 0xa2
 800b98e:	e000      	b.n	800b992 <commTx+0x66>
 800b990:	2bcc      	cmp	r3, #204	; 0xcc
 800b992:	d105      	bne.n	800b9a0 <commTx+0x74>
        {
        case 0xA2:
        case 0x55:
        case 0xCC:
          if(cfg.trace_messages < 3)
 800b994:	69f2      	ldr	r2, [r6, #28]
 800b996:	2a02      	cmp	r2, #2
 800b998:	dd2d      	ble.n	800b9f6 <commTx+0xca>
            break;
        case 0xB0:
        case 0xB1:
          if(cfg.trace_messages < 2)
 800b99a:	69f2      	ldr	r2, [r6, #28]
 800b99c:	2a01      	cmp	r2, #1
 800b99e:	dd2a      	ble.n	800b9f6 <commTx+0xca>
            break;
        default:
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == message->buffer[0])
 800b9a0:	69f2      	ldr	r2, [r6, #28]
 800b9a2:	2a03      	cmp	r2, #3
 800b9a4:	dd03      	ble.n	800b9ae <commTx+0x82>
 800b9a6:	4a70      	ldr	r2, [pc, #448]	; (800bb68 <commTx+0x23c>)
 800b9a8:	69d2      	ldr	r2, [r2, #28]
 800b9aa:	429a      	cmp	r2, r3
 800b9ac:	d123      	bne.n	800b9f6 <commTx+0xca>
            {
              dprintf(LL_DEBUG, "(%010d)Msg %x sent to %s:", xTaskGetTickCount(), message->buffer[0], portStr[portNum]);
 800b9ae:	6d33      	ldr	r3, [r6, #80]	; 0x50
 800b9b0:	2b02      	cmp	r3, #2
 800b9b2:	dd0b      	ble.n	800b9cc <commTx+0xa0>
 800b9b4:	f7fe fe76 	bl	800a6a4 <xTaskGetTickCount>
 800b9b8:	f8d4 2001 	ldr.w	r2, [r4, #1]
 800b9bc:	4b6b      	ldr	r3, [pc, #428]	; (800bb6c <commTx+0x240>)
 800b9be:	7812      	ldrb	r2, [r2, #0]
 800b9c0:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 800b9c4:	4601      	mov	r1, r0
 800b9c6:	486a      	ldr	r0, [pc, #424]	; (800bb70 <commTx+0x244>)
 800b9c8:	f7fc fecc 	bl	8008764 <xprintf>
#define TX_BUFFER_SIZE_T PORT_BUFFER.txBufferSize[TX_TAIL]
#define TX_HANDLE_T      PORT_BUFFER.handle[TX_TAIL]

#define TX_BUFFER_OFFSET PORT_BUFFER.txBufferOffset
static void commTx(void *data)
{
 800b9cc:	2700      	movs	r7, #0
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == message->buffer[0])
            {
              dprintf(LL_DEBUG, "(%010d)Msg %x sent to %s:", xTaskGetTickCount(), message->buffer[0], portStr[portNum]);
              int i;
              for(i = 0; i < message->bufferSize; i++)
 800b9ce:	f8d4 3005 	ldr.w	r3, [r4, #5]
 800b9d2:	429f      	cmp	r7, r3
                dprintf(LL_DEBUG, "%02x ", message->buffer[i]);
 800b9d4:	6d33      	ldr	r3, [r6, #80]	; 0x50
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == message->buffer[0])
            {
              dprintf(LL_DEBUG, "(%010d)Msg %x sent to %s:", xTaskGetTickCount(), message->buffer[0], portStr[portNum]);
              int i;
              for(i = 0; i < message->bufferSize; i++)
 800b9d6:	da09      	bge.n	800b9ec <commTx+0xc0>
                dprintf(LL_DEBUG, "%02x ", message->buffer[i]);
 800b9d8:	2b02      	cmp	r3, #2
 800b9da:	dd05      	ble.n	800b9e8 <commTx+0xbc>
 800b9dc:	f8d4 3001 	ldr.w	r3, [r4, #1]
 800b9e0:	4864      	ldr	r0, [pc, #400]	; (800bb74 <commTx+0x248>)
 800b9e2:	5dd9      	ldrb	r1, [r3, r7]
 800b9e4:	f7fc febe 	bl	8008764 <xprintf>
        {
          if(cfg.trace_messages <= 3 || cfg.trace_messages == message->buffer[0])
            {
              dprintf(LL_DEBUG, "(%010d)Msg %x sent to %s:", xTaskGetTickCount(), message->buffer[0], portStr[portNum]);
              int i;
              for(i = 0; i < message->bufferSize; i++)
 800b9e8:	3701      	adds	r7, #1
 800b9ea:	e7f0      	b.n	800b9ce <commTx+0xa2>
                dprintf(LL_DEBUG, "%02x ", message->buffer[i]);
              dprintf(LL_DEBUG, "\n");
 800b9ec:	2b02      	cmp	r3, #2
 800b9ee:	dd02      	ble.n	800b9f6 <commTx+0xca>
 800b9f0:	4861      	ldr	r0, [pc, #388]	; (800bb78 <commTx+0x24c>)
 800b9f2:	f7fc feb7 	bl	8008764 <xprintf>
 800b9f6:	f04f 0850 	mov.w	r8, #80	; 0x50
 800b9fa:	4b60      	ldr	r3, [pc, #384]	; (800bb7c <commTx+0x250>)
  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
    if((subPortNum == PORT_TYPE_SPI && portData[portNum].SPIhelper)
        ||(subPortNum == PORT_TYPE_USART && portData[portNum].UARThelper))
      {
        if (TX_NUM == WAIT_QUEUE_SIZE)
 800b9fc:	f8df 9188 	ldr.w	r9, [pc, #392]	; 800bb88 <commTx+0x25c>
 800ba00:	9301      	str	r3, [sp, #4]
 800ba02:	fb08 f805 	mul.w	r8, r8, r5
 800ba06:	f108 0808 	add.w	r8, r8, #8
 800ba0a:	4498      	add	r8, r3
#define TX_BUFFER_SIZE_T PORT_BUFFER.txBufferSize[TX_TAIL]
#define TX_HANDLE_T      PORT_BUFFER.handle[TX_TAIL]

#define TX_BUFFER_OFFSET PORT_BUFFER.txBufferOffset
static void commTx(void *data)
{
 800ba0c:	2700      	movs	r7, #0
 800ba0e:	46ca      	mov	sl, r9
        }
    }

  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
    if((subPortNum == PORT_TYPE_SPI && portData[portNum].SPIhelper)
 800ba10:	9a01      	ldr	r2, [sp, #4]
 800ba12:	2350      	movs	r3, #80	; 0x50
 800ba14:	2f01      	cmp	r7, #1
 800ba16:	fb03 2305 	mla	r3, r3, r5, r2
 800ba1a:	d102      	bne.n	800ba22 <commTx+0xf6>
 800ba1c:	691b      	ldr	r3, [r3, #16]
 800ba1e:	b923      	cbnz	r3, 800ba2a <commTx+0xfe>
 800ba20:	e090      	b.n	800bb44 <commTx+0x218>
        ||(subPortNum == PORT_TYPE_USART && portData[portNum].UARThelper))
 800ba22:	695b      	ldr	r3, [r3, #20]
 800ba24:	2b00      	cmp	r3, #0
 800ba26:	f000 8087 	beq.w	800bb38 <commTx+0x20c>
      {
        if (TX_NUM == WAIT_QUEUE_SIZE)
 800ba2a:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
 800ba2e:	23e0      	movs	r3, #224	; 0xe0
 800ba30:	436e      	muls	r6, r5
 800ba32:	fb03 6607 	mla	r6, r3, r7, r6
 800ba36:	444e      	add	r6, r9
 800ba38:	69b3      	ldr	r3, [r6, #24]
 800ba3a:	2b10      	cmp	r3, #16
 800ba3c:	d10b      	bne.n	800ba56 <commTx+0x12a>
          {
            //wait queue is full
            while (messageTxComplete(portNum, COMM_TX_FAILED, message->handle) < 0)
 800ba3e:	f8d4 2009 	ldr.w	r2, [r4, #9]
 800ba42:	2100      	movs	r1, #0
 800ba44:	4628      	mov	r0, r5
 800ba46:	f7ff fc6f 	bl	800b328 <messageTxComplete>
 800ba4a:	2800      	cmp	r0, #0
 800ba4c:	da74      	bge.n	800bb38 <commTx+0x20c>
              {
                //Sending failed. Try again
                vTaskDelay(1);
 800ba4e:	2001      	movs	r0, #1
 800ba50:	f7fe ff1e 	bl	800a890 <vTaskDelay>
 800ba54:	e7f3      	b.n	800ba3e <commTx+0x112>
              }
            continue;
          }

        dRef(message->buffer);
 800ba56:	f8d4 0001 	ldr.w	r0, [r4, #1]
        TX_BUFFER_SIZE_T = message->bufferSize;
 800ba5a:	3610      	adds	r6, #16
                vTaskDelay(1);
              }
            continue;
          }

        dRef(message->buffer);
 800ba5c:	3814      	subs	r0, #20
 800ba5e:	f002 f97f 	bl	800dd60 <bRef>
        TX_BUFFER_SIZE_T = message->bufferSize;
 800ba62:	2370      	movs	r3, #112	; 0x70
 800ba64:	6872      	ldr	r2, [r6, #4]
 800ba66:	f8d4 0005 	ldr.w	r0, [r4, #5]
 800ba6a:	2138      	movs	r1, #56	; 0x38
 800ba6c:	436b      	muls	r3, r5
 800ba6e:	fb01 3307 	mla	r3, r1, r7, r3
 800ba72:	4413      	add	r3, r2
 800ba74:	eb09 0183 	add.w	r1, r9, r3, lsl #2
        TX_BUFFER_T = message->buffer;
        TX_HANDLE_T = message->handle;
 800ba78:	eb09 0383 	add.w	r3, r9, r3, lsl #2
              }
            continue;
          }

        dRef(message->buffer);
        TX_BUFFER_SIZE_T = message->bufferSize;
 800ba7c:	65c8      	str	r0, [r1, #92]	; 0x5c
        TX_BUFFER_T = message->buffer;
 800ba7e:	f8d4 0001 	ldr.w	r0, [r4, #1]
 800ba82:	61c8      	str	r0, [r1, #28]
        TX_HANDLE_T = message->handle;
 800ba84:	f8d4 1009 	ldr.w	r1, [r4, #9]
 800ba88:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
        TX_TAIL = (TX_TAIL + 1) % WAIT_QUEUE_SIZE;
 800ba8c:	4b3c      	ldr	r3, [pc, #240]	; (800bb80 <commTx+0x254>)
 800ba8e:	3201      	adds	r2, #1
 800ba90:	4013      	ands	r3, r2
 800ba92:	2b00      	cmp	r3, #0
 800ba94:	bfbe      	ittt	lt
 800ba96:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800ba9a:	f063 030f 	ornlt	r3, r3, #15
 800ba9e:	3301      	addlt	r3, #1
 800baa0:	6073      	str	r3, [r6, #4]
        TX_NUM++;
 800baa2:	f44f 73e0 	mov.w	r3, #448	; 0x1c0
 800baa6:	436b      	muls	r3, r5
 800baa8:	22e0      	movs	r2, #224	; 0xe0
 800baaa:	fb02 3307 	mla	r3, r2, r7, r3
 800baae:	4453      	add	r3, sl
 800bab0:	699e      	ldr	r6, [r3, #24]
 800bab2:	3601      	adds	r6, #1

        //Send first data if necessary
        if (TX_NUM == 1)
 800bab4:	2e01      	cmp	r6, #1
        dRef(message->buffer);
        TX_BUFFER_SIZE_T = message->bufferSize;
        TX_BUFFER_T = message->buffer;
        TX_HANDLE_T = message->handle;
        TX_TAIL = (TX_TAIL + 1) % WAIT_QUEUE_SIZE;
        TX_NUM++;
 800bab6:	619e      	str	r6, [r3, #24]

        //Send first data if necessary
        if (TX_NUM == 1)
 800bab8:	d13e      	bne.n	800bb38 <commTx+0x20c>
          {
            massert(TX_BUFFER_OFFSET == 0);
 800baba:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 800babe:	bb83      	cbnz	r3, 800bb22 <commTx+0x1f6>
            int sentSize = portData[portNum].sendData[subPortNum](portNum, &(TX_BUFFER_H[TX_BUFFER_OFFSET]), TX_BUFFER_SIZE_H);
 800bac0:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
 800bac4:	23e0      	movs	r3, #224	; 0xe0
 800bac6:	436e      	muls	r6, r5
 800bac8:	fb03 6607 	mla	r6, r3, r7, r6
 800bacc:	4456      	add	r6, sl
 800bace:	46b3      	mov	fp, r6
 800bad0:	2270      	movs	r2, #112	; 0x70
 800bad2:	f85b 3f10 	ldr.w	r3, [fp, #16]!
 800bad6:	2138      	movs	r1, #56	; 0x38
 800bad8:	436a      	muls	r2, r5
 800bada:	fb01 2207 	mla	r2, r1, r7, r2
 800bade:	4413      	add	r3, r2
 800bae0:	9200      	str	r2, [sp, #0]
 800bae2:	f103 0216 	add.w	r2, r3, #22
 800bae6:	3306      	adds	r3, #6
 800bae8:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 800baec:	f8d6 10dc 	ldr.w	r1, [r6, #220]	; 0xdc
 800baf0:	6858      	ldr	r0, [r3, #4]
 800baf2:	f8d8 3000 	ldr.w	r3, [r8]
 800baf6:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 800bafa:	4401      	add	r1, r0
 800bafc:	6852      	ldr	r2, [r2, #4]
 800bafe:	4628      	mov	r0, r5
 800bb00:	4798      	blx	r3

            TX_BUFFER_OFFSET += sentSize;
 800bb02:	f8d6 30dc 	ldr.w	r3, [r6, #220]	; 0xdc
            TX_BUFFER_SIZE_H -= sentSize;
 800bb06:	9a00      	ldr	r2, [sp, #0]
        if (TX_NUM == 1)
          {
            massert(TX_BUFFER_OFFSET == 0);
            int sentSize = portData[portNum].sendData[subPortNum](portNum, &(TX_BUFFER_H[TX_BUFFER_OFFSET]), TX_BUFFER_SIZE_H);

            TX_BUFFER_OFFSET += sentSize;
 800bb08:	4403      	add	r3, r0
 800bb0a:	f8c6 30dc 	str.w	r3, [r6, #220]	; 0xdc
            TX_BUFFER_SIZE_H -= sentSize;
 800bb0e:	f8db 3000 	ldr.w	r3, [fp]
 800bb12:	4413      	add	r3, r2
 800bb14:	3316      	adds	r3, #22
 800bb16:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 800bb1a:	685a      	ldr	r2, [r3, #4]
 800bb1c:	1a10      	subs	r0, r2, r0
 800bb1e:	6058      	str	r0, [r3, #4]
 800bb20:	e00a      	b.n	800bb38 <commTx+0x20c>
        TX_NUM++;

        //Send first data if necessary
        if (TX_NUM == 1)
          {
            massert(TX_BUFFER_OFFSET == 0);
 800bb22:	4b18      	ldr	r3, [pc, #96]	; (800bb84 <commTx+0x258>)
 800bb24:	490e      	ldr	r1, [pc, #56]	; (800bb60 <commTx+0x234>)
 800bb26:	480f      	ldr	r0, [pc, #60]	; (800bb64 <commTx+0x238>)
 800bb28:	22de      	movs	r2, #222	; 0xde
 800bb2a:	f7fc fe1b 	bl	8008764 <xprintf>
 800bb2e:	9603      	str	r6, [sp, #12]
 800bb30:	9b03      	ldr	r3, [sp, #12]
 800bb32:	2b00      	cmp	r3, #0
 800bb34:	d1fc      	bne.n	800bb30 <commTx+0x204>
 800bb36:	e7c3      	b.n	800bac0 <commTx+0x194>
        break;
        }
    }

  int subPortNum;
  for(subPortNum = 0; subPortNum < 2; subPortNum++)
 800bb38:	3701      	adds	r7, #1
 800bb3a:	2f02      	cmp	r7, #2
 800bb3c:	f108 0804 	add.w	r8, r8, #4
 800bb40:	f47f af66 	bne.w	800ba10 <commTx+0xe4>

            TX_BUFFER_OFFSET += sentSize;
            TX_BUFFER_SIZE_H -= sentSize;
          }
      }
  dFree(message->buffer);
 800bb44:	f8d4 0001 	ldr.w	r0, [r4, #1]
 800bb48:	3814      	subs	r0, #20
 800bb4a:	f001 ffcb 	bl	800dae4 <bFree>
  dFree(message);
 800bb4e:	f1a4 0014 	sub.w	r0, r4, #20
 800bb52:	f001 ffc7 	bl	800dae4 <bFree>
}
 800bb56:	b005      	add	sp, #20
 800bb58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bb5c:	08014ff2 	.word	0x08014ff2
 800bb60:	08014f77 	.word	0x08014f77
 800bb64:	080148f4 	.word	0x080148f4
 800bb68:	10001000 	.word	0x10001000
 800bb6c:	2001abd8 	.word	0x2001abd8
 800bb70:	08015006 	.word	0x08015006
 800bb74:	08014869 	.word	0x08014869
 800bb78:	08014a9c 	.word	0x08014a9c
 800bb7c:	2001aabc 	.word	0x2001aabc
 800bb80:	8000000f 	.word	0x8000000f
 800bb84:	08015020 	.word	0x08015020
 800bb88:	20018498 	.word	0x20018498

0800bb8c <HWCommInit>:
  .stackSize = 2 * 1024,
  .name = "portCommunicator",
};

void HWCommInit(void)
{
 800bb8c:	b508      	push	{r3, lr}
  //Initialize ports module
  memset(portBuffer, 0, sizeof(portBuffer));
 800bb8e:	f44f 62a8 	mov.w	r2, #1344	; 0x540
 800bb92:	2100      	movs	r1, #0
 800bb94:	4803      	ldr	r0, [pc, #12]	; (800bba4 <HWCommInit+0x18>)
 800bb96:	f008 fcf5 	bl	8014584 <memset>
  moduleInit(&moduleHWComm);
 800bb9a:	4803      	ldr	r0, [pc, #12]	; (800bba8 <HWCommInit+0x1c>)
}
 800bb9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void HWCommInit(void)
{
  //Initialize ports module
  memset(portBuffer, 0, sizeof(portBuffer));
  moduleInit(&moduleHWComm);
 800bba0:	f7ff bb2e 	b.w	800b200 <moduleInit>
 800bba4:	20018498 	.word	0x20018498
 800bba8:	2001a8b8 	.word	0x2001a8b8

0800bbac <messageTx>:
  int bufferSize;
  uint32_t handle;
} messageTxData_t;

int messageTx(portNum_t portNum, char *buffer, int bufferSize, uint32_t handle)
{
 800bbac:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800bbb0:	4605      	mov	r5, r0
  //Allocate resources for data transfer
  messageTxData_t *message = dAlloc(sizeof(messageTxData_t));
 800bbb2:	200d      	movs	r0, #13
  int bufferSize;
  uint32_t handle;
} messageTxData_t;

int messageTx(portNum_t portNum, char *buffer, int bufferSize, uint32_t handle)
{
 800bbb4:	460e      	mov	r6, r1
 800bbb6:	4617      	mov	r7, r2
 800bbb8:	4698      	mov	r8, r3
  //Allocate resources for data transfer
  messageTxData_t *message = dAlloc(sizeof(messageTxData_t));
 800bbba:	f001 fd39 	bl	800d630 <bAlloc>
 800bbbe:	b120      	cbz	r0, 800bbca <messageTx+0x1e>

  massert(portNum < PORTS_NUM);
 800bbc0:	2d02      	cmp	r5, #2
} messageTxData_t;

int messageTx(portNum_t portNum, char *buffer, int bufferSize, uint32_t handle)
{
  //Allocate resources for data transfer
  messageTxData_t *message = dAlloc(sizeof(messageTxData_t));
 800bbc2:	f100 0414 	add.w	r4, r0, #20

  massert(portNum < PORTS_NUM);
 800bbc6:	d90f      	bls.n	800bbe8 <messageTx+0x3c>
 800bbc8:	e002      	b.n	800bbd0 <messageTx+0x24>
 800bbca:	2d02      	cmp	r5, #2
 800bbcc:	d91e      	bls.n	800bc0c <messageTx+0x60>
} messageTxData_t;

int messageTx(portNum_t portNum, char *buffer, int bufferSize, uint32_t handle)
{
  //Allocate resources for data transfer
  messageTxData_t *message = dAlloc(sizeof(messageTxData_t));
 800bbce:	4604      	mov	r4, r0

  massert(portNum < PORTS_NUM);
 800bbd0:	4b12      	ldr	r3, [pc, #72]	; (800bc1c <messageTx+0x70>)
 800bbd2:	4913      	ldr	r1, [pc, #76]	; (800bc20 <messageTx+0x74>)
 800bbd4:	4813      	ldr	r0, [pc, #76]	; (800bc24 <messageTx+0x78>)
 800bbd6:	2273      	movs	r2, #115	; 0x73
 800bbd8:	f7fc fdc4 	bl	8008764 <xprintf>
 800bbdc:	2301      	movs	r3, #1
 800bbde:	9301      	str	r3, [sp, #4]
 800bbe0:	9b01      	ldr	r3, [sp, #4]
 800bbe2:	2b00      	cmp	r3, #0
 800bbe4:	d1fc      	bne.n	800bbe0 <messageTx+0x34>
  if (message == NULL)
 800bbe6:	b18c      	cbz	r4, 800bc0c <messageTx+0x60>
    return -1;

  //Fill message
  message->portNum = portNum;
 800bbe8:	7025      	strb	r5, [r4, #0]
  message->buffer = buffer;
 800bbea:	f8c4 6001 	str.w	r6, [r4, #1]
  message->bufferSize = bufferSize;
 800bbee:	f8c4 7005 	str.w	r7, [r4, #5]
  message->handle = handle;
 800bbf2:	f8c4 8009 	str.w	r8, [r4, #9]

  //Send the message to the communicator
  if (moduleSendCommand(&moduleHWComm, CMD_COMM_TX, message) < 0)
 800bbf6:	4622      	mov	r2, r4
 800bbf8:	2100      	movs	r1, #0
 800bbfa:	480b      	ldr	r0, [pc, #44]	; (800bc28 <messageTx+0x7c>)
 800bbfc:	f7ff faac 	bl	800b158 <moduleSendCommand>
 800bc00:	2800      	cmp	r0, #0
 800bc02:	da06      	bge.n	800bc12 <messageTx+0x66>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800bc04:	f1a4 0014 	sub.w	r0, r4, #20
 800bc08:	f001 ff6c 	bl	800dae4 <bFree>
      return -1;
 800bc0c:	f04f 30ff 	mov.w	r0, #4294967295
 800bc10:	e000      	b.n	800bc14 <messageTx+0x68>
    }
  return 0;
 800bc12:	2000      	movs	r0, #0
}
 800bc14:	b002      	add	sp, #8
 800bc16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bc1a:	bf00      	nop
 800bc1c:	08014ff2 	.word	0x08014ff2
 800bc20:	08014f7e 	.word	0x08014f7e
 800bc24:	080148f4 	.word	0x080148f4
 800bc28:	2001a8b8 	.word	0x2001a8b8

0800bc2c <portDataTxRxComplete>:

/////////////////////////////////////////////////////////////////////
//Handle transmission.
int portDataTxRxComplete(portNum_t portNum, portType_e portType, rxTxComplete_e dir)
{
  massert(portNum < PORTS_NUM);
 800bc2c:	2802      	cmp	r0, #2
}

/////////////////////////////////////////////////////////////////////
//Handle transmission.
int portDataTxRxComplete(portNum_t portNum, portType_e portType, rxTxComplete_e dir)
{
 800bc2e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800bc30:	4605      	mov	r5, r0
 800bc32:	460e      	mov	r6, r1
 800bc34:	4614      	mov	r4, r2
  massert(portNum < PORTS_NUM);
 800bc36:	d808      	bhi.n	800bc4a <portDataTxRxComplete+0x1e>
  portSubport_t message = {.portNum = portNum, .subPortNum = portType};
 800bc38:	2300      	movs	r3, #0
 800bc3a:	9301      	str	r3, [sp, #4]
  if (dir & RXTX_COMPLETE_TX)
 800bc3c:	07e3      	lsls	r3, r4, #31
/////////////////////////////////////////////////////////////////////
//Handle transmission.
int portDataTxRxComplete(portNum_t portNum, portType_e portType, rxTxComplete_e dir)
{
  massert(portNum < PORTS_NUM);
  portSubport_t message = {.portNum = portNum, .subPortNum = portType};
 800bc3e:	f88d 5004 	strb.w	r5, [sp, #4]
 800bc42:	f88d 6005 	strb.w	r6, [sp, #5]
  if (dir & RXTX_COMPLETE_TX)
 800bc46:	d50c      	bpl.n	800bc62 <portDataTxRxComplete+0x36>
 800bc48:	e017      	b.n	800bc7a <portDataTxRxComplete+0x4e>

/////////////////////////////////////////////////////////////////////
//Handle transmission.
int portDataTxRxComplete(portNum_t portNum, portType_e portType, rxTxComplete_e dir)
{
  massert(portNum < PORTS_NUM);
 800bc4a:	4b11      	ldr	r3, [pc, #68]	; (800bc90 <portDataTxRxComplete+0x64>)
 800bc4c:	4911      	ldr	r1, [pc, #68]	; (800bc94 <portDataTxRxComplete+0x68>)
 800bc4e:	4812      	ldr	r0, [pc, #72]	; (800bc98 <portDataTxRxComplete+0x6c>)
 800bc50:	22ed      	movs	r2, #237	; 0xed
 800bc52:	f7fc fd87 	bl	8008764 <xprintf>
 800bc56:	2301      	movs	r3, #1
 800bc58:	9300      	str	r3, [sp, #0]
 800bc5a:	9b00      	ldr	r3, [sp, #0]
 800bc5c:	2b00      	cmp	r3, #0
 800bc5e:	d1fc      	bne.n	800bc5a <portDataTxRxComplete+0x2e>
 800bc60:	e7ea      	b.n	800bc38 <portDataTxRxComplete+0xc>
        {
          //Sending failed
          return -1;
        }
    }
  if (dir & RXTX_COMPLETE_RX)
 800bc62:	f004 0402 	and.w	r4, r4, #2
 800bc66:	f004 00ff 	and.w	r0, r4, #255	; 0xff
 800bc6a:	b17c      	cbz	r4, 800bc8c <portDataTxRxComplete+0x60>
    {
      if (moduleSendCommand(&moduleHWComm, CMD_PORT_RX, (void *)message.raw) < 0)
 800bc6c:	9a01      	ldr	r2, [sp, #4]
 800bc6e:	480b      	ldr	r0, [pc, #44]	; (800bc9c <portDataTxRxComplete+0x70>)
 800bc70:	2102      	movs	r1, #2
 800bc72:	f7ff fa71 	bl	800b158 <moduleSendCommand>
 800bc76:	17c0      	asrs	r0, r0, #31
 800bc78:	e008      	b.n	800bc8c <portDataTxRxComplete+0x60>
{
  massert(portNum < PORTS_NUM);
  portSubport_t message = {.portNum = portNum, .subPortNum = portType};
  if (dir & RXTX_COMPLETE_TX)
    {
      if (moduleSendCommand(&moduleHWComm, CMD_PORT_TX, (void *)message.raw) < 0)
 800bc7a:	9a01      	ldr	r2, [sp, #4]
 800bc7c:	4807      	ldr	r0, [pc, #28]	; (800bc9c <portDataTxRxComplete+0x70>)
 800bc7e:	2101      	movs	r1, #1
 800bc80:	f7ff fa6a 	bl	800b158 <moduleSendCommand>
 800bc84:	2800      	cmp	r0, #0
 800bc86:	daec      	bge.n	800bc62 <portDataTxRxComplete+0x36>
        {
          //Sending failed
          return -1;
 800bc88:	f04f 30ff 	mov.w	r0, #4294967295
          //Sending failed
          return -1;
        }
    }
  return 0;
}
 800bc8c:	b002      	add	sp, #8
 800bc8e:	bd70      	pop	{r4, r5, r6, pc}
 800bc90:	08014ff2 	.word	0x08014ff2
 800bc94:	08014f88 	.word	0x08014f88
 800bc98:	080148f4 	.word	0x080148f4
 800bc9c:	2001a8b8 	.word	0x2001a8b8

0800bca0 <switchPortHelper>:
  int type;
  uint8_t wait;
} messageSwitchPort_t;

int switchPortHelper(portNum_t portNum, int type)
{
 800bca0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800bca2:	4605      	mov	r5, r0
  //Allocate resources for data transfer
  messageSwitchPort_t *message = dAlloc(sizeof(messageSwitchPort_t));
 800bca4:	2006      	movs	r0, #6
  int type;
  uint8_t wait;
} messageSwitchPort_t;

int switchPortHelper(portNum_t portNum, int type)
{
 800bca6:	460e      	mov	r6, r1
  //Allocate resources for data transfer
  messageSwitchPort_t *message = dAlloc(sizeof(messageSwitchPort_t));
 800bca8:	f001 fcc2 	bl	800d630 <bAlloc>
 800bcac:	b120      	cbz	r0, 800bcb8 <switchPortHelper+0x18>

  massert(portNum < PORTS_NUM);
 800bcae:	2d02      	cmp	r5, #2
} messageSwitchPort_t;

int switchPortHelper(portNum_t portNum, int type)
{
  //Allocate resources for data transfer
  messageSwitchPort_t *message = dAlloc(sizeof(messageSwitchPort_t));
 800bcb0:	f100 0414 	add.w	r4, r0, #20

  massert(portNum < PORTS_NUM);
 800bcb4:	d910      	bls.n	800bcd8 <switchPortHelper+0x38>
 800bcb6:	e002      	b.n	800bcbe <switchPortHelper+0x1e>
 800bcb8:	2d02      	cmp	r5, #2
 800bcba:	d91d      	bls.n	800bcf8 <switchPortHelper+0x58>
} messageSwitchPort_t;

int switchPortHelper(portNum_t portNum, int type)
{
  //Allocate resources for data transfer
  messageSwitchPort_t *message = dAlloc(sizeof(messageSwitchPort_t));
 800bcbc:	4604      	mov	r4, r0

  massert(portNum < PORTS_NUM);
 800bcbe:	4b16      	ldr	r3, [pc, #88]	; (800bd18 <switchPortHelper+0x78>)
 800bcc0:	4916      	ldr	r1, [pc, #88]	; (800bd1c <switchPortHelper+0x7c>)
 800bcc2:	4817      	ldr	r0, [pc, #92]	; (800bd20 <switchPortHelper+0x80>)
 800bcc4:	f44f 72c4 	mov.w	r2, #392	; 0x188
 800bcc8:	f7fc fd4c 	bl	8008764 <xprintf>
 800bccc:	2301      	movs	r3, #1
 800bcce:	9301      	str	r3, [sp, #4]
 800bcd0:	9b01      	ldr	r3, [sp, #4]
 800bcd2:	2b00      	cmp	r3, #0
 800bcd4:	d1fc      	bne.n	800bcd0 <switchPortHelper+0x30>
  if (message == NULL)
 800bcd6:	b17c      	cbz	r4, 800bcf8 <switchPortHelper+0x58>
    return -1;

  //Fill message
  message->portNum = portNum;
  message->type = type;
  message->wait = 1;
 800bcd8:	2301      	movs	r3, #1
  massert(portNum < PORTS_NUM);
  if (message == NULL)
    return -1;

  //Fill message
  message->portNum = portNum;
 800bcda:	7025      	strb	r5, [r4, #0]
  message->type = type;
 800bcdc:	f8c4 6001 	str.w	r6, [r4, #1]
  message->wait = 1;
 800bce0:	7163      	strb	r3, [r4, #5]

  //Send the message to the communicator
  if (moduleSendCommand(&moduleHWComm, CMD_SWITCH_PORT, message) < 0)
 800bce2:	4622      	mov	r2, r4
 800bce4:	2103      	movs	r1, #3
 800bce6:	480f      	ldr	r0, [pc, #60]	; (800bd24 <switchPortHelper+0x84>)
 800bce8:	f7ff fa36 	bl	800b158 <moduleSendCommand>
 800bcec:	2800      	cmp	r0, #0
 800bcee:	da06      	bge.n	800bcfe <switchPortHelper+0x5e>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800bcf0:	f1a4 0014 	sub.w	r0, r4, #20
 800bcf4:	f001 fef6 	bl	800dae4 <bFree>
      return -1;
 800bcf8:	f04f 30ff 	mov.w	r0, #4294967295
 800bcfc:	e00a      	b.n	800bd14 <switchPortHelper+0x74>
    }
  while(message->wait) mdelay(1);
 800bcfe:	7965      	ldrb	r5, [r4, #5]
 800bd00:	b11d      	cbz	r5, 800bd0a <switchPortHelper+0x6a>
 800bd02:	2001      	movs	r0, #1
 800bd04:	f7fe fdc4 	bl	800a890 <vTaskDelay>
 800bd08:	e7f9      	b.n	800bcfe <switchPortHelper+0x5e>
  dFree(message);
 800bd0a:	f1a4 0014 	sub.w	r0, r4, #20
 800bd0e:	f001 fee9 	bl	800dae4 <bFree>
  return 0;
 800bd12:	4628      	mov	r0, r5

}
 800bd14:	b002      	add	sp, #8
 800bd16:	bd70      	pop	{r4, r5, r6, pc}
 800bd18:	08014ff2 	.word	0x08014ff2
 800bd1c:	08014f9d 	.word	0x08014f9d
 800bd20:	080148f4 	.word	0x080148f4
 800bd24:	2001a8b8 	.word	0x2001a8b8

0800bd28 <rrGet>:
  message->wait = 0;
}

//Get byte from round robin buffer
int rrGet(roundRobin_t *rr)
{
 800bd28:	b538      	push	{r3, r4, r5, lr}
 800bd2a:	4604      	mov	r4, r0
  taskENTER_CRITICAL();
 800bd2c:	f7fe fa02 	bl	800a134 <vPortEnterCritical>
  int ch = -1;
  if (rr->num > 0)
 800bd30:	68a2      	ldr	r2, [r4, #8]
 800bd32:	2a00      	cmp	r2, #0
 800bd34:	dd10      	ble.n	800bd58 <rrGet+0x30>
    {
      ch = rr->buffer[rr->head];
 800bd36:	6823      	ldr	r3, [r4, #0]
 800bd38:	18e1      	adds	r1, r4, r3
      rr->head = (rr->head + 1) % ROUND_ROBIN_SIZE;
      rr->num--;
 800bd3a:	3a01      	subs	r2, #1
{
  taskENTER_CRITICAL();
  int ch = -1;
  if (rr->num > 0)
    {
      ch = rr->buffer[rr->head];
 800bd3c:	7b0d      	ldrb	r5, [r1, #12]
      rr->head = (rr->head + 1) % ROUND_ROBIN_SIZE;
      rr->num--;
 800bd3e:	60a2      	str	r2, [r4, #8]
  taskENTER_CRITICAL();
  int ch = -1;
  if (rr->num > 0)
    {
      ch = rr->buffer[rr->head];
      rr->head = (rr->head + 1) % ROUND_ROBIN_SIZE;
 800bd40:	1c59      	adds	r1, r3, #1
 800bd42:	4b08      	ldr	r3, [pc, #32]	; (800bd64 <rrGet+0x3c>)
 800bd44:	400b      	ands	r3, r1
 800bd46:	2b00      	cmp	r3, #0
 800bd48:	bfbe      	ittt	lt
 800bd4a:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800bd4e:	f063 03ff 	ornlt	r3, r3, #255	; 0xff
 800bd52:	3301      	addlt	r3, #1
 800bd54:	6023      	str	r3, [r4, #0]
 800bd56:	e001      	b.n	800bd5c <rrGet+0x34>

//Get byte from round robin buffer
int rrGet(roundRobin_t *rr)
{
  taskENTER_CRITICAL();
  int ch = -1;
 800bd58:	f04f 35ff 	mov.w	r5, #4294967295
    {
      ch = rr->buffer[rr->head];
      rr->head = (rr->head + 1) % ROUND_ROBIN_SIZE;
      rr->num--;
    }
  taskEXIT_CRITICAL();
 800bd5c:	f7fe f9fc 	bl	800a158 <vPortExitCritical>
  return ch;
}
 800bd60:	4628      	mov	r0, r5
 800bd62:	bd38      	pop	{r3, r4, r5, pc}
 800bd64:	800000ff 	.word	0x800000ff

0800bd68 <rrPut>:

//Put a byte into round robin buffer
int rrPut(roundRobin_t *rr, char ch)
{
 800bd68:	b538      	push	{r3, r4, r5, lr}
 800bd6a:	4604      	mov	r4, r0
 800bd6c:	460d      	mov	r5, r1
  int res = 0;
  taskENTER_CRITICAL();
 800bd6e:	f7fe f9e1 	bl	800a134 <vPortEnterCritical>
  if (rr->num < ROUND_ROBIN_SIZE)
 800bd72:	68a2      	ldr	r2, [r4, #8]
 800bd74:	2aff      	cmp	r2, #255	; 0xff
 800bd76:	dc11      	bgt.n	800bd9c <rrPut+0x34>
    {
      rr->buffer[rr->tail] = ch;
 800bd78:	6863      	ldr	r3, [r4, #4]
 800bd7a:	18e0      	adds	r0, r4, r3
      rr->tail = (rr->tail + 1) % ROUND_ROBIN_SIZE;
 800bd7c:	1c59      	adds	r1, r3, #1
 800bd7e:	4b0a      	ldr	r3, [pc, #40]	; (800bda8 <rrPut+0x40>)
{
  int res = 0;
  taskENTER_CRITICAL();
  if (rr->num < ROUND_ROBIN_SIZE)
    {
      rr->buffer[rr->tail] = ch;
 800bd80:	7305      	strb	r5, [r0, #12]
      rr->tail = (rr->tail + 1) % ROUND_ROBIN_SIZE;
 800bd82:	400b      	ands	r3, r1
 800bd84:	2b00      	cmp	r3, #0
 800bd86:	bfbe      	ittt	lt
 800bd88:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800bd8c:	f063 03ff 	ornlt	r3, r3, #255	; 0xff
 800bd90:	3301      	addlt	r3, #1
      rr->num++;
 800bd92:	3201      	adds	r2, #1
  int res = 0;
  taskENTER_CRITICAL();
  if (rr->num < ROUND_ROBIN_SIZE)
    {
      rr->buffer[rr->tail] = ch;
      rr->tail = (rr->tail + 1) % ROUND_ROBIN_SIZE;
 800bd94:	6063      	str	r3, [r4, #4]
      rr->num++;
 800bd96:	60a2      	str	r2, [r4, #8]
}

//Put a byte into round robin buffer
int rrPut(roundRobin_t *rr, char ch)
{
  int res = 0;
 800bd98:	2400      	movs	r4, #0
 800bd9a:	e001      	b.n	800bda0 <rrPut+0x38>
    {
      rr->buffer[rr->tail] = ch;
      rr->tail = (rr->tail + 1) % ROUND_ROBIN_SIZE;
      rr->num++;
    }
  else res = -1;
 800bd9c:	f04f 34ff 	mov.w	r4, #4294967295
  taskEXIT_CRITICAL();
 800bda0:	f7fe f9da 	bl	800a158 <vPortExitCritical>
  return res;
}
 800bda4:	4620      	mov	r0, r4
 800bda6:	bd38      	pop	{r3, r4, r5, pc}
 800bda8:	800000ff 	.word	0x800000ff

0800bdac <USARTreceiveData>:
#include STMINCP()
#include STMINCS(_usart)

//Pick data from USART Rx buffer
int USARTreceiveData(portNum_t portNum, char *buffer, int maxSize)
{
 800bdac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int getNum = 0;
  while (maxSize)
    {
      int data = rrGet(&(((usartHelper_t *)portData[portNum].UARThelper)->rrRx));
 800bdb0:	2650      	movs	r6, #80	; 0x50
 800bdb2:	f8df 9034 	ldr.w	r9, [pc, #52]	; 800bde8 <USARTreceiveData+0x3c>
#include STMINCP()
#include STMINCS(_usart)

//Pick data from USART Rx buffer
int USARTreceiveData(portNum_t portNum, char *buffer, int maxSize)
{
 800bdb6:	460d      	mov	r5, r1
 800bdb8:	eb01 0802 	add.w	r8, r1, r2
  int getNum = 0;
  while (maxSize)
 800bdbc:	460c      	mov	r4, r1
    {
      int data = rrGet(&(((usartHelper_t *)portData[portNum].UARThelper)->rrRx));
 800bdbe:	4346      	muls	r6, r0

//Pick data from USART Rx buffer
int USARTreceiveData(portNum_t portNum, char *buffer, int maxSize)
{
  int getNum = 0;
  while (maxSize)
 800bdc0:	4544      	cmp	r4, r8
 800bdc2:	eba4 0705 	sub.w	r7, r4, r5
 800bdc6:	d00b      	beq.n	800bde0 <USARTreceiveData+0x34>
    {
      int data = rrGet(&(((usartHelper_t *)portData[portNum].UARThelper)->rrRx));
 800bdc8:	eb09 0306 	add.w	r3, r9, r6
 800bdcc:	6958      	ldr	r0, [r3, #20]
 800bdce:	f500 7086 	add.w	r0, r0, #268	; 0x10c
 800bdd2:	f7ff ffa9 	bl	800bd28 <rrGet>
      if (data < 0) break;
 800bdd6:	2800      	cmp	r0, #0
 800bdd8:	db02      	blt.n	800bde0 <USARTreceiveData+0x34>
      *buffer = data;
 800bdda:	f804 0b01 	strb.w	r0, [r4], #1
 800bdde:	e7ef      	b.n	800bdc0 <USARTreceiveData+0x14>
      buffer++;
      maxSize--;
      getNum++;
    }
  return getNum;
}
 800bde0:	4638      	mov	r0, r7
 800bde2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800bde6:	bf00      	nop
 800bde8:	2001aabc 	.word	0x2001aabc

0800bdec <USARTsendData>:

//Put data into USART Tx buffer and initiate transmission.
int USARTsendData (portNum_t portNum, char *buffer, int size)
{
 800bdec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int putNum = 0;
  taskENTER_CRITICAL();
  while (size)
    {
      if (rrPut(&(((usartHelper_t *)portData[portNum].UARThelper)->rrTx), *buffer) < 0) break;
 800bdf0:	4f13      	ldr	r7, [pc, #76]	; (800be40 <USARTsendData+0x54>)
  return getNum;
}

//Put data into USART Tx buffer and initiate transmission.
int USARTsendData (portNum_t portNum, char *buffer, int size)
{
 800bdf2:	460e      	mov	r6, r1
 800bdf4:	4680      	mov	r8, r0
 800bdf6:	4615      	mov	r5, r2
  int putNum = 0;
  taskENTER_CRITICAL();
 800bdf8:	f7fe f99c 	bl	800a134 <vPortEnterCritical>
  while (size)
    {
      if (rrPut(&(((usartHelper_t *)portData[portNum].UARThelper)->rrTx), *buffer) < 0) break;
 800bdfc:	2350      	movs	r3, #80	; 0x50
 800bdfe:	4435      	add	r5, r6
//Put data into USART Tx buffer and initiate transmission.
int USARTsendData (portNum_t portNum, char *buffer, int size)
{
  int putNum = 0;
  taskENTER_CRITICAL();
  while (size)
 800be00:	4634      	mov	r4, r6
    {
      if (rrPut(&(((usartHelper_t *)portData[portNum].UARThelper)->rrTx), *buffer) < 0) break;
 800be02:	fb03 7708 	mla	r7, r3, r8, r7
//Put data into USART Tx buffer and initiate transmission.
int USARTsendData (portNum_t portNum, char *buffer, int size)
{
  int putNum = 0;
  taskENTER_CRITICAL();
  while (size)
 800be06:	42ac      	cmp	r4, r5
 800be08:	ebc6 0904 	rsb	r9, r6, r4
 800be0c:	d006      	beq.n	800be1c <USARTsendData+0x30>
    {
      if (rrPut(&(((usartHelper_t *)portData[portNum].UARThelper)->rrTx), *buffer) < 0) break;
 800be0e:	f814 1b01 	ldrb.w	r1, [r4], #1
 800be12:	6978      	ldr	r0, [r7, #20]
 800be14:	f7ff ffa8 	bl	800bd68 <rrPut>
 800be18:	2800      	cmp	r0, #0
 800be1a:	daf4      	bge.n	800be06 <USARTsendData+0x1a>
      buffer++;
      size--;
      putNum++;
    }
  taskEXIT_CRITICAL();
 800be1c:	f7fe f99c 	bl	800a158 <vPortExitCritical>
  USART_ITConfig(((usartHelper_t *)portData[portNum].UARThelper)->usart, USART_IT_TXE, ENABLE);
 800be20:	4807      	ldr	r0, [pc, #28]	; (800be40 <USARTsendData+0x54>)
 800be22:	2350      	movs	r3, #80	; 0x50
 800be24:	fb03 0008 	mla	r0, r3, r8, r0
 800be28:	2201      	movs	r2, #1
 800be2a:	6943      	ldr	r3, [r0, #20]
 800be2c:	f240 7127 	movw	r1, #1831	; 0x727
 800be30:	f8d3 0218 	ldr.w	r0, [r3, #536]	; 0x218
 800be34:	f005 fbf0 	bl	8011618 <USART_ITConfig>
  return putNum;
}
 800be38:	4648      	mov	r0, r9
 800be3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800be3e:	bf00      	nop
 800be40:	2001aabc 	.word	0x2001aabc

0800be44 <getImageChunk>:


#ifdef RADIO_IMAGE

static void getImageChunk(uint8_t *chunk, const uint8_t *image, int offset, int size, uint32_t manId, uint32_t prodId)
{
 800be44:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint8_t *buff = intSafeMalloc(size+8);
 800be48:	f103 0a08 	add.w	sl, r3, #8


#ifdef RADIO_IMAGE

static void getImageChunk(uint8_t *chunk, const uint8_t *image, int offset, int size, uint32_t manId, uint32_t prodId)
{
 800be4c:	4681      	mov	r9, r0

  uint8_t *buff = intSafeMalloc(size+8);
 800be4e:	4650      	mov	r0, sl


#ifdef RADIO_IMAGE

static void getImageChunk(uint8_t *chunk, const uint8_t *image, int offset, int size, uint32_t manId, uint32_t prodId)
{
 800be50:	468b      	mov	fp, r1
 800be52:	4690      	mov	r8, r2
 800be54:	461d      	mov	r5, r3
 800be56:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800be58:	9e0b      	ldr	r6, [sp, #44]	; 0x2c

  uint8_t *buff = intSafeMalloc(size+8);
 800be5a:	f7fc fb02 	bl	8008462 <intSafeMalloc>
  uint32_t prodIdbe = END_SWAP_32(prodId);
  uint32_t manIdbe = END_SWAP_32(manId);
  memcpy(buff, image-4+offset, size+8);
 800be5e:	f1a8 0104 	sub.w	r1, r8, #4
 800be62:	4652      	mov	r2, sl
 800be64:	4459      	add	r1, fp
#ifdef RADIO_IMAGE

static void getImageChunk(uint8_t *chunk, const uint8_t *image, int offset, int size, uint32_t manId, uint32_t prodId)
{

  uint8_t *buff = intSafeMalloc(size+8);
 800be66:	4604      	mov	r4, r0
  uint32_t prodIdbe = END_SWAP_32(prodId);
  uint32_t manIdbe = END_SWAP_32(manId);
  memcpy(buff, image-4+offset, size+8);
 800be68:	f008 faf2 	bl	8014450 <memcpy>
  int p;
  for(p = 0; p < size+8-3;)
    {
      uint32_t *id = (uint32_t*)&buff[p];
      switch(*id)
 800be6c:	4810      	ldr	r0, [pc, #64]	; (800beb0 <getImageChunk+0x6c>)
 800be6e:	f8df e044 	ldr.w	lr, [pc, #68]	; 800beb4 <getImageChunk+0x70>
 800be72:	ba36      	rev	r6, r6
 800be74:	ba3f      	rev	r7, r7
  uint8_t *buff = intSafeMalloc(size+8);
  uint32_t prodIdbe = END_SWAP_32(prodId);
  uint32_t manIdbe = END_SWAP_32(manId);
  memcpy(buff, image-4+offset, size+8);
  int p;
  for(p = 0; p < size+8-3;)
 800be76:	2200      	movs	r2, #0
 800be78:	1d29      	adds	r1, r5, #4
 800be7a:	428a      	cmp	r2, r1
 800be7c:	dc0e      	bgt.n	800be9c <getImageChunk+0x58>
    {
      uint32_t *id = (uint32_t*)&buff[p];
      switch(*id)
 800be7e:	58a3      	ldr	r3, [r4, r2]
 800be80:	4283      	cmp	r3, r0
  uint32_t manIdbe = END_SWAP_32(manId);
  memcpy(buff, image-4+offset, size+8);
  int p;
  for(p = 0; p < size+8-3;)
    {
      uint32_t *id = (uint32_t*)&buff[p];
 800be82:	eb04 0c02 	add.w	ip, r4, r2
      switch(*id)
 800be86:	d004      	beq.n	800be92 <getImageChunk+0x4e>
 800be88:	4573      	cmp	r3, lr
 800be8a:	d105      	bne.n	800be98 <getImageChunk+0x54>
        case 0x01EFCDAB:
          *id = manIdbe;
          p+= 4;
          break;
        case 0x02EFCDAB:
          *id = prodIdbe;
 800be8c:	f8cc 6000 	str.w	r6, [ip]
 800be90:	e000      	b.n	800be94 <getImageChunk+0x50>
    {
      uint32_t *id = (uint32_t*)&buff[p];
      switch(*id)
        {
        case 0x01EFCDAB:
          *id = manIdbe;
 800be92:	50a7      	str	r7, [r4, r2]
          p+= 4;
          break;
        case 0x02EFCDAB:
          *id = prodIdbe;
          p+= 4;
 800be94:	3204      	adds	r2, #4
          break;
 800be96:	e7f0      	b.n	800be7a <getImageChunk+0x36>
        default:
          p+=1;
 800be98:	3201      	adds	r2, #1
          break;
 800be9a:	e7ee      	b.n	800be7a <getImageChunk+0x36>
        }
    }
  memcpy(chunk, buff+4, size);
 800be9c:	462a      	mov	r2, r5
 800be9e:	1d21      	adds	r1, r4, #4
 800bea0:	4648      	mov	r0, r9
 800bea2:	f008 fad5 	bl	8014450 <memcpy>
  intSafeFree(buff);
 800bea6:	4620      	mov	r0, r4
}
 800bea8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
          p+=1;
          break;
        }
    }
  memcpy(chunk, buff+4, size);
  intSafeFree(buff);
 800beac:	f7fc baea 	b.w	8008484 <intSafeFree>
 800beb0:	01efcdab 	.word	0x01efcdab
 800beb4:	02efcdab 	.word	0x02efcdab

0800beb8 <getImageCRC>:
}

static uint32_t getImageCRC(const uint8_t *image, uint32_t manId, uint32_t prodId)
{
 800beb8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t imageSize = (image[0x1E] << 8) | image[0x1F];
 800bebc:	7f84      	ldrb	r4, [r0, #30]
 800bebe:	7fc3      	ldrb	r3, [r0, #31]
  memcpy(chunk, buff+4, size);
  intSafeFree(buff);
}

static uint32_t getImageCRC(const uint8_t *image, uint32_t manId, uint32_t prodId)
{
 800bec0:	4680      	mov	r8, r0
  uint32_t imageSize = (image[0x1E] << 8) | image[0x1F];
  uint8_t *buff = intSafeMalloc(0x100);
 800bec2:	f44f 7080 	mov.w	r0, #256	; 0x100
  memcpy(chunk, buff+4, size);
  intSafeFree(buff);
}

static uint32_t getImageCRC(const uint8_t *image, uint32_t manId, uint32_t prodId)
{
 800bec6:	4689      	mov	r9, r1
 800bec8:	4692      	mov	sl, r2
  uint32_t imageSize = (image[0x1E] << 8) | image[0x1F];
 800beca:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
  uint8_t *buff = intSafeMalloc(0x100);
 800bece:	f7fc fac8 	bl	8008462 <intSafeMalloc>
  int sizeLeft = imageSize;
  uint32_t offset = 0;
  uint32_t crc = 0x0;
 800bed2:	2500      	movs	r5, #0
}

static uint32_t getImageCRC(const uint8_t *image, uint32_t manId, uint32_t prodId)
{
  uint32_t imageSize = (image[0x1E] << 8) | image[0x1F];
  uint8_t *buff = intSafeMalloc(0x100);
 800bed4:	4606      	mov	r6, r0
  int sizeLeft = imageSize;
  uint32_t offset = 0;
 800bed6:	462f      	mov	r7, r5
  uint32_t crc = 0x0;
  while(sizeLeft > 0)
 800bed8:	2c00      	cmp	r4, #0
 800beda:	dd18      	ble.n	800bf0e <getImageCRC+0x56>
    {
      int chunk = (sizeLeft >= 0x100)?0x100:sizeLeft;
 800bedc:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 800bee0:	46a3      	mov	fp, r4
      getImageChunk(buff, image, offset, 0x100, manId, prodId);
 800bee2:	463a      	mov	r2, r7
  int sizeLeft = imageSize;
  uint32_t offset = 0;
  uint32_t crc = 0x0;
  while(sizeLeft > 0)
    {
      int chunk = (sizeLeft >= 0x100)?0x100:sizeLeft;
 800bee4:	bfa8      	it	ge
 800bee6:	f44f 7b80 	movge.w	fp, #256	; 0x100
      getImageChunk(buff, image, offset, 0x100, manId, prodId);
 800beea:	f44f 7380 	mov.w	r3, #256	; 0x100
 800beee:	4641      	mov	r1, r8
 800bef0:	4630      	mov	r0, r6
 800bef2:	e88d 0600 	stmia.w	sp, {r9, sl}
 800bef6:	f7ff ffa5 	bl	800be44 <getImageChunk>
      offset   += chunk;
      sizeLeft -= chunk;

      crc = crc32(crc, buff, chunk);
 800befa:	4628      	mov	r0, r5
 800befc:	465a      	mov	r2, fp
 800befe:	4631      	mov	r1, r6
 800bf00:	f7f4 f9d4 	bl	80002ac <crc32>
  uint32_t crc = 0x0;
  while(sizeLeft > 0)
    {
      int chunk = (sizeLeft >= 0x100)?0x100:sizeLeft;
      getImageChunk(buff, image, offset, 0x100, manId, prodId);
      offset   += chunk;
 800bf04:	445f      	add	r7, fp
      sizeLeft -= chunk;
 800bf06:	ebcb 0404 	rsb	r4, fp, r4

      crc = crc32(crc, buff, chunk);
 800bf0a:	4605      	mov	r5, r0
 800bf0c:	e7e4      	b.n	800bed8 <getImageCRC+0x20>
    }
  intSafeFree(buff);
 800bf0e:	4630      	mov	r0, r6
 800bf10:	f7fc fab8 	bl	8008484 <intSafeFree>
  return END_SWAP_32(crc);
}
 800bf14:	ba28      	rev	r0, r5
 800bf16:	b003      	add	sp, #12
 800bf18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800bf1c <slaveConnect>:
  disconnectFromMaster();
}


static int slaveConnect(portNum_t port, remoteDev_t *device)
{
 800bf1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  spiHelper_t *helper = (spiHelper_t *)portData[port].SPIhelper;
 800bf20:	4e48      	ldr	r6, [pc, #288]	; (800c044 <slaveConnect+0x128>)
 800bf22:	2750      	movs	r7, #80	; 0x50
  disconnectFromMaster();
}


static int slaveConnect(portNum_t port, remoteDev_t *device)
{
 800bf24:	460c      	mov	r4, r1
  spiHelper_t *helper = (spiHelper_t *)portData[port].SPIhelper;
 800bf26:	fb07 6700 	mla	r7, r7, r0, r6
  disconnectFromMaster();
}


static int slaveConnect(portNum_t port, remoteDev_t *device)
{
 800bf2a:	b08c      	sub	sp, #48	; 0x30
 800bf2c:	4605      	mov	r5, r0
  spiHelper_t *helper = (spiHelper_t *)portData[port].SPIhelper;
  mdelay(1000);
 800bf2e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}


static int slaveConnect(portNum_t port, remoteDev_t *device)
{
  spiHelper_t *helper = (spiHelper_t *)portData[port].SPIhelper;
 800bf32:	f8d7 8010 	ldr.w	r8, [r7, #16]
  mdelay(1000);
 800bf36:	f7fe fcab 	bl	800a890 <vTaskDelay>
  if (doJoin(device->devID, device->manID) )
 800bf3a:	6861      	ldr	r1, [r4, #4]
 800bf3c:	6820      	ldr	r0, [r4, #0]
 800bf3e:	f007 fb9d 	bl	801367c <doJoin>
 800bf42:	2800      	cmp	r0, #0
 800bf44:	d06e      	beq.n	800c024 <slaveConnect+0x108>
    {
      helper->connDev = *device;
 800bf46:	4621      	mov	r1, r4
 800bf48:	f208 1315 	addw	r3, r8, #277	; 0x115
 800bf4c:	f104 020c 	add.w	r2, r4, #12
 800bf50:	f851 0b04 	ldr.w	r0, [r1], #4
 800bf54:	f843 0b04 	str.w	r0, [r3], #4
 800bf58:	4291      	cmp	r1, r2
 800bf5a:	d1f9      	bne.n	800bf50 <slaveConnect+0x34>
 800bf5c:	880a      	ldrh	r2, [r1, #0]
      dprintf(LL_INFO, "Connected to master (%08x:%08x:%08x). Switching to radio connection.\n",
 800bf5e:	4c3a      	ldr	r4, [pc, #232]	; (800c048 <slaveConnect+0x12c>)
{
  spiHelper_t *helper = (spiHelper_t *)portData[port].SPIhelper;
  mdelay(1000);
  if (doJoin(device->devID, device->manID) )
    {
      helper->connDev = *device;
 800bf60:	801a      	strh	r2, [r3, #0]
      dprintf(LL_INFO, "Connected to master (%08x:%08x:%08x). Switching to radio connection.\n",
 800bf62:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800bf64:	2b01      	cmp	r3, #1
 800bf66:	dd08      	ble.n	800bf7a <slaveConnect+0x5e>
 800bf68:	f8d8 311d 	ldr.w	r3, [r8, #285]	; 0x11d
 800bf6c:	f8d8 2119 	ldr.w	r2, [r8, #281]	; 0x119
 800bf70:	f8d8 1115 	ldr.w	r1, [r8, #277]	; 0x115
 800bf74:	4835      	ldr	r0, [pc, #212]	; (800c04c <slaveConnect+0x130>)
 800bf76:	f7fc fbf5 	bl	8008764 <xprintf>
              helper->connDev.devID,
              helper->connDev.manID,
              helper->connDev.prodID);

      switchPortHelper(port, PORT_TYPE_SPI);
 800bf7a:	2101      	movs	r1, #1
 800bf7c:	4628      	mov	r0, r5
 800bf7e:	f7ff fe8f 	bl	800bca0 <switchPortHelper>
      SmokLEDsState(-1, 1, SET_CONN, -1);
 800bf82:	f04f 33ff 	mov.w	r3, #4294967295
 800bf86:	2201      	movs	r2, #1
 800bf88:	4618      	mov	r0, r3
 800bf8a:	4611      	mov	r1, r2
 800bf8c:	f7fd fc80 	bl	8009890 <SmokLEDsState>

      slaveSetAudioLink(helper, (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?0x7:0x3);
 800bf90:	4b2f      	ldr	r3, [pc, #188]	; (800c050 <slaveConnect+0x134>)
 800bf92:	681b      	ldr	r3, [r3, #0]
 800bf94:	2b01      	cmp	r3, #1
 800bf96:	d007      	beq.n	800bfa8 <slaveConnect+0x8c>
 800bf98:	7e73      	ldrb	r3, [r6, #25]
 800bf9a:	2beb      	cmp	r3, #235	; 0xeb
 800bf9c:	bf8c      	ite	hi
 800bf9e:	f04f 0e07 	movhi.w	lr, #7
 800bfa2:	f04f 0e03 	movls.w	lr, #3
 800bfa6:	e001      	b.n	800bfac <slaveConnect+0x90>
 800bfa8:	f04f 0e07 	mov.w	lr, #7
}
#endif
#ifdef SMOK
static int slaveSetAudioLink(spiHelper_t *helper, int channelsMask)
{
  uint8_t channelSetupTable[MAX_SLOT_NUM] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 800bfac:	4b29      	ldr	r3, [pc, #164]	; (800c054 <slaveConnect+0x138>)
 800bfae:	466a      	mov	r2, sp
 800bfb0:	f103 0c10 	add.w	ip, r3, #16
 800bfb4:	46e8      	mov	r8, sp
 800bfb6:	6818      	ldr	r0, [r3, #0]
 800bfb8:	6859      	ldr	r1, [r3, #4]
 800bfba:	4617      	mov	r7, r2
 800bfbc:	c703      	stmia	r7!, {r0, r1}
 800bfbe:	3308      	adds	r3, #8
 800bfc0:	4563      	cmp	r3, ip
 800bfc2:	463a      	mov	r2, r7
 800bfc4:	d1f7      	bne.n	800bfb6 <slaveConnect+0x9a>
  int i;
  for(i = 0; i < 16; i++)
 800bfc6:	2300      	movs	r3, #0
    if(channelsMask & (1<<i)) channelSetupTable[i] = i;
 800bfc8:	fa4e f203 	asr.w	r2, lr, r3
 800bfcc:	07d2      	lsls	r2, r2, #31
 800bfce:	bf48      	it	mi
 800bfd0:	f808 3003 	strbmi.w	r3, [r8, r3]
#ifdef SMOK
static int slaveSetAudioLink(spiHelper_t *helper, int channelsMask)
{
  uint8_t channelSetupTable[MAX_SLOT_NUM] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
  int i;
  for(i = 0; i < 16; i++)
 800bfd4:	3301      	adds	r3, #1
 800bfd6:	2b10      	cmp	r3, #16
 800bfd8:	d1f6      	bne.n	800bfc8 <slaveConnect+0xac>
    if(channelsMask & (1<<i)) channelSetupTable[i] = i;

  WAIT_BUSY;
 800bfda:	f007 fd7e 	bl	8013ada <ehifGetStatus>
 800bfde:	0403      	lsls	r3, r0, #16
 800bfe0:	d403      	bmi.n	800bfea <slaveConnect+0xce>
 800bfe2:	2001      	movs	r0, #1
 800bfe4:	f7fe fc54 	bl	800a890 <vTaskDelay>
 800bfe8:	e7f7      	b.n	800bfda <slaveConnect+0xbe>
  EHIF_CMD_NWM_GET_STATUS_SLAVE_DATA_T slaveStat = getStatus();
 800bfea:	a804      	add	r0, sp, #16
 800bfec:	f007 fa82 	bl	80134f4 <getStatus>


  dprintf(LL_DEBUG, "Protocol master supports channels mask: %x\n", slaveStat.bvAchSupportedByWpm);
 800bff0:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800bff2:	2b02      	cmp	r3, #2
 800bff4:	dd04      	ble.n	800c000 <slaveConnect+0xe4>
 800bff6:	f8bd 101d 	ldrh.w	r1, [sp, #29]
 800bffa:	4817      	ldr	r0, [pc, #92]	; (800c058 <slaveConnect+0x13c>)
 800bffc:	f7fc fbb2 	bl	8008764 <xprintf>

  activateChannels(channelSetupTable);
 800c000:	4640      	mov	r0, r8
 800c002:	f007 fb61 	bl	80136c8 <activateChannels>

      switchPortHelper(port, PORT_TYPE_SPI);
      SmokLEDsState(-1, 1, SET_CONN, -1);

      slaveSetAudioLink(helper, (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?0x7:0x3);
      portData[port].prevConnState = portData[port].connState;
 800c006:	2350      	movs	r3, #80	; 0x50
 800c008:	fb03 6605 	mla	r6, r3, r5, r6
      portData[port].connState = DEV_PCONN;
      sendKANow(port);
 800c00c:	4628      	mov	r0, r5

      switchPortHelper(port, PORT_TYPE_SPI);
      SmokLEDsState(-1, 1, SET_CONN, -1);

      slaveSetAudioLink(helper, (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?0x7:0x3);
      portData[port].prevConnState = portData[port].connState;
 800c00e:	f896 3020 	ldrb.w	r3, [r6, #32]
 800c012:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
      portData[port].connState = DEV_PCONN;
 800c016:	2302      	movs	r3, #2
 800c018:	f886 3020 	strb.w	r3, [r6, #32]
      sendKANow(port);
 800c01c:	f7fc fdba 	bl	8008b94 <sendKANow>
      return 0;
 800c020:	2000      	movs	r0, #0
 800c022:	e00c      	b.n	800c03e <slaveConnect+0x122>
    }
  if(portData[port].connState != DEV_NCONN)
 800c024:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c028:	b10b      	cbz	r3, 800c02e <slaveConnect+0x112>
    portData[port].prevConnState = portData[port].connState;
 800c02a:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
  portData[port].connState = DEV_NCONN;
 800c02e:	2350      	movs	r3, #80	; 0x50
 800c030:	fb03 6505 	mla	r5, r3, r5, r6
 800c034:	2300      	movs	r3, #0
 800c036:	f885 3020 	strb.w	r3, [r5, #32]
  return -1;
 800c03a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c03e:	b00c      	add	sp, #48	; 0x30
 800c040:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c044:	2001aabc 	.word	0x2001aabc
 800c048:	10001000 	.word	0x10001000
 800c04c:	0801d0b0 	.word	0x0801d0b0
 800c050:	2001ac34 	.word	0x2001ac34
 800c054:	08015048 	.word	0x08015048
 800c058:	0801d0f6 	.word	0x0801d0f6

0800c05c <SPIevent>:
  } __attribute__((packed));
  uint32_t raw;
} __attribute__((packed)) ev_t;

int SPIevent(portNum_t portNum, uint8_t evType)
{
 800c05c:	b507      	push	{r0, r1, r2, lr}
  ev_t ev = {.portNum = portNum, .evType = evType};
 800c05e:	2300      	movs	r3, #0
 800c060:	9301      	str	r3, [sp, #4]
 800c062:	f88d 0004 	strb.w	r0, [sp, #4]
 800c066:	f88d 1005 	strb.w	r1, [sp, #5]
  if (moduleSendCommand(&moduleSPI, CMD_EVENT, (void *)ev.raw) < 0)
 800c06a:	9a01      	ldr	r2, [sp, #4]
 800c06c:	4803      	ldr	r0, [pc, #12]	; (800c07c <SPIevent+0x20>)
 800c06e:	4619      	mov	r1, r3
 800c070:	f7ff f872 	bl	800b158 <moduleSendCommand>
    {
      //Sending failed
      return -1;
    }
  return 0;
}
 800c074:	17c0      	asrs	r0, r0, #31
 800c076:	b003      	add	sp, #12
 800c078:	f85d fb04 	ldr.w	pc, [sp], #4
 800c07c:	2001a8f8 	.word	0x2001a8f8

0800c080 <SPIreceiveData>:

  eventType = 1;//Timeout by default
}

int SPIreceiveData(portNum_t portNum, char *buffer, int maxSize)
{
 800c080:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800c084:	460e      	mov	r6, r1
  int getNum = 0;
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 800c086:	4917      	ldr	r1, [pc, #92]	; (800c0e4 <SPIreceiveData+0x64>)
 800c088:	2350      	movs	r3, #80	; 0x50
 800c08a:	fb03 1300 	mla	r3, r3, r0, r1

  eventType = 1;//Timeout by default
}

int SPIreceiveData(portNum_t portNum, char *buffer, int maxSize)
{
 800c08e:	4607      	mov	r7, r0
  int getNum = 0;
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 800c090:	f8d3 8010 	ldr.w	r8, [r3, #16]
 800c094:	4615      	mov	r5, r2
  eventType = 1;//Timeout by default
}

int SPIreceiveData(portNum_t portNum, char *buffer, int maxSize)
{
  int getNum = 0;
 800c096:	2400      	movs	r4, #0
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
  while (maxSize--)
 800c098:	b14d      	cbz	r5, 800c0ae <SPIreceiveData+0x2e>
    {
      int data = rrGet(&(helper->rr));
 800c09a:	4640      	mov	r0, r8
 800c09c:	f7ff fe44 	bl	800bd28 <rrGet>
      if (data >= 0)
 800c0a0:	2800      	cmp	r0, #0
        {
          *(buffer++) = data;
 800c0a2:	bfa2      	ittt	ge
 800c0a4:	7030      	strbge	r0, [r6, #0]
          getNum++;
 800c0a6:	3401      	addge	r4, #1
  while (maxSize--)
    {
      int data = rrGet(&(helper->rr));
      if (data >= 0)
        {
          *(buffer++) = data;
 800c0a8:	3601      	addge	r6, #1
 800c0aa:	3d01      	subs	r5, #1
 800c0ac:	e7f4      	b.n	800c098 <SPIreceiveData+0x18>
          getNum++;
        }
    }
  if (helper->rr.num > 0)
 800c0ae:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800c0b2:	2b00      	cmp	r3, #0
 800c0b4:	dd12      	ble.n	800c0dc <SPIreceiveData+0x5c>
    massert(portDataTxRxComplete(portNum, PORT_TYPE_SPI, RXTX_COMPLETE_RX) >= 0);
 800c0b6:	2202      	movs	r2, #2
 800c0b8:	2101      	movs	r1, #1
 800c0ba:	4638      	mov	r0, r7
 800c0bc:	f7ff fdb6 	bl	800bc2c <portDataTxRxComplete>
 800c0c0:	2800      	cmp	r0, #0
 800c0c2:	da0b      	bge.n	800c0dc <SPIreceiveData+0x5c>
 800c0c4:	4b08      	ldr	r3, [pc, #32]	; (800c0e8 <SPIreceiveData+0x68>)
 800c0c6:	4909      	ldr	r1, [pc, #36]	; (800c0ec <SPIreceiveData+0x6c>)
 800c0c8:	4809      	ldr	r0, [pc, #36]	; (800c0f0 <SPIreceiveData+0x70>)
 800c0ca:	f44f 72df 	mov.w	r2, #446	; 0x1be
 800c0ce:	f7fc fb49 	bl	8008764 <xprintf>
 800c0d2:	2301      	movs	r3, #1
 800c0d4:	9301      	str	r3, [sp, #4]
 800c0d6:	9b01      	ldr	r3, [sp, #4]
 800c0d8:	2b00      	cmp	r3, #0
 800c0da:	d1fc      	bne.n	800c0d6 <SPIreceiveData+0x56>
  return getNum;
}
 800c0dc:	4620      	mov	r0, r4
 800c0de:	b002      	add	sp, #8
 800c0e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c0e4:	2001aabc 	.word	0x2001aabc
 800c0e8:	0801d122 	.word	0x0801d122
 800c0ec:	08015058 	.word	0x08015058
 800c0f0:	080148f4 	.word	0x080148f4

0800c0f4 <SPIsendData>:

int SPIsendData (portNum_t portNum, char *buffer, int size)
{
 800c0f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c0f6:	4606      	mov	r6, r0
} messageSendBuffer_t;

static int SPISendBuffer(portNum_t portNum, char *buffer, int bufferLen)
{
  //Allocate resources for data transfer
  messageSendBuffer_t *message = dAlloc(sizeof(messageSendBuffer_t));
 800c0f8:	2009      	movs	r0, #9
    massert(portDataTxRxComplete(portNum, PORT_TYPE_SPI, RXTX_COMPLETE_RX) >= 0);
  return getNum;
}

int SPIsendData (portNum_t portNum, char *buffer, int size)
{
 800c0fa:	460f      	mov	r7, r1
 800c0fc:	4615      	mov	r5, r2
} messageSendBuffer_t;

static int SPISendBuffer(portNum_t portNum, char *buffer, int bufferLen)
{
  //Allocate resources for data transfer
  messageSendBuffer_t *message = dAlloc(sizeof(messageSendBuffer_t));
 800c0fe:	f001 fa97 	bl	800d630 <bAlloc>
 800c102:	4604      	mov	r4, r0
 800c104:	b178      	cbz	r0, 800c126 <SPIsendData+0x32>

  if (message == NULL)
    return -1;

  //Fill message
  message->buffer = buffer;
 800c106:	6147      	str	r7, [r0, #20]
  message->bufLen = bufferLen;
 800c108:	6185      	str	r5, [r0, #24]
  message->portNum = portNum;
 800c10a:	7706      	strb	r6, [r0, #28]

  //Send the message to communicator
  if (moduleSendCommand(&moduleSPI, CMD_SEND_BUFFER, message) < 0)
 800c10c:	f100 0214 	add.w	r2, r0, #20
 800c110:	2101      	movs	r1, #1
 800c112:	4806      	ldr	r0, [pc, #24]	; (800c12c <SPIsendData+0x38>)
 800c114:	f7ff f820 	bl	800b158 <moduleSendCommand>
 800c118:	2800      	cmp	r0, #0
 800c11a:	da05      	bge.n	800c128 <SPIsendData+0x34>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800c11c:	4620      	mov	r0, r4
 800c11e:	f001 fce1 	bl	800dae4 <bFree>
  return getNum;
}

int SPIsendData (portNum_t portNum, char *buffer, int size)
{
  int putNum = 0;
 800c122:	2500      	movs	r5, #0
 800c124:	e000      	b.n	800c128 <SPIsendData+0x34>
 800c126:	4605      	mov	r5, r0
  if (SPISendBuffer(portNum, buffer, size) >= 0 )
    putNum = size;
  return putNum;
}
 800c128:	4628      	mov	r0, r5
 800c12a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c12c:	2001a8f8 	.word	0x2001a8f8

0800c130 <spiHelperInit>:

void spiHelperInit(void)
{
 800c130:	b507      	push	{r0, r1, r2, lr}
  massert((mutex = xSemaphoreCreateMutex()));
 800c132:	2001      	movs	r0, #1
 800c134:	f7fe febf 	bl	800aeb6 <xQueueCreateMutex>
 800c138:	4b0b      	ldr	r3, [pc, #44]	; (800c168 <spiHelperInit+0x38>)
 800c13a:	6018      	str	r0, [r3, #0]
 800c13c:	b130      	cbz	r0, 800c14c <spiHelperInit+0x1c>
  moduleSPI.privateData = &moduleSPI;
 800c13e:	480b      	ldr	r0, [pc, #44]	; (800c16c <spiHelperInit+0x3c>)
 800c140:	6300      	str	r0, [r0, #48]	; 0x30
  moduleInit(&(moduleSPI));
 800c142:	f7ff f85d 	bl	800b200 <moduleInit>
}
 800c146:	b003      	add	sp, #12
 800c148:	f85d fb04 	ldr.w	pc, [sp], #4
  return putNum;
}

void spiHelperInit(void)
{
  massert((mutex = xSemaphoreCreateMutex()));
 800c14c:	4b08      	ldr	r3, [pc, #32]	; (800c170 <spiHelperInit+0x40>)
 800c14e:	4909      	ldr	r1, [pc, #36]	; (800c174 <spiHelperInit+0x44>)
 800c150:	4809      	ldr	r0, [pc, #36]	; (800c178 <spiHelperInit+0x48>)
 800c152:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
 800c156:	f7fc fb05 	bl	8008764 <xprintf>
 800c15a:	2301      	movs	r3, #1
 800c15c:	9301      	str	r3, [sp, #4]
 800c15e:	9b01      	ldr	r3, [sp, #4]
 800c160:	2b00      	cmp	r3, #0
 800c162:	d1fc      	bne.n	800c15e <spiHelperInit+0x2e>
 800c164:	e7eb      	b.n	800c13e <spiHelperInit+0xe>
 800c166:	bf00      	nop
 800c168:	2001ad54 	.word	0x2001ad54
 800c16c:	2001a8f8 	.word	0x2001a8f8
 800c170:	0801d166 	.word	0x0801d166
 800c174:	08015067 	.word	0x08015067
 800c178:	080148f4 	.word	0x080148f4

0800c17c <ehifStart>:
}

static spi_t *EHIF_SPI_HOOK = NULL;

int ehifStart(spi_t *spi)
{
 800c17c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  massert(spi);
 800c17e:	4605      	mov	r5, r0
 800c180:	b160      	cbz	r0, 800c19c <ehifStart+0x20>
  if( xSemaphoreTake( mutex, portMAX_DELAY) == pdTRUE )
 800c182:	4c0f      	ldr	r4, [pc, #60]	; (800c1c0 <ehifStart+0x44>)
 800c184:	2300      	movs	r3, #0
 800c186:	f04f 32ff 	mov.w	r2, #4294967295
 800c18a:	4619      	mov	r1, r3
 800c18c:	6820      	ldr	r0, [r4, #0]
 800c18e:	f7fe ff0b 	bl	800afa8 <xQueueGenericReceive>
 800c192:	2801      	cmp	r0, #1
 800c194:	d00f      	beq.n	800c1b6 <ehifStart+0x3a>
    {
      EHIF_SPI_HOOK = spi;
      return 0;
    }
  return -1;
 800c196:	f04f 30ff 	mov.w	r0, #4294967295
 800c19a:	e00e      	b.n	800c1ba <ehifStart+0x3e>

static spi_t *EHIF_SPI_HOOK = NULL;

int ehifStart(spi_t *spi)
{
  massert(spi);
 800c19c:	4b09      	ldr	r3, [pc, #36]	; (800c1c4 <ehifStart+0x48>)
 800c19e:	490a      	ldr	r1, [pc, #40]	; (800c1c8 <ehifStart+0x4c>)
 800c1a0:	480a      	ldr	r0, [pc, #40]	; (800c1cc <ehifStart+0x50>)
 800c1a2:	f240 12d5 	movw	r2, #469	; 0x1d5
 800c1a6:	f7fc fadd 	bl	8008764 <xprintf>
 800c1aa:	2301      	movs	r3, #1
 800c1ac:	9301      	str	r3, [sp, #4]
 800c1ae:	9b01      	ldr	r3, [sp, #4]
 800c1b0:	2b00      	cmp	r3, #0
 800c1b2:	d1fc      	bne.n	800c1ae <ehifStart+0x32>
 800c1b4:	e7e5      	b.n	800c182 <ehifStart+0x6>
  if( xSemaphoreTake( mutex, portMAX_DELAY) == pdTRUE )
    {
      EHIF_SPI_HOOK = spi;
 800c1b6:	6065      	str	r5, [r4, #4]
      return 0;
 800c1b8:	2000      	movs	r0, #0
    }
  return -1;
}
 800c1ba:	b003      	add	sp, #12
 800c1bc:	bd30      	pop	{r4, r5, pc}
 800c1be:	bf00      	nop
 800c1c0:	2001ad54 	.word	0x2001ad54
 800c1c4:	0801d188 	.word	0x0801d188
 800c1c8:	08015075 	.word	0x08015075
 800c1cc:	080148f4 	.word	0x080148f4

0800c1d0 <ehifStop>:

void ehifStop(void)
{
  if(EHIF_SPI_HOOK)
 800c1d0:	4805      	ldr	r0, [pc, #20]	; (800c1e8 <ehifStop+0x18>)
 800c1d2:	6843      	ldr	r3, [r0, #4]
 800c1d4:	b133      	cbz	r3, 800c1e4 <ehifStop+0x14>
    {
      EHIF_SPI_HOOK = NULL;
 800c1d6:	2300      	movs	r3, #0
 800c1d8:	6043      	str	r3, [r0, #4]
      xSemaphoreGive(mutex);
 800c1da:	461a      	mov	r2, r3
 800c1dc:	4619      	mov	r1, r3
 800c1de:	6800      	ldr	r0, [r0, #0]
 800c1e0:	f7fe bddf 	b.w	800ada2 <xQueueGenericSend>
 800c1e4:	4770      	bx	lr
 800c1e6:	bf00      	nop
 800c1e8:	2001ad54 	.word	0x2001ad54

0800c1ec <checkDataReady>:

  massert(portDataTxRxComplete(message->portNum, PORT_TYPE_SPI, RXTX_COMPLETE_TX) >= 0);
  dFree(message);
}
static void checkDataReady(void)
{
 800c1ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int radioNum;
  for (radioNum = 0 ; radioNum < RADIO_MODULES; radioNum++)
    {
      radioModule_t *rm = &(radioModule[radioNum]);
      if(rm->spi.spi)
 800c1f0:	4c61      	ldr	r4, [pc, #388]	; (800c378 <checkDataReady+0x18c>)
 800c1f2:	6823      	ldr	r3, [r4, #0]

  massert(portDataTxRxComplete(message->portNum, PORT_TYPE_SPI, RXTX_COMPLETE_TX) >= 0);
  dFree(message);
}
static void checkDataReady(void)
{
 800c1f4:	b08d      	sub	sp, #52	; 0x34
  int radioNum;
  for (radioNum = 0 ; radioNum < RADIO_MODULES; radioNum++)
    {
      radioModule_t *rm = &(radioModule[radioNum]);
      if(rm->spi.spi)
 800c1f6:	2b00      	cmp	r3, #0
 800c1f8:	f000 80ba 	beq.w	800c370 <checkDataReady+0x184>
    {
      // data rx
      portNum_t p;
      for (p = 0; p < PORTS_NUM; p++)
        {
          spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
 800c1fc:	4e5f      	ldr	r6, [pc, #380]	; (800c37c <checkDataReady+0x190>)
 800c1fe:	4637      	mov	r7, r6
}

static int SPI_Check(radioModule_t *rm, int eventType)
{
  int ret = 0;
  if (rm && rm->spi.spi)
 800c200:	6823      	ldr	r3, [r4, #0]
 800c202:	f8df 8174 	ldr.w	r8, [pc, #372]	; 800c378 <checkDataReady+0x18c>
 800c206:	2b00      	cmp	r3, #0
 800c208:	f000 80b2 	beq.w	800c370 <checkDataReady+0x184>
    {
      ehifStart(&rm->spi);
 800c20c:	4640      	mov	r0, r8
 800c20e:	f7ff ffb5 	bl	800c17c <ehifStart>
      //Check if data is ready
      rm->status = ehifGetStatus();
 800c212:	f007 fc62 	bl	8013ada <ehifGetStatus>
      if(rm->status != 0xFFFF)
 800c216:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800c21a:	4298      	cmp	r0, r3
  int ret = 0;
  if (rm && rm->spi.spi)
    {
      ehifStart(&rm->spi);
      //Check if data is ready
      rm->status = ehifGetStatus();
 800c21c:	4605      	mov	r5, r0
 800c21e:	f8a8 0038 	strh.w	r0, [r8, #56]	; 0x38
      if(rm->status != 0xFFFF)
 800c222:	d039      	beq.n	800c298 <checkDataReady+0xac>
        {
          uint16_t clrMask = (uint32_t)rm->status & (BV_EHIF_EVT_VOL_CHG | BV_EHIF_EVT_PS_CHG | BV_EHIF_EVT_NWK_CHG | BV_EHIF_EVT_SR_CHG | BV_EHIF_EVT_DSC_RESET);
          if(clrMask)
 800c224:	f010 082f 	ands.w	r8, r0, #47	; 0x2f
 800c228:	d02e      	beq.n	800c288 <checkDataReady+0x9c>
            {
              //              if(clrMask&BV_EHIF_EVT_DSC_RESET) dprintf(LL_INFO, "Data channel has been reset\n");
              if(clrMask&BV_EHIF_EVT_VOL_CHG)   dprintf(LL_INFO, "Volume has changed\n");
 800c22a:	0703      	lsls	r3, r0, #28
 800c22c:	d506      	bpl.n	800c23c <checkDataReady+0x50>
 800c22e:	4b54      	ldr	r3, [pc, #336]	; (800c380 <checkDataReady+0x194>)
 800c230:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c232:	2b01      	cmp	r3, #1
 800c234:	dd02      	ble.n	800c23c <checkDataReady+0x50>
 800c236:	4853      	ldr	r0, [pc, #332]	; (800c384 <checkDataReady+0x198>)
 800c238:	f7fc fa94 	bl	8008764 <xprintf>
              if(clrMask&BV_EHIF_EVT_PS_CHG)    dprintf(LL_INFO, "Power state has changed to %x\n", (rm->status >> 9)&0x7);
 800c23c:	0768      	lsls	r0, r5, #29
 800c23e:	d509      	bpl.n	800c254 <checkDataReady+0x68>
 800c240:	4b4f      	ldr	r3, [pc, #316]	; (800c380 <checkDataReady+0x194>)
 800c242:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c244:	2b01      	cmp	r3, #1
 800c246:	dd05      	ble.n	800c254 <checkDataReady+0x68>
 800c248:	8f21      	ldrh	r1, [r4, #56]	; 0x38
 800c24a:	484f      	ldr	r0, [pc, #316]	; (800c388 <checkDataReady+0x19c>)
 800c24c:	f3c1 2142 	ubfx	r1, r1, #9, #3
 800c250:	f7fc fa88 	bl	8008764 <xprintf>
              if(clrMask&BV_EHIF_EVT_NWK_CHG)
 800c254:	07a9      	lsls	r1, r5, #30
 800c256:	d50b      	bpl.n	800c270 <checkDataReady+0x84>
                {
                  dprintf(LL_INFO, "Network state has changed\n");
 800c258:	4b49      	ldr	r3, [pc, #292]	; (800c380 <checkDataReady+0x194>)
 800c25a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c25c:	2b01      	cmp	r3, #1
 800c25e:	dd02      	ble.n	800c266 <checkDataReady+0x7a>
 800c260:	484a      	ldr	r0, [pc, #296]	; (800c38c <checkDataReady+0x1a0>)
 800c262:	f7fc fa7f 	bl	8008764 <xprintf>
                  rm->nwkStateChange++;
 800c266:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
 800c26a:	3301      	adds	r3, #1
 800c26c:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
                }
              if(clrMask&BV_EHIF_EVT_SR_CHG)    dprintf(LL_INFO, "Sample rate has changed\n");
 800c270:	07ea      	lsls	r2, r5, #31
 800c272:	d506      	bpl.n	800c282 <checkDataReady+0x96>
 800c274:	4b42      	ldr	r3, [pc, #264]	; (800c380 <checkDataReady+0x194>)
 800c276:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c278:	2b01      	cmp	r3, #1
 800c27a:	dd02      	ble.n	800c282 <checkDataReady+0x96>
 800c27c:	4844      	ldr	r0, [pc, #272]	; (800c390 <checkDataReady+0x1a4>)
 800c27e:	f7fc fa71 	bl	8008764 <xprintf>
              clearFlags(clrMask);
 800c282:	4640      	mov	r0, r8
 800c284:	f007 f864 	bl	8013350 <clearFlags>
            }
          if ( rm->status & BV_EHIF_STAT_CONNECTED )  //0xFFFF when no CS or no cable connection
 800c288:	8f25      	ldrh	r5, [r4, #56]	; 0x38
#endif
}

static int SPI_Check(radioModule_t *rm, int eventType)
{
  int ret = 0;
 800c28a:	f405 75c0 	and.w	r5, r5, #384	; 0x180
 800c28e:	f5a5 73c0 	sub.w	r3, r5, #384	; 0x180
 800c292:	425d      	negs	r5, r3
 800c294:	415d      	adcs	r5, r3
 800c296:	e000      	b.n	800c29a <checkDataReady+0xae>
 800c298:	2500      	movs	r5, #0
            {
              if (rm->status & BV_EHIF_EVT_DSC_RX_AVAIL)
                ret =  1;
            }
        }
      ehifStop();
 800c29a:	f7ff ff99 	bl	800c1d0 <ehifStop>
    {
      radioModule_t *rm = &(radioModule[radioNum]);
      if(rm->spi.spi)
        {
          //Check for data
          while (SPI_Check(rm, eventType))
 800c29e:	2d00      	cmp	r5, #0
 800c2a0:	d066      	beq.n	800c370 <checkDataReady+0x184>
  return ret;
}

static int radioReceive(radioModule_t *rm, portNum_t *portNum, char *rxBuffer)
{
  ehifStart(&rm->spi);
 800c2a2:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 800c378 <checkDataReady+0x18c>
 800c2a6:	4640      	mov	r0, r8
 800c2a8:	f7ff ff68 	bl	800c17c <ehifStart>
  uint32_t address = 0 ;
  uint8_t reset = 0;;
 800c2ac:	aa0c      	add	r2, sp, #48	; 0x30
}

static int radioReceive(radioModule_t *rm, portNum_t *portNum, char *rxBuffer)
{
  ehifStart(&rm->spi);
  uint32_t address = 0 ;
 800c2ae:	2500      	movs	r5, #0
  uint8_t reset = 0;;
  int size = queueRX(&address, (uint8_t *)rxBuffer, &reset) ;
 800c2b0:	f10d 0910 	add.w	r9, sp, #16

static int radioReceive(radioModule_t *rm, portNum_t *portNum, char *rxBuffer)
{
  ehifStart(&rm->spi);
  uint32_t address = 0 ;
  uint8_t reset = 0;;
 800c2b4:	f802 5d29 	strb.w	r5, [r2, #-41]!
  int size = queueRX(&address, (uint8_t *)rxBuffer, &reset) ;
 800c2b8:	4649      	mov	r1, r9
 800c2ba:	a803      	add	r0, sp, #12
}

static int radioReceive(radioModule_t *rm, portNum_t *portNum, char *rxBuffer)
{
  ehifStart(&rm->spi);
  uint32_t address = 0 ;
 800c2bc:	9503      	str	r5, [sp, #12]
  uint8_t reset = 0;;
  int size = queueRX(&address, (uint8_t *)rxBuffer, &reset) ;
 800c2be:	f007 f869 	bl	8013394 <queueRX>
 800c2c2:	4682      	mov	sl, r0
  ehifStop();
 800c2c4:	f7ff ff84 	bl	800c1d0 <ehifStop>
  if (size)
 800c2c8:	f1ba 0f00 	cmp.w	sl, #0
 800c2cc:	d098      	beq.n	800c200 <checkDataReady+0x14>
#ifdef MADO
              //For master the address is remote.
              helper->connDev.devID == address
#else
              //For slave it is slaves address
              helper->radioModule->device.devID == address
 800c2ce:	f8d8 e01c 	ldr.w	lr, [r8, #28]
 800c2d2:	9903      	ldr	r1, [sp, #12]
 800c2d4:	462b      	mov	r3, r5
    {
      // data rx
      portNum_t p;
      for (p = 0; p < PORTS_NUM; p++)
        {
          spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
 800c2d6:	f04f 0c50 	mov.w	ip, #80	; 0x50
 800c2da:	fb0c 6203 	mla	r2, ip, r3, r6
 800c2de:	b2dd      	uxtb	r5, r3
 800c2e0:	6910      	ldr	r0, [r2, #16]
          if (helper &&
 800c2e2:	b168      	cbz	r0, 800c300 <checkDataReady+0x114>
              helper->radioModule &&
 800c2e4:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
      // data rx
      portNum_t p;
      for (p = 0; p < PORTS_NUM; p++)
        {
          spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
          if (helper &&
 800c2e8:	b150      	cbz	r0, 800c300 <checkDataReady+0x114>
              helper->radioModule &&
 800c2ea:	42a0      	cmp	r0, r4
 800c2ec:	d108      	bne.n	800c300 <checkDataReady+0x114>
              helper->radioModule == rm &&
 800c2ee:	458e      	cmp	lr, r1
 800c2f0:	d106      	bne.n	800c300 <checkDataReady+0x114>
              helper->radioModule->device.devID == address
#endif
             )
            {
              *portNum = p;
              if(reset)
 800c2f2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c2f6:	b193      	cbz	r3, 800c31e <checkDataReady+0x132>
                portData[p].dscResetRx++;
 800c2f8:	6c93      	ldr	r3, [r2, #72]	; 0x48
 800c2fa:	3301      	adds	r3, #1
 800c2fc:	6493      	str	r3, [r2, #72]	; 0x48
 800c2fe:	e00e      	b.n	800c31e <checkDataReady+0x132>
 800c300:	3301      	adds	r3, #1
  ehifStop();
  if (size)
    {
      // data rx
      portNum_t p;
      for (p = 0; p < PORTS_NUM; p++)
 800c302:	2b03      	cmp	r3, #3
 800c304:	d1e9      	bne.n	800c2da <checkDataReady+0xee>
                portData[p].dscResetRx++;

              break;
            }
        }
      if (p == PORTS_NUM)
 800c306:	2d02      	cmp	r5, #2
 800c308:	d108      	bne.n	800c31c <checkDataReady+0x130>
        {
          dprintf(LL_WARNING, "No matching port for message with address %x found.\n", address);
 800c30a:	4b1d      	ldr	r3, [pc, #116]	; (800c380 <checkDataReady+0x194>)
 800c30c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c30e:	2b00      	cmp	r3, #0
 800c310:	f77f af76 	ble.w	800c200 <checkDataReady+0x14>
 800c314:	481f      	ldr	r0, [pc, #124]	; (800c394 <checkDataReady+0x1a8>)
 800c316:	f7fc fa25 	bl	8008764 <xprintf>
 800c31a:	e771      	b.n	800c200 <checkDataReady+0x14>
          //Check for data
          while (SPI_Check(rm, eventType))
            {
              char buffer[MAX_DATA_SIZE];
              int size;
              portNum_t p = 0;
 800c31c:	2500      	movs	r5, #0
              if ((size = radioReceive(rm, &p, buffer)))
 800c31e:	f1ba 0f00 	cmp.w	sl, #0
 800c322:	f43f af6d 	beq.w	800c200 <checkDataReady+0x14>
                {
                  int idx = 0;
                  spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
 800c326:	2350      	movs	r3, #80	; 0x50
 800c328:	fb03 7305 	mla	r3, r3, r5, r7
 800c32c:	f04f 0800 	mov.w	r8, #0
 800c330:	f8d3 b010 	ldr.w	fp, [r3, #16]
                  while (size--) rrPut(&(helper->rr), buffer[idx++]);
 800c334:	f819 1008 	ldrb.w	r1, [r9, r8]
 800c338:	4658      	mov	r0, fp
 800c33a:	f108 0801 	add.w	r8, r8, #1
 800c33e:	f7ff fd13 	bl	800bd68 <rrPut>
 800c342:	45c2      	cmp	sl, r8
 800c344:	d1f6      	bne.n	800c334 <checkDataReady+0x148>
                  massert(portDataTxRxComplete(p, PORT_TYPE_SPI, RXTX_COMPLETE_RX) >= 0);
 800c346:	2202      	movs	r2, #2
 800c348:	2101      	movs	r1, #1
 800c34a:	4628      	mov	r0, r5
 800c34c:	f7ff fc6e 	bl	800bc2c <portDataTxRxComplete>
 800c350:	2800      	cmp	r0, #0
 800c352:	f6bf af55 	bge.w	800c200 <checkDataReady+0x14>
 800c356:	4b10      	ldr	r3, [pc, #64]	; (800c398 <checkDataReady+0x1ac>)
 800c358:	4910      	ldr	r1, [pc, #64]	; (800c39c <checkDataReady+0x1b0>)
 800c35a:	4811      	ldr	r0, [pc, #68]	; (800c3a0 <checkDataReady+0x1b4>)
 800c35c:	f44f 72ca 	mov.w	r2, #404	; 0x194
 800c360:	f7fc fa00 	bl	8008764 <xprintf>
 800c364:	2301      	movs	r3, #1
 800c366:	9302      	str	r3, [sp, #8]
 800c368:	9b02      	ldr	r3, [sp, #8]
 800c36a:	2b00      	cmp	r3, #0
 800c36c:	d1fc      	bne.n	800c368 <checkDataReady+0x17c>
 800c36e:	e747      	b.n	800c200 <checkDataReady+0x14>
                }
            }
        }
    }
}
 800c370:	b00d      	add	sp, #52	; 0x34
 800c372:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c376:	bf00      	nop
 800c378:	2001add4 	.word	0x2001add4
 800c37c:	2001aabc 	.word	0x2001aabc
 800c380:	10001000 	.word	0x10001000
 800c384:	0801d1ff 	.word	0x0801d1ff
 800c388:	0801d213 	.word	0x0801d213
 800c38c:	0801d232 	.word	0x0801d232
 800c390:	0801d24d 	.word	0x0801d24d
 800c394:	0801d18c 	.word	0x0801d18c
 800c398:	0801d1c1 	.word	0x0801d1c1
 800c39c:	0801507f 	.word	0x0801507f
 800c3a0:	080148f4 	.word	0x080148f4

0800c3a4 <slaveDisconnect>:
  return 1;
}

void slaveDisconnect(void)
{
  disconnectFromMaster();
 800c3a4:	f007 b950 	b.w	8013648 <disconnectFromMaster>

0800c3a8 <sendNetworkStatus>:

int __attribute__((weak))sendNetworkStatus(portNum_t portNum, netStatus_e status, uint8_t lastByte)
{
  //Weak placeholder.
  return 0;
}
 800c3a8:	2000      	movs	r0, #0
 800c3aa:	4770      	bx	lr

0800c3ac <SPIInternalEvent>:
  return 0;
}

static int eventType = 1;//Timeout by default
static void SPIInternalEvent(void *data)
{
 800c3ac:	b5f0      	push	{r4, r5, r6, r7, lr}
  ev_t ev = {.raw = (uint32_t)data};
  switch (ev.evType)
 800c3ae:	f3c0 2207 	ubfx	r2, r0, #8, #8
  return 0;
}

static int eventType = 1;//Timeout by default
static void SPIInternalEvent(void *data)
{
 800c3b2:	b085      	sub	sp, #20
  ev_t ev = {.raw = (uint32_t)data};
  switch (ev.evType)
 800c3b4:	2a02      	cmp	r2, #2
}

static int eventType = 1;//Timeout by default
static void SPIInternalEvent(void *data)
{
  ev_t ev = {.raw = (uint32_t)data};
 800c3b6:	9003      	str	r0, [sp, #12]
  switch (ev.evType)
 800c3b8:	d041      	beq.n	800c43e <SPIInternalEvent+0x92>
 800c3ba:	2a03      	cmp	r2, #3
 800c3bc:	f000 8081 	beq.w	800c4c2 <SPIInternalEvent+0x116>
 800c3c0:	2a01      	cmp	r2, #1
 800c3c2:	f040 80ca 	bne.w	800c55a <SPIInternalEvent+0x1ae>
      eventType = 2;
      break;
    case SPI_EV_TYPE_LINK_ERROR:
    {
      //Degrade connection status as link connection error was detected
      spiHelper_t *helper = (spiHelper_t *)portData[ev.portNum].SPIhelper;
 800c3c6:	f89d 500c 	ldrb.w	r5, [sp, #12]
 800c3ca:	4a65      	ldr	r2, [pc, #404]	; (800c560 <SPIInternalEvent+0x1b4>)
 800c3cc:	2350      	movs	r3, #80	; 0x50
 800c3ce:	fb03 2305 	mla	r3, r3, r5, r2
 800c3d2:	691c      	ldr	r4, [r3, #16]
      if(!helper) break;
 800c3d4:	2c00      	cmp	r4, #0
 800c3d6:	f000 80c0 	beq.w	800c55a <SPIInternalEvent+0x1ae>
      if(portData[ev.portNum].portType == PORT_TYPE_SPI)
 800c3da:	7e1a      	ldrb	r2, [r3, #24]
 800c3dc:	2a01      	cmp	r2, #1
 800c3de:	f893 2020 	ldrb.w	r2, [r3, #32]
 800c3e2:	d126      	bne.n	800c432 <SPIInternalEvent+0x86>
        {
          if (portData[ev.portNum].connState != DEV_NCONN)
 800c3e4:	2a00      	cmp	r2, #0
 800c3e6:	f000 80b8 	beq.w	800c55a <SPIInternalEvent+0x1ae>
            {
              portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
              portData[ev.portNum].connState = DEV_NCONN;
 800c3ea:	2000      	movs	r0, #0
      if(!helper) break;
      if(portData[ev.portNum].portType == PORT_TYPE_SPI)
        {
          if (portData[ev.portNum].connState != DEV_NCONN)
            {
              portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
 800c3ec:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
              portData[ev.portNum].connState = DEV_NCONN;
 800c3f0:	f883 0020 	strb.w	r0, [r3, #32]
              connectionState(NET_NC);
 800c3f4:	f7fd f85e 	bl	80094b4 <connectionState>
              dprintf(LL_INFO, "Connection with peer (%08x:%08x:%08x) lost.\n",
 800c3f8:	4b5a      	ldr	r3, [pc, #360]	; (800c564 <SPIInternalEvent+0x1b8>)
 800c3fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c3fc:	2b01      	cmp	r3, #1
 800c3fe:	dd08      	ble.n	800c412 <SPIInternalEvent+0x66>
 800c400:	f8d4 311d 	ldr.w	r3, [r4, #285]	; 0x11d
 800c404:	f8d4 2119 	ldr.w	r2, [r4, #281]	; 0x119
 800c408:	f8d4 1115 	ldr.w	r1, [r4, #277]	; 0x115
 800c40c:	4856      	ldr	r0, [pc, #344]	; (800c568 <SPIInternalEvent+0x1bc>)
 800c40e:	f7fc f9a9 	bl	8008764 <xprintf>
                      helper->connDev.devID,
                      helper->connDev.manID,
                      helper->connDev.prodID);
              switchPortHelper(ev.portNum, PORT_TYPE_USART);
 800c412:	2100      	movs	r1, #0
 800c414:	4628      	mov	r0, r5
 800c416:	f7ff fc43 	bl	800bca0 <switchPortHelper>
                {
                  //Deregister speakerset from a stream
                  pipeSetSpkSet(0, -1, (ev.portNum-PER1_PORT)>>1);
                }
#else
              SmokLEDsState(-1, 0, SET_NONE, -1);
 800c41a:	2200      	movs	r2, #0
 800c41c:	f04f 33ff 	mov.w	r3, #4294967295
 800c420:	4611      	mov	r1, r2
 800c422:	4618      	mov	r0, r3
 800c424:	f7fd fa34 	bl	8009890 <SmokLEDsState>
#endif

              sendNetworkStatus(ev.portNum, NET_DROPPED, (uint8_t)helper->connDev.devID);
 800c428:	f8d4 2115 	ldr.w	r2, [r4, #277]	; 0x115
 800c42c:	2103      	movs	r1, #3
 800c42e:	b2d2      	uxtb	r2, r2
 800c430:	e07c      	b.n	800c52c <SPIInternalEvent+0x180>
            }
        }
      else
        {
          if (portData[ev.portNum].connState == DEV_UCONN)
 800c432:	2a03      	cmp	r2, #3
 800c434:	f040 8091 	bne.w	800c55a <SPIInternalEvent+0x1ae>
            {
              portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
 800c438:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
 800c43c:	e02c      	b.n	800c498 <SPIInternalEvent+0xec>
    }
    break;
    case SPI_EV_TYPE_DLINK_ERROR:
    {
      //Degrade connection status as link connection error was detected
      spiHelper_t *helper = (spiHelper_t *)portData[ev.portNum].SPIhelper;
 800c43e:	f89d 500c 	ldrb.w	r5, [sp, #12]
 800c442:	4947      	ldr	r1, [pc, #284]	; (800c560 <SPIInternalEvent+0x1b4>)
 800c444:	2350      	movs	r3, #80	; 0x50
 800c446:	fb03 1305 	mla	r3, r3, r5, r1
 800c44a:	691c      	ldr	r4, [r3, #16]
      if(!helper) break;
 800c44c:	2c00      	cmp	r4, #0
 800c44e:	f000 8084 	beq.w	800c55a <SPIInternalEvent+0x1ae>
      if(portData[ev.portNum].portType == PORT_TYPE_SPI)
 800c452:	7e19      	ldrb	r1, [r3, #24]
 800c454:	f893 0020 	ldrb.w	r0, [r3, #32]
 800c458:	2901      	cmp	r1, #1
 800c45a:	d119      	bne.n	800c490 <SPIInternalEvent+0xe4>
        {
          if (portData[ev.portNum].connState == DEV_CONN)
 800c45c:	2801      	cmp	r0, #1
 800c45e:	d17c      	bne.n	800c55a <SPIInternalEvent+0x1ae>
            {
              portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
 800c460:	f883 0021 	strb.w	r0, [r3, #33]	; 0x21
              portData[ev.portNum].connState = DEV_PCONN;
 800c464:	f883 2020 	strb.w	r2, [r3, #32]
              connectionState(NET_PARTIAL);
 800c468:	f7fd f824 	bl	80094b4 <connectionState>
              dprintf(LL_INFO, "Datagram connection with peer (%08x:%08x:%08x) lost.\n",
 800c46c:	4b3d      	ldr	r3, [pc, #244]	; (800c564 <SPIInternalEvent+0x1b8>)
 800c46e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c470:	2b01      	cmp	r3, #1
 800c472:	dd08      	ble.n	800c486 <SPIInternalEvent+0xda>
 800c474:	f8d4 311d 	ldr.w	r3, [r4, #285]	; 0x11d
 800c478:	f8d4 2119 	ldr.w	r2, [r4, #281]	; 0x119
 800c47c:	f8d4 1115 	ldr.w	r1, [r4, #277]	; 0x115
 800c480:	483a      	ldr	r0, [pc, #232]	; (800c56c <SPIInternalEvent+0x1c0>)
 800c482:	f7fc f96f 	bl	8008764 <xprintf>
                      helper->connDev.devID,
                      helper->connDev.manID,
                      helper->connDev.prodID);
              sendNetworkStatus(ev.portNum, NET_DATAGRAM_LOST, (uint8_t)helper->connDev.devID);
 800c486:	f8d4 2115 	ldr.w	r2, [r4, #277]	; 0x115
 800c48a:	2102      	movs	r1, #2
 800c48c:	b2d2      	uxtb	r2, r2
 800c48e:	e04d      	b.n	800c52c <SPIInternalEvent+0x180>

            }
        }
      else
        {
          if (portData[ev.portNum].connState == DEV_UCONN)
 800c490:	2803      	cmp	r0, #3
 800c492:	d162      	bne.n	800c55a <SPIInternalEvent+0x1ae>
            {
              portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
 800c494:	f883 0021 	strb.w	r0, [r3, #33]	; 0x21
              portData[ev.portNum].connState = DEV_NCONN;
 800c498:	2000      	movs	r0, #0
 800c49a:	f883 0020 	strb.w	r0, [r3, #32]
              connectionState(NET_NC);
 800c49e:	f7fd f809 	bl	80094b4 <connectionState>
              dprintf(LL_INFO, "Cable connection with peer (%08x:%08x:%08x) lost.\n",
 800c4a2:	4b30      	ldr	r3, [pc, #192]	; (800c564 <SPIInternalEvent+0x1b8>)
 800c4a4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c4a6:	2b01      	cmp	r3, #1
 800c4a8:	dd57      	ble.n	800c55a <SPIInternalEvent+0x1ae>
 800c4aa:	f8d4 311d 	ldr.w	r3, [r4, #285]	; 0x11d
 800c4ae:	f8d4 2119 	ldr.w	r2, [r4, #281]	; 0x119
 800c4b2:	f8d4 1115 	ldr.w	r1, [r4, #277]	; 0x115
 800c4b6:	482e      	ldr	r0, [pc, #184]	; (800c570 <SPIInternalEvent+0x1c4>)
#endif
        }
    }
    break;
    }
}
 800c4b8:	b005      	add	sp, #20
 800c4ba:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
          if (portData[ev.portNum].connState == DEV_UCONN)
            {
              portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
              portData[ev.portNum].connState = DEV_NCONN;
              connectionState(NET_NC);
              dprintf(LL_INFO, "Cable connection with peer (%08x:%08x:%08x) lost.\n",
 800c4be:	f7fc b951 	b.w	8008764 <xprintf>
        }
    }
    break;
    case SPI_EV_TYPE_LINK_ESTABLISHED:
    {
      spiHelper_t *helper = (spiHelper_t *)portData[ev.portNum].SPIhelper;
 800c4c2:	4c27      	ldr	r4, [pc, #156]	; (800c560 <SPIInternalEvent+0x1b4>)
 800c4c4:	f89d 500c 	ldrb.w	r5, [sp, #12]
 800c4c8:	2350      	movs	r3, #80	; 0x50
 800c4ca:	fb03 4305 	mla	r3, r3, r5, r4
 800c4ce:	4627      	mov	r7, r4
 800c4d0:	691e      	ldr	r6, [r3, #16]

      int changedState = DEV_NCONN;
      if(helper && portData[ev.portNum].portType == PORT_TYPE_SPI && portData[ev.portNum].connState == DEV_PCONN)
 800c4d2:	b13e      	cbz	r6, 800c4e4 <SPIInternalEvent+0x138>
 800c4d4:	7e1c      	ldrb	r4, [r3, #24]
 800c4d6:	2c01      	cmp	r4, #1
 800c4d8:	d104      	bne.n	800c4e4 <SPIInternalEvent+0x138>
 800c4da:	f893 3020 	ldrb.w	r3, [r3, #32]
 800c4de:	2b02      	cmp	r3, #2
 800c4e0:	d13b      	bne.n	800c55a <SPIInternalEvent+0x1ae>
 800c4e2:	e027      	b.n	800c534 <SPIInternalEvent+0x188>
        changedState = DEV_CONN;//Radio full connection established
      else if ((!helper || portData[ev.portNum].portType != PORT_TYPE_SPI) && portData[ev.portNum].connState == DEV_NCONN)
 800c4e4:	2350      	movs	r3, #80	; 0x50
 800c4e6:	fb03 7305 	mla	r3, r3, r5, r7
 800c4ea:	f893 3020 	ldrb.w	r3, [r3, #32]
 800c4ee:	bba3      	cbnz	r3, 800c55a <SPIInternalEvent+0x1ae>
                      helper->connDev.manID,
                      helper->connDev.prodID);
            }
          else
            {
              dprintf(LL_INFO, "%s: Cable connection with peer  established.\n", portStr[ev.portNum]);
 800c4f0:	4b1c      	ldr	r3, [pc, #112]	; (800c564 <SPIInternalEvent+0x1b8>)
 800c4f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c4f4:	2b01      	cmp	r3, #1
 800c4f6:	dd05      	ble.n	800c504 <SPIInternalEvent+0x158>
 800c4f8:	4b1e      	ldr	r3, [pc, #120]	; (800c574 <SPIInternalEvent+0x1c8>)
 800c4fa:	481f      	ldr	r0, [pc, #124]	; (800c578 <SPIInternalEvent+0x1cc>)
 800c4fc:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
 800c500:	f7fc f930 	bl	8008764 <xprintf>

      int changedState = DEV_NCONN;
      if(helper && portData[ev.portNum].portType == PORT_TYPE_SPI && portData[ev.portNum].connState == DEV_PCONN)
        changedState = DEV_CONN;//Radio full connection established
      else if ((!helper || portData[ev.portNum].portType != PORT_TYPE_SPI) && portData[ev.portNum].connState == DEV_NCONN)
        changedState = DEV_UCONN;//UART connection established
 800c504:	2303      	movs	r3, #3
          else
            {
              dprintf(LL_INFO, "%s: Cable connection with peer  established.\n", portStr[ev.portNum]);
            }

          portData[ev.portNum].prevConnState = portData[ev.portNum].connState;
 800c506:	2250      	movs	r2, #80	; 0x50
 800c508:	fb02 7405 	mla	r4, r2, r5, r7
 800c50c:	f894 2020 	ldrb.w	r2, [r4, #32]
 800c510:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
          portData[ev.portNum].connState = changedState;;
 800c514:	f884 3020 	strb.w	r3, [r4, #32]
          portData[ev.portNum].tsConnectedDatagram = xTaskGetTickCount();
 800c518:	f7fe f8c4 	bl	800a6a4 <xTaskGetTickCount>
 800c51c:	6320      	str	r0, [r4, #48]	; 0x30
          connectionState(NET_DATAGRAM);
 800c51e:	2002      	movs	r0, #2
 800c520:	f7fc ffc8 	bl	80094b4 <connectionState>
          sendNetworkStatus(ev.portNum, NET_DATAGRAM_CONNECTED, (uint8_t)helper->connDev.devID);
 800c524:	f8d6 2115 	ldr.w	r2, [r6, #277]	; 0x115
 800c528:	2101      	movs	r1, #1
 800c52a:	b2d2      	uxtb	r2, r2
 800c52c:	4628      	mov	r0, r5
 800c52e:	f7ff ff3b 	bl	800c3a8 <sendNetworkStatus>
#endif
        }
    }
    break;
    }
}
 800c532:	e012      	b.n	800c55a <SPIInternalEvent+0x1ae>

      if(changedState != DEV_NCONN)
        {
          if(changedState == DEV_CONN)
            {
              dprintf(LL_INFO, "%s: Datagram connection with peer (%08x:%08x:%08x) established.\n", portStr[ev.portNum],
 800c534:	4b0b      	ldr	r3, [pc, #44]	; (800c564 <SPIInternalEvent+0x1b8>)
 800c536:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c538:	2b01      	cmp	r3, #1
 800c53a:	dd0c      	ble.n	800c556 <SPIInternalEvent+0x1aa>
 800c53c:	f8d6 111d 	ldr.w	r1, [r6, #285]	; 0x11d
 800c540:	f8d6 3119 	ldr.w	r3, [r6, #281]	; 0x119
 800c544:	f8d6 2115 	ldr.w	r2, [r6, #277]	; 0x115
 800c548:	9100      	str	r1, [sp, #0]
 800c54a:	490a      	ldr	r1, [pc, #40]	; (800c574 <SPIInternalEvent+0x1c8>)
 800c54c:	480b      	ldr	r0, [pc, #44]	; (800c57c <SPIInternalEvent+0x1d0>)
 800c54e:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
 800c552:	f7fc f907 	bl	8008764 <xprintf>
    {
      spiHelper_t *helper = (spiHelper_t *)portData[ev.portNum].SPIhelper;

      int changedState = DEV_NCONN;
      if(helper && portData[ev.portNum].portType == PORT_TYPE_SPI && portData[ev.portNum].connState == DEV_PCONN)
        changedState = DEV_CONN;//Radio full connection established
 800c556:	4623      	mov	r3, r4
 800c558:	e7d5      	b.n	800c506 <SPIInternalEvent+0x15a>
#endif
        }
    }
    break;
    }
}
 800c55a:	b005      	add	sp, #20
 800c55c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c55e:	bf00      	nop
 800c560:	2001aabc 	.word	0x2001aabc
 800c564:	10001000 	.word	0x10001000
 800c568:	0801d266 	.word	0x0801d266
 800c56c:	0801d2c6 	.word	0x0801d2c6
 800c570:	0801d293 	.word	0x0801d293
 800c574:	2001abd8 	.word	0x2001abd8
 800c578:	0801d33d 	.word	0x0801d33d
 800c57c:	0801d2fc 	.word	0x0801d2fc

0800c580 <slaveCheckLink>:
    portData[port].prevConnState = portData[port].connState;
  portData[port].connState = DEV_NCONN;
  return -1;
}
static int slaveCheckLink(radioModule_t *rm)
{
 800c580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c584:	b091      	sub	sp, #68	; 0x44
 800c586:	4ea1      	ldr	r6, [pc, #644]	; (800c80c <slaveCheckLink+0x28c>)
 800c588:	9001      	str	r0, [sp, #4]
  ehifStart(&rm->spi);
 800c58a:	f7ff fdf7 	bl	800c17c <ehifStart>
                  for(fm = 0; fm < 2; fm++)
                    {
                      int ms = (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?1:0;
                      do
                        {
                          dprintf(LL_DEBUG, "Looking for %s %s  master with ManID %x: ",
 800c58e:	f8df b284 	ldr.w	fp, [pc, #644]	; 800c814 <slaveCheckLink+0x294>
  portData[port].connState = DEV_NCONN;
  return -1;
}
static int slaveCheckLink(radioModule_t *rm)
{
  ehifStart(&rm->spi);
 800c592:	f04f 0900 	mov.w	r9, #0
  portNum_t p;
  for (p = 0; p < PORTS_NUM; p++)
    {
      if(portData[p].SPIhelper)
 800c596:	6934      	ldr	r4, [r6, #16]
 800c598:	fa5f fa89 	uxtb.w	sl, r9
 800c59c:	2c00      	cmp	r4, #0
 800c59e:	f000 80ee 	beq.w	800c77e <slaveCheckLink+0x1fe>
        {
          spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
          uint16_t status = ehifGetStatus();
 800c5a2:	f007 fa9a 	bl	8013ada <ehifGetStatus>
          if ( status & BV_EHIF_STAT_CONNECTED)
 800c5a6:	f410 7f80 	tst.w	r0, #256	; 0x100
 800c5aa:	f896 3020 	ldrb.w	r3, [r6, #32]
 800c5ae:	d023      	beq.n	800c5f8 <slaveCheckLink+0x78>
            {
              if(portData[p].connState == DEV_NCONN)
 800c5b0:	b93b      	cbnz	r3, 800c5c2 <slaveCheckLink+0x42>
                {
                  portData[p].prevConnState = portData[p].connState;
 800c5b2:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
                  portData[p].connState = DEV_PCONN;
                  sendKANow(p);
 800c5b6:	4650      	mov	r0, sl
          if ( status & BV_EHIF_STAT_CONNECTED)
            {
              if(portData[p].connState == DEV_NCONN)
                {
                  portData[p].prevConnState = portData[p].connState;
                  portData[p].connState = DEV_PCONN;
 800c5b8:	2302      	movs	r3, #2
 800c5ba:	f886 3020 	strb.w	r3, [r6, #32]
                  sendKANow(p);
 800c5be:	f7fc fae9 	bl	8008b94 <sendKANow>
                }

              EHIF_CMD_NWM_GET_STATUS_SLAVE_DATA_T slaveStat = getStatus();
 800c5c2:	a808      	add	r0, sp, #32
 800c5c4:	f006 ff96 	bl	80134f4 <getStatus>
              helper->connDev.audioConnState = slaveStat.bvAchUsedByMe;
 800c5c8:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
 800c5cc:	f8a4 3121 	strh.w	r3, [r4, #289]	; 0x121
              rm->smplRate = 25*slaveStat.smplRate;
 800c5d0:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 800c5d4:	9a01      	ldr	r2, [sp, #4]
 800c5d6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800c5da:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800c5de:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800c5e2:	6313      	str	r3, [r2, #48]	; 0x30
              rm->tsPeriod = 2000+slaveStat.tsPeriod*250;
 800c5e4:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
 800c5e8:	22fa      	movs	r2, #250	; 0xfa
 800c5ea:	091b      	lsrs	r3, r3, #4
 800c5ec:	4353      	muls	r3, r2
 800c5ee:	9a01      	ldr	r2, [sp, #4]
 800c5f0:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 800c5f4:	6353      	str	r3, [r2, #52]	; 0x34
 800c5f6:	e0c2      	b.n	800c77e <slaveCheckLink+0x1fe>
            }
          else
            {
              if (portData[p].connState == DEV_PCONN || portData[p].connState == DEV_CONN)
 800c5f8:	3b01      	subs	r3, #1
 800c5fa:	2b01      	cmp	r3, #1
 800c5fc:	d81e      	bhi.n	800c63c <slaveCheckLink+0xbc>
                {
                  dprintf(LL_INFO, "Lost connection with master (%08x:%08x:%08x).",
 800c5fe:	f8db 3050 	ldr.w	r3, [fp, #80]	; 0x50
 800c602:	2b01      	cmp	r3, #1
 800c604:	dd08      	ble.n	800c618 <slaveCheckLink+0x98>
 800c606:	f8d4 311d 	ldr.w	r3, [r4, #285]	; 0x11d
 800c60a:	f8d4 2119 	ldr.w	r2, [r4, #281]	; 0x119
 800c60e:	f8d4 1115 	ldr.w	r1, [r4, #277]	; 0x115
 800c612:	487f      	ldr	r0, [pc, #508]	; (800c810 <slaveCheckLink+0x290>)
 800c614:	f7fc f8a6 	bl	8008764 <xprintf>
                          helper->connDev.prodID);

                  /* if(switchPortHelper(p, PORT_TYPE_USART) == 0) */
                  /*   dprintf("Switching to cable connection.\n"); */
                  /* else */
                  dprintf(LL_INFO, "\n");
 800c618:	4b7e      	ldr	r3, [pc, #504]	; (800c814 <slaveCheckLink+0x294>)
 800c61a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c61c:	2b01      	cmp	r3, #1
 800c61e:	dd02      	ble.n	800c626 <slaveCheckLink+0xa6>
 800c620:	487d      	ldr	r0, [pc, #500]	; (800c818 <slaveCheckLink+0x298>)
 800c622:	f7fc f89f 	bl	8008764 <xprintf>
  return 0;
}

static int SPIeventNOW(portNum_t portNum, uint8_t evType)
{
  ev_t ev = {.portNum = portNum, .evType = evType};
 800c626:	2300      	movs	r3, #0
 800c628:	9308      	str	r3, [sp, #32]
 800c62a:	2301      	movs	r3, #1
 800c62c:	f88d a020 	strb.w	sl, [sp, #32]
 800c630:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
  SPIInternalEvent((void *)ev.raw);
 800c634:	9808      	ldr	r0, [sp, #32]
 800c636:	f7ff feb9 	bl	800c3ac <SPIInternalEvent>
 800c63a:	e0a0      	b.n	800c77e <slaveCheckLink+0x1fe>
                  dprintf(LL_INFO, "\n");
                  SPIeventNOW(p, SPI_EV_TYPE_LINK_ERROR);
                }
              else
                {
                  WAIT_BUSY;
 800c63c:	f007 fa4d 	bl	8013ada <ehifGetStatus>
 800c640:	0403      	lsls	r3, r0, #16
 800c642:	d403      	bmi.n	800c64c <slaveCheckLink+0xcc>
 800c644:	2001      	movs	r0, #1
 800c646:	f7fe f923 	bl	800a890 <vTaskDelay>
 800c64a:	e7f7      	b.n	800c63c <slaveCheckLink+0xbc>
                  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
                  uint32_t masterManId[2][2] = {{0}};
 800c64c:	2210      	movs	r2, #16
 800c64e:	2100      	movs	r1, #0
 800c650:	a808      	add	r0, sp, #32
 800c652:	f007 ff97 	bl	8014584 <memset>
                  masterManId[0][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK));
 800c656:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 800c65a:	6a1b      	ldr	r3, [r3, #32]
 800c65c:	f023 02fe 	bic.w	r2, r3, #254	; 0xfe
 800c660:	9208      	str	r2, [sp, #32]
                  masterManId[0][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK;
                  masterManId[1][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_STEREO_MASK;
 800c662:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
                {
                  WAIT_BUSY;
                  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
                  uint32_t masterManId[2][2] = {{0}};
                  masterManId[0][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK));
                  masterManId[0][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK;
 800c666:	f042 0202 	orr.w	r2, r2, #2
 800c66a:	9209      	str	r2, [sp, #36]	; 0x24
                  masterManId[1][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_STEREO_MASK;
 800c66c:	f043 0201 	orr.w	r2, r3, #1
                  masterManId[1][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK | MAN_ID_STEREO_MASK;
 800c670:	f043 0303 	orr.w	r3, r3, #3
                  WAIT_BUSY;
                  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
                  uint32_t masterManId[2][2] = {{0}};
                  masterManId[0][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK));
                  masterManId[0][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK;
                  masterManId[1][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_STEREO_MASK;
 800c674:	920a      	str	r2, [sp, #40]	; 0x28
                  masterManId[1][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK | MAN_ID_STEREO_MASK;
 800c676:	930b      	str	r3, [sp, #44]	; 0x2c
                  int fm;
                  for(fm = 0; fm < 2; fm++)
 800c678:	2700      	movs	r7, #0
                    {
                      int ms = (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?1:0;
 800c67a:	4b68      	ldr	r3, [pc, #416]	; (800c81c <slaveCheckLink+0x29c>)
 800c67c:	681d      	ldr	r5, [r3, #0]
 800c67e:	2d01      	cmp	r5, #1
 800c680:	d005      	beq.n	800c68e <slaveCheckLink+0x10e>
 800c682:	4b62      	ldr	r3, [pc, #392]	; (800c80c <slaveCheckLink+0x28c>)
 800c684:	7e5d      	ldrb	r5, [r3, #25]
 800c686:	2deb      	cmp	r5, #235	; 0xeb
 800c688:	bf94      	ite	ls
 800c68a:	2500      	movls	r5, #0
 800c68c:	2501      	movhi	r5, #1
 800c68e:	4b64      	ldr	r3, [pc, #400]	; (800c820 <slaveCheckLink+0x2a0>)
 800c690:	4a64      	ldr	r2, [pc, #400]	; (800c824 <slaveCheckLink+0x2a4>)
 800c692:	2f00      	cmp	r7, #0
 800c694:	bf18      	it	ne
 800c696:	461a      	movne	r2, r3
                      do
                        {
                          dprintf(LL_DEBUG, "Looking for %s %s  master with ManID %x: ",
                                  (fm==0)?"first":"second",( ms==0)?"MultiSlave":"SingleSlave", masterManId[ms][fm]);
                          devInfo = getNetworkID(masterManId[ms][fm], 1000);
                          helper->remote[fm].devID  = devInfo.deviceId;
 800c698:	230e      	movs	r3, #14
 800c69a:	fb03 4307 	mla	r3, r3, r7, r4
 800c69e:	9203      	str	r2, [sp, #12]
 800c6a0:	9302      	str	r3, [sp, #8]
                  for(fm = 0; fm < 2; fm++)
                    {
                      int ms = (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?1:0;
                      do
                        {
                          dprintf(LL_DEBUG, "Looking for %s %s  master with ManID %x: ",
 800c6a2:	f8db 3050 	ldr.w	r3, [fp, #80]	; 0x50
 800c6a6:	f8df 816c 	ldr.w	r8, [pc, #364]	; 800c814 <slaveCheckLink+0x294>
 800c6aa:	2b02      	cmp	r3, #2
 800c6ac:	dd0f      	ble.n	800c6ce <slaveCheckLink+0x14e>
 800c6ae:	aa10      	add	r2, sp, #64	; 0x40
 800c6b0:	eb07 0345 	add.w	r3, r7, r5, lsl #1
 800c6b4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800c6b8:	495b      	ldr	r1, [pc, #364]	; (800c828 <slaveCheckLink+0x2a8>)
 800c6ba:	4a5c      	ldr	r2, [pc, #368]	; (800c82c <slaveCheckLink+0x2ac>)
 800c6bc:	f853 3c20 	ldr.w	r3, [r3, #-32]
 800c6c0:	485b      	ldr	r0, [pc, #364]	; (800c830 <slaveCheckLink+0x2b0>)
 800c6c2:	2d00      	cmp	r5, #0
 800c6c4:	bf08      	it	eq
 800c6c6:	460a      	moveq	r2, r1
 800c6c8:	9903      	ldr	r1, [sp, #12]
 800c6ca:	f7fc f84b 	bl	8008764 <xprintf>
                                  (fm==0)?"first":"second",( ms==0)?"MultiSlave":"SingleSlave", masterManId[ms][fm]);
                          devInfo = getNetworkID(masterManId[ms][fm], 1000);
 800c6ce:	aa10      	add	r2, sp, #64	; 0x40
 800c6d0:	eb07 0345 	add.w	r3, r7, r5, lsl #1
 800c6d4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800c6d8:	a805      	add	r0, sp, #20
 800c6da:	f853 1c20 	ldr.w	r1, [r3, #-32]
 800c6de:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800c6e2:	f006 ff49 	bl	8013578 <getNetworkID>
                          helper->remote[fm].devID  = devInfo.deviceId;
 800c6e6:	9b02      	ldr	r3, [sp, #8]
                      int ms = (amIStereo == 1 || portData[CEN_PORT].kond_pom >= 0xEC)?1:0;
                      do
                        {
                          dprintf(LL_DEBUG, "Looking for %s %s  master with ManID %x: ",
                                  (fm==0)?"first":"second",( ms==0)?"MultiSlave":"SingleSlave", masterManId[ms][fm]);
                          devInfo = getNetworkID(masterManId[ms][fm], 1000);
 800c6e8:	9a05      	ldr	r2, [sp, #20]
                          helper->remote[fm].devID  = devInfo.deviceId;
 800c6ea:	f8c3 2123 	str.w	r2, [r3, #291]	; 0x123
 800c6ee:	f503 7190 	add.w	r1, r3, #288	; 0x120
                          helper->remote[fm].manID  = devInfo.mfctId;
 800c6f2:	9b06      	ldr	r3, [sp, #24]
 800c6f4:	f8c1 3007 	str.w	r3, [r1, #7]
                          helper->remote[fm].prodID = devInfo.prodId;
 800c6f8:	9802      	ldr	r0, [sp, #8]
 800c6fa:	9b07      	ldr	r3, [sp, #28]
 800c6fc:	f8c0 312b 	str.w	r3, [r0, #299]	; 0x12b
                          if(devInfo.deviceId)
 800c700:	b15a      	cbz	r2, 800c71a <slaveCheckLink+0x19a>
                            {
                              dprintf(LL_DEBUG, "found (%08x:%08x:%08x) \n",
 800c702:	4a44      	ldr	r2, [pc, #272]	; (800c814 <slaveCheckLink+0x294>)
 800c704:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800c706:	2a02      	cmp	r2, #2
 800c708:	dd16      	ble.n	800c738 <slaveCheckLink+0x1b8>
 800c70a:	f8d1 2007 	ldr.w	r2, [r1, #7]
 800c70e:	4849      	ldr	r0, [pc, #292]	; (800c834 <slaveCheckLink+0x2b4>)
 800c710:	f8d1 1003 	ldr.w	r1, [r1, #3]
 800c714:	f7fc f826 	bl	8008764 <xprintf>
 800c718:	e00e      	b.n	800c738 <slaveCheckLink+0x1b8>
                              //Do not look further
                              ms = -1;
                            }
                          else
                            {
                              dprintf(LL_DEBUG, "not found\n");
 800c71a:	4b3e      	ldr	r3, [pc, #248]	; (800c814 <slaveCheckLink+0x294>)
 800c71c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c71e:	2b02      	cmp	r3, #2
 800c720:	dd02      	ble.n	800c728 <slaveCheckLink+0x1a8>
 800c722:	4845      	ldr	r0, [pc, #276]	; (800c838 <slaveCheckLink+0x2b8>)
 800c724:	f7fc f81e 	bl	8008764 <xprintf>
                              if(portData[CEN_PORT].kond_pom < 0xEC)
 800c728:	4b38      	ldr	r3, [pc, #224]	; (800c80c <slaveCheckLink+0x28c>)
 800c72a:	7e5b      	ldrb	r3, [r3, #25]
 800c72c:	2beb      	cmp	r3, #235	; 0xeb
 800c72e:	d803      	bhi.n	800c738 <slaveCheckLink+0x1b8>
                                ms--;
                              else
                                ms = -1;
                            }
                        }
                      while(ms >= 0);
 800c730:	2d01      	cmp	r5, #1
 800c732:	d101      	bne.n	800c738 <slaveCheckLink+0x1b8>
                            }
                          else
                            {
                              dprintf(LL_DEBUG, "not found\n");
                              if(portData[CEN_PORT].kond_pom < 0xEC)
                                ms--;
 800c734:	2500      	movs	r5, #0
 800c736:	e7b4      	b.n	800c6a2 <slaveCheckLink+0x122>
                  masterManId[0][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK));
                  masterManId[0][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK;
                  masterManId[1][0] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_STEREO_MASK;
                  masterManId[1][1] = (helper->radioModule->device.manID&(MAN_ID_UNIQUE_MASK | MAN_ID_STEREO_MASK)) | MAN_ID_LR_MASK | MAN_ID_STEREO_MASK;
                  int fm;
                  for(fm = 0; fm < 2; fm++)
 800c738:	3701      	adds	r7, #1
 800c73a:	2f02      	cmp	r7, #2
 800c73c:	d19d      	bne.n	800c67a <slaveCheckLink+0xfa>
                            }
                        }
                      while(ms >= 0);
                    }

                  if (helper->remote[helper->currentRemote].devID)
 800c73e:	f8d4 313f 	ldr.w	r3, [r4, #319]	; 0x13f
 800c742:	220e      	movs	r2, #14
 800c744:	fb02 4303 	mla	r3, r2, r3, r4
 800c748:	f503 7390 	add.w	r3, r3, #288	; 0x120
 800c74c:	f8d3 2003 	ldr.w	r2, [r3, #3]
 800c750:	2a00      	cmp	r2, #0
 800c752:	d053      	beq.n	800c7fc <slaveCheckLink+0x27c>
                    {
                      dprintf(LL_DEBUG, "Trying to pair with master with manID = %x devId = %x \n",
 800c754:	f8d8 1050 	ldr.w	r1, [r8, #80]	; 0x50
 800c758:	2902      	cmp	r1, #2
 800c75a:	dd04      	ble.n	800c766 <slaveCheckLink+0x1e6>
 800c75c:	f8d3 1007 	ldr.w	r1, [r3, #7]
 800c760:	4836      	ldr	r0, [pc, #216]	; (800c83c <slaveCheckLink+0x2bc>)
 800c762:	f7fb ffff 	bl	8008764 <xprintf>
                              helper->remote[helper->currentRemote].manID, helper->remote[helper->currentRemote].devID);
                      if(slaveConnect(p, &helper->remote[helper->currentRemote]) < 0)
 800c766:	f8d4 313f 	ldr.w	r3, [r4, #319]	; 0x13f
 800c76a:	210e      	movs	r1, #14
 800c76c:	fb01 4103 	mla	r1, r1, r3, r4
 800c770:	f201 1123 	addw	r1, r1, #291	; 0x123
 800c774:	4650      	mov	r0, sl
 800c776:	f7ff fbd1 	bl	800bf1c <slaveConnect>
 800c77a:	2800      	cmp	r0, #0
 800c77c:	db0d      	blt.n	800c79a <slaveCheckLink+0x21a>
 800c77e:	f109 0901 	add.w	r9, r9, #1
}
static int slaveCheckLink(radioModule_t *rm)
{
  ehifStart(&rm->spi);
  portNum_t p;
  for (p = 0; p < PORTS_NUM; p++)
 800c782:	f1b9 0f03 	cmp.w	r9, #3
 800c786:	f106 0650 	add.w	r6, r6, #80	; 0x50
 800c78a:	f47f af04 	bne.w	800c596 <slaveCheckLink+0x16>
                    }
                }
            }
        }
    }
  ehifStop();
 800c78e:	f7ff fd1f 	bl	800c1d0 <ehifStop>
  return 0;
}
 800c792:	2000      	movs	r0, #0
 800c794:	b011      	add	sp, #68	; 0x44
 800c796:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    {
                      dprintf(LL_DEBUG, "Trying to pair with master with manID = %x devId = %x \n",
                              helper->remote[helper->currentRemote].manID, helper->remote[helper->currentRemote].devID);
                      if(slaveConnect(p, &helper->remote[helper->currentRemote]) < 0)
                        {
                          dprintf(LL_WARNING, "Connection failed. Trying secondary as a fallback.\n");
 800c79a:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 800c79e:	2b00      	cmp	r3, #0
 800c7a0:	dd02      	ble.n	800c7a8 <slaveCheckLink+0x228>
 800c7a2:	4827      	ldr	r0, [pc, #156]	; (800c840 <slaveCheckLink+0x2c0>)
 800c7a4:	f7fb ffde 	bl	8008764 <xprintf>

                          if (helper->remote[1-helper->currentRemote].devID)
 800c7a8:	f8d4 313f 	ldr.w	r3, [r4, #319]	; 0x13f
 800c7ac:	220e      	movs	r2, #14
 800c7ae:	f1c3 0301 	rsb	r3, r3, #1
 800c7b2:	fb02 4303 	mla	r3, r2, r3, r4
 800c7b6:	f503 7390 	add.w	r3, r3, #288	; 0x120
 800c7ba:	f8d3 2003 	ldr.w	r2, [r3, #3]
 800c7be:	2a00      	cmp	r2, #0
 800c7c0:	d0dd      	beq.n	800c77e <slaveCheckLink+0x1fe>
                            {
                              dprintf(LL_DEBUG, "Trying to pair with master with manID = %x devId = %x \n",
 800c7c2:	f8d8 1050 	ldr.w	r1, [r8, #80]	; 0x50
 800c7c6:	2902      	cmp	r1, #2
 800c7c8:	dd04      	ble.n	800c7d4 <slaveCheckLink+0x254>
 800c7ca:	f8d3 1007 	ldr.w	r1, [r3, #7]
 800c7ce:	481b      	ldr	r0, [pc, #108]	; (800c83c <slaveCheckLink+0x2bc>)
 800c7d0:	f7fb ffc8 	bl	8008764 <xprintf>
                                      helper->remote[1-helper->currentRemote].manID, helper->remote[1-helper->currentRemote].devID);
                              if(slaveConnect(p, &helper->remote[1-helper->currentRemote]) < 0)
 800c7d4:	f8d4 113f 	ldr.w	r1, [r4, #319]	; 0x13f
 800c7d8:	230e      	movs	r3, #14
 800c7da:	f1c1 0101 	rsb	r1, r1, #1
 800c7de:	fb03 4101 	mla	r1, r3, r1, r4
 800c7e2:	f201 1123 	addw	r1, r1, #291	; 0x123
 800c7e6:	4650      	mov	r0, sl
 800c7e8:	f7ff fb98 	bl	800bf1c <slaveConnect>
 800c7ec:	2800      	cmp	r0, #0
 800c7ee:	dac6      	bge.n	800c77e <slaveCheckLink+0x1fe>
                                {
                                  dprintf(LL_WARNING, "Connection failed.\n");
 800c7f0:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 800c7f4:	2b00      	cmp	r3, #0
 800c7f6:	ddc2      	ble.n	800c77e <slaveCheckLink+0x1fe>
 800c7f8:	4812      	ldr	r0, [pc, #72]	; (800c844 <slaveCheckLink+0x2c4>)
 800c7fa:	e004      	b.n	800c806 <slaveCheckLink+0x286>
                            }
                        }
                    }
                  else
                    {
                      dprintf(LL_WARNING, "Master not found.\n");
 800c7fc:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 800c800:	2b00      	cmp	r3, #0
 800c802:	ddbc      	ble.n	800c77e <slaveCheckLink+0x1fe>
 800c804:	4810      	ldr	r0, [pc, #64]	; (800c848 <slaveCheckLink+0x2c8>)
 800c806:	f7fb ffad 	bl	8008764 <xprintf>
 800c80a:	e7b8      	b.n	800c77e <slaveCheckLink+0x1fe>
 800c80c:	2001aabc 	.word	0x2001aabc
 800c810:	0801d382 	.word	0x0801d382
 800c814:	10001000 	.word	0x10001000
 800c818:	08014a9c 	.word	0x08014a9c
 800c81c:	2001ac34 	.word	0x2001ac34
 800c820:	0801d3b6 	.word	0x0801d3b6
 800c824:	0801d3b0 	.word	0x0801d3b0
 800c828:	0801d36b 	.word	0x0801d36b
 800c82c:	0801d376 	.word	0x0801d376
 800c830:	0801d3bd 	.word	0x0801d3bd
 800c834:	0801d3e7 	.word	0x0801d3e7
 800c838:	0801d400 	.word	0x0801d400
 800c83c:	0801d40b 	.word	0x0801d40b
 800c840:	0801d443 	.word	0x0801d443
 800c844:	0801d477 	.word	0x0801d477
 800c848:	0801d48b 	.word	0x0801d48b

0800c84c <doAlways>:
        }
    }
}

static void doAlways(void *data)
{
 800c84c:	b508      	push	{r3, lr}
#ifdef WATCHDOG_HWCOMMSPI
  wdogFeed(WATCHDOG_HWCOMMSPI(moduleNum));
 800c84e:	2002      	movs	r0, #2
 800c850:	f002 fac6 	bl	800ede0 <wdogFeed>
#endif
  int radioNum;
  for (radioNum = 0 ; radioNum < RADIO_MODULES; radioNum++)
    {
      radioModule_t *rm = &(radioModule[radioNum]);
      if(rm->spi.spi)
 800c854:	4804      	ldr	r0, [pc, #16]	; (800c868 <doAlways+0x1c>)
 800c856:	6803      	ldr	r3, [r0, #0]
 800c858:	b10b      	cbz	r3, 800c85e <doAlways+0x12>
  masterCheckLink(rm);
#endif
#ifdef SMOK
  //Slave. Connect to master if not not already connected
  // or connection lost.
  slaveCheckLink(rm);
 800c85a:	f7ff fe91 	bl	800c580 <slaveCheckLink>
    }

  checkDataReady();

  eventType = 1;//Timeout by default
}
 800c85e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
          //Check connection
          checkConnection(rm);
        }
    }

  checkDataReady();
 800c862:	f7ff bcc3 	b.w	800c1ec <checkDataReady>
 800c866:	bf00      	nop
 800c868:	2001add4 	.word	0x2001add4

0800c86c <sendBuffer>:
  return 0;
}

static int resetRadio(void);
static void sendBuffer(void *data)
{
 800c86c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  messageSendBuffer_t *message = data;
  spiHelper_t *helper = (spiHelper_t *)portData[message->portNum].SPIhelper;
 800c870:	4d51      	ldr	r5, [pc, #324]	; (800c9b8 <sendBuffer+0x14c>)
 800c872:	7a03      	ldrb	r3, [r0, #8]
 800c874:	2250      	movs	r2, #80	; 0x50
 800c876:	fb02 5303 	mla	r3, r2, r3, r5
  return 0;
}

static int resetRadio(void);
static void sendBuffer(void *data)
{
 800c87a:	b087      	sub	sp, #28
  messageSendBuffer_t *message = data;
  spiHelper_t *helper = (spiHelper_t *)portData[message->portNum].SPIhelper;
 800c87c:	f8d3 a010 	ldr.w	sl, [r3, #16]
  return 0;
}

static int resetRadio(void);
static void sendBuffer(void *data)
{
 800c880:	4604      	mov	r4, r0
  messageSendBuffer_t *message = data;
  spiHelper_t *helper = (spiHelper_t *)portData[message->portNum].SPIhelper;
  int status = 0;
  int retry = 100;
 800c882:	f04f 0864 	mov.w	r8, #100	; 0x64
static int resetRadio(void);
static void sendBuffer(void *data)
{
  messageSendBuffer_t *message = data;
  spiHelper_t *helper = (spiHelper_t *)portData[message->portNum].SPIhelper;
  int status = 0;
 800c886:	2600      	movs	r6, #0
  int retry = 100;
  do
    {
      if(helper->radioModule && helper->radioModule->spi.spi)
 800c888:	f8da 310c 	ldr.w	r3, [sl, #268]	; 0x10c
 800c88c:	2b00      	cmp	r3, #0
 800c88e:	d073      	beq.n	800c978 <sendBuffer+0x10c>
 800c890:	681b      	ldr	r3, [r3, #0]
 800c892:	2b00      	cmp	r3, #0
 800c894:	d070      	beq.n	800c978 <sendBuffer+0x10c>
        if((status = radioSend(message->portNum, message->buffer, message->bufLen)) == 1)
 800c896:	6863      	ldr	r3, [r4, #4]
  return size;
}

static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 800c898:	7a27      	ldrb	r7, [r4, #8]
  int status = 0;
  int retry = 100;
  do
    {
      if(helper->radioModule && helper->radioModule->spi.spi)
        if((status = radioSend(message->portNum, message->buffer, message->bufLen)) == 1)
 800c89a:	9301      	str	r3, [sp, #4]
  return size;
}

static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 800c89c:	2350      	movs	r3, #80	; 0x50
 800c89e:	fb03 5307 	mla	r3, r3, r7, r5
  int status = 0;
  int retry = 100;
  do
    {
      if(helper->radioModule && helper->radioModule->spi.spi)
        if((status = radioSend(message->portNum, message->buffer, message->bufLen)) == 1)
 800c8a2:	f8d4 b000 	ldr.w	fp, [r4]

static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
  remoteDev_t *dev = &(helper->connDev);
  int sendReset = (portData[portNum].connState != DEV_CONN);
 800c8a6:	f893 9020 	ldrb.w	r9, [r3, #32]
  return size;
}

static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
 800c8aa:	691e      	ldr	r6, [r3, #16]
  remoteDev_t *dev = &(helper->connDev);
  int sendReset = (portData[portNum].connState != DEV_CONN);
 800c8ac:	f119 33ff 	adds.w	r3, r9, #4294967295
 800c8b0:	bf18      	it	ne
 800c8b2:	2301      	movne	r3, #1
 800c8b4:	9303      	str	r3, [sp, #12]
  if(txBuffer[0] == 0x55 && portData[portNum].connState == DEV_PCONN)
 800c8b6:	f89b 3000 	ldrb.w	r3, [fp]
}

static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
  remoteDev_t *dev = &(helper->connDev);
 800c8ba:	f206 1215 	addw	r2, r6, #277	; 0x115
  int sendReset = (portData[portNum].connState != DEV_CONN);
  if(txBuffer[0] == 0x55 && portData[portNum].connState == DEV_PCONN)
 800c8be:	2b55      	cmp	r3, #85	; 0x55
}

static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
  remoteDev_t *dev = &(helper->connDev);
 800c8c0:	9202      	str	r2, [sp, #8]
  int sendReset = (portData[portNum].connState != DEV_CONN);
  if(txBuffer[0] == 0x55 && portData[portNum].connState == DEV_PCONN)
 800c8c2:	d011      	beq.n	800c8e8 <sendBuffer+0x7c>
    massert(helper && helper->radioModule);
  ehifStart(&(helper->radioModule->spi));
 800c8c4:	f8d6 010c 	ldr.w	r0, [r6, #268]	; 0x10c
 800c8c8:	f7ff fc58 	bl	800c17c <ehifStart>
  int stat = queueTX(dev, transferSize, (uint8_t *)txBuffer, sendReset);
 800c8cc:	465a      	mov	r2, fp
 800c8ce:	9b03      	ldr	r3, [sp, #12]
 800c8d0:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 800c8d4:	9802      	ldr	r0, [sp, #8]
 800c8d6:	f006 fd93 	bl	8013400 <queueTX>
 800c8da:	4683      	mov	fp, r0
  ehifStop();
 800c8dc:	f7ff fc78 	bl	800c1d0 <ehifStop>
  if(sendReset)
 800c8e0:	f1b9 0f01 	cmp.w	r9, #1
 800c8e4:	d115      	bne.n	800c912 <sendBuffer+0xa6>
 800c8e6:	e01e      	b.n	800c926 <sendBuffer+0xba>
static int radioSend(portNum_t portNum, char *txBuffer, int transferSize)
{
  spiHelper_t *helper = (spiHelper_t *)portData[portNum].SPIhelper;
  remoteDev_t *dev = &(helper->connDev);
  int sendReset = (portData[portNum].connState != DEV_CONN);
  if(txBuffer[0] == 0x55 && portData[portNum].connState == DEV_PCONN)
 800c8e8:	f1b9 0f02 	cmp.w	r9, #2
 800c8ec:	d1ea      	bne.n	800c8c4 <sendBuffer+0x58>
    massert(helper && helper->radioModule);
 800c8ee:	b11e      	cbz	r6, 800c8f8 <sendBuffer+0x8c>
 800c8f0:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
 800c8f4:	2b00      	cmp	r3, #0
 800c8f6:	d1e5      	bne.n	800c8c4 <sendBuffer+0x58>
 800c8f8:	4b30      	ldr	r3, [pc, #192]	; (800c9bc <sendBuffer+0x150>)
 800c8fa:	4931      	ldr	r1, [pc, #196]	; (800c9c0 <sendBuffer+0x154>)
 800c8fc:	4831      	ldr	r0, [pc, #196]	; (800c9c4 <sendBuffer+0x158>)
 800c8fe:	f240 325d 	movw	r2, #861	; 0x35d
 800c902:	f7fb ff2f 	bl	8008764 <xprintf>
 800c906:	2301      	movs	r3, #1
 800c908:	9305      	str	r3, [sp, #20]
 800c90a:	9b05      	ldr	r3, [sp, #20]
 800c90c:	2b00      	cmp	r3, #0
 800c90e:	d1fc      	bne.n	800c90a <sendBuffer+0x9e>
 800c910:	e7d8      	b.n	800c8c4 <sendBuffer+0x58>
  ehifStart(&(helper->radioModule->spi));
  int stat = queueTX(dev, transferSize, (uint8_t *)txBuffer, sendReset);
  ehifStop();
  if(sendReset)
    {
      if(stat >= 0)
 800c912:	f1bb 0f00 	cmp.w	fp, #0
 800c916:	db06      	blt.n	800c926 <sendBuffer+0xba>
        portData[portNum].dscResetTx++;
 800c918:	2350      	movs	r3, #80	; 0x50
 800c91a:	fb03 5507 	mla	r5, r3, r7, r5
 800c91e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800c920:	3301      	adds	r3, #1
 800c922:	64eb      	str	r3, [r5, #76]	; 0x4c
 800c924:	e02c      	b.n	800c980 <sendBuffer+0x114>
    }

  if(stat == -1)
 800c926:	f1bb 3fff 	cmp.w	fp, #4294967295
 800c92a:	d105      	bne.n	800c938 <sendBuffer+0xcc>
    helper->radioModule->txFull++;
 800c92c:	f8d6 210c 	ldr.w	r2, [r6, #268]	; 0x10c
 800c930:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800c932:	3301      	adds	r3, #1
 800c934:	6293      	str	r3, [r2, #40]	; 0x28
 800c936:	e007      	b.n	800c948 <sendBuffer+0xdc>
  if(stat == -2)
 800c938:	f11b 0f02 	cmn.w	fp, #2
 800c93c:	d104      	bne.n	800c948 <sendBuffer+0xdc>
    helper->radioModule->txNoConn++;
 800c93e:	f8d6 210c 	ldr.w	r2, [r6, #268]	; 0x10c
 800c942:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800c944:	3301      	adds	r3, #1
 800c946:	62d3      	str	r3, [r2, #44]	; 0x2c
  int status = 0;
  int retry = 100;
  do
    {
      if(helper->radioModule && helper->radioModule->spi.spi)
        if((status = radioSend(message->portNum, message->buffer, message->bufLen)) == 1)
 800c948:	f1bb 0f00 	cmp.w	fp, #0
  if(stat == -1)
    helper->radioModule->txFull++;
  if(stat == -2)
    helper->radioModule->txNoConn++;

  return (stat >= 0)?0:1;
 800c94c:	ea4f 76db 	mov.w	r6, fp, lsr #31
  int status = 0;
  int retry = 100;
  do
    {
      if(helper->radioModule && helper->radioModule->spi.spi)
        if((status = radioSend(message->portNum, message->buffer, message->bufLen)) == 1)
 800c950:	da12      	bge.n	800c978 <sendBuffer+0x10c>
          {
            retry--;
            if(retry == 0)
 800c952:	f1b8 0801 	subs.w	r8, r8, #1
 800c956:	d10a      	bne.n	800c96e <sendBuffer+0x102>
  masterCheckLink(rm);
#endif
#ifdef SMOK
  //Slave. Connect to master if not not already connected
  // or connection lost.
  slaveCheckLink(rm);
 800c958:	f8da 010c 	ldr.w	r0, [sl, #268]	; 0x10c
 800c95c:	f7ff fe10 	bl	800c580 <slaveCheckLink>
              {
                //ehifStart(&(helper->radioModule->spi));
                //		resetRadio();
                //ehifStop();
                checkConnection(helper->radioModule);
                portData[message->portNum].txFullDrop++;
 800c960:	7a23      	ldrb	r3, [r4, #8]
 800c962:	2250      	movs	r2, #80	; 0x50
 800c964:	fb02 5303 	mla	r3, r2, r3, r5
 800c968:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800c96a:	3201      	adds	r2, #1
 800c96c:	645a      	str	r2, [r3, #68]	; 0x44
              }
            checkDataReady();
 800c96e:	f7ff fc3d 	bl	800c1ec <checkDataReady>
            mdelay(1);
 800c972:	2001      	movs	r0, #1
 800c974:	f7fd ff8c 	bl	800a890 <vTaskDelay>
          }
    }
  while(status == 1 && retry != 0);
 800c978:	b116      	cbz	r6, 800c980 <sendBuffer+0x114>
 800c97a:	f1b8 0f00 	cmp.w	r8, #0
 800c97e:	d183      	bne.n	800c888 <sendBuffer+0x1c>

  //Send is comlete or failed.

  massert(portDataTxRxComplete(message->portNum, PORT_TYPE_SPI, RXTX_COMPLETE_TX) >= 0);
 800c980:	2201      	movs	r2, #1
 800c982:	4611      	mov	r1, r2
 800c984:	7a20      	ldrb	r0, [r4, #8]
 800c986:	f7ff f951 	bl	800bc2c <portDataTxRxComplete>
 800c98a:	2800      	cmp	r0, #0
 800c98c:	db06      	blt.n	800c99c <sendBuffer+0x130>
  dFree(message);
 800c98e:	f1a4 0014 	sub.w	r0, r4, #20
 800c992:	f001 f8a7 	bl	800dae4 <bFree>
}
 800c996:	b007      	add	sp, #28
 800c998:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
  while(status == 1 && retry != 0);

  //Send is comlete or failed.

  massert(portDataTxRxComplete(message->portNum, PORT_TYPE_SPI, RXTX_COMPLETE_TX) >= 0);
 800c99c:	4b0a      	ldr	r3, [pc, #40]	; (800c9c8 <sendBuffer+0x15c>)
 800c99e:	490b      	ldr	r1, [pc, #44]	; (800c9cc <sendBuffer+0x160>)
 800c9a0:	4808      	ldr	r0, [pc, #32]	; (800c9c4 <sendBuffer+0x158>)
 800c9a2:	f44f 72bf 	mov.w	r2, #382	; 0x17e
 800c9a6:	f7fb fedd 	bl	8008764 <xprintf>
 800c9aa:	2301      	movs	r3, #1
 800c9ac:	9304      	str	r3, [sp, #16]
 800c9ae:	9b04      	ldr	r3, [sp, #16]
 800c9b0:	2b00      	cmp	r3, #0
 800c9b2:	d1fc      	bne.n	800c9ae <sendBuffer+0x142>
 800c9b4:	e7eb      	b.n	800c98e <sendBuffer+0x122>
 800c9b6:	bf00      	nop
 800c9b8:	2001aabc 	.word	0x2001aabc
 800c9bc:	0801d49e 	.word	0x0801d49e
 800c9c0:	0801508e 	.word	0x0801508e
 800c9c4:	080148f4 	.word	0x080148f4
 800c9c8:	0801d4bc 	.word	0x0801d4bc
 800c9cc:	08015098 	.word	0x08015098

0800c9d0 <EHIF_SPI_BEGIN>:
/////////////////////////////////////////    CC85xx EHIF     /////////////////////////////////////////////////////////

/// Activates CSn, starting an SPI operation
void EHIF_SPI_BEGIN(void)
{
  if (EHIF_SPI_HOOK)
 800c9d0:	4b04      	ldr	r3, [pc, #16]	; (800c9e4 <EHIF_SPI_BEGIN+0x14>)
 800c9d2:	685b      	ldr	r3, [r3, #4]
 800c9d4:	b123      	cbz	r3, 800c9e0 <EHIF_SPI_BEGIN+0x10>
    GPIO_WriteBit(EHIF_SPI_HOOK->cs.gpio, EHIF_SPI_HOOK->cs.pin, 0);
 800c9d6:	2200      	movs	r2, #0
 800c9d8:	8919      	ldrh	r1, [r3, #8]
 800c9da:	6858      	ldr	r0, [r3, #4]
 800c9dc:	f004 bada 	b.w	8010f94 <GPIO_WriteBit>
 800c9e0:	4770      	bx	lr
 800c9e2:	bf00      	nop
 800c9e4:	2001ad54 	.word	0x2001ad54

0800c9e8 <EHIF_SPI_IS_CMDREQ_READY>:
}

/// Non-zero when EHIF is ready, zero when EHIF is not ready
char EHIF_SPI_IS_CMDREQ_READY(void)
{
  if (EHIF_SPI_HOOK)
 800c9e8:	4b03      	ldr	r3, [pc, #12]	; (800c9f8 <EHIF_SPI_IS_CMDREQ_READY+0x10>)
 800c9ea:	6858      	ldr	r0, [r3, #4]
 800c9ec:	b118      	cbz	r0, 800c9f6 <EHIF_SPI_IS_CMDREQ_READY+0xe>
    return readPin(EHIF_SPI_HOOK->miso.gpio, EHIF_SPI_HOOK->miso.pin);
 800c9ee:	8a81      	ldrh	r1, [r0, #20]
 800c9f0:	6900      	ldr	r0, [r0, #16]
 800c9f2:	f001 bbe7 	b.w	800e1c4 <readPin>
  return 0;
}
 800c9f6:	4770      	bx	lr
 800c9f8:	2001ad54 	.word	0x2001ad54

0800c9fc <EHIF_SPI_TX>:

/// Transmits a single byte
void EHIF_SPI_TX(char x)
{
  if (EHIF_SPI_HOOK)
 800c9fc:	4b03      	ldr	r3, [pc, #12]	; (800ca0c <EHIF_SPI_TX+0x10>)
 800c9fe:	685b      	ldr	r3, [r3, #4]
  return 0;
}

/// Transmits a single byte
void EHIF_SPI_TX(char x)
{
 800ca00:	4601      	mov	r1, r0
  if (EHIF_SPI_HOOK)
 800ca02:	b113      	cbz	r3, 800ca0a <EHIF_SPI_TX+0xe>
    {
      txSPI(EHIF_SPI_HOOK->spi, x);
 800ca04:	6818      	ldr	r0, [r3, #0]
 800ca06:	f001 ba0f 	b.w	800de28 <txSPI>
 800ca0a:	4770      	bx	lr
 800ca0c:	2001ad54 	.word	0x2001ad54

0800ca10 <EHIF_SPI_WAIT_TXRX>:
    }
}

/// Waits for completion of \ref EHIF_SPI_TX() (no timeout required!)
void EHIF_SPI_WAIT_TXRX(void)
{
 800ca10:	4770      	bx	lr
	...

0800ca14 <EHIF_SPI_RX>:
} //No need to wait as it is done in EHIF_SPI_TX

/// The received byte after completing the last \ref EHIF_SPI_TX()
char EHIF_SPI_RX(void)
{
  if (EHIF_SPI_HOOK)
 800ca14:	4b03      	ldr	r3, [pc, #12]	; (800ca24 <EHIF_SPI_RX+0x10>)
 800ca16:	6858      	ldr	r0, [r3, #4]
 800ca18:	b110      	cbz	r0, 800ca20 <EHIF_SPI_RX+0xc>
    {
      return rxSPI(EHIF_SPI_HOOK->spi);
 800ca1a:	6800      	ldr	r0, [r0, #0]
 800ca1c:	f001 ba48 	b.w	800deb0 <rxSPI>
    }
  return 0;
}
 800ca20:	4770      	bx	lr
 800ca22:	bf00      	nop
 800ca24:	2001ad54 	.word	0x2001ad54

0800ca28 <EHIF_SPI_END>:

/// Deactivates CSn, ending an SPI operation
void EHIF_SPI_END(void)
{
  if (EHIF_SPI_HOOK)
 800ca28:	4b04      	ldr	r3, [pc, #16]	; (800ca3c <EHIF_SPI_END+0x14>)
 800ca2a:	685b      	ldr	r3, [r3, #4]
 800ca2c:	b123      	cbz	r3, 800ca38 <EHIF_SPI_END+0x10>
    GPIO_WriteBit(EHIF_SPI_HOOK->cs.gpio, EHIF_SPI_HOOK->cs.pin, 1);
 800ca2e:	2201      	movs	r2, #1
 800ca30:	8919      	ldrh	r1, [r3, #8]
 800ca32:	6858      	ldr	r0, [r3, #4]
 800ca34:	f004 baae 	b.w	8010f94 <GPIO_WriteBit>
 800ca38:	4770      	bx	lr
 800ca3a:	bf00      	nop
 800ca3c:	2001ad54 	.word	0x2001ad54

0800ca40 <hwCommunicatorRadioInit>:
    }
  return 0;
}

static void hwCommunicatorRadioInit(void)
{
 800ca40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ca44:	b089      	sub	sp, #36	; 0x24
  //Blink all leds
  LEDblink(LED_BLINKER_SPI_HELPER, ~0, 1, 500, 1, 1, 500, 0);
 800ca46:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800ca4a:	2201      	movs	r2, #1
 800ca4c:	2500      	movs	r5, #0
 800ca4e:	9302      	str	r3, [sp, #8]
 800ca50:	9201      	str	r2, [sp, #4]
 800ca52:	9200      	str	r2, [sp, #0]
 800ca54:	f04f 31ff 	mov.w	r1, #4294967295
 800ca58:	9503      	str	r5, [sp, #12]
 800ca5a:	4628      	mov	r0, r5
  for (m = 0; m < RADIO_MODULES; m++)
    {
      //Set SPI hook for radio module HAL
      ehifStart(&radioModule[m].spi);
      EHIF_SPI_END();
      dprintf(LL_INFO, "Initializing Radio Module %d\n", m);
 800ca5c:	4ca1      	ldr	r4, [pc, #644]	; (800cce4 <hwCommunicatorRadioInit+0x2a4>)
}

static void hwCommunicatorRadioInit(void)
{
  //Blink all leds
  LEDblink(LED_BLINKER_SPI_HELPER, ~0, 1, 500, 1, 1, 500, 0);
 800ca5e:	f000 f9c3 	bl	800cde8 <LEDblink>
  int m;
  for (m = 0; m < RADIO_MODULES; m++)
    {
      //Set SPI hook for radio module HAL
      ehifStart(&radioModule[m].spi);
 800ca62:	48a1      	ldr	r0, [pc, #644]	; (800cce8 <hwCommunicatorRadioInit+0x2a8>)
 800ca64:	f7ff fb8a 	bl	800c17c <ehifStart>
      EHIF_SPI_END();
 800ca68:	f7ff ffde 	bl	800ca28 <EHIF_SPI_END>
      dprintf(LL_INFO, "Initializing Radio Module %d\n", m);
 800ca6c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800ca6e:	2b01      	cmp	r3, #1
 800ca70:	dd03      	ble.n	800ca7a <hwCommunicatorRadioInit+0x3a>
 800ca72:	4629      	mov	r1, r5
 800ca74:	489d      	ldr	r0, [pc, #628]	; (800ccec <hwCommunicatorRadioInit+0x2ac>)
 800ca76:	f7fb fe75 	bl	8008764 <xprintf>
#ifdef RADIO_IMAGE

      uint32_t radioManId = cfg.manId;
 800ca7a:	6b27      	ldr	r7, [r4, #48]	; 0x30
      uint32_t radioProdId = cfg.kondPom<<PROD_ID_KONDPOM_BIT;
 800ca7c:	6b63      	ldr	r3, [r4, #52]	; 0x34
#endif
      int radioModuleSet = 0;
#ifdef SMOK
      int twoOutputs = 0;
#endif
      switch(cfg.kondPom)
 800ca7e:	6b66      	ldr	r6, [r4, #52]	; 0x34
        default:
          break;
        }
#endif
#ifdef SMOK
      radioProdId |= (((cfg.flags&FLAGS_PRIMARY_STREAM_MASK)>>FLAGS_PRIMARY_STREAM_BIT) <<PROD_ID_PRIMARY_STREAM_BIT);
 800ca80:	6ba5      	ldr	r5, [r4, #56]	; 0x38
}

static void verifyRadioImage(int ms, int num, uint32_t manId, uint32_t prodId)
{
  uint32_t imageSize = (radioImage[ms][num][0x1E] << 8) | radioImage[ms][num][0x1F];
  uint32_t expectedCrcVal = getImageCRC((void*)radioImage[ms][num], manId, prodId);
 800ca82:	489b      	ldr	r0, [pc, #620]	; (800ccf0 <hwCommunicatorRadioInit+0x2b0>)
        default:
          break;
        }
#endif
#ifdef SMOK
      radioProdId |= (((cfg.flags&FLAGS_PRIMARY_STREAM_MASK)>>FLAGS_PRIMARY_STREAM_BIT) <<PROD_ID_PRIMARY_STREAM_BIT);
 800ca84:	03ad      	lsls	r5, r5, #14
 800ca86:	f405 3580 	and.w	r5, r5, #65536	; 0x10000
 800ca8a:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
#endif
      int radioModuleSet = 0;
#ifdef SMOK
      int twoOutputs = 0;
#endif
      switch(cfg.kondPom)
 800ca8e:	3eec      	subs	r6, #236	; 0xec
          break;
        }
#endif
#ifdef SMOK
      radioProdId |= (((cfg.flags&FLAGS_PRIMARY_STREAM_MASK)>>FLAGS_PRIMARY_STREAM_BIT) <<PROD_ID_PRIMARY_STREAM_BIT);
      if(cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)
 800ca90:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      switch(cfg.kondPom)
        {
        case 0xEC:
        case 0xED:
        case 0xEE:
          twoOutputs = 1;
 800ca92:	2e02      	cmp	r6, #2
 800ca94:	bf8c      	ite	hi
 800ca96:	2600      	movhi	r6, #0
 800ca98:	2601      	movls	r6, #1
          break;
        }
#endif
#ifdef SMOK
      radioProdId |= (((cfg.flags&FLAGS_PRIMARY_STREAM_MASK)>>FLAGS_PRIMARY_STREAM_BIT) <<PROD_ID_PRIMARY_STREAM_BIT);
      if(cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)
 800ca9a:	07db      	lsls	r3, r3, #31
        {
          //Right channel
          radioManId  |= MAN_ID_LR_MASK;
 800ca9c:	bf46      	itte	mi
 800ca9e:	f047 0702 	orrmi.w	r7, r7, #2
          radioProdId |= (2<<PROD_ID_LR_BIT);
 800caa2:	f045 0502 	orrmi.w	r5, r5, #2
        }
      else
        {
          //Left channel
          radioProdId |= (1<<PROD_ID_LR_BIT);
 800caa6:	f045 0501 	orrpl.w	r5, r5, #1
}

static void verifyRadioImage(int ms, int num, uint32_t manId, uint32_t prodId)
{
  uint32_t imageSize = (radioImage[ms][num][0x1E] << 8) | radioImage[ms][num][0x1F];
  uint32_t expectedCrcVal = getImageCRC((void*)radioImage[ms][num], manId, prodId);
 800caaa:	462a      	mov	r2, r5
 800caac:	4639      	mov	r1, r7
 800caae:	f7ff fa03 	bl	800beb8 <getImageCRC>
 800cab2:	4680      	mov	r8, r0

  // Enter the SPI bootloader
  ehifBootResetSpi();
 800cab4:	f007 f926 	bl	8013d04 <ehifBootResetSpi>
  uint16_t status = ehifBlUnlockSpi();
 800cab8:	f006 ffa2 	bl	8013a00 <ehifBlUnlockSpi>
  if (status != EHIF_BL_SPI_LOADER_READY)
 800cabc:	f248 0320 	movw	r3, #32800	; 0x8020
 800cac0:	4298      	cmp	r0, r3
 800cac2:	d152      	bne.n	800cb6a <hwCommunicatorRadioInit+0x12a>
      ehifSysResetSpi(1); // with wait rready flag
      ehifWaitReadyMs(300);
      ehifGetWaitReadyError();
      return;
    }
  uint32_t actualCrcVal = 0;
 800cac4:	a908      	add	r1, sp, #32
 800cac6:	2300      	movs	r3, #0
 800cac8:	f841 3d10 	str.w	r3, [r1, #-16]!
  ehifBlFlashVerify(imageSize, (uint8_t*)&actualCrcVal);
 800cacc:	f647 30fc 	movw	r0, #31740	; 0x7bfc
 800cad0:	f006 ffe0 	bl	8013a94 <ehifBlFlashVerify>

  ehifSysResetSpi(1); // with wait rready flag
 800cad4:	2001      	movs	r0, #1
 800cad6:	f007 f8f1 	bl	8013cbc <ehifSysResetSpi>
  ehifWaitReadyMs(300);
 800cada:	f44f 7096 	mov.w	r0, #300	; 0x12c
 800cade:	f007 f8d5 	bl	8013c8c <ehifWaitReadyMs>
  ehifGetWaitReadyError();
 800cae2:	f007 f93b 	bl	8013d5c <ehifGetWaitReadyError>

  //If crc differs then reaplce image
  if(actualCrcVal != expectedCrcVal)
 800cae6:	9b04      	ldr	r3, [sp, #16]
 800cae8:	4598      	cmp	r8, r3
    {
      dprintf(LL_WARNING, "\e[31mRadio flash invalid. Raplacing.\e[m\n");
 800caea:	6d23      	ldr	r3, [r4, #80]	; 0x50
  ehifSysResetSpi(1); // with wait rready flag
  ehifWaitReadyMs(300);
  ehifGetWaitReadyError();

  //If crc differs then reaplce image
  if(actualCrcVal != expectedCrcVal)
 800caec:	d05f      	beq.n	800cbae <hwCommunicatorRadioInit+0x16e>
    {
      dprintf(LL_WARNING, "\e[31mRadio flash invalid. Raplacing.\e[m\n");
 800caee:	2b00      	cmp	r3, #0
 800caf0:	dd02      	ble.n	800caf8 <hwCommunicatorRadioInit+0xb8>
 800caf2:	4880      	ldr	r0, [pc, #512]	; (800ccf4 <hwCommunicatorRadioInit+0x2b4>)
 800caf4:	f7fb fe36 	bl	8008764 <xprintf>
static uint16_t eraseProgVerifyFlash(const uint8_t* pFlashImage, uint32_t manId, uint32_t prodId)
{

  // Extract information from the image
  uint32_t imageSize = (pFlashImage[0x1E] << 8) | pFlashImage[0x1F];
  const uint32_t expectedCrcVal = getImageCRC(pFlashImage, manId, prodId);
 800caf8:	462a      	mov	r2, r5
 800cafa:	4639      	mov	r1, r7
 800cafc:	487c      	ldr	r0, [pc, #496]	; (800ccf0 <hwCommunicatorRadioInit+0x2b0>)
 800cafe:	f7ff f9db 	bl	800beb8 <getImageCRC>

  // Enter the SPI bootloader
  ehifBootResetSpi();
 800cb02:	f007 f8ff 	bl	8013d04 <ehifBootResetSpi>
  uint16_t status = ehifBlUnlockSpi();
 800cb06:	f006 ff7b 	bl	8013a00 <ehifBlUnlockSpi>
  if (status != EHIF_BL_SPI_LOADER_READY) return status;
 800cb0a:	f248 0320 	movw	r3, #32800	; 0x8020
 800cb0e:	4298      	cmp	r0, r3
 800cb10:	d152      	bne.n	800cbb8 <hwCommunicatorRadioInit+0x178>
  // Erase current flash contents
  status = ehifBlFlashMassErase();
 800cb12:	f006 ff85 	bl	8013a20 <ehifBlFlashMassErase>
  while(status == EHIF_BL_ERASE_WORKING)
 800cb16:	2802      	cmp	r0, #2
 800cb18:	d105      	bne.n	800cb26 <hwCommunicatorRadioInit+0xe6>
    {
      mdelay(10);
 800cb1a:	200a      	movs	r0, #10
 800cb1c:	f7fd feb8 	bl	800a890 <vTaskDelay>
      status = ehifGetStatus();
 800cb20:	f006 ffdb 	bl	8013ada <ehifGetStatus>
 800cb24:	e7f7      	b.n	800cb16 <hwCommunicatorRadioInit+0xd6>
    }
  if (status != EHIF_BL_ERASE_DONE) return status;
 800cb26:	f248 0303 	movw	r3, #32771	; 0x8003
 800cb2a:	4298      	cmp	r0, r3
 800cb2c:	d144      	bne.n	800cbb8 <hwCommunicatorRadioInit+0x178>

  // For each 1 kB flash page ...
  uint16_t offset;
  uint8_t *buff = intSafeMalloc(0x400);
 800cb2e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800cb32:	f7fb fc96 	bl	8008462 <intSafeMalloc>
 800cb36:	f04f 0800 	mov.w	r8, #0
 800cb3a:	4681      	mov	r9, r0
 800cb3c:	e001      	b.n	800cb42 <hwCommunicatorRadioInit+0x102>
 800cb3e:	f508 6880 	add.w	r8, r8, #1024	; 0x400
  for (offset = 0x0000; offset < 0x8000; offset += 0x0400)
    {
      getImageChunk(buff, pFlashImage, offset, 0x400, manId, prodId);
 800cb42:	9501      	str	r5, [sp, #4]
 800cb44:	9700      	str	r7, [sp, #0]
 800cb46:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800cb4a:	4642      	mov	r2, r8
 800cb4c:	4968      	ldr	r1, [pc, #416]	; (800ccf0 <hwCommunicatorRadioInit+0x2b0>)
 800cb4e:	4648      	mov	r0, r9
 800cb50:	f7ff f978 	bl	800be44 <getImageChunk>

      // Bail out when the entire image has been programmed (it is normally less than 32 kB)
      if (offset >= imageSize) break;
 800cb54:	f5b8 4ff8 	cmp.w	r8, #31744	; 0x7c00
 800cb58:	d111      	bne.n	800cb7e <hwCommunicatorRadioInit+0x13e>
        {
          intSafeFree(buff);
          return status;
        }
    }
  intSafeFree(buff);
 800cb5a:	4648      	mov	r0, r9
 800cb5c:	f7fb fc92 	bl	8008484 <intSafeFree>
  // Verify the flash contents by performing CRC-32 check. Also compare the calculated CRC with the one
  // in the image to make sure that we've actually programmed it and not just verified what was already
  // in the flash memory
  uint8_t pActualCrcVal[sizeof(uint32_t)];
  status = ehifBlFlashVerify(imageSize, pActualCrcVal);
 800cb60:	a905      	add	r1, sp, #20
 800cb62:	f647 30fc 	movw	r0, #31740	; 0x7bfc
 800cb66:	f006 ff95 	bl	8013a94 <ehifBlFlashVerify>
        }
    }

  // Exit the SPI bootloader (not waiting for EHIF CMD_REQ_RDY since this will interfere with button
  // functionality on the CSn pin in autonomous operation)
  ehifSysResetSpi(1);
 800cb6a:	2001      	movs	r0, #1
 800cb6c:	f007 f8a6 	bl	8013cbc <ehifSysResetSpi>
  ehifWaitReadyMs(300);
 800cb70:	f44f 7096 	mov.w	r0, #300	; 0x12c
 800cb74:	f007 f88a 	bl	8013c8c <ehifWaitReadyMs>
  ehifGetWaitReadyError();
 800cb78:	f007 f8f0 	bl	8013d5c <ehifGetWaitReadyError>
 800cb7c:	e01c      	b.n	800cbb8 <hwCommunicatorRadioInit+0x178>

      // Bail out when the entire image has been programmed (it is normally less than 32 kB)
      if (offset >= imageSize) break;

      // Write the page data to RAM
      ehifSetAddr(0x6000);
 800cb7e:	f44f 40c0 	mov.w	r0, #24576	; 0x6000
 800cb82:	f007 f866 	bl	8013c52 <ehifSetAddr>
      ehifWrite(0x0400, buff);
 800cb86:	4649      	mov	r1, r9
 800cb88:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800cb8c:	f006 ffd2 	bl	8013b34 <ehifWrite>

      // Program the page
      status = ehifBlFlashPageProg(0x6000, 0x8000 + offset);
 800cb90:	f5a8 4100 	sub.w	r1, r8, #32768	; 0x8000
 800cb94:	b289      	uxth	r1, r1
 800cb96:	f44f 40c0 	mov.w	r0, #24576	; 0x6000
 800cb9a:	f006 ff51 	bl	8013a40 <ehifBlFlashPageProg>
      if (status != EHIF_BL_PROG_DONE)
 800cb9e:	f248 030b 	movw	r3, #32779	; 0x800b
 800cba2:	4298      	cmp	r0, r3
 800cba4:	d0cb      	beq.n	800cb3e <hwCommunicatorRadioInit+0xfe>
        {
          intSafeFree(buff);
 800cba6:	4648      	mov	r0, r9
 800cba8:	f7fb fc6c 	bl	8008484 <intSafeFree>
 800cbac:	e004      	b.n	800cbb8 <hwCommunicatorRadioInit+0x178>
    {
      dprintf(LL_WARNING, "\e[31mRadio flash invalid. Raplacing.\e[m\n");
      eraseProgVerifyFlash((void*)radioImage[ms][num], manId, prodId);
    }
  else
    dprintf(LL_INFO, "Radio flash valid.\n");
 800cbae:	2b01      	cmp	r3, #1
 800cbb0:	dd02      	ble.n	800cbb8 <hwCommunicatorRadioInit+0x178>
 800cbb2:	4851      	ldr	r0, [pc, #324]	; (800ccf8 <hwCommunicatorRadioInit+0x2b8>)
 800cbb4:	f7fb fdd6 	bl	8008764 <xprintf>
        }

#endif
      verifyRadioImage(radioModuleSet, m, radioManId, radioProdId);
#endif
      if(cfg.proto & 0x2)
 800cbb8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800cbba:	0798      	lsls	r0, r3, #30
 800cbbc:	d403      	bmi.n	800cbc6 <hwCommunicatorRadioInit+0x186>
  hwCommunicatorRadioInit();
}

static int resetRadio(void)
{
  if(cfg.proto & 0x2)
 800cbbe:	4b49      	ldr	r3, [pc, #292]	; (800cce4 <hwCommunicatorRadioInit+0x2a4>)
 800cbc0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800cbc2:	0799      	lsls	r1, r3, #30
 800cbc4:	d502      	bpl.n	800cbcc <hwCommunicatorRadioInit+0x18c>
    {
      ehifBootResetSpi();
 800cbc6:	f007 f89d 	bl	8013d04 <ehifBootResetSpi>
 800cbca:	e063      	b.n	800cc94 <hwCommunicatorRadioInit+0x254>
    }
  else if (!reset_powerActive())
 800cbcc:	f006 fc7e 	bl	80134cc <reset_powerActive>
 800cbd0:	2800      	cmp	r0, #0
 800cbd2:	d15f      	bne.n	800cc94 <hwCommunicatorRadioInit+0x254>
    {
      EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
      WAIT_BUSY;
 800cbd4:	f006 ff81 	bl	8013ada <ehifGetStatus>
 800cbd8:	0402      	lsls	r2, r0, #16
 800cbda:	d403      	bmi.n	800cbe4 <hwCommunicatorRadioInit+0x1a4>
 800cbdc:	2001      	movs	r0, #1
 800cbde:	f7fd fe57 	bl	800a890 <vTaskDelay>
 800cbe2:	e7f7      	b.n	800cbd4 <hwCommunicatorRadioInit+0x194>
      devInfo = getDeviceInfo();
 800cbe4:	a805      	add	r0, sp, #20
 800cbe6:	f006 fb95 	bl	8013314 <getDeviceInfo>
      if (devInfo.deviceId != 0 && devInfo.deviceId != 0xFFFFFFFF)
 800cbea:	9b05      	ldr	r3, [sp, #20]
 800cbec:	3b01      	subs	r3, #1
 800cbee:	3303      	adds	r3, #3
 800cbf0:	d850      	bhi.n	800cc94 <hwCommunicatorRadioInit+0x254>
        {
          clearFlags(0xFF);  //Clear them all
 800cbf2:	20ff      	movs	r0, #255	; 0xff
 800cbf4:	f006 fbac 	bl	8013350 <clearFlags>
#ifdef MADO
          //I am master
          chipRadioEnable(ENABLE);
#endif

          setIntEvents( BV_EHIF_EVT_DSC_RX_AVAIL | BV_EHIF_EVT_DSC_RESET | BV_EHIF_EVT_NWK_CHG | BV_EHIF_EVT_DSC_RESET);
 800cbf8:	20a2      	movs	r0, #162	; 0xa2
 800cbfa:	f006 fbb9 	bl	8013370 <setIntEvents>
          ehifBootResetSpi();
        }
      else if(resetRadio())
        {
          EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
          WAIT_BUSY;
 800cbfe:	f006 ff6c 	bl	8013ada <ehifGetStatus>
 800cc02:	0403      	lsls	r3, r0, #16
 800cc04:	d403      	bmi.n	800cc0e <hwCommunicatorRadioInit+0x1ce>
 800cc06:	2001      	movs	r0, #1
 800cc08:	f7fd fe42 	bl	800a890 <vTaskDelay>
 800cc0c:	e7f7      	b.n	800cbfe <hwCommunicatorRadioInit+0x1be>
          devInfo = getDeviceInfo();
 800cc0e:	a805      	add	r0, sp, #20
 800cc10:	f006 fb80 	bl	8013314 <getDeviceInfo>
 800cc14:	9905      	ldr	r1, [sp, #20]
          if (devInfo.deviceId != 0 && devInfo.deviceId != 0xFFFFFFFF)
 800cc16:	1e4b      	subs	r3, r1, #1
 800cc18:	3303      	adds	r3, #3
 800cc1a:	d83b      	bhi.n	800cc94 <hwCommunicatorRadioInit+0x254>
            {
              radioModule[m].device.devID = devInfo.deviceId;
 800cc1c:	4b32      	ldr	r3, [pc, #200]	; (800cce8 <hwCommunicatorRadioInit+0x2a8>)
        }
      else if(resetRadio())
        {
          EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
          WAIT_BUSY;
          devInfo = getDeviceInfo();
 800cc1e:	9a06      	ldr	r2, [sp, #24]
 800cc20:	9d07      	ldr	r5, [sp, #28]
          if (devInfo.deviceId != 0 && devInfo.deviceId != 0xFFFFFFFF)
            {
              radioModule[m].device.devID = devInfo.deviceId;
 800cc22:	61d9      	str	r1, [r3, #28]
              radioModule[m].device.manID = devInfo.mfctId;
 800cc24:	621a      	str	r2, [r3, #32]
              radioModule[m].device.prodID = devInfo.prodId;
 800cc26:	625d      	str	r5, [r3, #36]	; 0x24

              dprintf(LL_INFO, "Found Radio Module (%08x:%08x:%08x)\n",
 800cc28:	6d20      	ldr	r0, [r4, #80]	; 0x50
 800cc2a:	2801      	cmp	r0, #1
 800cc2c:	461f      	mov	r7, r3
 800cc2e:	dd03      	ble.n	800cc38 <hwCommunicatorRadioInit+0x1f8>
 800cc30:	462b      	mov	r3, r5
 800cc32:	4832      	ldr	r0, [pc, #200]	; (800ccfc <hwCommunicatorRadioInit+0x2bc>)
 800cc34:	f7fb fd96 	bl	8008764 <xprintf>
              dprintf(LL_INFO, "Master initialized. Status %04x \n", (int)ehifGetStatus());
              portData[CEN_PORT].kond_pom = (devInfo.prodId >> 8)&0xFF;
#endif
#ifdef SMOK
              //I a slave.
              portData[CEN_PORT].urzadzenie = ((devInfo.prodId)&0xff);
 800cc38:	4b31      	ldr	r3, [pc, #196]	; (800cd00 <hwCommunicatorRadioInit+0x2c0>)
              portData[CEN_PORT].kond_pom = (devInfo.prodId >> 8)&0xFF;
              spiHelper_t *helper = (spiHelper_t *)portData[CEN_PORT].SPIhelper;
 800cc3a:	6919      	ldr	r1, [r3, #16]
              dprintf(LL_INFO, "Master initialized. Status %04x \n", (int)ehifGetStatus());
              portData[CEN_PORT].kond_pom = (devInfo.prodId >> 8)&0xFF;
#endif
#ifdef SMOK
              //I a slave.
              portData[CEN_PORT].urzadzenie = ((devInfo.prodId)&0xff);
 800cc3c:	769d      	strb	r5, [r3, #26]
              portData[CEN_PORT].kond_pom = (devInfo.prodId >> 8)&0xFF;
 800cc3e:	0a2d      	lsrs	r5, r5, #8
 800cc40:	765d      	strb	r5, [r3, #25]
              spiHelper_t *helper = (spiHelper_t *)portData[CEN_PORT].SPIhelper;
              helper->radioModule = &radioModule[m];
 800cc42:	f8c1 710c 	str.w	r7, [r1, #268]	; 0x10c
              int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
 800cc46:	6ba2      	ldr	r2, [r4, #56]	; 0x38
              int pipeNum = (cfg.flags&FLAGS_PRIMARY_STREAM_MASK)?1:0;
 800cc48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
              helper->currentRemote = (int)masterMap[channel][pipeNum][twoOutputs];
 800cc4a:	f002 0201 	and.w	r2, r2, #1
 800cc4e:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800cc52:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800cc56:	4a2b      	ldr	r2, [pc, #172]	; (800cd04 <hwCommunicatorRadioInit+0x2c4>)
 800cc58:	eb02 0343 	add.w	r3, r2, r3, lsl #1

              connectionState(NET_NC);
 800cc5c:	2000      	movs	r0, #0
              portData[CEN_PORT].kond_pom = (devInfo.prodId >> 8)&0xFF;
              spiHelper_t *helper = (spiHelper_t *)portData[CEN_PORT].SPIhelper;
              helper->radioModule = &radioModule[m];
              int channel = (cfg.flags & FLAGS_RIGHT_CHANNEL_MASK)?1:0;
              int pipeNum = (cfg.flags&FLAGS_PRIMARY_STREAM_MASK)?1:0;
              helper->currentRemote = (int)masterMap[channel][pipeNum][twoOutputs];
 800cc5e:	5d9b      	ldrb	r3, [r3, r6]
 800cc60:	f8c1 313f 	str.w	r3, [r1, #319]	; 0x13f

              connectionState(NET_NC);
 800cc64:	f7fc fc26 	bl	80094b4 <connectionState>
              dprintf(LL_INFO, "Slave initialized. Status %04x \n", (int)ehifGetStatus());
 800cc68:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800cc6a:	2b01      	cmp	r3, #1
 800cc6c:	dd05      	ble.n	800cc7a <hwCommunicatorRadioInit+0x23a>
 800cc6e:	f006 ff34 	bl	8013ada <ehifGetStatus>
 800cc72:	4601      	mov	r1, r0
 800cc74:	4824      	ldr	r0, [pc, #144]	; (800cd08 <hwCommunicatorRadioInit+0x2c8>)
 800cc76:	f7fb fd75 	bl	8008764 <xprintf>
              LEDblink(LED_BLINKER_SPI_HELPER, LED_WHITE, 2, 1000, 1000, 100, 1000, 0);
 800cc7a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800cc7e:	2264      	movs	r2, #100	; 0x64
 800cc80:	2000      	movs	r0, #0
 800cc82:	9201      	str	r2, [sp, #4]
 800cc84:	9003      	str	r0, [sp, #12]
 800cc86:	9302      	str	r3, [sp, #8]
 800cc88:	9300      	str	r3, [sp, #0]
 800cc8a:	2202      	movs	r2, #2
 800cc8c:	2103      	movs	r1, #3
 800cc8e:	f000 f8ab 	bl	800cde8 <LEDblink>
 800cc92:	e01a      	b.n	800ccca <hwCommunicatorRadioInit+0x28a>
              ehifStop();
              continue;
            }
        }

      dprintf(LL_WARNING, "Did not find Radio Module %d\n", m);
 800cc94:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800cc96:	2b00      	cmp	r3, #0
 800cc98:	dd03      	ble.n	800cca2 <hwCommunicatorRadioInit+0x262>
 800cc9a:	2100      	movs	r1, #0
 800cc9c:	481b      	ldr	r0, [pc, #108]	; (800cd0c <hwCommunicatorRadioInit+0x2cc>)
 800cc9e:	f7fb fd61 	bl	8008764 <xprintf>

#ifdef MADO
      LEDblink(LED_BLINKER_SPI_HELPER, LD3, 1, 1000, 100, 100, 100, 0);
#endif
#ifdef SMOK
      switchPortHelper(CEN_PORT, PORT_TYPE_USART);
 800cca2:	2100      	movs	r1, #0
 800cca4:	4608      	mov	r0, r1
 800cca6:	f7fe fffb 	bl	800bca0 <switchPortHelper>
      spiHelper_t *helper = (spiHelper_t *)portData[CEN_PORT].SPIhelper;
 800ccaa:	4b15      	ldr	r3, [pc, #84]	; (800cd00 <hwCommunicatorRadioInit+0x2c0>)
      helper->radioModule = NULL;
 800ccac:	691a      	ldr	r2, [r3, #16]
 800ccae:	2300      	movs	r3, #0
 800ccb0:	f882 310c 	strb.w	r3, [r2, #268]	; 0x10c
 800ccb4:	f882 310d 	strb.w	r3, [r2, #269]	; 0x10d
 800ccb8:	f882 310e 	strb.w	r3, [r2, #270]	; 0x10e
 800ccbc:	f882 310f 	strb.w	r3, [r2, #271]	; 0x10f
#endif
      radioModule[m].spi.spi = NULL;
 800ccc0:	4a09      	ldr	r2, [pc, #36]	; (800cce8 <hwCommunicatorRadioInit+0x2a8>)
 800ccc2:	7013      	strb	r3, [r2, #0]
 800ccc4:	7053      	strb	r3, [r2, #1]
 800ccc6:	7093      	strb	r3, [r2, #2]
 800ccc8:	70d3      	strb	r3, [r2, #3]
      ehifStop();
 800ccca:	f7ff fa81 	bl	800c1d0 <ehifStop>
    }
#ifdef MADO
  LEDset(LED_BLINKER_SPI_HELPER, LD5, 0);
#else
  SmokLEDsState(0, 0, SET_NONE, -1);
 800ccce:	2200      	movs	r2, #0
 800ccd0:	f04f 33ff 	mov.w	r3, #4294967295
 800ccd4:	4611      	mov	r1, r2
 800ccd6:	4610      	mov	r0, r2
 800ccd8:	f7fc fdda 	bl	8009890 <SmokLEDsState>
#endif
}
 800ccdc:	b009      	add	sp, #36	; 0x24
 800ccde:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800cce2:	bf00      	nop
 800cce4:	10001000 	.word	0x10001000
 800cce8:	2001add4 	.word	0x2001add4
 800ccec:	0801d509 	.word	0x0801d509
 800ccf0:	080150a3 	.word	0x080150a3
 800ccf4:	0801d527 	.word	0x0801d527
 800ccf8:	0801d550 	.word	0x0801d550
 800ccfc:	0801d564 	.word	0x0801d564
 800cd00:	2001aabc 	.word	0x2001aabc
 800cd04:	08014878 	.word	0x08014878
 800cd08:	0801d589 	.word	0x0801d589
 800cd0c:	0801d5aa 	.word	0x0801d5aa

0800cd10 <radioReinitMsg>:
    }
  return 0;
}

static void radioReinitMsg(void *data)
{
 800cd10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cd14:	4c1e      	ldr	r4, [pc, #120]	; (800cd90 <radioReinitMsg+0x80>)
          if (portData[p].connState != DEV_NCONN)
            {
              portData[p].prevConnState = portData[p].connState;
              portData[p].connState = DEV_NCONN;
              connectionState(NET_NC);
              dprintf(LL_INFO, "Disconnecting peer (%08x:%08x:%08x).\n",
 800cd16:	f8df 9080 	ldr.w	r9, [pc, #128]	; 800cd98 <radioReinitMsg+0x88>
    }
  return 0;
}

static void radioReinitMsg(void *data)
{
 800cd1a:	4680      	mov	r8, r0
  messageRadioReinit_t *message = data;
  //Disconnect all ports
  portNum_t p;
  for (p = PER1_PORT; p < PORTS_NUM; p++)
 800cd1c:	2501      	movs	r5, #1
    {
      portData[p].enabled = 0;
 800cd1e:	2700      	movs	r7, #0

      spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
 800cd20:	6e26      	ldr	r6, [r4, #96]	; 0x60
  messageRadioReinit_t *message = data;
  //Disconnect all ports
  portNum_t p;
  for (p = PER1_PORT; p < PORTS_NUM; p++)
    {
      portData[p].enabled = 0;
 800cd22:	f884 706b 	strb.w	r7, [r4, #107]	; 0x6b

      spiHelper_t *helper = (spiHelper_t *)portData[p].SPIhelper;
      if(!helper) continue;
 800cd26:	b32e      	cbz	r6, 800cd74 <radioReinitMsg+0x64>
      if(portData[p].portType == PORT_TYPE_SPI)
 800cd28:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800cd2c:	2b01      	cmp	r3, #1
 800cd2e:	d121      	bne.n	800cd74 <radioReinitMsg+0x64>
        {
          if (portData[p].connState != DEV_NCONN)
 800cd30:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
 800cd34:	b1f3      	cbz	r3, 800cd74 <radioReinitMsg+0x64>
            {
              portData[p].prevConnState = portData[p].connState;
              portData[p].connState = DEV_NCONN;
              connectionState(NET_NC);
 800cd36:	2000      	movs	r0, #0
      if(!helper) continue;
      if(portData[p].portType == PORT_TYPE_SPI)
        {
          if (portData[p].connState != DEV_NCONN)
            {
              portData[p].prevConnState = portData[p].connState;
 800cd38:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
              portData[p].connState = DEV_NCONN;
 800cd3c:	f884 7070 	strb.w	r7, [r4, #112]	; 0x70
              connectionState(NET_NC);
 800cd40:	f7fc fbb8 	bl	80094b4 <connectionState>
              dprintf(LL_INFO, "Disconnecting peer (%08x:%08x:%08x).\n",
 800cd44:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
 800cd48:	2b01      	cmp	r3, #1
 800cd4a:	dd08      	ble.n	800cd5e <radioReinitMsg+0x4e>
 800cd4c:	f8d6 311d 	ldr.w	r3, [r6, #285]	; 0x11d
 800cd50:	f8d6 2119 	ldr.w	r2, [r6, #281]	; 0x119
 800cd54:	f8d6 1115 	ldr.w	r1, [r6, #277]	; 0x115
 800cd58:	480e      	ldr	r0, [pc, #56]	; (800cd94 <radioReinitMsg+0x84>)
 800cd5a:	f7fb fd03 	bl	8008764 <xprintf>
                      helper->connDev.devID,
                      helper->connDev.manID,
                      helper->connDev.prodID);
              switchPortHelper(p, PORT_TYPE_USART);
 800cd5e:	2100      	movs	r1, #0
 800cd60:	4628      	mov	r0, r5
 800cd62:	f7fe ff9d 	bl	800bca0 <switchPortHelper>
              helper->connDev.prodID = 0;
              helper->radioModule = NULL;
              helper->connDev.audioConnState = 0;
#endif

              sendNetworkStatus(p, NET_DROPPED, (uint8_t)helper->connDev.devID);
 800cd66:	f8d6 2115 	ldr.w	r2, [r6, #277]	; 0x115
 800cd6a:	2103      	movs	r1, #3
 800cd6c:	b2d2      	uxtb	r2, r2
 800cd6e:	4628      	mov	r0, r5
 800cd70:	f7ff fb1a 	bl	800c3a8 <sendNetworkStatus>
static void radioReinitMsg(void *data)
{
  messageRadioReinit_t *message = data;
  //Disconnect all ports
  portNum_t p;
  for (p = PER1_PORT; p < PORTS_NUM; p++)
 800cd74:	3501      	adds	r5, #1
 800cd76:	b2ed      	uxtb	r5, r5
 800cd78:	2d03      	cmp	r5, #3
 800cd7a:	f104 0450 	add.w	r4, r4, #80	; 0x50
 800cd7e:	d1cf      	bne.n	800cd20 <radioReinitMsg+0x10>
              sendNetworkStatus(p, NET_DROPPED, (uint8_t)helper->connDev.devID);
            }
        }
    }
  //Reinit radio modules
  hwCommunicatorRadioInit();
 800cd80:	f7ff fe5e 	bl	800ca40 <hwCommunicatorRadioInit>

  dFree(message);
 800cd84:	f1a8 0014 	sub.w	r0, r8, #20
}
 800cd88:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        }
    }
  //Reinit radio modules
  hwCommunicatorRadioInit();

  dFree(message);
 800cd8c:	f000 beaa 	b.w	800dae4 <bFree>
 800cd90:	2001aabc 	.word	0x2001aabc
 800cd94:	0801d5c8 	.word	0x0801d5c8
 800cd98:	10001000 	.word	0x10001000

0800cd9c <hwCommunicatorSPIInit>:

}
#endif

static void hwCommunicatorSPIInit(void *data)
{
 800cd9c:	b508      	push	{r3, lr}
  mdelay(100);
 800cd9e:	2064      	movs	r0, #100	; 0x64
 800cda0:	f7fd fd76 	bl	800a890 <vTaskDelay>
  hwCommunicatorRadioInit();
}
 800cda4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#endif

static void hwCommunicatorSPIInit(void *data)
{
  mdelay(100);
  hwCommunicatorRadioInit();
 800cda8:	f7ff be4a 	b.w	800ca40 <hwCommunicatorRadioInit>

0800cdac <EHIF_DELAY_US>:

void __attribute__((optimize("-Os")))EHIF_DELAY_US(int x)
{
  //Must not block CPUi
  //  EHIF_DELAY_MS(1);
  volatile int countDown =x*(SystemCoreClock/7000000UL);
 800cdac:	4b07      	ldr	r3, [pc, #28]	; (800cdcc <EHIF_DELAY_US+0x20>)
 800cdae:	4a08      	ldr	r2, [pc, #32]	; (800cdd0 <EHIF_DELAY_US+0x24>)
 800cdb0:	681b      	ldr	r3, [r3, #0]
 800cdb2:	fbb3 f3f2 	udiv	r3, r3, r2
}

//uint32_t cnt = 1000;

void __attribute__((optimize("-Os")))EHIF_DELAY_US(int x)
{
 800cdb6:	b082      	sub	sp, #8
  //Must not block CPUi
  //  EHIF_DELAY_MS(1);
  volatile int countDown =x*(SystemCoreClock/7000000UL);
 800cdb8:	4358      	muls	r0, r3
 800cdba:	9001      	str	r0, [sp, #4]
  while(countDown--);
 800cdbc:	9b01      	ldr	r3, [sp, #4]
 800cdbe:	1e5a      	subs	r2, r3, #1
 800cdc0:	9201      	str	r2, [sp, #4]
 800cdc2:	2b00      	cmp	r3, #0
 800cdc4:	d1fa      	bne.n	800cdbc <EHIF_DELAY_US+0x10>
}
 800cdc6:	b002      	add	sp, #8
 800cdc8:	4770      	bx	lr
 800cdca:	bf00      	nop
 800cdcc:	2001abe4 	.word	0x2001abe4
 800cdd0:	006acfc0 	.word	0x006acfc0

0800cdd4 <wdog>:
static void wdog(void *data)
{
#ifdef WATCHDOG_LED
  int i;
  for(i=0; i < LED_BLINKER_NUM; i++)
    if(&module[i] == data)
 800cdd4:	4b03      	ldr	r3, [pc, #12]	; (800cde4 <wdog+0x10>)
 800cdd6:	4283      	cmp	r3, r0
 800cdd8:	d102      	bne.n	800cde0 <wdog+0xc>
      wdogFeed(WATCHDOG_LED(0));
 800cdda:	2001      	movs	r0, #1
 800cddc:	f002 b800 	b.w	800ede0 <wdogFeed>
 800cde0:	4770      	bx	lr
 800cde2:	bf00      	nop
 800cde4:	2001a938 	.word	0x2001a938

0800cde8 <LEDblink>:
  int time_post;
  uint32_t loop;
} messageLEDData_t;
static int Bnum[LED_BLINKER_NUM];
int LEDblink(int LEDblinker, uint32_t ledsMask, int blinkNum, int time_on, int time_break, int time_pre, int time_post, uint8_t loop)
{
 800cde8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (LEDblinker >= LED_BLINKER_NUM)
 800cdec:	1e05      	subs	r5, r0, #0
  int time_post;
  uint32_t loop;
} messageLEDData_t;
static int Bnum[LED_BLINKER_NUM];
int LEDblink(int LEDblinker, uint32_t ledsMask, int blinkNum, int time_on, int time_break, int time_pre, int time_post, uint8_t loop)
{
 800cdee:	4689      	mov	r9, r1
 800cdf0:	4616      	mov	r6, r2
 800cdf2:	4698      	mov	r8, r3
 800cdf4:	f89d 702c 	ldrb.w	r7, [sp, #44]	; 0x2c
  if (LEDblinker >= LED_BLINKER_NUM)
 800cdf8:	dc28      	bgt.n	800ce4c <LEDblink+0x64>
    return -1;
  if (blinkNum == LED_BLINK_STOP)
 800cdfa:	1c53      	adds	r3, r2, #1
 800cdfc:	d103      	bne.n	800ce06 <LEDblink+0x1e>
    {
      Bnum[LEDblinker] = LED_BLINK_STOP;
 800cdfe:	4b17      	ldr	r3, [pc, #92]	; (800ce5c <LEDblink+0x74>)
 800ce00:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 800ce04:	e026      	b.n	800ce54 <LEDblink+0x6c>
    }
  else
    {
      //Allocate resources for data transfer
      messageLEDData_t *message = dAlloc(sizeof(messageLEDData_t));
 800ce06:	2020      	movs	r0, #32
 800ce08:	f000 fc12 	bl	800d630 <bAlloc>
 800ce0c:	4604      	mov	r4, r0
 800ce0e:	b1e8      	cbz	r0, 800ce4c <LEDblink+0x64>
      //Fill message
      message->LEDblinker = LEDblinker;
      message->ledsMask = ledsMask;
      message->blinkNum = blinkNum;
      message->time_on = time_on;
      message->time_break = time_break;
 800ce10:	9b08      	ldr	r3, [sp, #32]
 800ce12:	6243      	str	r3, [r0, #36]	; 0x24
      message->time_pre = time_pre;
 800ce14:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ce16:	6283      	str	r3, [r0, #40]	; 0x28
      message->time_post = time_post;
 800ce18:	9b0a      	ldr	r3, [sp, #40]	; 0x28

      if (message == NULL)
        return -1;

      //Fill message
      message->LEDblinker = LEDblinker;
 800ce1a:	6145      	str	r5, [r0, #20]
      message->ledsMask = ledsMask;
      message->blinkNum = blinkNum;
      message->time_on = time_on;
      message->time_break = time_break;
      message->time_pre = time_pre;
      message->time_post = time_post;
 800ce1c:	62c3      	str	r3, [r0, #44]	; 0x2c
      if (message == NULL)
        return -1;

      //Fill message
      message->LEDblinker = LEDblinker;
      message->ledsMask = ledsMask;
 800ce1e:	f8c0 9018 	str.w	r9, [r0, #24]
      message->blinkNum = blinkNum;
 800ce22:	61c6      	str	r6, [r0, #28]
      message->time_on = time_on;
 800ce24:	f8c0 8020 	str.w	r8, [r0, #32]
      Bnum[LEDblinker] = LED_BLINK_STOP;
    }
  else
    {
      //Allocate resources for data transfer
      messageLEDData_t *message = dAlloc(sizeof(messageLEDData_t));
 800ce28:	f100 0214 	add.w	r2, r0, #20
 800ce2c:	480c      	ldr	r0, [pc, #48]	; (800ce60 <LEDblink+0x78>)
 800ce2e:	01ad      	lsls	r5, r5, #6
      message->blinkNum = blinkNum;
      message->time_on = time_on;
      message->time_break = time_break;
      message->time_pre = time_pre;
      message->time_post = time_post;
      message->loop = loop?LOOP_COUNT(LEDblinker):LOOP_COUNT(LEDblinker)-1;
 800ce30:	1943      	adds	r3, r0, r5
 800ce32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ce34:	b907      	cbnz	r7, 800ce38 <LEDblink+0x50>
 800ce36:	3b01      	subs	r3, #1
 800ce38:	6323      	str	r3, [r4, #48]	; 0x30

      //Send the message to communicator
      if (moduleSendCommand(&module[LEDblinker], CMD_LED_BLINK, message) < 0)
 800ce3a:	2100      	movs	r1, #0
 800ce3c:	4428      	add	r0, r5
 800ce3e:	f7fe f98b 	bl	800b158 <moduleSendCommand>
 800ce42:	2800      	cmp	r0, #0
 800ce44:	da06      	bge.n	800ce54 <LEDblink+0x6c>
        {
          //Sending failed
          //Free allocated resources
          dFree(message);
 800ce46:	4620      	mov	r0, r4
 800ce48:	f000 fe4c 	bl	800dae4 <bFree>
          return -1;
 800ce4c:	f04f 30ff 	mov.w	r0, #4294967295
 800ce50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }
    }
  return 0;
 800ce54:	2000      	movs	r0, #0
}
 800ce56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ce5a:	bf00      	nop
 800ce5c:	2001ad5c 	.word	0x2001ad5c
 800ce60:	2001a938 	.word	0x2001a938

0800ce64 <LEDset>:
  uint32_t ledsMaskOn;
  uint32_t ledsMaskOff;
} messageLEDSetData_t;
static int Bnum[LED_BLINKER_NUM];
int LEDset(int LEDblinker, uint32_t ledsMaskOn, uint32_t ledsMaskOff)
{
 800ce64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (LEDblinker >= LED_BLINKER_NUM)
 800ce66:	1e05      	subs	r5, r0, #0
  uint32_t ledsMaskOn;
  uint32_t ledsMaskOff;
} messageLEDSetData_t;
static int Bnum[LED_BLINKER_NUM];
int LEDset(int LEDblinker, uint32_t ledsMaskOn, uint32_t ledsMaskOff)
{
 800ce68:	460f      	mov	r7, r1
 800ce6a:	4616      	mov	r6, r2
  if (LEDblinker >= LED_BLINKER_NUM)
 800ce6c:	dc18      	bgt.n	800cea0 <LEDset+0x3c>
    return -1;

  //Nothing to set
  if(ledsMaskOn == 0 && ledsMaskOff == 0)
 800ce6e:	b911      	cbnz	r1, 800ce76 <LEDset+0x12>
 800ce70:	b90a      	cbnz	r2, 800ce76 <LEDset+0x12>
    return 0;
 800ce72:	2000      	movs	r0, #0
 800ce74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  //Allocate resources for data transfer
  messageLEDSetData_t *message = dAlloc(sizeof(messageLEDSetData_t));
 800ce76:	200c      	movs	r0, #12
 800ce78:	f000 fbda 	bl	800d630 <bAlloc>
 800ce7c:	4604      	mov	r4, r0
 800ce7e:	b178      	cbz	r0, 800cea0 <LEDset+0x3c>

  if (message == NULL)
    return -1;

  //Fill message
  message->LEDblinker = LEDblinker;
 800ce80:	6145      	str	r5, [r0, #20]
  message->ledsMaskOn = ledsMaskOn;
 800ce82:	6187      	str	r7, [r0, #24]
  message->ledsMaskOff = ledsMaskOff;
 800ce84:	61c6      	str	r6, [r0, #28]

  //Send the message to communicator
  if (moduleSendCommand(&module[LEDblinker], CMD_LED_SET, message) < 0)
 800ce86:	f100 0214 	add.w	r2, r0, #20
 800ce8a:	4807      	ldr	r0, [pc, #28]	; (800cea8 <LEDset+0x44>)
 800ce8c:	2101      	movs	r1, #1
 800ce8e:	eb00 1085 	add.w	r0, r0, r5, lsl #6
 800ce92:	f7fe f961 	bl	800b158 <moduleSendCommand>
 800ce96:	2800      	cmp	r0, #0
 800ce98:	daeb      	bge.n	800ce72 <LEDset+0xe>
    {
      //Sending failed
      //Free allocated resources
      dFree(message);
 800ce9a:	4620      	mov	r0, r4
 800ce9c:	f000 fe22 	bl	800dae4 <bFree>
      return -1;
 800cea0:	f04f 30ff 	mov.w	r0, #4294967295
    }
  return 0;
}
 800cea4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cea6:	bf00      	nop
 800cea8:	2001a938 	.word	0x2001a938

0800ceac <LEDSset>:

void LEDSset(uint32_t ledsMaskOn, uint32_t ledsMaskOff)
{
 800ceac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ceb0:	4d19      	ldr	r5, [pc, #100]	; (800cf18 <LEDSset+0x6c>)
      else if(ledsMaskOn & 1)value = 1;
      if (value >= 0)
        {
          if(leds[LEDNum].pin)
            GPIO_WriteBit(leds[LEDNum].gpio, leds[LEDNum].pin, leds[LEDNum].invertPolarity ? !value : value);
          if(LED_print)
 800ceb2:	f8df a068 	ldr.w	sl, [pc, #104]	; 800cf1c <LEDSset+0x70>
    }
  return 0;
}

void LEDSset(uint32_t ledsMaskOn, uint32_t ledsMaskOff)
{
 800ceb6:	4607      	mov	r7, r0
 800ceb8:	4688      	mov	r8, r1
  int LEDNum = 0;
 800ceba:	2400      	movs	r4, #0
 800cebc:	46a9      	mov	r9, r5
  while ((ledsMaskOn || ledsMaskOff) && LEDNum < LEDS_NUM)
 800cebe:	b917      	cbnz	r7, 800cec6 <LEDSset+0x1a>
 800cec0:	f1b8 0f00 	cmp.w	r8, #0
 800cec4:	d025      	beq.n	800cf12 <LEDSset+0x66>
 800cec6:	2c05      	cmp	r4, #5
 800cec8:	d01d      	beq.n	800cf06 <LEDSset+0x5a>
    {
      int value  = -1;
      if(ledsMaskOff & 1)value = 0;
 800ceca:	f018 0f01 	tst.w	r8, #1
 800cece:	d102      	bne.n	800ced6 <LEDSset+0x2a>
      else if(ledsMaskOn & 1)value = 1;
 800ced0:	07fb      	lsls	r3, r7, #31
 800ced2:	d41a      	bmi.n	800cf0a <LEDSset+0x5e>
 800ced4:	e011      	b.n	800cefa <LEDSset+0x4e>
{
  int LEDNum = 0;
  while ((ledsMaskOn || ledsMaskOff) && LEDNum < LEDS_NUM)
    {
      int value  = -1;
      if(ledsMaskOff & 1)value = 0;
 800ced6:	2600      	movs	r6, #0
      else if(ledsMaskOn & 1)value = 1;
      if (value >= 0)
        {
          if(leds[LEDNum].pin)
 800ced8:	88a9      	ldrh	r1, [r5, #4]
 800ceda:	b139      	cbz	r1, 800ceec <LEDSset+0x40>
            GPIO_WriteBit(leds[LEDNum].gpio, leds[LEDNum].pin, leds[LEDNum].invertPolarity ? !value : value);
 800cedc:	79ab      	ldrb	r3, [r5, #6]
 800cede:	f859 0034 	ldr.w	r0, [r9, r4, lsl #3]
 800cee2:	b1a3      	cbz	r3, 800cf0e <LEDSset+0x62>
 800cee4:	f086 0201 	eor.w	r2, r6, #1
 800cee8:	f004 f854 	bl	8010f94 <GPIO_WriteBit>
          if(LED_print)
 800ceec:	f1ba 0f00 	cmp.w	sl, #0
 800cef0:	d003      	beq.n	800cefa <LEDSset+0x4e>
            LED_print(LEDNum, value);
 800cef2:	4631      	mov	r1, r6
 800cef4:	4620      	mov	r0, r4
 800cef6:	f001 ff3d 	bl	800ed74 <LED_print>
        }
      LEDNum++;
 800cefa:	3401      	adds	r4, #1
      ledsMaskOn >>= 1;
 800cefc:	087f      	lsrs	r7, r7, #1
      ledsMaskOff >>= 1;
 800cefe:	ea4f 0858 	mov.w	r8, r8, lsr #1
 800cf02:	3508      	adds	r5, #8
 800cf04:	e7db      	b.n	800cebe <LEDSset+0x12>
 800cf06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  int LEDNum = 0;
  while ((ledsMaskOn || ledsMaskOff) && LEDNum < LEDS_NUM)
    {
      int value  = -1;
      if(ledsMaskOff & 1)value = 0;
      else if(ledsMaskOn & 1)value = 1;
 800cf0a:	2601      	movs	r6, #1
 800cf0c:	e7e4      	b.n	800ced8 <LEDSset+0x2c>
      if (value >= 0)
        {
          if(leds[LEDNum].pin)
            GPIO_WriteBit(leds[LEDNum].gpio, leds[LEDNum].pin, leds[LEDNum].invertPolarity ? !value : value);
 800cf0e:	b2f2      	uxtb	r2, r6
 800cf10:	e7ea      	b.n	800cee8 <LEDSset+0x3c>
 800cf12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800cf16:	bf00      	nop
 800cf18:	2001abb0 	.word	0x2001abb0
 800cf1c:	0800ed75 	.word	0x0800ed75

0800cf20 <LEDInit>:
#endif
}

static uint32_t ledsState = 0;
void LEDInit(void)
{
 800cf20:	b508      	push	{r3, lr}
  //Initialize LED blinker
  LEDSset(0, ~0);
 800cf22:	2000      	movs	r0, #0
 800cf24:	f04f 31ff 	mov.w	r1, #4294967295
 800cf28:	f7ff ffc0 	bl	800ceac <LEDSset>
  ledsState = 0;
 800cf2c:	4b03      	ldr	r3, [pc, #12]	; (800cf3c <LEDInit+0x1c>)
  int blinker;
  for (blinker = 0; blinker < LED_BLINKER_NUM; blinker++)
    {
      moduleInit(&(module[blinker]));
 800cf2e:	4804      	ldr	r0, [pc, #16]	; (800cf40 <LEDInit+0x20>)
static uint32_t ledsState = 0;
void LEDInit(void)
{
  //Initialize LED blinker
  LEDSset(0, ~0);
  ledsState = 0;
 800cf30:	2200      	movs	r2, #0
 800cf32:	605a      	str	r2, [r3, #4]
  int blinker;
  for (blinker = 0; blinker < LED_BLINKER_NUM; blinker++)
    {
      moduleInit(&(module[blinker]));
    }
}
 800cf34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LEDSset(0, ~0);
  ledsState = 0;
  int blinker;
  for (blinker = 0; blinker < LED_BLINKER_NUM; blinker++)
    {
      moduleInit(&(module[blinker]));
 800cf38:	f7fe b962 	b.w	800b200 <moduleInit>
 800cf3c:	2001ad5c 	.word	0x2001ad5c
 800cf40:	2001a938 	.word	0x2001a938

0800cf44 <ledSet>:
      return;//Sending ok
  dFree(message);
}

static void ledSet(void *data)
{
 800cf44:	b510      	push	{r4, lr}
 800cf46:	4604      	mov	r4, r0
  messageLEDSetData_t *message = data;

  LEDSset(message->ledsMaskOn, message->ledsMaskOff);
 800cf48:	6881      	ldr	r1, [r0, #8]
 800cf4a:	6840      	ldr	r0, [r0, #4]
 800cf4c:	f7ff ffae 	bl	800ceac <LEDSset>
  ledsState &= ~message->ledsMaskOff;
  ledsState |= message->ledsMaskOn;
 800cf50:	4906      	ldr	r1, [pc, #24]	; (800cf6c <ledSet+0x28>)
 800cf52:	68a2      	ldr	r2, [r4, #8]
 800cf54:	684b      	ldr	r3, [r1, #4]
 800cf56:	ea23 0202 	bic.w	r2, r3, r2
 800cf5a:	6863      	ldr	r3, [r4, #4]
 800cf5c:	4313      	orrs	r3, r2
 800cf5e:	604b      	str	r3, [r1, #4]
  dFree(message);
 800cf60:	f1a4 0014 	sub.w	r0, r4, #20
}
 800cf64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  messageLEDSetData_t *message = data;

  LEDSset(message->ledsMaskOn, message->ledsMaskOff);
  ledsState &= ~message->ledsMaskOff;
  ledsState |= message->ledsMaskOn;
  dFree(message);
 800cf68:	f000 bdbc 	b.w	800dae4 <bFree>
 800cf6c:	2001ad5c 	.word	0x2001ad5c

0800cf70 <ledBlink>:
      ledsMaskOff >>= 1;
    }
}

static void ledBlink(void *data)
{
 800cf70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cf74:	4604      	mov	r4, r0
  messageLEDData_t *message = data;

  //Pre blink
  LEDSset(0, message->ledsMask);
 800cf76:	6841      	ldr	r1, [r0, #4]
  vTaskDelay(message->time_pre);

  //Blink
  int *num = &Bnum[message->LEDblinker];
  *num = message->blinkNum;
 800cf78:	4e26      	ldr	r6, [pc, #152]	; (800d014 <ledBlink+0xa4>)
static void ledBlink(void *data)
{
  messageLEDData_t *message = data;

  //Pre blink
  LEDSset(0, message->ledsMask);
 800cf7a:	2000      	movs	r0, #0
 800cf7c:	f7ff ff96 	bl	800ceac <LEDSset>
  vTaskDelay(message->time_pre);
 800cf80:	6960      	ldr	r0, [r4, #20]
 800cf82:	f7fd fc85 	bl	800a890 <vTaskDelay>

  //Blink
  int *num = &Bnum[message->LEDblinker];
 800cf86:	6827      	ldr	r7, [r4, #0]
  *num = message->blinkNum;
 800cf88:	68a3      	ldr	r3, [r4, #8]
 800cf8a:	f846 3027 	str.w	r3, [r6, r7, lsl #2]

  while (*num)
 800cf8e:	46b0      	mov	r8, r6
      if (*num != LED_BLINK_INFINITY)
        {
          if (*num != LED_BLINK_STOP)
            (*num)--;
          else
            *num = 0;
 800cf90:	f04f 0900 	mov.w	r9, #0

  //Blink
  int *num = &Bnum[message->LEDblinker];
  *num = message->blinkNum;

  while (*num)
 800cf94:	f856 5027 	ldr.w	r5, [r6, r7, lsl #2]
 800cf98:	b1e5      	cbz	r5, 800cfd4 <ledBlink+0x64>
    {
      if (*num != LED_BLINK_INFINITY)
 800cf9a:	1caa      	adds	r2, r5, #2
 800cf9c:	d007      	beq.n	800cfae <ledBlink+0x3e>
        {
          if (*num != LED_BLINK_STOP)
 800cf9e:	1c6b      	adds	r3, r5, #1
            (*num)--;
 800cfa0:	bf1a      	itte	ne
 800cfa2:	f105 35ff 	addne.w	r5, r5, #4294967295
 800cfa6:	f848 5027 	strne.w	r5, [r8, r7, lsl #2]
          else
            *num = 0;
 800cfaa:	f848 9027 	streq.w	r9, [r8, r7, lsl #2]
        }

      LEDSset(message->ledsMask, 0);
 800cfae:	2100      	movs	r1, #0
 800cfb0:	6860      	ldr	r0, [r4, #4]
 800cfb2:	f7ff ff7b 	bl	800ceac <LEDSset>
      vTaskDelay(message->time_on);
 800cfb6:	68e0      	ldr	r0, [r4, #12]
 800cfb8:	f7fd fc6a 	bl	800a890 <vTaskDelay>
      LEDSset(0, message->ledsMask);
 800cfbc:	6861      	ldr	r1, [r4, #4]
 800cfbe:	2000      	movs	r0, #0
 800cfc0:	f7ff ff74 	bl	800ceac <LEDSset>
      //For last blink do not wait for time_break
      if (*num != 0)
 800cfc4:	f856 3027 	ldr.w	r3, [r6, r7, lsl #2]
 800cfc8:	2b00      	cmp	r3, #0
 800cfca:	d0e3      	beq.n	800cf94 <ledBlink+0x24>
        vTaskDelay(message->time_break);
 800cfcc:	6920      	ldr	r0, [r4, #16]
 800cfce:	f7fd fc5f 	bl	800a890 <vTaskDelay>
 800cfd2:	e7df      	b.n	800cf94 <ledBlink+0x24>
    }
  vTaskDelay(message->time_post);
 800cfd4:	69a0      	ldr	r0, [r4, #24]
 800cfd6:	f7fd fc5b 	bl	800a890 <vTaskDelay>
  LEDSset(message->ledsMask & ledsState, 0);
 800cfda:	4b0e      	ldr	r3, [pc, #56]	; (800d014 <ledBlink+0xa4>)
 800cfdc:	6860      	ldr	r0, [r4, #4]
 800cfde:	685b      	ldr	r3, [r3, #4]
 800cfe0:	4629      	mov	r1, r5
 800cfe2:	4018      	ands	r0, r3
 800cfe4:	f7ff ff62 	bl	800ceac <LEDSset>

  if(message->loop == LOOP_COUNT(message->LEDblinker))
 800cfe8:	4b0b      	ldr	r3, [pc, #44]	; (800d018 <ledBlink+0xa8>)
 800cfea:	6820      	ldr	r0, [r4, #0]
 800cfec:	eb03 1080 	add.w	r0, r3, r0, lsl #6
 800cff0:	69e3      	ldr	r3, [r4, #28]
 800cff2:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800cff4:	429a      	cmp	r2, r3
 800cff6:	d005      	beq.n	800d004 <ledBlink+0x94>
    if (moduleSendCommand(&module[message->LEDblinker], CMD_LED_BLINK, message) >= 0)
      return;//Sending ok
  dFree(message);
 800cff8:	f1a4 0014 	sub.w	r0, r4, #20
}
 800cffc:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  LEDSset(message->ledsMask & ledsState, 0);

  if(message->loop == LOOP_COUNT(message->LEDblinker))
    if (moduleSendCommand(&module[message->LEDblinker], CMD_LED_BLINK, message) >= 0)
      return;//Sending ok
  dFree(message);
 800d000:	f000 bd70 	b.w	800dae4 <bFree>
    }
  vTaskDelay(message->time_post);
  LEDSset(message->ledsMask & ledsState, 0);

  if(message->loop == LOOP_COUNT(message->LEDblinker))
    if (moduleSendCommand(&module[message->LEDblinker], CMD_LED_BLINK, message) >= 0)
 800d004:	4622      	mov	r2, r4
 800d006:	4629      	mov	r1, r5
 800d008:	f7fe f8a6 	bl	800b158 <moduleSendCommand>
 800d00c:	2800      	cmp	r0, #0
 800d00e:	dbf3      	blt.n	800cff8 <ledBlink+0x88>
      return;//Sending ok
  dFree(message);
}
 800d010:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d014:	2001ad5c 	.word	0x2001ad5c
 800d018:	2001a938 	.word	0x2001a938

0800d01c <adcProtoTask>:
#endif
    }
}

static void adcProtoTask(void *pvParameters)
{
 800d01c:	b508      	push	{r3, lr}
  while (1)
    {
      mdelay(100);
 800d01e:	2064      	movs	r0, #100	; 0x64
 800d020:	f7fd fc36 	bl	800a890 <vTaskDelay>
#ifdef WATCHDOG_ADC
      wdogFeed(WATCHDOG_ADC(0));
 800d024:	2010      	movs	r0, #16
 800d026:	f001 fedb 	bl	800ede0 <wdogFeed>
 800d02a:	e7f8      	b.n	800d01e <adcProtoTask+0x2>

0800d02c <adcTask>:
}

static volatile char measeureDoubleBuffer[BUFFER_SIZE]__attribute__((section(".noload")));
static volatile uint16_t *buffer[2] = {(uint16_t *) &measeureDoubleBuffer[0], (uint16_t *) &measeureDoubleBuffer[HALF_BUFFER_SIZE]};
static void adcTask(void *pvParameters)
{
 800d02c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d030:	b09b      	sub	sp, #108	; 0x6c
  taskWaitInit();
 800d032:	f7fb fa7f 	bl	8008534 <taskWaitInit>
  //First time measure for ADC_CHECK time
  int measures_per_message = ADC_CHECK / ADC_FREQ;
  memset((void *)measeureDoubleBuffer, 0, BUFFER_SIZE);
 800d036:	2100      	movs	r1, #0
 800d038:	f44f 5283 	mov.w	r2, #4192	; 0x1060
 800d03c:	481b      	ldr	r0, [pc, #108]	; (800d0ac <adcTask+0x80>)
 800d03e:	f007 faa1 	bl	8014584 <memset>
  ADC_startConversion((void *)measeureDoubleBuffer, BUFFER_SIZE);
 800d042:	f44f 5183 	mov.w	r1, #4192	; 0x1060
 800d046:	4819      	ldr	r0, [pc, #100]	; (800d0ac <adcTask+0x80>)
 800d048:	f001 f87e 	bl	800e148 <ADC_startConversion>
    {
      int V1min = ADC_MAX, V1max = 0, V1accu = 0;
      int I1min = ADC_MAX, I1max = 0, I1accu = 0;
      int V2min = ADC_MAX, V2max = 0, V2accu = 0;
      int I2min = ADC_MAX, I2max = 0, I2accu = 0;
      int V2I1max = 0;
 800d04c:	2400      	movs	r4, #0
  while (1)
    {
      int V1min = ADC_MAX, V1max = 0, V1accu = 0;
      int I1min = ADC_MAX, I1max = 0, I1accu = 0;
      int V2min = ADC_MAX, V2max = 0, V2accu = 0;
      int I2min = ADC_MAX, I2max = 0, I2accu = 0;
 800d04e:	f640 75ff 	movw	r5, #4095	; 0xfff
}

static volatile char measeureDoubleBuffer[BUFFER_SIZE]__attribute__((section(".noload")));
static volatile uint16_t *buffer[2] = {(uint16_t *) &measeureDoubleBuffer[0], (uint16_t *) &measeureDoubleBuffer[HALF_BUFFER_SIZE]};
static void adcTask(void *pvParameters)
{
 800d052:	230a      	movs	r3, #10
 800d054:	9309      	str	r3, [sp, #36]	; 0x24
  while (1)
    {
      int V1min = ADC_MAX, V1max = 0, V1accu = 0;
      int I1min = ADC_MAX, I1max = 0, I1accu = 0;
      int V2min = ADC_MAX, V2max = 0, V2accu = 0;
      int I2min = ADC_MAX, I2max = 0, I2accu = 0;
 800d056:	9408      	str	r4, [sp, #32]
 800d058:	46a3      	mov	fp, r4

  while (1)
    {
      int V1min = ADC_MAX, V1max = 0, V1accu = 0;
      int I1min = ADC_MAX, I1max = 0, I1accu = 0;
      int V2min = ADC_MAX, V2max = 0, V2accu = 0;
 800d05a:	9406      	str	r4, [sp, #24]
 800d05c:	46a2      	mov	sl, r4
 800d05e:	46a9      	mov	r9, r5
  ADC_startConversion((void *)measeureDoubleBuffer, BUFFER_SIZE);

  while (1)
    {
      int V1min = ADC_MAX, V1max = 0, V1accu = 0;
      int I1min = ADC_MAX, I1max = 0, I1accu = 0;
 800d060:	9407      	str	r4, [sp, #28]
 800d062:	9404      	str	r4, [sp, #16]
 800d064:	46a8      	mov	r8, r5
  memset((void *)measeureDoubleBuffer, 0, BUFFER_SIZE);
  ADC_startConversion((void *)measeureDoubleBuffer, BUFFER_SIZE);

  while (1)
    {
      int V1min = ADC_MAX, V1max = 0, V1accu = 0;
 800d066:	9405      	str	r4, [sp, #20]
 800d068:	4627      	mov	r7, r4
 800d06a:	462e      	mov	r6, r5
      int V2I1max = 0;
      int measureNum;
      for (measureNum = 0; measureNum < measures_per_message; measureNum++)
        {
          //Wait before next measure
          massert(xSemaphoreTake(ADC_xSemaphore, portMAX_DELAY ) == pdTRUE );
 800d06c:	4810      	ldr	r0, [pc, #64]	; (800d0b0 <adcTask+0x84>)
 800d06e:	2300      	movs	r3, #0
 800d070:	f04f 32ff 	mov.w	r2, #4294967295
 800d074:	4619      	mov	r1, r3
 800d076:	6800      	ldr	r0, [r0, #0]
 800d078:	f7fd ff96 	bl	800afa8 <xQueueGenericReceive>
 800d07c:	2801      	cmp	r0, #1
 800d07e:	d108      	bne.n	800d092 <adcTask+0x66>
          int sample;
          for (sample = 0; sample < SAMPLES_PER_ADC_FREQ; sample++)
            {
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
 800d080:	4b0c      	ldr	r3, [pc, #48]	; (800d0b4 <adcTask+0x88>)
 800d082:	681a      	ldr	r2, [r3, #0]
 800d084:	4b0c      	ldr	r3, [pc, #48]	; (800d0b8 <adcTask+0x8c>)
 800d086:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800d08a:	1c8b      	adds	r3, r1, #2
 800d08c:	f601 0c32 	addw	ip, r1, #2098	; 0x832
 800d090:	e01a      	b.n	800d0c8 <adcTask+0x9c>
      int V2I1max = 0;
      int measureNum;
      for (measureNum = 0; measureNum < measures_per_message; measureNum++)
        {
          //Wait before next measure
          massert(xSemaphoreTake(ADC_xSemaphore, portMAX_DELAY ) == pdTRUE );
 800d092:	4b0a      	ldr	r3, [pc, #40]	; (800d0bc <adcTask+0x90>)
 800d094:	490a      	ldr	r1, [pc, #40]	; (800d0c0 <adcTask+0x94>)
 800d096:	480b      	ldr	r0, [pc, #44]	; (800d0c4 <adcTask+0x98>)
 800d098:	2277      	movs	r2, #119	; 0x77
 800d09a:	f7fb fb63 	bl	8008764 <xprintf>
 800d09e:	2301      	movs	r3, #1
 800d0a0:	9319      	str	r3, [sp, #100]	; 0x64
 800d0a2:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800d0a4:	2b00      	cmp	r3, #0
 800d0a6:	d1fc      	bne.n	800d0a2 <adcTask+0x76>
 800d0a8:	e7ea      	b.n	800d080 <adcTask+0x54>
 800d0aa:	bf00      	nop
 800d0ac:	200189d8 	.word	0x200189d8
 800d0b0:	2001ae50 	.word	0x2001ae50
 800d0b4:	2001ad64 	.word	0x2001ad64
 800d0b8:	0801d614 	.word	0x0801d614
 800d0bc:	0801d634 	.word	0x0801d634
 800d0c0:	0801d61c 	.word	0x0801d61c
 800d0c4:	080148f4 	.word	0x080148f4
          int sample;
          for (sample = 0; sample < SAMPLES_PER_ADC_FREQ; sample++)
            {
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
 800d0c8:	8858      	ldrh	r0, [r3, #2]
 800d0ca:	9904      	ldr	r1, [sp, #16]
 800d0cc:	b280      	uxth	r0, r0
 800d0ce:	4288      	cmp	r0, r1
                V2I1max = buffer[bufferNum][4*(sample)+(1)];
 800d0d0:	bfc8      	it	gt
 800d0d2:	881c      	ldrhgt	r4, [r3, #0]

              SET_MIN_MAX_ACCU(V1, sample, 0);
 800d0d4:	9905      	ldr	r1, [sp, #20]
 800d0d6:	f833 0c02 	ldrh.w	r0, [r3, #-2]
 800d0da:	fa11 f180 	uxtah	r1, r1, r0
 800d0de:	f833 0c02 	ldrh.w	r0, [r3, #-2]
 800d0e2:	9105      	str	r1, [sp, #20]
 800d0e4:	f1a3 0e02 	sub.w	lr, r3, #2
 800d0e8:	b280      	uxth	r0, r0
          int sample;
          for (sample = 0; sample < SAMPLES_PER_ADC_FREQ; sample++)
            {
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
                V2I1max = buffer[bufferNum][4*(sample)+(1)];
 800d0ea:	bfc8      	it	gt
 800d0ec:	b2a4      	uxthgt	r4, r4

              SET_MIN_MAX_ACCU(V1, sample, 0);
 800d0ee:	42b8      	cmp	r0, r7
 800d0f0:	bfc8      	it	gt
 800d0f2:	f833 7c02 	ldrhgt.w	r7, [r3, #-2]
 800d0f6:	f8be 0000 	ldrh.w	r0, [lr]
              SET_MIN_MAX_ACCU(V2, sample, 1);
 800d0fa:	9906      	ldr	r1, [sp, #24]
            {
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
                V2I1max = buffer[bufferNum][4*(sample)+(1)];

              SET_MIN_MAX_ACCU(V1, sample, 0);
 800d0fc:	b280      	uxth	r0, r0
 800d0fe:	bfc8      	it	gt
 800d100:	b2bf      	uxthgt	r7, r7
 800d102:	42b0      	cmp	r0, r6
 800d104:	bfb8      	it	lt
 800d106:	f8be 6000 	ldrhlt.w	r6, [lr]
              SET_MIN_MAX_ACCU(V2, sample, 1);
 800d10a:	8818      	ldrh	r0, [r3, #0]
 800d10c:	fa11 f180 	uxtah	r1, r1, r0
 800d110:	8818      	ldrh	r0, [r3, #0]
 800d112:	9106      	str	r1, [sp, #24]
 800d114:	b280      	uxth	r0, r0
            {
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
                V2I1max = buffer[bufferNum][4*(sample)+(1)];

              SET_MIN_MAX_ACCU(V1, sample, 0);
 800d116:	bfb8      	it	lt
 800d118:	b2b6      	uxthlt	r6, r6
              SET_MIN_MAX_ACCU(V2, sample, 1);
 800d11a:	4550      	cmp	r0, sl
 800d11c:	bfc8      	it	gt
 800d11e:	f8b3 a000 	ldrhgt.w	sl, [r3]
 800d122:	8818      	ldrh	r0, [r3, #0]
              SET_MIN_MAX_ACCU(I1, sample, 2);
 800d124:	9907      	ldr	r1, [sp, #28]
 800d126:	f103 0202 	add.w	r2, r3, #2
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
                V2I1max = buffer[bufferNum][4*(sample)+(1)];

              SET_MIN_MAX_ACCU(V1, sample, 0);
              SET_MIN_MAX_ACCU(V2, sample, 1);
 800d12a:	b280      	uxth	r0, r0
 800d12c:	bfc8      	it	gt
 800d12e:	fa1f fa8a 	uxthgt.w	sl, sl
 800d132:	4548      	cmp	r0, r9
 800d134:	bfb8      	it	lt
 800d136:	f8b3 9000 	ldrhlt.w	r9, [r3]
              SET_MIN_MAX_ACCU(I1, sample, 2);
 800d13a:	8810      	ldrh	r0, [r2, #0]
 800d13c:	fa11 f180 	uxtah	r1, r1, r0
 800d140:	8810      	ldrh	r0, [r2, #0]
 800d142:	9107      	str	r1, [sp, #28]
 800d144:	9904      	ldr	r1, [sp, #16]
 800d146:	b280      	uxth	r0, r0
              //Snapshot of voltage for max I1
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
                V2I1max = buffer[bufferNum][4*(sample)+(1)];

              SET_MIN_MAX_ACCU(V1, sample, 0);
              SET_MIN_MAX_ACCU(V2, sample, 1);
 800d148:	bfb8      	it	lt
 800d14a:	fa1f f989 	uxthlt.w	r9, r9
              SET_MIN_MAX_ACCU(I1, sample, 2);
 800d14e:	4288      	cmp	r0, r1
 800d150:	bfc4      	itt	gt
 800d152:	8810      	ldrhgt	r0, [r2, #0]
 800d154:	b281      	uxthgt	r1, r0
 800d156:	8810      	ldrh	r0, [r2, #0]
 800d158:	bfc8      	it	gt
 800d15a:	9104      	strgt	r1, [sp, #16]
 800d15c:	b280      	uxth	r0, r0
 800d15e:	4540      	cmp	r0, r8
 800d160:	bfb8      	it	lt
 800d162:	f8b2 8000 	ldrhlt.w	r8, [r2]
              SET_MIN_MAX_ACCU(I2, sample, 3);
 800d166:	9908      	ldr	r1, [sp, #32]
 800d168:	889a      	ldrh	r2, [r3, #4]
 800d16a:	fa11 f282 	uxtah	r2, r1, r2
 800d16e:	9208      	str	r2, [sp, #32]
 800d170:	889a      	ldrh	r2, [r3, #4]
 800d172:	f103 0004 	add.w	r0, r3, #4
 800d176:	b292      	uxth	r2, r2
              if(I1max < buffer[bufferNum][4*(sample)+(2)])
                V2I1max = buffer[bufferNum][4*(sample)+(1)];

              SET_MIN_MAX_ACCU(V1, sample, 0);
              SET_MIN_MAX_ACCU(V2, sample, 1);
              SET_MIN_MAX_ACCU(I1, sample, 2);
 800d178:	bfb8      	it	lt
 800d17a:	fa1f f888 	uxthlt.w	r8, r8
              SET_MIN_MAX_ACCU(I2, sample, 3);
 800d17e:	455a      	cmp	r2, fp
 800d180:	bfc8      	it	gt
 800d182:	f8b3 b004 	ldrhgt.w	fp, [r3, #4]
 800d186:	8802      	ldrh	r2, [r0, #0]
 800d188:	b292      	uxth	r2, r2
 800d18a:	bfc8      	it	gt
 800d18c:	fa1f fb8b 	uxthgt.w	fp, fp
 800d190:	42aa      	cmp	r2, r5
 800d192:	bfb8      	it	lt
 800d194:	8805      	ldrhlt	r5, [r0, #0]
 800d196:	f103 0308 	add.w	r3, r3, #8
 800d19a:	bfb8      	it	lt
 800d19c:	b2ad      	uxthlt	r5, r5
      for (measureNum = 0; measureNum < measures_per_message; measureNum++)
        {
          //Wait before next measure
          massert(xSemaphoreTake(ADC_xSemaphore, portMAX_DELAY ) == pdTRUE );
          int sample;
          for (sample = 0; sample < SAMPLES_PER_ADC_FREQ; sample++)
 800d19e:	459c      	cmp	ip, r3
 800d1a0:	d192      	bne.n	800d0c8 <adcTask+0x9c>
      int I1min = ADC_MAX, I1max = 0, I1accu = 0;
      int V2min = ADC_MAX, V2max = 0, V2accu = 0;
      int I2min = ADC_MAX, I2max = 0, I2accu = 0;
      int V2I1max = 0;
      int measureNum;
      for (measureNum = 0; measureNum < measures_per_message; measureNum++)
 800d1a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d1a4:	3b01      	subs	r3, #1
 800d1a6:	9309      	str	r3, [sp, #36]	; 0x24
 800d1a8:	f47f af60 	bne.w	800d06c <adcTask+0x40>
              SET_MIN_MAX_ACCU(I1, sample, 2);
              SET_MIN_MAX_ACCU(I2, sample, 3);
            }
        }

      taskENTER_CRITICAL();
 800d1ac:	f7fc ffc2 	bl	800a134 <vPortEnterCritical>
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
 800d1b0:	4bbe      	ldr	r3, [pc, #760]	; (800d4ac <adcTask+0x480>)
      Uwe_val_data += V1accu;
 800d1b2:	4dbf      	ldr	r5, [pc, #764]	; (800d4b0 <adcTask+0x484>)
            }
        }

      taskENTER_CRITICAL();
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
 800d1b4:	685a      	ldr	r2, [r3, #4]
      Uwe_val_data += V1accu;
 800d1b6:	9905      	ldr	r1, [sp, #20]
            }
        }

      taskENTER_CRITICAL();
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
 800d1b8:	9209      	str	r2, [sp, #36]	; 0x24
 800d1ba:	609a      	str	r2, [r3, #8]
      Uwe_val_data += V1accu;
 800d1bc:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d1c0:	460e      	mov	r6, r1
 800d1c2:	18b6      	adds	r6, r6, r2
 800d1c4:	ea4f 77e1 	mov.w	r7, r1, asr #31
 800d1c8:	4608      	mov	r0, r1
 800d1ca:	4639      	mov	r1, r7
 800d1cc:	415f      	adcs	r7, r3
 800d1ce:	4632      	mov	r2, r6
 800d1d0:	463b      	mov	r3, r7
 800d1d2:	e9c5 2300 	strd	r2, r3, [r5]
      Uwy_val_data += V2accu;
 800d1d6:	4db7      	ldr	r5, [pc, #732]	; (800d4b4 <adcTask+0x488>)
        }

      taskENTER_CRITICAL();
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
      Uwe_val_data += V1accu;
 800d1d8:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
      Uwy_val_data += V2accu;
 800d1dc:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d1e0:	9f06      	ldr	r7, [sp, #24]
 800d1e2:	46b8      	mov	r8, r7
 800d1e4:	eb18 0802 	adds.w	r8, r8, r2
 800d1e8:	ea4f 79e7 	mov.w	r9, r7, asr #31
 800d1ec:	463e      	mov	r6, r7
 800d1ee:	464f      	mov	r7, r9
 800d1f0:	eb49 0903 	adc.w	r9, r9, r3
 800d1f4:	4642      	mov	r2, r8
 800d1f6:	464b      	mov	r3, r9
 800d1f8:	e9c5 2300 	strd	r2, r3, [r5]
      Uwy_k_data += V2accu;
 800d1fc:	4dae      	ldr	r5, [pc, #696]	; (800d4b8 <adcTask+0x48c>)
 800d1fe:	e9d5 2300 	ldrd	r2, r3, [r5]

      taskENTER_CRITICAL();
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
      Uwe_val_data += V1accu;
      Uwy_val_data += V2accu;
 800d202:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
      Uwy_k_data += V2accu;
 800d206:	eb16 0802 	adds.w	r8, r6, r2
 800d20a:	eb47 0903 	adc.w	r9, r7, r3
 800d20e:	4642      	mov	r2, r8
 800d210:	464b      	mov	r3, r9
 800d212:	e9c5 2300 	strd	r2, r3, [r5]
      meaniL_data  += I1accu;
 800d216:	4da9      	ldr	r5, [pc, #676]	; (800d4bc <adcTask+0x490>)
 800d218:	9b07      	ldr	r3, [sp, #28]
      taskENTER_CRITICAL();
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
      Uwe_val_data += V1accu;
      Uwy_val_data += V2accu;
      Uwy_k_data += V2accu;
 800d21a:	e9cd 890e 	strd	r8, r9, [sp, #56]	; 0x38
      meaniL_data  += I1accu;
 800d21e:	e9d5 8900 	ldrd	r8, r9, [r5]
 800d222:	eb18 0203 	adds.w	r2, r8, r3
 800d226:	eb49 73e3 	adc.w	r3, r9, r3, asr #31
 800d22a:	e9c5 2300 	strd	r2, r3, [r5]
      UwyI_data += V2accu;
 800d22e:	4da4      	ldr	r5, [pc, #656]	; (800d4c0 <adcTask+0x494>)
      int samplesNum = (SAMPLES_PER_ADC_FREQ * measureNum);
      kSensADC = sensADC;
      Uwe_val_data += V1accu;
      Uwy_val_data += V2accu;
      Uwy_k_data += V2accu;
      meaniL_data  += I1accu;
 800d230:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
      UwyI_data += V2accu;
 800d234:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d238:	eb16 0802 	adds.w	r8, r6, r2
 800d23c:	eb47 0903 	adc.w	r9, r7, r3
 800d240:	4642      	mov	r2, r8
 800d242:	464b      	mov	r3, r9
 800d244:	e9c5 2300 	strd	r2, r3, [r5]
      meaniH_data  += I2accu;
 800d248:	4d9e      	ldr	r5, [pc, #632]	; (800d4c4 <adcTask+0x498>)
 800d24a:	9e08      	ldr	r6, [sp, #32]
 800d24c:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d250:	1997      	adds	r7, r2, r6
      kSensADC = sensADC;
      Uwe_val_data += V1accu;
      Uwy_val_data += V2accu;
      Uwy_k_data += V2accu;
      meaniL_data  += I1accu;
      UwyI_data += V2accu;
 800d252:	e9cd 8912 	strd	r8, r9, [sp, #72]	; 0x48
      meaniH_data  += I2accu;
 800d256:	eb43 78e6 	adc.w	r8, r3, r6, asr #31
 800d25a:	463a      	mov	r2, r7
 800d25c:	4643      	mov	r3, r8
 800d25e:	e9c5 2300 	strd	r2, r3, [r5]
      UweI_data += V1accu;
 800d262:	4d99      	ldr	r5, [pc, #612]	; (800d4c8 <adcTask+0x49c>)
 800d264:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d268:	1886      	adds	r6, r0, r2
      Uwe_val_data += V1accu;
      Uwy_val_data += V2accu;
      Uwy_k_data += V2accu;
      meaniL_data  += I1accu;
      UwyI_data += V2accu;
      meaniH_data  += I2accu;
 800d26a:	e9cd 7814 	strd	r7, r8, [sp, #80]	; 0x50
      UweI_data += V1accu;
 800d26e:	eb41 0703 	adc.w	r7, r1, r3
 800d272:	4632      	mov	r2, r6
 800d274:	463b      	mov	r3, r7
 800d276:	e9c5 2300 	strd	r2, r3, [r5]

      Uwe_val_smpl += samplesNum;
 800d27a:	4a94      	ldr	r2, [pc, #592]	; (800d4cc <adcTask+0x4a0>)
      Uwy_val_smpl += samplesNum;
 800d27c:	4994      	ldr	r1, [pc, #592]	; (800d4d0 <adcTask+0x4a4>)
      meaniL_data  += I1accu;
      UwyI_data += V2accu;
      meaniH_data  += I2accu;
      UweI_data += V1accu;

      Uwe_val_smpl += samplesNum;
 800d27e:	6813      	ldr	r3, [r2, #0]
 800d280:	f603 233c 	addw	r3, r3, #2620	; 0xa3c
 800d284:	6013      	str	r3, [r2, #0]
      Uwy_val_smpl += samplesNum;
 800d286:	680a      	ldr	r2, [r1, #0]
 800d288:	f602 2a3c 	addw	sl, r2, #2620	; 0xa3c
 800d28c:	f8c1 a000 	str.w	sl, [r1]
      Uwy_k_smpl += samplesNum;
 800d290:	4990      	ldr	r1, [pc, #576]	; (800d4d4 <adcTask+0x4a8>)
      Uwy_val_data += V2accu;
      Uwy_k_data += V2accu;
      meaniL_data  += I1accu;
      UwyI_data += V2accu;
      meaniH_data  += I2accu;
      UweI_data += V1accu;
 800d292:	e9cd 6716 	strd	r6, r7, [sp, #88]	; 0x58

      Uwe_val_smpl += samplesNum;
      Uwy_val_smpl += samplesNum;
      Uwy_k_smpl += samplesNum;
 800d296:	680a      	ldr	r2, [r1, #0]
 800d298:	f602 293c 	addw	r9, r2, #2620	; 0xa3c
      meaniL_smpl  += samplesNum;
 800d29c:	4a8e      	ldr	r2, [pc, #568]	; (800d4d8 <adcTask+0x4ac>)
      meaniH_data  += I2accu;
      UweI_data += V1accu;

      Uwe_val_smpl += samplesNum;
      Uwy_val_smpl += samplesNum;
      Uwy_k_smpl += samplesNum;
 800d29e:	f8c1 9000 	str.w	r9, [r1]
      meaniL_smpl  += samplesNum;
 800d2a2:	6815      	ldr	r5, [r2, #0]
      UwyI_smpl += samplesNum;
      meaniH_smpl  += samplesNum;
      UweI_smpl += samplesNum;
 800d2a4:	498d      	ldr	r1, [pc, #564]	; (800d4dc <adcTask+0x4b0>)
      UweI_data += V1accu;

      Uwe_val_smpl += samplesNum;
      Uwy_val_smpl += samplesNum;
      Uwy_k_smpl += samplesNum;
      meaniL_smpl  += samplesNum;
 800d2a6:	f605 253c 	addw	r5, r5, #2620	; 0xa3c
 800d2aa:	6015      	str	r5, [r2, #0]
      UwyI_smpl += samplesNum;
 800d2ac:	4a8c      	ldr	r2, [pc, #560]	; (800d4e0 <adcTask+0x4b4>)
 800d2ae:	6816      	ldr	r6, [r2, #0]
 800d2b0:	f606 263c 	addw	r6, r6, #2620	; 0xa3c
 800d2b4:	6016      	str	r6, [r2, #0]
      meaniH_smpl  += samplesNum;
 800d2b6:	4a8b      	ldr	r2, [pc, #556]	; (800d4e4 <adcTask+0x4b8>)
 800d2b8:	6817      	ldr	r7, [r2, #0]
 800d2ba:	f607 273c 	addw	r7, r7, #2620	; 0xa3c
 800d2be:	6017      	str	r7, [r2, #0]
      UweI_smpl += samplesNum;
 800d2c0:	680a      	ldr	r2, [r1, #0]
 800d2c2:	f602 283c 	addw	r8, r2, #2620	; 0xa3c
 800d2c6:	f8c1 8000 	str.w	r8, [r1]
  return  getmV(data);
}

static int getAvgVmV(uint64_t data, int smpl)
{
  if(smpl)
 800d2ca:	469b      	mov	fp, r3
 800d2cc:	b18b      	cbz	r3, 800d2f2 <adcTask+0x2c6>
    {
      //Get average
      return getmV(data)/smpl;
 800d2ce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d2d0:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 800d2d4:	fba2 0103 	umull	r0, r1, r2, r3
 800d2d8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d2da:	fb03 1102 	mla	r1, r3, r2, r1
 800d2de:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d2e2:	2300      	movs	r3, #0
 800d2e4:	f006 fef6 	bl	80140d4 <__aeabi_uldivmod>
 800d2e8:	465a      	mov	r2, fp
 800d2ea:	17d3      	asrs	r3, r2, #31
 800d2ec:	f006 fef2 	bl	80140d4 <__aeabi_uldivmod>
 800d2f0:	4683      	mov	fp, r0
      meaniL_smpl  += samplesNum;
      UwyI_smpl += samplesNum;
      meaniH_smpl  += samplesNum;
      UweI_smpl += samplesNum;

      Uwe_val = getAvgVmV(Uwe_val_data, Uwe_val_smpl);
 800d2f2:	4b7d      	ldr	r3, [pc, #500]	; (800d4e8 <adcTask+0x4bc>)
 800d2f4:	f8c3 b000 	str.w	fp, [r3]
  return  getmV(data);
}

static int getAvgVmV(uint64_t data, int smpl)
{
  if(smpl)
 800d2f8:	f1ba 0f00 	cmp.w	sl, #0
 800d2fc:	d011      	beq.n	800d322 <adcTask+0x2f6>
    {
      //Get average
      return getmV(data)/smpl;
 800d2fe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800d300:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 800d304:	fba2 0103 	umull	r0, r1, r2, r3
 800d308:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d30a:	fb03 1102 	mla	r1, r3, r2, r1
 800d30e:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d312:	2300      	movs	r3, #0
 800d314:	f006 fede 	bl	80140d4 <__aeabi_uldivmod>
 800d318:	4652      	mov	r2, sl
 800d31a:	17d3      	asrs	r3, r2, #31
 800d31c:	f006 feda 	bl	80140d4 <__aeabi_uldivmod>
 800d320:	4682      	mov	sl, r0
      UwyI_smpl += samplesNum;
      meaniH_smpl  += samplesNum;
      UweI_smpl += samplesNum;

      Uwe_val = getAvgVmV(Uwe_val_data, Uwe_val_smpl);
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
 800d322:	4b72      	ldr	r3, [pc, #456]	; (800d4ec <adcTask+0x4c0>)
 800d324:	f8c3 a000 	str.w	sl, [r3]
  return  getmV(data);
}

static int getAvgVmV(uint64_t data, int smpl)
{
  if(smpl)
 800d328:	f1b9 0f00 	cmp.w	r9, #0
 800d32c:	d011      	beq.n	800d352 <adcTask+0x326>
    {
      //Get average
      return getmV(data)/smpl;
 800d32e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d330:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 800d334:	fba2 0103 	umull	r0, r1, r2, r3
 800d338:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d33a:	fb03 1102 	mla	r1, r3, r2, r1
 800d33e:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d342:	2300      	movs	r3, #0
 800d344:	f006 fec6 	bl	80140d4 <__aeabi_uldivmod>
 800d348:	464a      	mov	r2, r9
 800d34a:	17d3      	asrs	r3, r2, #31
 800d34c:	f006 fec2 	bl	80140d4 <__aeabi_uldivmod>
 800d350:	4681      	mov	r9, r0
      meaniH_smpl  += samplesNum;
      UweI_smpl += samplesNum;

      Uwe_val = getAvgVmV(Uwe_val_data, Uwe_val_smpl);
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
 800d352:	4b67      	ldr	r3, [pc, #412]	; (800d4f0 <adcTask+0x4c4>)
 800d354:	f8c3 9000 	str.w	r9, [r3]
  return  getmV(data);
}

static int getAvgVmV(uint64_t data, int smpl)
{
  if(smpl)
 800d358:	f1b8 0f00 	cmp.w	r8, #0
 800d35c:	d011      	beq.n	800d382 <adcTask+0x356>
    {
      //Get average
      return getmV(data)/smpl;
 800d35e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800d360:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 800d364:	fba2 0103 	umull	r0, r1, r2, r3
 800d368:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800d36a:	fb03 1102 	mla	r1, r3, r2, r1
 800d36e:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d372:	2300      	movs	r3, #0
 800d374:	f006 feae 	bl	80140d4 <__aeabi_uldivmod>
 800d378:	4642      	mov	r2, r8
 800d37a:	17d3      	asrs	r3, r2, #31
 800d37c:	f006 feaa 	bl	80140d4 <__aeabi_uldivmod>
 800d380:	4680      	mov	r8, r0
      UweI_smpl += samplesNum;

      Uwe_val = getAvgVmV(Uwe_val_data, Uwe_val_smpl);
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
 800d382:	4b5c      	ldr	r3, [pc, #368]	; (800d4f4 <adcTask+0x4c8>)
 800d384:	f8c3 8000 	str.w	r8, [r3]
  return 0;
}

static int getAvgImA(uint64_t data, int smpl)
{
  if(smpl)
 800d388:	b1ef      	cbz	r7, 800d3c6 <adcTask+0x39a>
    {
      //Get average and convert yo I
      return (int)((100ULL * getImV(data))/(uint64_t)(smpl*k10[kSensADC]));
 800d38a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800d38c:	f640 43e4 	movw	r3, #3300	; 0xce4
 800d390:	fba2 0103 	umull	r0, r1, r2, r3
 800d394:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800d396:	fb03 1102 	mla	r1, r3, r2, r1
 800d39a:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d39e:	2300      	movs	r3, #0
 800d3a0:	f006 fe98 	bl	80140d4 <__aeabi_uldivmod>
 800d3a4:	2364      	movs	r3, #100	; 0x64
 800d3a6:	fba0 8903 	umull	r8, r9, r0, r3
 800d3aa:	fb03 9901 	mla	r9, r3, r1, r9
 800d3ae:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d3b0:	4b51      	ldr	r3, [pc, #324]	; (800d4f8 <adcTask+0x4cc>)
 800d3b2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800d3b6:	4640      	mov	r0, r8
 800d3b8:	691a      	ldr	r2, [r3, #16]
 800d3ba:	437a      	muls	r2, r7
 800d3bc:	17d3      	asrs	r3, r2, #31
 800d3be:	4649      	mov	r1, r9
 800d3c0:	f006 fe88 	bl	80140d4 <__aeabi_uldivmod>
 800d3c4:	4607      	mov	r7, r0

      Uwe_val = getAvgVmV(Uwe_val_data, Uwe_val_smpl);
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
 800d3c6:	4b4d      	ldr	r3, [pc, #308]	; (800d4fc <adcTask+0x4d0>)
 800d3c8:	494d      	ldr	r1, [pc, #308]	; (800d500 <adcTask+0x4d4>)
 800d3ca:	f8d3 20c4 	ldr.w	r2, [r3, #196]	; 0xc4
 800d3ce:	1aba      	subs	r2, r7, r2
 800d3d0:	600a      	str	r2, [r1, #0]
 800d3d2:	461f      	mov	r7, r3
  return  getmV(data);
}

static int getAvgVmV(uint64_t data, int smpl)
{
  if(smpl)
 800d3d4:	b18e      	cbz	r6, 800d3fa <adcTask+0x3ce>
    {
      //Get average
      return getmV(data)/smpl;
 800d3d6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800d3d8:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 800d3dc:	fba2 0103 	umull	r0, r1, r2, r3
 800d3e0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d3e2:	fb03 1102 	mla	r1, r3, r2, r1
 800d3e6:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d3ea:	2300      	movs	r3, #0
 800d3ec:	f006 fe72 	bl	80140d4 <__aeabi_uldivmod>
 800d3f0:	4632      	mov	r2, r6
 800d3f2:	17f3      	asrs	r3, r6, #31
 800d3f4:	f006 fe6e 	bl	80140d4 <__aeabi_uldivmod>
 800d3f8:	4606      	mov	r6, r0
      Uwe_val = getAvgVmV(Uwe_val_data, Uwe_val_smpl);
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
 800d3fa:	4b42      	ldr	r3, [pc, #264]	; (800d504 <adcTask+0x4d8>)
 800d3fc:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 800d4f8 <adcTask+0x4cc>
 800d400:	601e      	str	r6, [r3, #0]
 800d402:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d404:	ea4f 0883 	mov.w	r8, r3, lsl #2
  return 0;
}

static int getAvgImA(uint64_t data, int smpl)
{
  if(smpl)
 800d408:	b1dd      	cbz	r5, 800d442 <adcTask+0x416>
    {
      //Get average and convert yo I
      return (int)((100ULL * getImV(data))/(uint64_t)(smpl*k10[kSensADC]));
 800d40a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800d40c:	f640 43e4 	movw	r3, #3300	; 0xce4
 800d410:	fba2 0103 	umull	r0, r1, r2, r3
 800d414:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800d416:	fb03 1102 	mla	r1, r3, r2, r1
 800d41a:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d41e:	2300      	movs	r3, #0
 800d420:	f006 fe58 	bl	80140d4 <__aeabi_uldivmod>
 800d424:	2364      	movs	r3, #100	; 0x64
 800d426:	fba0 ab03 	umull	sl, fp, r0, r3
 800d42a:	fb03 bb01 	mla	fp, r3, r1, fp
 800d42e:	eb09 0308 	add.w	r3, r9, r8
 800d432:	4650      	mov	r0, sl
 800d434:	691a      	ldr	r2, [r3, #16]
 800d436:	436a      	muls	r2, r5
 800d438:	17d3      	asrs	r3, r2, #31
 800d43a:	4659      	mov	r1, fp
 800d43c:	f006 fe4a 	bl	80140d4 <__aeabi_uldivmod>
 800d440:	4605      	mov	r5, r0
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d442:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
 800d446:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 800d44a:	f8d7 a0c0 	ldr.w	sl, [r7, #192]	; 0xc0
 800d44e:	17d3      	asrs	r3, r2, #31
 800d450:	fb86 0100 	smull	r0, r1, r6, r0
 800d454:	f006 fdee 	bl	8014034 <__aeabi_ldivmod>
 800d458:	4b2b      	ldr	r3, [pc, #172]	; (800d508 <adcTask+0x4dc>)
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d45a:	9904      	ldr	r1, [sp, #16]
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d45c:	1a28      	subs	r0, r5, r0
 800d45e:	ebca 0500 	rsb	r5, sl, r0
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d462:	f640 40e4 	movw	r0, #3300	; 0xce4
      Uwy_val = getAvgVmV(Uwy_val_data, Uwy_val_smpl);
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d466:	601d      	str	r5, [r3, #0]
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d468:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d46c:	2300      	movs	r3, #0
 800d46e:	fba1 0100 	umull	r0, r1, r1, r0
 800d472:	f006 fe2f 	bl	80140d4 <__aeabi_uldivmod>
  return 0;
}

static int getImA(uint64_t data)
{
  return (int)((100ULL * getImV(data))/(uint64_t)(k10[kSensADC]));
 800d476:	44c8      	add	r8, r9
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d478:	2364      	movs	r3, #100	; 0x64
 800d47a:	f8d8 2010 	ldr.w	r2, [r8, #16]
 800d47e:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
 800d482:	f8d7 a0bc 	ldr.w	sl, [r7, #188]	; 0xbc
 800d486:	f8d7 70c0 	ldr.w	r7, [r7, #192]	; 0xc0
 800d48a:	fba0 bc03 	umull	fp, ip, r0, r3
 800d48e:	fb03 cc01 	mla	ip, r3, r1, ip
 800d492:	4661      	mov	r1, ip
 800d494:	17d3      	asrs	r3, r2, #31
 800d496:	4658      	mov	r0, fp
 800d498:	f006 fe1c 	bl	80140d4 <__aeabi_uldivmod>
 800d49c:	4652      	mov	r2, sl
 800d49e:	17d3      	asrs	r3, r2, #31
 800d4a0:	4680      	mov	r8, r0
 800d4a2:	fb86 0105 	smull	r0, r1, r6, r5
 800d4a6:	f006 fdc5 	bl	8014034 <__aeabi_ldivmod>
 800d4aa:	e02f      	b.n	800d50c <adcTask+0x4e0>
 800d4ac:	2001ad64 	.word	0x2001ad64
 800d4b0:	2001ae40 	.word	0x2001ae40
 800d4b4:	2001ae70 	.word	0x2001ae70
 800d4b8:	2001ae10 	.word	0x2001ae10
 800d4bc:	2001ae30 	.word	0x2001ae30
 800d4c0:	2001ae78 	.word	0x2001ae78
 800d4c4:	2001ae88 	.word	0x2001ae88
 800d4c8:	2001ae20 	.word	0x2001ae20
 800d4cc:	2001ae38 	.word	0x2001ae38
 800d4d0:	2001ae60 	.word	0x2001ae60
 800d4d4:	2001ae28 	.word	0x2001ae28
 800d4d8:	2001ae3c 	.word	0x2001ae3c
 800d4dc:	2001ae18 	.word	0x2001ae18
 800d4e0:	2001ae5c 	.word	0x2001ae5c
 800d4e4:	2001ae90 	.word	0x2001ae90
 800d4e8:	2001ae68 	.word	0x2001ae68
 800d4ec:	2001ae48 	.word	0x2001ae48
 800d4f0:	2001ae64 	.word	0x2001ae64
 800d4f4:	2001ae6c 	.word	0x2001ae6c
 800d4f8:	0801d614 	.word	0x0801d614
 800d4fc:	10001000 	.word	0x10001000
 800d500:	2001ae80 	.word	0x2001ae80
 800d504:	2001ae4c 	.word	0x2001ae4c
 800d508:	2001ae58 	.word	0x2001ae58
      if(sMaxiL < newMaxiL)
 800d50c:	4b13      	ldr	r3, [pc, #76]	; (800d55c <adcTask+0x530>)
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d50e:	ebc0 0008 	rsb	r0, r0, r8
      if(sMaxiL < newMaxiL)
 800d512:	681a      	ldr	r2, [r3, #0]
      Uwy_k = getAvgVmV(Uwy_k_data, Uwy_k_smpl);
      UweI = getAvgVmV(UweI_data, UweI_smpl);
      meaniH  = getAvgImA(meaniH_data, meaniH_smpl) - cfg.c;
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
 800d514:	1bc7      	subs	r7, r0, r7
      if(sMaxiL < newMaxiL)
 800d516:	4297      	cmp	r7, r2
 800d518:	dd0b      	ble.n	800d532 <adcTask+0x506>
        {
          sMaxiL  = newMaxiL;
          sMaxvL  = getVmV(V2I1max);
 800d51a:	f649 20b0 	movw	r0, #39600	; 0x9ab0
      UwyI = getAvgVmV(UwyI_data, UwyI_smpl);
      meaniL  = getAvgImA(meaniL_data, meaniL_smpl) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
      int newMaxiL = getImA(I1max) - (int)(((int64_t)UwyI*(int64_t)cfg.a_nom)/(int64_t)cfg.a_den) - cfg.b;
      if(sMaxiL < newMaxiL)
        {
          sMaxiL  = newMaxiL;
 800d51e:	601f      	str	r7, [r3, #0]
          sMaxvL  = getVmV(V2I1max);
 800d520:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d524:	2300      	movs	r3, #0
 800d526:	fba4 0100 	umull	r0, r1, r4, r0
 800d52a:	f006 fdd3 	bl	80140d4 <__aeabi_uldivmod>
 800d52e:	4b0c      	ldr	r3, [pc, #48]	; (800d560 <adcTask+0x534>)
 800d530:	6018      	str	r0, [r3, #0]
        }
      taskEXIT_CRITICAL();
 800d532:	f7fc fe11 	bl	800a158 <vPortExitCritical>

      //Send result to the Communicator
      messageADCMeasure((SAMPLES_PER_ADC_FREQ * measureNum), sensADC,
 800d536:	9b08      	ldr	r3, [sp, #32]
 800d538:	9303      	str	r3, [sp, #12]
 800d53a:	9b07      	ldr	r3, [sp, #28]
 800d53c:	9302      	str	r3, [sp, #8]
 800d53e:	4909      	ldr	r1, [pc, #36]	; (800d564 <adcTask+0x538>)
 800d540:	9b04      	ldr	r3, [sp, #16]
 800d542:	9300      	str	r3, [sp, #0]
 800d544:	9401      	str	r4, [sp, #4]
 800d546:	9b06      	ldr	r3, [sp, #24]
 800d548:	9a05      	ldr	r2, [sp, #20]
 800d54a:	6849      	ldr	r1, [r1, #4]
 800d54c:	f640 203c 	movw	r0, #2620	; 0xa3c
 800d550:	f7fd ff08 	bl	800b364 <messageADCMeasure>
                        I1max, V2I1max, I1accu, I2accu);

      //All measures but first are for ADC_WINDOW time
      measures_per_message = ADC_WINDOW / ADC_FREQ;
#ifdef WATCHDOG_ADC
      wdogFeed(WATCHDOG_ADC(0));
 800d554:	2010      	movs	r0, #16
 800d556:	f001 fc43 	bl	800ede0 <wdogFeed>
#endif
    }
 800d55a:	e577      	b.n	800d04c <adcTask+0x20>
 800d55c:	2001ae1c 	.word	0x2001ae1c
 800d560:	2001ae54 	.word	0x2001ae54
 800d564:	2001ad64 	.word	0x2001ad64

0800d568 <ADCInit>:
#endif
    }
}

void ADCInit(void)
{
 800d568:	b530      	push	{r4, r5, lr}
  if(!(cfg.proto&0x01))
 800d56a:	4b1d      	ldr	r3, [pc, #116]	; (800d5e0 <ADCInit+0x78>)
 800d56c:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 800d56e:	f014 0401 	ands.w	r4, r4, #1
#endif
    }
}

void ADCInit(void)
{
 800d572:	b087      	sub	sp, #28
  if(!(cfg.proto&0x01))
 800d574:	d11a      	bne.n	800d5ac <ADCInit+0x44>
    {
      ADC_hwInit();

      //Create the task
      massert(xTaskCreate(adcTask, (signed char *)"ADC", 0x1000 / 4, NULL, 1, NULL) == pdPASS);
 800d576:	2501      	movs	r5, #1

void ADCInit(void)
{
  if(!(cfg.proto&0x01))
    {
      ADC_hwInit();
 800d578:	f000 fd3e 	bl	800dff8 <ADC_hwInit>

      //Create the task
      massert(xTaskCreate(adcTask, (signed char *)"ADC", 0x1000 / 4, NULL, 1, NULL) == pdPASS);
 800d57c:	9403      	str	r4, [sp, #12]
 800d57e:	9402      	str	r4, [sp, #8]
 800d580:	9401      	str	r4, [sp, #4]
 800d582:	9500      	str	r5, [sp, #0]
 800d584:	4623      	mov	r3, r4
 800d586:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800d58a:	4916      	ldr	r1, [pc, #88]	; (800d5e4 <ADCInit+0x7c>)
 800d58c:	4816      	ldr	r0, [pc, #88]	; (800d5e8 <ADCInit+0x80>)
 800d58e:	f7fc ff8b 	bl	800a4a8 <xTaskGenericCreate>
 800d592:	42a8      	cmp	r0, r5
 800d594:	d022      	beq.n	800d5dc <ADCInit+0x74>
 800d596:	4b15      	ldr	r3, [pc, #84]	; (800d5ec <ADCInit+0x84>)
 800d598:	4915      	ldr	r1, [pc, #84]	; (800d5f0 <ADCInit+0x88>)
 800d59a:	4816      	ldr	r0, [pc, #88]	; (800d5f4 <ADCInit+0x8c>)
 800d59c:	22c7      	movs	r2, #199	; 0xc7
 800d59e:	f7fb f8e1 	bl	8008764 <xprintf>
 800d5a2:	9504      	str	r5, [sp, #16]
 800d5a4:	9b04      	ldr	r3, [sp, #16]
 800d5a6:	2b00      	cmp	r3, #0
 800d5a8:	d1fc      	bne.n	800d5a4 <ADCInit+0x3c>
 800d5aa:	e017      	b.n	800d5dc <ADCInit+0x74>
    }
  else
    {
      massert(xTaskCreate(adcProtoTask, (signed char *)"ADC", 0x1000 / 4, NULL, 1, NULL) == pdPASS);
 800d5ac:	2300      	movs	r3, #0
 800d5ae:	2401      	movs	r4, #1
 800d5b0:	9303      	str	r3, [sp, #12]
 800d5b2:	9302      	str	r3, [sp, #8]
 800d5b4:	9301      	str	r3, [sp, #4]
 800d5b6:	9400      	str	r4, [sp, #0]
 800d5b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800d5bc:	4909      	ldr	r1, [pc, #36]	; (800d5e4 <ADCInit+0x7c>)
 800d5be:	480e      	ldr	r0, [pc, #56]	; (800d5f8 <ADCInit+0x90>)
 800d5c0:	f7fc ff72 	bl	800a4a8 <xTaskGenericCreate>
 800d5c4:	42a0      	cmp	r0, r4
 800d5c6:	d009      	beq.n	800d5dc <ADCInit+0x74>
 800d5c8:	4b0c      	ldr	r3, [pc, #48]	; (800d5fc <ADCInit+0x94>)
 800d5ca:	4909      	ldr	r1, [pc, #36]	; (800d5f0 <ADCInit+0x88>)
 800d5cc:	4809      	ldr	r0, [pc, #36]	; (800d5f4 <ADCInit+0x8c>)
 800d5ce:	22cb      	movs	r2, #203	; 0xcb
 800d5d0:	f7fb f8c8 	bl	8008764 <xprintf>
 800d5d4:	9405      	str	r4, [sp, #20]
 800d5d6:	9b05      	ldr	r3, [sp, #20]
 800d5d8:	2b00      	cmp	r3, #0
 800d5da:	d1fc      	bne.n	800d5d6 <ADCInit+0x6e>
    }
}
 800d5dc:	b007      	add	sp, #28
 800d5de:	bd30      	pop	{r4, r5, pc}
 800d5e0:	10001000 	.word	0x10001000
 800d5e4:	0801d66d 	.word	0x0801d66d
 800d5e8:	0800d02d 	.word	0x0800d02d
 800d5ec:	0801d671 	.word	0x0801d671
 800d5f0:	0801d62c 	.word	0x0801d62c
 800d5f4:	080148f4 	.word	0x080148f4
 800d5f8:	0800d01d 	.word	0x0800d01d
 800d5fc:	0801d6c1 	.word	0x0801d6c1

0800d600 <bAdd>:
#define bEnterCS(...) taskENTER_CRITICAL()
#define bExitCS(...)  taskEXIT_CRITICAL()

void bAdd(bBuffer_t **first, bBuffer_t *buf)
{
  buf->next = *first;
 800d600:	6803      	ldr	r3, [r0, #0]
 800d602:	610b      	str	r3, [r1, #16]
  *first = buf;
 800d604:	6001      	str	r1, [r0, #0]
 800d606:	4770      	bx	lr

0800d608 <bRemove>:
}

void bRemove(bBuffer_t **first, bBuffer_t *buf)
{
  if (*first == buf)
 800d608:	6803      	ldr	r3, [r0, #0]
 800d60a:	428b      	cmp	r3, r1
 800d60c:	d108      	bne.n	800d620 <bRemove+0x18>
    {
      *first = buf->next;
 800d60e:	691a      	ldr	r2, [r3, #16]
 800d610:	6002      	str	r2, [r0, #0]
      buf->next = NULL;
 800d612:	2200      	movs	r2, #0
 800d614:	611a      	str	r2, [r3, #16]
 800d616:	4770      	bx	lr
    }
  else
    {
      bBuffer_t *prev = *first;
      while (prev && prev->next != buf)
 800d618:	691a      	ldr	r2, [r3, #16]
 800d61a:	4291      	cmp	r1, r2
 800d61c:	d003      	beq.n	800d626 <bRemove+0x1e>
 800d61e:	4613      	mov	r3, r2
 800d620:	2b00      	cmp	r3, #0
 800d622:	d1f9      	bne.n	800d618 <bRemove+0x10>
 800d624:	e003      	b.n	800d62e <bRemove+0x26>
        prev = prev->next;
      if (prev)
        {
          prev->next = buf->next;
 800d626:	690a      	ldr	r2, [r1, #16]
 800d628:	611a      	str	r2, [r3, #16]
          buf->next = NULL;
 800d62a:	2300      	movs	r3, #0
 800d62c:	610b      	str	r3, [r1, #16]
 800d62e:	4770      	bx	lr

0800d630 <bAlloc>:
unsigned int heapLastSize  = 0;
bBuffer_t __attribute__((optimize("-O4"))) *bAlloc(int size)
{
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
 800d630:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
unsigned int heapAllocs    = 0;
unsigned int heapFrees     = 0;
unsigned int heapAllocated = 0;
unsigned int heapLastSize  = 0;
bBuffer_t __attribute__((optimize("-O4"))) *bAlloc(int size)
{
 800d634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d636:	4605      	mov	r5, r0
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
 800d638:	f000 80d3 	beq.w	800d7e2 <bAlloc+0x1b2>
 800d63c:	dc24      	bgt.n	800d688 <bAlloc+0x58>
 800d63e:	2801      	cmp	r0, #1
 800d640:	db51      	blt.n	800d6e6 <bAlloc+0xb6>
 800d642:	2820      	cmp	r0, #32
 800d644:	dd69      	ble.n	800d71a <bAlloc+0xea>
 800d646:	28c0      	cmp	r0, #192	; 0xc0
 800d648:	dc4d      	bgt.n	800d6e6 <bAlloc+0xb6>
bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
 800d64a:	4eb8      	ldr	r6, [pc, #736]	; (800d92c <bAlloc+0x2fc>)

bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
 800d64c:	f7fc fd72 	bl	800a134 <vPortEnterCritical>
  if (queue->refilling)
 800d650:	f896 304f 	ldrb.w	r3, [r6, #79]	; 0x4f
 800d654:	061a      	lsls	r2, r3, #24
 800d656:	f140 80ef 	bpl.w	800d838 <bAlloc+0x208>
    {
      if (queue->refillCount < queue->count)
 800d65a:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 800d65c:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
 800d65e:	f342 021e 	sbfx	r2, r2, #0, #31
 800d662:	428a      	cmp	r2, r1
 800d664:	f0c0 80e1 	bcc.w	800d82a <bAlloc+0x1fa>
          if (queue->refillCount > queue->count)
            queue->refilling = 1;
        }
    }
  else
    queue->empty++;
 800d668:	6e33      	ldr	r3, [r6, #96]	; 0x60
 800d66a:	3301      	adds	r3, #1
 800d66c:	6633      	str	r3, [r6, #96]	; 0x60

  bExitCS();
 800d66e:	f7fc fd73 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d672:	6d33      	ldr	r3, [r6, #80]	; 0x50
 800d674:	4aad      	ldr	r2, [pc, #692]	; (800d92c <bAlloc+0x2fc>)
 800d676:	2b00      	cmp	r3, #0
 800d678:	f000 8214 	beq.w	800daa4 <bAlloc+0x474>
 800d67c:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800d67e:	2a00      	cmp	r2, #0
 800d680:	f040 821e 	bne.w	800dac0 <bAlloc+0x490>
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
 800d684:	23c0      	movs	r3, #192	; 0xc0
 800d686:	e02a      	b.n	800d6de <bAlloc+0xae>
unsigned int heapLastSize  = 0;
bBuffer_t __attribute__((optimize("-O4"))) *bAlloc(int size)
{
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
 800d688:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 800d68c:	dd7d      	ble.n	800d78a <bAlloc+0x15a>
 800d68e:	f5b0 6f04 	cmp.w	r0, #2112	; 0x840
 800d692:	dc28      	bgt.n	800d6e6 <bAlloc+0xb6>
bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
 800d694:	4ea5      	ldr	r6, [pc, #660]	; (800d92c <bAlloc+0x2fc>)

bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
 800d696:	f7fc fd4d 	bl	800a134 <vPortEnterCritical>
  if (queue->refilling)
 800d69a:	f896 30eb 	ldrb.w	r3, [r6, #235]	; 0xeb
 800d69e:	061a      	lsls	r2, r3, #24
 800d6a0:	f140 80f0 	bpl.w	800d884 <bAlloc+0x254>
    {
      if (queue->refillCount < queue->count)
 800d6a4:	f8d6 20e8 	ldr.w	r2, [r6, #232]	; 0xe8
 800d6a8:	f8d6 10d8 	ldr.w	r1, [r6, #216]	; 0xd8
 800d6ac:	f342 021e 	sbfx	r2, r2, #0, #31
 800d6b0:	428a      	cmp	r2, r1
 800d6b2:	f0c0 80e0 	bcc.w	800d876 <bAlloc+0x246>
          if (queue->refillCount > queue->count)
            queue->refilling = 1;
        }
    }
  else
    queue->empty++;
 800d6b6:	f8d6 30fc 	ldr.w	r3, [r6, #252]	; 0xfc
 800d6ba:	3301      	adds	r3, #1
 800d6bc:	f8c6 30fc 	str.w	r3, [r6, #252]	; 0xfc

  bExitCS();
 800d6c0:	f7fc fd4a 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d6c4:	f8d6 30ec 	ldr.w	r3, [r6, #236]	; 0xec
 800d6c8:	4a98      	ldr	r2, [pc, #608]	; (800d92c <bAlloc+0x2fc>)
 800d6ca:	2b00      	cmp	r3, #0
 800d6cc:	f000 8201 	beq.w	800dad2 <bAlloc+0x4a2>
 800d6d0:	f8d2 20e0 	ldr.w	r2, [r2, #224]	; 0xe0
 800d6d4:	2a00      	cmp	r2, #0
 800d6d6:	f040 81ed 	bne.w	800dab4 <bAlloc+0x484>
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
      ALLOC_BUFFER(513, 1024);
      ALLOC_BUFFER(1025,2112);
 800d6da:	f44f 6304 	mov.w	r3, #2112	; 0x840
 800d6de:	461e      	mov	r6, r3
 800d6e0:	f103 0014 	add.w	r0, r3, #20
 800d6e4:	e002      	b.n	800d6ec <bAlloc+0xbc>
 800d6e6:	462e      	mov	r6, r5
 800d6e8:	f105 0014 	add.w	r0, r5, #20
    }
  if (!buffer)
    {
      //No suitable buffer on queue. Alloc from heap
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
 800d6ec:	f7fa feb9 	bl	8008462 <intSafeMalloc>
      if (buffer)
 800d6f0:	4604      	mov	r4, r0
 800d6f2:	2800      	cmp	r0, #0
 800d6f4:	f000 8165 	beq.w	800d9c2 <bAlloc+0x392>
        memset(buffer, 0x00, alloc_size);
      heapLastSize = alloc_size;
 800d6f8:	4f8d      	ldr	r7, [pc, #564]	; (800d930 <bAlloc+0x300>)
  if (!buffer)
    {
      //No suitable buffer on queue. Alloc from heap
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
      if (buffer)
        memset(buffer, 0x00, alloc_size);
 800d6fa:	4632      	mov	r2, r6
 800d6fc:	2100      	movs	r1, #0
 800d6fe:	f006 ff41 	bl	8014584 <memset>
      heapLastSize = alloc_size;
 800d702:	603e      	str	r6, [r7, #0]
      bEnterCS();
 800d704:	f7fc fd16 	bl	800a134 <vPortEnterCritical>
      heapAllocs++;
 800d708:	687a      	ldr	r2, [r7, #4]
      heapAllocated++;
 800d70a:	68bb      	ldr	r3, [r7, #8]
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
      if (buffer)
        memset(buffer, 0x00, alloc_size);
      heapLastSize = alloc_size;
      bEnterCS();
      heapAllocs++;
 800d70c:	3201      	adds	r2, #1
      heapAllocated++;
 800d70e:	3301      	adds	r3, #1
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
      if (buffer)
        memset(buffer, 0x00, alloc_size);
      heapLastSize = alloc_size;
      bEnterCS();
      heapAllocs++;
 800d710:	607a      	str	r2, [r7, #4]
      heapAllocated++;
 800d712:	60bb      	str	r3, [r7, #8]
      bExitCS();
 800d714:	f7fc fd20 	bl	800a158 <vPortExitCritical>
 800d718:	e024      	b.n	800d764 <bAlloc+0x134>
bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
 800d71a:	4e84      	ldr	r6, [pc, #528]	; (800d92c <bAlloc+0x2fc>)

bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
 800d71c:	f7fc fd0a 	bl	800a134 <vPortEnterCritical>
  if (queue->refilling)
 800d720:	7ef3      	ldrb	r3, [r6, #27]
 800d722:	0618      	lsls	r0, r3, #24
 800d724:	f100 8132 	bmi.w	800d98c <bAlloc+0x35c>
 800d728:	68b0      	ldr	r0, [r6, #8]
        queue->refilling = 0;
    }

  if (!queue->refilling)
    {
      buffer = queue->head;
 800d72a:	6834      	ldr	r4, [r6, #0]
 800d72c:	4f7f      	ldr	r7, [pc, #508]	; (800d92c <bAlloc+0x2fc>)
      if (buffer)
 800d72e:	2c00      	cmp	r4, #0
 800d730:	f000 8154 	beq.w	800d9dc <bAlloc+0x3ac>
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
 800d734:	2300      	movs	r3, #0
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d736:	6922      	ldr	r2, [r4, #16]
          buffer->next = NULL;
 800d738:	6123      	str	r3, [r4, #16]
          count = --queue->count;
          queue->dequeues++;
 800d73a:	6a3b      	ldr	r3, [r7, #32]
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d73c:	603a      	str	r2, [r7, #0]
          buffer->next = NULL;
          count = --queue->count;
          queue->dequeues++;
 800d73e:	3301      	adds	r3, #1
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d740:	1e46      	subs	r6, r0, #1
          queue->dequeues++;
 800d742:	623b      	str	r3, [r7, #32]
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d744:	60be      	str	r6, [r7, #8]
        }
    }
  else
    queue->empty++;

  bExitCS();
 800d746:	f7fc fd07 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d74a:	69fb      	ldr	r3, [r7, #28]
 800d74c:	b153      	cbz	r3, 800d764 <bAlloc+0x134>
 800d74e:	693a      	ldr	r2, [r7, #16]
 800d750:	4296      	cmp	r6, r2
 800d752:	d302      	bcc.n	800d75a <bAlloc+0x12a>
 800d754:	697a      	ldr	r2, [r7, #20]
 800d756:	4296      	cmp	r6, r2
 800d758:	d904      	bls.n	800d764 <bAlloc+0x134>
    queue->callback(count);
 800d75a:	4630      	mov	r0, r6
 800d75c:	4798      	blx	r3
{
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
 800d75e:	2320      	movs	r3, #32
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
      ALLOC_BUFFER(513, 1024);
      ALLOC_BUFFER(1025,2112);
    }
  if (!buffer)
 800d760:	2c00      	cmp	r4, #0
 800d762:	d0bc      	beq.n	800d6de <bAlloc+0xae>
      heapAllocated++;
      bExitCS();
    }
  if (buffer)
    {
      if(cfg.empty_buffers)
 800d764:	4b73      	ldr	r3, [pc, #460]	; (800d934 <bAlloc+0x304>)
 800d766:	699b      	ldr	r3, [r3, #24]
 800d768:	b943      	cbnz	r3, 800d77c <bAlloc+0x14c>
        memset(buffer->data, 0, size);
      buffer->maxSize = size;
      buffer->size = 0;
 800d76a:	2300      	movs	r3, #0
      buffer->offset = 0;
      buffer->ref = 1;
 800d76c:	2201      	movs	r2, #1
    }
  if (buffer)
    {
      if(cfg.empty_buffers)
        memset(buffer->data, 0, size);
      buffer->maxSize = size;
 800d76e:	8065      	strh	r5, [r4, #2]
      buffer->size = 0;
 800d770:	8023      	strh	r3, [r4, #0]
      buffer->offset = 0;
 800d772:	80a3      	strh	r3, [r4, #4]
      buffer->ref = 1;
      buffer->next = NULL;
 800d774:	6123      	str	r3, [r4, #16]
      if(cfg.empty_buffers)
        memset(buffer->data, 0, size);
      buffer->maxSize = size;
      buffer->size = 0;
      buffer->offset = 0;
      buffer->ref = 1;
 800d776:	80e2      	strh	r2, [r4, #6]
      buffer->next = NULL;
    }
  return buffer;
}
 800d778:	4620      	mov	r0, r4
 800d77a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      bExitCS();
    }
  if (buffer)
    {
      if(cfg.empty_buffers)
        memset(buffer->data, 0, size);
 800d77c:	462a      	mov	r2, r5
 800d77e:	2100      	movs	r1, #0
 800d780:	f104 0014 	add.w	r0, r4, #20
 800d784:	f006 fefe 	bl	8014584 <memset>
 800d788:	e7ef      	b.n	800d76a <bAlloc+0x13a>
bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
 800d78a:	4e68      	ldr	r6, [pc, #416]	; (800d92c <bAlloc+0x2fc>)

bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
 800d78c:	f7fc fcd2 	bl	800a134 <vPortEnterCritical>
  if (queue->refilling)
 800d790:	f896 30b7 	ldrb.w	r3, [r6, #183]	; 0xb7
 800d794:	0618      	lsls	r0, r3, #24
 800d796:	f140 809f 	bpl.w	800d8d8 <bAlloc+0x2a8>
    {
      if (queue->refillCount < queue->count)
 800d79a:	f8d6 20b4 	ldr.w	r2, [r6, #180]	; 0xb4
 800d79e:	f8d6 10a4 	ldr.w	r1, [r6, #164]	; 0xa4
 800d7a2:	f342 021e 	sbfx	r2, r2, #0, #31
 800d7a6:	428a      	cmp	r2, r1
 800d7a8:	d206      	bcs.n	800d7b8 <bAlloc+0x188>
        queue->refilling = 0;
 800d7aa:	f36f 13c7 	bfc	r3, #7, #1
    }

  if (!queue->refilling)
 800d7ae:	0619      	lsls	r1, r3, #24
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d7b0:	f886 30b7 	strb.w	r3, [r6, #183]	; 0xb7
    }

  if (!queue->refilling)
 800d7b4:	f140 8090 	bpl.w	800d8d8 <bAlloc+0x2a8>
          if (queue->refillCount > queue->count)
            queue->refilling = 1;
        }
    }
  else
    queue->empty++;
 800d7b8:	f8d6 30c8 	ldr.w	r3, [r6, #200]	; 0xc8
 800d7bc:	3301      	adds	r3, #1
 800d7be:	f8c6 30c8 	str.w	r3, [r6, #200]	; 0xc8

  bExitCS();
 800d7c2:	f7fc fcc9 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d7c6:	f8d6 30b8 	ldr.w	r3, [r6, #184]	; 0xb8
 800d7ca:	4a58      	ldr	r2, [pc, #352]	; (800d92c <bAlloc+0x2fc>)
 800d7cc:	2b00      	cmp	r3, #0
 800d7ce:	f000 816c 	beq.w	800daaa <bAlloc+0x47a>
 800d7d2:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 800d7d6:	2a00      	cmp	r2, #0
 800d7d8:	f040 816f 	bne.w	800daba <bAlloc+0x48a>
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
      ALLOC_BUFFER(513, 1024);
 800d7dc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800d7e0:	e77d      	b.n	800d6de <bAlloc+0xae>
bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
 800d7e2:	4e52      	ldr	r6, [pc, #328]	; (800d92c <bAlloc+0x2fc>)

bBuffer_t __attribute__((optimize("-O4"))) *bDequeue(bQueue_t *queue)
{
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
 800d7e4:	f7fc fca6 	bl	800a134 <vPortEnterCritical>
  if (queue->refilling)
 800d7e8:	f896 3083 	ldrb.w	r3, [r6, #131]	; 0x83
 800d7ec:	061f      	lsls	r7, r3, #24
 800d7ee:	f140 80aa 	bpl.w	800d946 <bAlloc+0x316>
    {
      if (queue->refillCount < queue->count)
 800d7f2:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
 800d7f6:	6f31      	ldr	r1, [r6, #112]	; 0x70
 800d7f8:	f342 021e 	sbfx	r2, r2, #0, #31
 800d7fc:	428a      	cmp	r2, r1
 800d7fe:	f0c0 809b 	bcc.w	800d938 <bAlloc+0x308>
          if (queue->refillCount > queue->count)
            queue->refilling = 1;
        }
    }
  else
    queue->empty++;
 800d802:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 800d806:	3301      	adds	r3, #1
 800d808:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94

  bExitCS();
 800d80c:	f7fc fca4 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d810:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 800d814:	4a45      	ldr	r2, [pc, #276]	; (800d92c <bAlloc+0x2fc>)
 800d816:	2b00      	cmp	r3, #0
 800d818:	f000 813c 	beq.w	800da94 <bAlloc+0x464>
 800d81c:	6f92      	ldr	r2, [r2, #120]	; 0x78
 800d81e:	2a00      	cmp	r2, #0
 800d820:	f040 8151 	bne.w	800dac6 <bAlloc+0x496>
  int alloc_size = size;
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
 800d824:	f44f 7300 	mov.w	r3, #512	; 0x200
 800d828:	e759      	b.n	800d6de <bAlloc+0xae>
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d82a:	f36f 13c7 	bfc	r3, #7, #1
 800d82e:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
    }

  if (!queue->refilling)
 800d832:	061b      	lsls	r3, r3, #24
 800d834:	f53f af18 	bmi.w	800d668 <bAlloc+0x38>
    {
      buffer = queue->head;
 800d838:	6b74      	ldr	r4, [r6, #52]	; 0x34
 800d83a:	4f3c      	ldr	r7, [pc, #240]	; (800d92c <bAlloc+0x2fc>)
      if (buffer)
 800d83c:	2c00      	cmp	r4, #0
 800d83e:	f000 80da 	beq.w	800d9f6 <bAlloc+0x3c6>
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
 800d842:	2300      	movs	r3, #0
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d844:	6922      	ldr	r2, [r4, #16]
          buffer->next = NULL;
 800d846:	6123      	str	r3, [r4, #16]
          count = --queue->count;
          queue->dequeues++;
 800d848:	6d7b      	ldr	r3, [r7, #84]	; 0x54
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d84a:	6bfe      	ldr	r6, [r7, #60]	; 0x3c
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d84c:	637a      	str	r2, [r7, #52]	; 0x34
          buffer->next = NULL;
          count = --queue->count;
          queue->dequeues++;
 800d84e:	3301      	adds	r3, #1
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d850:	3e01      	subs	r6, #1
          queue->dequeues++;
 800d852:	657b      	str	r3, [r7, #84]	; 0x54
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d854:	63fe      	str	r6, [r7, #60]	; 0x3c
        }
    }
  else
    queue->empty++;

  bExitCS();
 800d856:	f7fc fc7f 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d85a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d85c:	2b00      	cmp	r3, #0
 800d85e:	d081      	beq.n	800d764 <bAlloc+0x134>
 800d860:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800d862:	4296      	cmp	r6, r2
 800d864:	d303      	bcc.n	800d86e <bAlloc+0x23e>
 800d866:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800d868:	4296      	cmp	r6, r2
 800d86a:	f67f af7b 	bls.w	800d764 <bAlloc+0x134>
    queue->callback(count);
 800d86e:	4630      	mov	r0, r6
 800d870:	4798      	blx	r3
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
 800d872:	23c0      	movs	r3, #192	; 0xc0
 800d874:	e774      	b.n	800d760 <bAlloc+0x130>
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d876:	f36f 13c7 	bfc	r3, #7, #1
 800d87a:	f886 30eb 	strb.w	r3, [r6, #235]	; 0xeb
    }

  if (!queue->refilling)
 800d87e:	061b      	lsls	r3, r3, #24
 800d880:	f53f af19 	bmi.w	800d6b6 <bAlloc+0x86>
    {
      buffer = queue->head;
 800d884:	f8d6 40d0 	ldr.w	r4, [r6, #208]	; 0xd0
 800d888:	4f28      	ldr	r7, [pc, #160]	; (800d92c <bAlloc+0x2fc>)
      if (buffer)
 800d88a:	2c00      	cmp	r4, #0
 800d88c:	f000 80ed 	beq.w	800da6a <bAlloc+0x43a>
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
 800d890:	2300      	movs	r3, #0
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d892:	6922      	ldr	r2, [r4, #16]
          buffer->next = NULL;
 800d894:	6123      	str	r3, [r4, #16]
          count = --queue->count;
          queue->dequeues++;
 800d896:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d89a:	f8d7 60d8 	ldr.w	r6, [r7, #216]	; 0xd8
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d89e:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
          buffer->next = NULL;
          count = --queue->count;
          queue->dequeues++;
 800d8a2:	3301      	adds	r3, #1
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d8a4:	3e01      	subs	r6, #1
          queue->dequeues++;
 800d8a6:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d8aa:	f8c7 60d8 	str.w	r6, [r7, #216]	; 0xd8
        }
    }
  else
    queue->empty++;

  bExitCS();
 800d8ae:	f7fc fc53 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d8b2:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800d8b6:	2b00      	cmp	r3, #0
 800d8b8:	f43f af54 	beq.w	800d764 <bAlloc+0x134>
 800d8bc:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800d8c0:	4296      	cmp	r6, r2
 800d8c2:	d304      	bcc.n	800d8ce <bAlloc+0x29e>
 800d8c4:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 800d8c8:	4296      	cmp	r6, r2
 800d8ca:	f67f af4b 	bls.w	800d764 <bAlloc+0x134>
    queue->callback(count);
 800d8ce:	4630      	mov	r0, r6
 800d8d0:	4798      	blx	r3
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
      ALLOC_BUFFER(513, 1024);
      ALLOC_BUFFER(1025,2112);
 800d8d2:	f44f 6304 	mov.w	r3, #2112	; 0x840
 800d8d6:	e743      	b.n	800d760 <bAlloc+0x130>
        queue->refilling = 0;
    }

  if (!queue->refilling)
    {
      buffer = queue->head;
 800d8d8:	f8d6 409c 	ldr.w	r4, [r6, #156]	; 0x9c
 800d8dc:	4f13      	ldr	r7, [pc, #76]	; (800d92c <bAlloc+0x2fc>)
      if (buffer)
 800d8de:	2c00      	cmp	r4, #0
 800d8e0:	f000 80ae 	beq.w	800da40 <bAlloc+0x410>
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
 800d8e4:	2300      	movs	r3, #0
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d8e6:	6922      	ldr	r2, [r4, #16]
          buffer->next = NULL;
 800d8e8:	6123      	str	r3, [r4, #16]
          count = --queue->count;
          queue->dequeues++;
 800d8ea:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d8ee:	f8d7 60a4 	ldr.w	r6, [r7, #164]	; 0xa4
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d8f2:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
          buffer->next = NULL;
          count = --queue->count;
          queue->dequeues++;
 800d8f6:	3301      	adds	r3, #1
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d8f8:	3e01      	subs	r6, #1
          queue->dequeues++;
 800d8fa:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d8fe:	f8c7 60a4 	str.w	r6, [r7, #164]	; 0xa4
        }
    }
  else
    queue->empty++;

  bExitCS();
 800d902:	f7fc fc29 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d906:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800d90a:	2b00      	cmp	r3, #0
 800d90c:	f43f af2a 	beq.w	800d764 <bAlloc+0x134>
 800d910:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 800d914:	4296      	cmp	r6, r2
 800d916:	d304      	bcc.n	800d922 <bAlloc+0x2f2>
 800d918:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800d91c:	4296      	cmp	r6, r2
 800d91e:	f67f af21 	bls.w	800d764 <bAlloc+0x134>
    queue->callback(count);
 800d922:	4630      	mov	r0, r6
 800d924:	4798      	blx	r3
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
      ALLOC_BUFFER(513, 1024);
 800d926:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800d92a:	e719      	b.n	800d760 <bAlloc+0x130>
 800d92c:	2001a978 	.word	0x2001a978
 800d930:	2001ad74 	.word	0x2001ad74
 800d934:	10001000 	.word	0x10001000
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d938:	f36f 13c7 	bfc	r3, #7, #1
    }

  if (!queue->refilling)
 800d93c:	061c      	lsls	r4, r3, #24
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d93e:	f886 3083 	strb.w	r3, [r6, #131]	; 0x83
    }

  if (!queue->refilling)
 800d942:	f53f af5e 	bmi.w	800d802 <bAlloc+0x1d2>
    {
      buffer = queue->head;
 800d946:	6eb4      	ldr	r4, [r6, #104]	; 0x68
 800d948:	4f64      	ldr	r7, [pc, #400]	; (800dadc <bAlloc+0x4ac>)
      if (buffer)
 800d94a:	2c00      	cmp	r4, #0
 800d94c:	d064      	beq.n	800da18 <bAlloc+0x3e8>
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
 800d94e:	2300      	movs	r3, #0
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d950:	6922      	ldr	r2, [r4, #16]
          buffer->next = NULL;
 800d952:	6123      	str	r3, [r4, #16]
          count = --queue->count;
          queue->dequeues++;
 800d954:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d958:	6f3e      	ldr	r6, [r7, #112]	; 0x70
  if (!queue->refilling)
    {
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
 800d95a:	66ba      	str	r2, [r7, #104]	; 0x68
          buffer->next = NULL;
          count = --queue->count;
          queue->dequeues++;
 800d95c:	3301      	adds	r3, #1
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d95e:	3e01      	subs	r6, #1
          queue->dequeues++;
 800d960:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
      buffer = queue->head;
      if (buffer)
        {
          queue->head = queue->head->next;
          buffer->next = NULL;
          count = --queue->count;
 800d964:	673e      	str	r6, [r7, #112]	; 0x70
        }
    }
  else
    queue->empty++;

  bExitCS();
 800d966:	f7fc fbf7 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d96a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800d96e:	2b00      	cmp	r3, #0
 800d970:	f43f aef8 	beq.w	800d764 <bAlloc+0x134>
 800d974:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800d976:	4296      	cmp	r6, r2
 800d978:	d303      	bcc.n	800d982 <bAlloc+0x352>
 800d97a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800d97c:	4296      	cmp	r6, r2
 800d97e:	f67f aef1 	bls.w	800d764 <bAlloc+0x134>
    queue->callback(count);
 800d982:	4630      	mov	r0, r6
 800d984:	4798      	blx	r3
  int alloc_size = size;
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
      ALLOC_BUFFER( 33,  192);
      ALLOC_BUFFER(512,  512);
 800d986:	f44f 7300 	mov.w	r3, #512	; 0x200
 800d98a:	e6e9      	b.n	800d760 <bAlloc+0x130>
  unsigned int count = 0;
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
 800d98c:	69b2      	ldr	r2, [r6, #24]
 800d98e:	68b0      	ldr	r0, [r6, #8]
 800d990:	f342 021e 	sbfx	r2, r2, #0, #31
 800d994:	4282      	cmp	r2, r0
 800d996:	d30e      	bcc.n	800d9b6 <bAlloc+0x386>
          if (queue->refillCount > queue->count)
            queue->refilling = 1;
        }
    }
  else
    queue->empty++;
 800d998:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800d99a:	3301      	adds	r3, #1
 800d99c:	62f3      	str	r3, [r6, #44]	; 0x2c

  bExitCS();
 800d99e:	f7fc fbdb 	bl	800a158 <vPortExitCritical>

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800d9a2:	69f3      	ldr	r3, [r6, #28]
 800d9a4:	4a4d      	ldr	r2, [pc, #308]	; (800dadc <bAlloc+0x4ac>)
 800d9a6:	2b00      	cmp	r3, #0
 800d9a8:	d079      	beq.n	800da9e <bAlloc+0x46e>
 800d9aa:	6912      	ldr	r2, [r2, #16]
 800d9ac:	2a00      	cmp	r2, #0
 800d9ae:	f040 808d 	bne.w	800dacc <bAlloc+0x49c>
{
  bBuffer_t *buffer = NULL;
  int alloc_size = size;
  switch (size)
    {
      ALLOC_BUFFER(  1,   32);
 800d9b2:	2320      	movs	r3, #32
 800d9b4:	e693      	b.n	800d6de <bAlloc+0xae>
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d9b6:	f36f 13c7 	bfc	r3, #7, #1
    }

  if (!queue->refilling)
 800d9ba:	0619      	lsls	r1, r3, #24
  bBuffer_t *buffer = NULL;
  bEnterCS();
  if (queue->refilling)
    {
      if (queue->refillCount < queue->count)
        queue->refilling = 0;
 800d9bc:	76f3      	strb	r3, [r6, #27]
    }

  if (!queue->refilling)
 800d9be:	d4eb      	bmi.n	800d998 <bAlloc+0x368>
 800d9c0:	e6b3      	b.n	800d72a <bAlloc+0xfa>
    {
      //No suitable buffer on queue. Alloc from heap
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
      if (buffer)
        memset(buffer, 0x00, alloc_size);
      heapLastSize = alloc_size;
 800d9c2:	4d47      	ldr	r5, [pc, #284]	; (800dae0 <bAlloc+0x4b0>)
 800d9c4:	602e      	str	r6, [r5, #0]
      bEnterCS();
 800d9c6:	f7fc fbb5 	bl	800a134 <vPortEnterCritical>
      heapAllocs++;
 800d9ca:	686a      	ldr	r2, [r5, #4]
      heapAllocated++;
 800d9cc:	68ab      	ldr	r3, [r5, #8]
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
      if (buffer)
        memset(buffer, 0x00, alloc_size);
      heapLastSize = alloc_size;
      bEnterCS();
      heapAllocs++;
 800d9ce:	3201      	adds	r2, #1
      heapAllocated++;
 800d9d0:	3301      	adds	r3, #1
      buffer = intSafeMalloc(alloc_size + sizeof(bBuffer_t));
      if (buffer)
        memset(buffer, 0x00, alloc_size);
      heapLastSize = alloc_size;
      bEnterCS();
      heapAllocs++;
 800d9d2:	606a      	str	r2, [r5, #4]
      heapAllocated++;
 800d9d4:	60ab      	str	r3, [r5, #8]
      bExitCS();
 800d9d6:	f7fc fbbf 	bl	800a158 <vPortExitCritical>
      buffer->size = 0;
      buffer->offset = 0;
      buffer->ref = 1;
      buffer->next = NULL;
    }
  return buffer;
 800d9da:	e6cd      	b.n	800d778 <bAlloc+0x148>
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
          if (queue->refillCount > queue->count)
 800d9dc:	69bb      	ldr	r3, [r7, #24]
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800d9de:	6afa      	ldr	r2, [r7, #44]	; 0x2c
          if (queue->refillCount > queue->count)
 800d9e0:	f343 031e 	sbfx	r3, r3, #0, #31
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800d9e4:	3201      	adds	r2, #1
          if (queue->refillCount > queue->count)
 800d9e6:	4283      	cmp	r3, r0
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800d9e8:	62fa      	str	r2, [r7, #44]	; 0x2c
          if (queue->refillCount > queue->count)
 800d9ea:	d9d8      	bls.n	800d99e <bAlloc+0x36e>
            queue->refilling = 1;
 800d9ec:	7efb      	ldrb	r3, [r7, #27]
 800d9ee:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d9f2:	76fb      	strb	r3, [r7, #27]
 800d9f4:	e7d3      	b.n	800d99e <bAlloc+0x36e>
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
          if (queue->refillCount > queue->count)
 800d9f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800d9f8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
          if (queue->refillCount > queue->count)
 800d9fa:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800d9fc:	f343 031e 	sbfx	r3, r3, #0, #31
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da00:	3201      	adds	r2, #1
          if (queue->refillCount > queue->count)
 800da02:	428b      	cmp	r3, r1
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da04:	663a      	str	r2, [r7, #96]	; 0x60
          if (queue->refillCount > queue->count)
 800da06:	f67f ae32 	bls.w	800d66e <bAlloc+0x3e>
            queue->refilling = 1;
 800da0a:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 800da0e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800da12:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
 800da16:	e62a      	b.n	800d66e <bAlloc+0x3e>
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
          if (queue->refillCount > queue->count)
 800da18:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da1c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
          if (queue->refillCount > queue->count)
 800da20:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800da22:	f343 031e 	sbfx	r3, r3, #0, #31
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da26:	3201      	adds	r2, #1
          if (queue->refillCount > queue->count)
 800da28:	428b      	cmp	r3, r1
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da2a:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
          if (queue->refillCount > queue->count)
 800da2e:	f67f aeed 	bls.w	800d80c <bAlloc+0x1dc>
            queue->refilling = 1;
 800da32:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 800da36:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800da3a:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
 800da3e:	e6e5      	b.n	800d80c <bAlloc+0x1dc>
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
          if (queue->refillCount > queue->count)
 800da40:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da44:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
          if (queue->refillCount > queue->count)
 800da48:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 800da4c:	f343 031e 	sbfx	r3, r3, #0, #31
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da50:	3201      	adds	r2, #1
          if (queue->refillCount > queue->count)
 800da52:	428b      	cmp	r3, r1
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da54:	f8c7 20c8 	str.w	r2, [r7, #200]	; 0xc8
          if (queue->refillCount > queue->count)
 800da58:	f67f aeb3 	bls.w	800d7c2 <bAlloc+0x192>
            queue->refilling = 1;
 800da5c:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 800da60:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800da64:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
 800da68:	e6ab      	b.n	800d7c2 <bAlloc+0x192>
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
          if (queue->refillCount > queue->count)
 800da6a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da6e:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
          if (queue->refillCount > queue->count)
 800da72:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
 800da76:	f343 031e 	sbfx	r3, r3, #0, #31
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da7a:	3201      	adds	r2, #1
          if (queue->refillCount > queue->count)
 800da7c:	428b      	cmp	r3, r1
          count = --queue->count;
          queue->dequeues++;
        }
      else
        {
          queue->empty++;
 800da7e:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
          if (queue->refillCount > queue->count)
 800da82:	f67f ae1d 	bls.w	800d6c0 <bAlloc+0x90>
            queue->refilling = 1;
 800da86:	f897 30eb 	ldrb.w	r3, [r7, #235]	; 0xeb
 800da8a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800da8e:	f887 30eb 	strb.w	r3, [r7, #235]	; 0xeb
 800da92:	e615      	b.n	800d6c0 <bAlloc+0x90>
    queue->empty++;

  bExitCS();

  //Call a callback if number of elements in queue went below initialized value
  if (queue->callback && (count < queue->belowCount || count > queue->aboveCount))
 800da94:	f44f 7005 	mov.w	r0, #532	; 0x214
 800da98:	f44f 7600 	mov.w	r6, #512	; 0x200
 800da9c:	e626      	b.n	800d6ec <bAlloc+0xbc>
 800da9e:	2034      	movs	r0, #52	; 0x34
 800daa0:	2620      	movs	r6, #32
 800daa2:	e623      	b.n	800d6ec <bAlloc+0xbc>
 800daa4:	20d4      	movs	r0, #212	; 0xd4
 800daa6:	26c0      	movs	r6, #192	; 0xc0
 800daa8:	e620      	b.n	800d6ec <bAlloc+0xbc>
 800daaa:	f240 4014 	movw	r0, #1044	; 0x414
 800daae:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800dab2:	e61b      	b.n	800d6ec <bAlloc+0xbc>
 800dab4:	2400      	movs	r4, #0
 800dab6:	4626      	mov	r6, r4
 800dab8:	e709      	b.n	800d8ce <bAlloc+0x29e>
 800daba:	2400      	movs	r4, #0
 800dabc:	4626      	mov	r6, r4
 800dabe:	e730      	b.n	800d922 <bAlloc+0x2f2>
 800dac0:	2400      	movs	r4, #0
 800dac2:	4626      	mov	r6, r4
 800dac4:	e6d3      	b.n	800d86e <bAlloc+0x23e>
 800dac6:	2400      	movs	r4, #0
 800dac8:	4626      	mov	r6, r4
 800daca:	e75a      	b.n	800d982 <bAlloc+0x352>
 800dacc:	2400      	movs	r4, #0
 800dace:	4626      	mov	r6, r4
 800dad0:	e643      	b.n	800d75a <bAlloc+0x12a>
 800dad2:	f640 0054 	movw	r0, #2132	; 0x854
 800dad6:	f44f 6604 	mov.w	r6, #2112	; 0x840
 800dada:	e607      	b.n	800d6ec <bAlloc+0xbc>
 800dadc:	2001a978 	.word	0x2001a978
 800dae0:	2001ad74 	.word	0x2001ad74

0800dae4 <bFree>:
      buffer->next = NULL;
    }
  return buffer;
}
void __attribute__((optimize("-O4")))bFree(bBuffer_t *buffer)
{
 800dae4:	b570      	push	{r4, r5, r6, lr}
 800dae6:	4605      	mov	r5, r0
  bEnterCS();
 800dae8:	f7fc fb24 	bl	800a134 <vPortEnterCritical>
  int ref = --buffer->ref;
 800daec:	88ec      	ldrh	r4, [r5, #6]
 800daee:	3c01      	subs	r4, #1
 800daf0:	b2a4      	uxth	r4, r4
 800daf2:	80ec      	strh	r4, [r5, #6]
  bExitCS();
 800daf4:	f7fc fb30 	bl	800a158 <vPortExitCritical>

  if (ref == 0)
 800daf8:	2c00      	cmp	r4, #0
 800dafa:	f040 80f3 	bne.w	800dce4 <bFree+0x200>
    {
      switch (buffer->maxSize)
 800dafe:	886b      	ldrh	r3, [r5, #2]
 800db00:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800db04:	f000 80c8 	beq.w	800dc98 <bFree+0x1b4>
 800db08:	d829      	bhi.n	800db5e <bFree+0x7a>
 800db0a:	2b00      	cmp	r3, #0
 800db0c:	d063      	beq.n	800dbd6 <bFree+0xf2>
 800db0e:	2b20      	cmp	r3, #32
 800db10:	d971      	bls.n	800dbf6 <bFree+0x112>
 800db12:	2bc0      	cmp	r3, #192	; 0xc0
 800db14:	d85f      	bhi.n	800dbd6 <bFree+0xf2>
  queue->refillCount = refillCount;
  return 0;
}
int __attribute__((optimize("-O4")))bEnqueue(bQueue_t *queue, bBuffer_t *buffer)
{
  if (queue->callback && queue->count > queue->aboveCount)
 800db16:	4c90      	ldr	r4, [pc, #576]	; (800dd58 <bFree+0x274>)
 800db18:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800db1a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800db1c:	b11b      	cbz	r3, 800db26 <bFree+0x42>
 800db1e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800db20:	4290      	cmp	r0, r2
 800db22:	f200 80e7 	bhi.w	800dcf4 <bFree+0x210>
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
 800db26:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800db28:	4e8b      	ldr	r6, [pc, #556]	; (800dd58 <bFree+0x274>)
 800db2a:	4283      	cmp	r3, r0
 800db2c:	f000 810f 	beq.w	800dd4e <bFree+0x26a>
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
 800db30:	f7fc fb00 	bl	800a134 <vPortEnterCritical>
  buffer->next = NULL;
  if (queue->head)
 800db34:	6b73      	ldr	r3, [r6, #52]	; 0x34
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
  buffer->next = NULL;
 800db36:	2200      	movs	r2, #0
 800db38:	612a      	str	r2, [r5, #16]
  if (queue->head)
 800db3a:	2b00      	cmp	r3, #0
 800db3c:	f000 80ee 	beq.w	800dd1c <bFree+0x238>
    {
      queue->tail->next = buffer;
 800db40:	6bb3      	ldr	r3, [r6, #56]	; 0x38
      queue->tail = buffer;
 800db42:	63b5      	str	r5, [r6, #56]	; 0x38
    }
  bEnterCS();
  buffer->next = NULL;
  if (queue->head)
    {
      queue->tail->next = buffer;
 800db44:	611d      	str	r5, [r3, #16]
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
  queue->count++;
 800db46:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800db48:	6da2      	ldr	r2, [r4, #88]	; 0x58
  queue->count++;
  if (queue->count > queue->maxFilling)
 800db4a:	6e61      	ldr	r1, [r4, #100]	; 0x64
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800db4c:	4882      	ldr	r0, [pc, #520]	; (800dd58 <bFree+0x274>)
  queue->count++;
 800db4e:	3301      	adds	r3, #1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800db50:	3201      	adds	r2, #1
  queue->count++;
  if (queue->count > queue->maxFilling)
 800db52:	428b      	cmp	r3, r1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800db54:	65a2      	str	r2, [r4, #88]	; 0x58
  queue->count++;
 800db56:	63e3      	str	r3, [r4, #60]	; 0x3c
  if (queue->count > queue->maxFilling)
 800db58:	d949      	bls.n	800dbee <bFree+0x10a>
    queue->maxFilling = queue->count;
 800db5a:	6643      	str	r3, [r0, #100]	; 0x64
 800db5c:	e047      	b.n	800dbee <bFree+0x10a>
  int ref = --buffer->ref;
  bExitCS();

  if (ref == 0)
    {
      switch (buffer->maxSize)
 800db5e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800db62:	d96b      	bls.n	800dc3c <bFree+0x158>
 800db64:	f5b3 6f04 	cmp.w	r3, #2112	; 0x840
 800db68:	d835      	bhi.n	800dbd6 <bFree+0xf2>
  queue->refillCount = refillCount;
  return 0;
}
int __attribute__((optimize("-O4")))bEnqueue(bQueue_t *queue, bBuffer_t *buffer)
{
  if (queue->callback && queue->count > queue->aboveCount)
 800db6a:	4c7b      	ldr	r4, [pc, #492]	; (800dd58 <bFree+0x274>)
 800db6c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 800db70:	f8d4 00d8 	ldr.w	r0, [r4, #216]	; 0xd8
 800db74:	b123      	cbz	r3, 800db80 <bFree+0x9c>
 800db76:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
 800db7a:	4290      	cmp	r0, r2
 800db7c:	f200 80b3 	bhi.w	800dce6 <bFree+0x202>
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
 800db80:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800db84:	4e74      	ldr	r6, [pc, #464]	; (800dd58 <bFree+0x274>)
 800db86:	4298      	cmp	r0, r3
 800db88:	f000 80db 	beq.w	800dd42 <bFree+0x25e>
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
 800db8c:	f7fc fad2 	bl	800a134 <vPortEnterCritical>
  buffer->next = NULL;
  if (queue->head)
 800db90:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
  buffer->next = NULL;
 800db94:	2200      	movs	r2, #0
 800db96:	612a      	str	r2, [r5, #16]
  if (queue->head)
 800db98:	2b00      	cmp	r3, #0
 800db9a:	f000 80ba 	beq.w	800dd12 <bFree+0x22e>
    {
      queue->tail->next = buffer;
 800db9e:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
      queue->tail = buffer;
 800dba2:	f8c6 50d4 	str.w	r5, [r6, #212]	; 0xd4
    }
  bEnterCS();
  buffer->next = NULL;
  if (queue->head)
    {
      queue->tail->next = buffer;
 800dba6:	611d      	str	r5, [r3, #16]
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
  queue->count++;
 800dba8:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dbac:	f8d4 20f4 	ldr.w	r2, [r4, #244]	; 0xf4
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dbb0:	f8d4 1100 	ldr.w	r1, [r4, #256]	; 0x100
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dbb4:	4868      	ldr	r0, [pc, #416]	; (800dd58 <bFree+0x274>)
  queue->count++;
 800dbb6:	3301      	adds	r3, #1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dbb8:	3201      	adds	r2, #1
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dbba:	428b      	cmp	r3, r1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dbbc:	f8c4 20f4 	str.w	r2, [r4, #244]	; 0xf4
  queue->count++;
 800dbc0:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
  if (queue->count > queue->maxFilling)
 800dbc4:	d913      	bls.n	800dbee <bFree+0x10a>
    queue->maxFilling = queue->count;
 800dbc6:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 800dbca:	e010      	b.n	800dbee <bFree+0x10a>
  if (queue->callback && queue->count > queue->aboveCount)
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
    {
      queue->full++;
 800dbcc:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 800dbd0:	3301      	adds	r3, #1
 800dbd2:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
          FREE_BUFFER(1025,2112);
        }
      if (buffer)
        {
          //No suitable buffer queue.
          intSafeFree(buffer);
 800dbd6:	4628      	mov	r0, r5
 800dbd8:	f7fa fc54 	bl	8008484 <intSafeFree>
          bEnterCS();
 800dbdc:	f7fc faaa 	bl	800a134 <vPortEnterCritical>
          heapFrees++;
 800dbe0:	4b5e      	ldr	r3, [pc, #376]	; (800dd5c <bFree+0x278>)
 800dbe2:	68d9      	ldr	r1, [r3, #12]
          heapAllocated--;
 800dbe4:	689a      	ldr	r2, [r3, #8]
      if (buffer)
        {
          //No suitable buffer queue.
          intSafeFree(buffer);
          bEnterCS();
          heapFrees++;
 800dbe6:	3101      	adds	r1, #1
          heapAllocated--;
 800dbe8:	3a01      	subs	r2, #1
      if (buffer)
        {
          //No suitable buffer queue.
          intSafeFree(buffer);
          bEnterCS();
          heapFrees++;
 800dbea:	60d9      	str	r1, [r3, #12]
          heapAllocated--;
 800dbec:	609a      	str	r2, [r3, #8]
          bExitCS();
        }
    }
}
 800dbee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          //No suitable buffer queue.
          intSafeFree(buffer);
          bEnterCS();
          heapFrees++;
          heapAllocated--;
          bExitCS();
 800dbf2:	f7fc bab1 	b.w	800a158 <vPortExitCritical>
  queue->refillCount = refillCount;
  return 0;
}
int __attribute__((optimize("-O4")))bEnqueue(bQueue_t *queue, bBuffer_t *buffer)
{
  if (queue->callback && queue->count > queue->aboveCount)
 800dbf6:	4c58      	ldr	r4, [pc, #352]	; (800dd58 <bFree+0x274>)
 800dbf8:	69e3      	ldr	r3, [r4, #28]
 800dbfa:	68a0      	ldr	r0, [r4, #8]
 800dbfc:	b113      	cbz	r3, 800dc04 <bFree+0x120>
 800dbfe:	6962      	ldr	r2, [r4, #20]
 800dc00:	4290      	cmp	r0, r2
 800dc02:	d874      	bhi.n	800dcee <bFree+0x20a>
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
 800dc04:	68e3      	ldr	r3, [r4, #12]
 800dc06:	4e54      	ldr	r6, [pc, #336]	; (800dd58 <bFree+0x274>)
 800dc08:	4283      	cmp	r3, r0
 800dc0a:	f000 8090 	beq.w	800dd2e <bFree+0x24a>
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
 800dc0e:	f7fc fa91 	bl	800a134 <vPortEnterCritical>
  buffer->next = NULL;
  if (queue->head)
 800dc12:	6833      	ldr	r3, [r6, #0]
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
  buffer->next = NULL;
 800dc14:	2200      	movs	r2, #0
 800dc16:	612a      	str	r2, [r5, #16]
  if (queue->head)
 800dc18:	2b00      	cmp	r3, #0
 800dc1a:	f000 8085 	beq.w	800dd28 <bFree+0x244>
    {
      queue->tail->next = buffer;
 800dc1e:	6873      	ldr	r3, [r6, #4]
      queue->tail = buffer;
 800dc20:	6075      	str	r5, [r6, #4]
    }
  bEnterCS();
  buffer->next = NULL;
  if (queue->head)
    {
      queue->tail->next = buffer;
 800dc22:	611d      	str	r5, [r3, #16]
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
  queue->count++;
 800dc24:	68a3      	ldr	r3, [r4, #8]
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc26:	6a62      	ldr	r2, [r4, #36]	; 0x24
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dc28:	6b21      	ldr	r1, [r4, #48]	; 0x30
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc2a:	484b      	ldr	r0, [pc, #300]	; (800dd58 <bFree+0x274>)
  queue->count++;
 800dc2c:	3301      	adds	r3, #1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc2e:	3201      	adds	r2, #1
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dc30:	428b      	cmp	r3, r1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc32:	6262      	str	r2, [r4, #36]	; 0x24
  queue->count++;
 800dc34:	60a3      	str	r3, [r4, #8]
  if (queue->count > queue->maxFilling)
 800dc36:	d9da      	bls.n	800dbee <bFree+0x10a>
    queue->maxFilling = queue->count;
 800dc38:	6303      	str	r3, [r0, #48]	; 0x30
 800dc3a:	e7d8      	b.n	800dbee <bFree+0x10a>
  queue->refillCount = refillCount;
  return 0;
}
int __attribute__((optimize("-O4")))bEnqueue(bQueue_t *queue, bBuffer_t *buffer)
{
  if (queue->callback && queue->count > queue->aboveCount)
 800dc3c:	4c46      	ldr	r4, [pc, #280]	; (800dd58 <bFree+0x274>)
 800dc3e:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 800dc42:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 800dc46:	b11b      	cbz	r3, 800dc50 <bFree+0x16c>
 800dc48:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 800dc4c:	4290      	cmp	r0, r2
 800dc4e:	d857      	bhi.n	800dd00 <bFree+0x21c>
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
 800dc50:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 800dc54:	4e40      	ldr	r6, [pc, #256]	; (800dd58 <bFree+0x274>)
 800dc56:	4283      	cmp	r3, r0
 800dc58:	d06d      	beq.n	800dd36 <bFree+0x252>
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
 800dc5a:	f7fc fa6b 	bl	800a134 <vPortEnterCritical>
  buffer->next = NULL;
  if (queue->head)
 800dc5e:	f8d6 309c 	ldr.w	r3, [r6, #156]	; 0x9c
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
  buffer->next = NULL;
 800dc62:	2200      	movs	r2, #0
 800dc64:	612a      	str	r2, [r5, #16]
  if (queue->head)
 800dc66:	2b00      	cmp	r3, #0
 800dc68:	d04e      	beq.n	800dd08 <bFree+0x224>
    {
      queue->tail->next = buffer;
 800dc6a:	f8d6 30a0 	ldr.w	r3, [r6, #160]	; 0xa0
      queue->tail = buffer;
 800dc6e:	f8c6 50a0 	str.w	r5, [r6, #160]	; 0xa0
    }
  bEnterCS();
  buffer->next = NULL;
  if (queue->head)
    {
      queue->tail->next = buffer;
 800dc72:	611d      	str	r5, [r3, #16]
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
  queue->count++;
 800dc74:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc78:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dc7c:	f8d4 10cc 	ldr.w	r1, [r4, #204]	; 0xcc
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc80:	4835      	ldr	r0, [pc, #212]	; (800dd58 <bFree+0x274>)
  queue->count++;
 800dc82:	3301      	adds	r3, #1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc84:	3201      	adds	r2, #1
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dc86:	428b      	cmp	r3, r1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dc88:	f8c4 20c0 	str.w	r2, [r4, #192]	; 0xc0
  queue->count++;
 800dc8c:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
  if (queue->count > queue->maxFilling)
 800dc90:	d9ad      	bls.n	800dbee <bFree+0x10a>
    queue->maxFilling = queue->count;
 800dc92:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
 800dc96:	e7aa      	b.n	800dbee <bFree+0x10a>
  queue->refillCount = refillCount;
  return 0;
}
int __attribute__((optimize("-O4")))bEnqueue(bQueue_t *queue, bBuffer_t *buffer)
{
  if (queue->callback && queue->count > queue->aboveCount)
 800dc98:	4c2f      	ldr	r4, [pc, #188]	; (800dd58 <bFree+0x274>)
 800dc9a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800dc9e:	6f20      	ldr	r0, [r4, #112]	; 0x70
 800dca0:	b113      	cbz	r3, 800dca8 <bFree+0x1c4>
 800dca2:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800dca4:	4290      	cmp	r0, r2
 800dca6:	d828      	bhi.n	800dcfa <bFree+0x216>
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
 800dca8:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800dcaa:	4e2b      	ldr	r6, [pc, #172]	; (800dd58 <bFree+0x274>)
 800dcac:	4283      	cmp	r3, r0
 800dcae:	d08d      	beq.n	800dbcc <bFree+0xe8>
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
 800dcb0:	f7fc fa40 	bl	800a134 <vPortEnterCritical>
  buffer->next = NULL;
  if (queue->head)
 800dcb4:	6eb3      	ldr	r3, [r6, #104]	; 0x68
    {
      queue->full++;
      return -1;
    }
  bEnterCS();
  buffer->next = NULL;
 800dcb6:	2200      	movs	r2, #0
 800dcb8:	612a      	str	r2, [r5, #16]
  if (queue->head)
 800dcba:	2b00      	cmp	r3, #0
 800dcbc:	d031      	beq.n	800dd22 <bFree+0x23e>
    {
      queue->tail->next = buffer;
 800dcbe:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
      queue->tail = buffer;
 800dcc0:	66f5      	str	r5, [r6, #108]	; 0x6c
    }
  bEnterCS();
  buffer->next = NULL;
  if (queue->head)
    {
      queue->tail->next = buffer;
 800dcc2:	611d      	str	r5, [r3, #16]
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
  queue->count++;
 800dcc4:	6f23      	ldr	r3, [r4, #112]	; 0x70
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dcc6:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dcca:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dcce:	4822      	ldr	r0, [pc, #136]	; (800dd58 <bFree+0x274>)
  queue->count++;
 800dcd0:	3301      	adds	r3, #1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dcd2:	3201      	adds	r2, #1
  queue->count++;
  if (queue->count > queue->maxFilling)
 800dcd4:	428b      	cmp	r3, r1
  else
    {
      queue->tail = buffer;
      queue->head = buffer;
    }
  queue->enqueues++;
 800dcd6:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
  queue->count++;
 800dcda:	6723      	str	r3, [r4, #112]	; 0x70
  if (queue->count > queue->maxFilling)
 800dcdc:	d987      	bls.n	800dbee <bFree+0x10a>
    queue->maxFilling = queue->count;
 800dcde:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
 800dce2:	e784      	b.n	800dbee <bFree+0x10a>
 800dce4:	bd70      	pop	{r4, r5, r6, pc}
  return 0;
}
int __attribute__((optimize("-O4")))bEnqueue(bQueue_t *queue, bBuffer_t *buffer)
{
  if (queue->callback && queue->count > queue->aboveCount)
    queue->callback(queue->count);
 800dce6:	4798      	blx	r3
 800dce8:	f8d4 00d8 	ldr.w	r0, [r4, #216]	; 0xd8
 800dcec:	e748      	b.n	800db80 <bFree+0x9c>
 800dcee:	4798      	blx	r3
 800dcf0:	68a0      	ldr	r0, [r4, #8]
 800dcf2:	e787      	b.n	800dc04 <bFree+0x120>
 800dcf4:	4798      	blx	r3
 800dcf6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800dcf8:	e715      	b.n	800db26 <bFree+0x42>
 800dcfa:	4798      	blx	r3
 800dcfc:	6f20      	ldr	r0, [r4, #112]	; 0x70
 800dcfe:	e7d3      	b.n	800dca8 <bFree+0x1c4>
 800dd00:	4798      	blx	r3
 800dd02:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 800dd06:	e7a3      	b.n	800dc50 <bFree+0x16c>
      queue->tail->next = buffer;
      queue->tail = buffer;
    }
  else
    {
      queue->tail = buffer;
 800dd08:	f8c6 50a0 	str.w	r5, [r6, #160]	; 0xa0
      queue->head = buffer;
 800dd0c:	f8c6 509c 	str.w	r5, [r6, #156]	; 0x9c
 800dd10:	e7b0      	b.n	800dc74 <bFree+0x190>
      queue->tail->next = buffer;
      queue->tail = buffer;
    }
  else
    {
      queue->tail = buffer;
 800dd12:	f8c6 50d4 	str.w	r5, [r6, #212]	; 0xd4
      queue->head = buffer;
 800dd16:	f8c6 50d0 	str.w	r5, [r6, #208]	; 0xd0
 800dd1a:	e745      	b.n	800dba8 <bFree+0xc4>
      queue->tail->next = buffer;
      queue->tail = buffer;
    }
  else
    {
      queue->tail = buffer;
 800dd1c:	63b5      	str	r5, [r6, #56]	; 0x38
      queue->head = buffer;
 800dd1e:	6375      	str	r5, [r6, #52]	; 0x34
 800dd20:	e711      	b.n	800db46 <bFree+0x62>
      queue->tail->next = buffer;
      queue->tail = buffer;
    }
  else
    {
      queue->tail = buffer;
 800dd22:	66f5      	str	r5, [r6, #108]	; 0x6c
      queue->head = buffer;
 800dd24:	66b5      	str	r5, [r6, #104]	; 0x68
 800dd26:	e7cd      	b.n	800dcc4 <bFree+0x1e0>
      queue->tail->next = buffer;
      queue->tail = buffer;
    }
  else
    {
      queue->tail = buffer;
 800dd28:	6075      	str	r5, [r6, #4]
      queue->head = buffer;
 800dd2a:	6035      	str	r5, [r6, #0]
 800dd2c:	e77a      	b.n	800dc24 <bFree+0x140>
  if (queue->callback && queue->count > queue->aboveCount)
    queue->callback(queue->count);

  if (queue->count == queue->maxCount)
    {
      queue->full++;
 800dd2e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800dd30:	3301      	adds	r3, #1
 800dd32:	62b3      	str	r3, [r6, #40]	; 0x28
 800dd34:	e74f      	b.n	800dbd6 <bFree+0xf2>
 800dd36:	f8d6 30c4 	ldr.w	r3, [r6, #196]	; 0xc4
 800dd3a:	3301      	adds	r3, #1
 800dd3c:	f8c6 30c4 	str.w	r3, [r6, #196]	; 0xc4
 800dd40:	e749      	b.n	800dbd6 <bFree+0xf2>
 800dd42:	f8d6 30f8 	ldr.w	r3, [r6, #248]	; 0xf8
 800dd46:	3301      	adds	r3, #1
 800dd48:	f8c6 30f8 	str.w	r3, [r6, #248]	; 0xf8
 800dd4c:	e743      	b.n	800dbd6 <bFree+0xf2>
 800dd4e:	6df3      	ldr	r3, [r6, #92]	; 0x5c
 800dd50:	3301      	adds	r3, #1
 800dd52:	65f3      	str	r3, [r6, #92]	; 0x5c
 800dd54:	e73f      	b.n	800dbd6 <bFree+0xf2>
 800dd56:	bf00      	nop
 800dd58:	2001a978 	.word	0x2001a978
 800dd5c:	2001ad74 	.word	0x2001ad74

0800dd60 <bRef>:
        }
    }
}

void __attribute__((optimize("-O4")))bRef(bBuffer_t *buffer)
{
 800dd60:	b510      	push	{r4, lr}
 800dd62:	4604      	mov	r4, r0
  bEnterCS();
 800dd64:	f7fc f9e6 	bl	800a134 <vPortEnterCritical>
  buffer->ref++;
 800dd68:	88e3      	ldrh	r3, [r4, #6]
 800dd6a:	3301      	adds	r3, #1
 800dd6c:	80e3      	strh	r3, [r4, #6]
  bExitCS();
}
 800dd6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void __attribute__((optimize("-O4")))bRef(bBuffer_t *buffer)
{
  bEnterCS();
  buffer->ref++;
  bExitCS();
 800dd72:	f7fc b9f1 	b.w	800a158 <vPortExitCritical>
	...

0800dd78 <DMA2_Stream0_IRQHandler>:

extern xSemaphoreHandle ADC_xSemaphore;
extern int sensADCnew;
extern int sensADC;
//Create IRQ handler for ADC
ADC_HANDLER(DMA2, 0, ADC_xSemaphore);
 800dd78:	b513      	push	{r0, r1, r4, lr}
 800dd7a:	2300      	movs	r3, #0
 800dd7c:	9301      	str	r3, [sp, #4]
 800dd7e:	4b1d      	ldr	r3, [pc, #116]	; (800ddf4 <DMA2_Stream0_IRQHandler+0x7c>)
 800dd80:	6819      	ldr	r1, [r3, #0]
 800dd82:	1c4a      	adds	r2, r1, #1
 800dd84:	4a1c      	ldr	r2, [pc, #112]	; (800ddf8 <DMA2_Stream0_IRQHandler+0x80>)
 800dd86:	d108      	bne.n	800dd9a <DMA2_Stream0_IRQHandler+0x22>
 800dd88:	491c      	ldr	r1, [pc, #112]	; (800ddfc <DMA2_Stream0_IRQHandler+0x84>)
 800dd8a:	6812      	ldr	r2, [r2, #0]
 800dd8c:	6808      	ldr	r0, [r1, #0]
 800dd8e:	4290      	cmp	r0, r2
 800dd90:	d007      	beq.n	800dda2 <DMA2_Stream0_IRQHandler+0x2a>
 800dd92:	6018      	str	r0, [r3, #0]
 800dd94:	f002 ff0e 	bl	8010bb4 <adcSens>
 800dd98:	e003      	b.n	800dda2 <DMA2_Stream0_IRQHandler+0x2a>
 800dd9a:	6011      	str	r1, [r2, #0]
 800dd9c:	f04f 32ff 	mov.w	r2, #4294967295
 800dda0:	601a      	str	r2, [r3, #0]
 800dda2:	4917      	ldr	r1, [pc, #92]	; (800de00 <DMA2_Stream0_IRQHandler+0x88>)
 800dda4:	4817      	ldr	r0, [pc, #92]	; (800de04 <DMA2_Stream0_IRQHandler+0x8c>)
 800dda6:	f004 fee1 	bl	8012b6c <DMA_GetITStatus>
 800ddaa:	4604      	mov	r4, r0
 800ddac:	b140      	cbz	r0, 800ddc0 <DMA2_Stream0_IRQHandler+0x48>
 800ddae:	4914      	ldr	r1, [pc, #80]	; (800de00 <DMA2_Stream0_IRQHandler+0x88>)
 800ddb0:	4814      	ldr	r0, [pc, #80]	; (800de04 <DMA2_Stream0_IRQHandler+0x8c>)
 800ddb2:	f005 f823 	bl	8012dfc <DMA_ClearITPendingBit>
 800ddb6:	4b14      	ldr	r3, [pc, #80]	; (800de08 <DMA2_Stream0_IRQHandler+0x90>)
 800ddb8:	2201      	movs	r2, #1
 800ddba:	601a      	str	r2, [r3, #0]
 800ddbc:	2300      	movs	r3, #0
 800ddbe:	e00b      	b.n	800ddd8 <DMA2_Stream0_IRQHandler+0x60>
 800ddc0:	4912      	ldr	r1, [pc, #72]	; (800de0c <DMA2_Stream0_IRQHandler+0x94>)
 800ddc2:	4810      	ldr	r0, [pc, #64]	; (800de04 <DMA2_Stream0_IRQHandler+0x8c>)
 800ddc4:	f004 fed2 	bl	8012b6c <DMA_GetITStatus>
 800ddc8:	b160      	cbz	r0, 800dde4 <DMA2_Stream0_IRQHandler+0x6c>
 800ddca:	4910      	ldr	r1, [pc, #64]	; (800de0c <DMA2_Stream0_IRQHandler+0x94>)
 800ddcc:	480d      	ldr	r0, [pc, #52]	; (800de04 <DMA2_Stream0_IRQHandler+0x8c>)
 800ddce:	f005 f815 	bl	8012dfc <DMA_ClearITPendingBit>
 800ddd2:	4b0d      	ldr	r3, [pc, #52]	; (800de08 <DMA2_Stream0_IRQHandler+0x90>)
 800ddd4:	601c      	str	r4, [r3, #0]
 800ddd6:	4623      	mov	r3, r4
 800ddd8:	480d      	ldr	r0, [pc, #52]	; (800de10 <DMA2_Stream0_IRQHandler+0x98>)
 800ddda:	aa01      	add	r2, sp, #4
 800dddc:	4619      	mov	r1, r3
 800ddde:	6800      	ldr	r0, [r0, #0]
 800dde0:	f7fd f895 	bl	800af0e <xQueueGenericSendFromISR>
 800dde4:	9b01      	ldr	r3, [sp, #4]
 800dde6:	b11b      	cbz	r3, 800ddf0 <DMA2_Stream0_IRQHandler+0x78>
 800dde8:	4b0a      	ldr	r3, [pc, #40]	; (800de14 <DMA2_Stream0_IRQHandler+0x9c>)
 800ddea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ddee:	601a      	str	r2, [r3, #0]
 800ddf0:	b002      	add	sp, #8
 800ddf2:	bd10      	pop	{r4, pc}
 800ddf4:	2001aa7c 	.word	0x2001aa7c
 800ddf8:	2001ad68 	.word	0x2001ad68
 800ddfc:	2001ad70 	.word	0x2001ad70
 800de00:	10008020 	.word	0x10008020
 800de04:	40026410 	.word	0x40026410
 800de08:	2001ad64 	.word	0x2001ad64
 800de0c:	10004010 	.word	0x10004010
 800de10:	2001ae50 	.word	0x2001ae50
 800de14:	e000ed04 	.word	0xe000ed04

0800de18 <spiIRQEnable>:
#include <hwCommunicatorUARThelper.h>

static int spiNoIRQ = 0;
void spiIRQEnable(int enable)
{
  spiNoIRQ = !enable;
 800de18:	fab0 f080 	clz	r0, r0
 800de1c:	4b01      	ldr	r3, [pc, #4]	; (800de24 <spiIRQEnable+0xc>)
 800de1e:	0940      	lsrs	r0, r0, #5
 800de20:	6018      	str	r0, [r3, #0]
 800de22:	4770      	bx	lr
 800de24:	2001ad84 	.word	0x2001ad84

0800de28 <txSPI>:
}
void __attribute__((optimize("-O3")))txSPI(void *spi, uint8_t txByte)
{
 800de28:	b570      	push	{r4, r5, r6, lr}
 800de2a:	460d      	mov	r5, r1
 800de2c:	b082      	sub	sp, #8
 800de2e:	4604      	mov	r4, r0
  //  while (SPI_I2S_GetFlagStatus(spi, SPI_FLAG_BSY) != RESET);
  //Discard old data
  (void)SPI_I2S_ReceiveData(spi);
 800de30:	f003 feb0 	bl	8011b94 <SPI_I2S_ReceiveData>
  SPI_I2S_SendData(spi, txByte);
 800de34:	4629      	mov	r1, r5
 800de36:	4620      	mov	r0, r4
 800de38:	f003 fed6 	bl	8011be8 <SPI_I2S_SendData>
  if(!spiNoIRQ)
 800de3c:	4b17      	ldr	r3, [pc, #92]	; (800de9c <txSPI+0x74>)
 800de3e:	681d      	ldr	r5, [r3, #0]
 800de40:	b13d      	cbz	r5, 800de52 <txSPI+0x2a>
        {
          SPI_I2S_ITConfig(spi, SPI_I2S_IT_TXE, ENABLE);
          massert(xSemaphoreTake(spiData[spiNum].xSemaphore, portMAX_DELAY ) == pdTRUE );
        }
    }
  while (SPI_I2S_GetFlagStatus(spi, SPI_FLAG_TXE) == RESET);
 800de42:	2102      	movs	r1, #2
 800de44:	4620      	mov	r0, r4
 800de46:	f003 ff8f 	bl	8011d68 <SPI_I2S_GetFlagStatus>
 800de4a:	2800      	cmp	r0, #0
 800de4c:	d0f9      	beq.n	800de42 <txSPI+0x1a>
}
 800de4e:	b002      	add	sp, #8
 800de50:	bd70      	pop	{r4, r5, r6, pc}
  //Discard old data
  (void)SPI_I2S_ReceiveData(spi);
  SPI_I2S_SendData(spi, txByte);
  if(!spiNoIRQ)
    {
      int spiNum = spiToSpiNum(spi);
 800de52:	4620      	mov	r0, r4
 800de54:	f001 fc68 	bl	800f728 <spiToSpiNum>
      if (spiNum != -1)
 800de58:	1c43      	adds	r3, r0, #1
  //Discard old data
  (void)SPI_I2S_ReceiveData(spi);
  SPI_I2S_SendData(spi, txByte);
  if(!spiNoIRQ)
    {
      int spiNum = spiToSpiNum(spi);
 800de5a:	4606      	mov	r6, r0
      if (spiNum != -1)
 800de5c:	d0f1      	beq.n	800de42 <txSPI+0x1a>
        {
          SPI_I2S_ITConfig(spi, SPI_I2S_IT_TXE, ENABLE);
 800de5e:	2201      	movs	r2, #1
 800de60:	2171      	movs	r1, #113	; 0x71
 800de62:	4620      	mov	r0, r4
 800de64:	f003 ff32 	bl	8011ccc <SPI_I2S_ITConfig>
          massert(xSemaphoreTake(spiData[spiNum].xSemaphore, portMAX_DELAY ) == pdTRUE );
 800de68:	4b0d      	ldr	r3, [pc, #52]	; (800dea0 <txSPI+0x78>)
 800de6a:	ebc6 06c6 	rsb	r6, r6, r6, lsl #3
 800de6e:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 800de72:	4629      	mov	r1, r5
 800de74:	462b      	mov	r3, r5
 800de76:	69b0      	ldr	r0, [r6, #24]
 800de78:	f04f 32ff 	mov.w	r2, #4294967295
 800de7c:	f7fd f894 	bl	800afa8 <xQueueGenericReceive>
 800de80:	2801      	cmp	r0, #1
 800de82:	d0de      	beq.n	800de42 <txSPI+0x1a>
 800de84:	4b07      	ldr	r3, [pc, #28]	; (800dea4 <txSPI+0x7c>)
 800de86:	4908      	ldr	r1, [pc, #32]	; (800dea8 <txSPI+0x80>)
 800de88:	4808      	ldr	r0, [pc, #32]	; (800deac <txSPI+0x84>)
 800de8a:	2224      	movs	r2, #36	; 0x24
 800de8c:	f7fa fc6a 	bl	8008764 <xprintf>
 800de90:	2301      	movs	r3, #1
 800de92:	9301      	str	r3, [sp, #4]
 800de94:	9b01      	ldr	r3, [sp, #4]
 800de96:	2b00      	cmp	r3, #0
 800de98:	d1fc      	bne.n	800de94 <txSPI+0x6c>
 800de9a:	e7d2      	b.n	800de42 <txSPI+0x1a>
 800de9c:	2001ad84 	.word	0x2001ad84
 800dea0:	2001aa84 	.word	0x2001aa84
 800dea4:	0801d758 	.word	0x0801d758
 800dea8:	0801d718 	.word	0x0801d718
 800deac:	0801d7a0 	.word	0x0801d7a0

0800deb0 <rxSPI>:
        }
    }
  while (SPI_I2S_GetFlagStatus(spi, SPI_FLAG_TXE) == RESET);
}
uint8_t  __attribute__((optimize("-O3")))rxSPI(void *spi)
{
 800deb0:	b510      	push	{r4, lr}
 800deb2:	4604      	mov	r4, r0
  while (SPI_I2S_GetFlagStatus(spi, SPI_FLAG_RXNE) == RESET);
 800deb4:	2101      	movs	r1, #1
 800deb6:	4620      	mov	r0, r4
 800deb8:	f003 ff56 	bl	8011d68 <SPI_I2S_GetFlagStatus>
 800debc:	2800      	cmp	r0, #0
 800debe:	d0f9      	beq.n	800deb4 <rxSPI+0x4>
  //  while (SPI_I2S_GetFlagStatus(spi, SPI_FLAG_BSY) != RESET);
  return SPI_I2S_ReceiveData(spi);
 800dec0:	4620      	mov	r0, r4
 800dec2:	f003 fe67 	bl	8011b94 <SPI_I2S_ReceiveData>
}
 800dec6:	b2c0      	uxtb	r0, r0
 800dec8:	bd10      	pop	{r4, pc}
	...

0800decc <configureDMAforSPI>:

void __attribute__((optimize("-O3")))configureDMAforSPI(void *spi, void *txBuffer, void *rxBuffer, int size)
{
 800decc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ded0:	b090      	sub	sp, #64	; 0x40
 800ded2:	461c      	mov	r4, r3
 800ded4:	460d      	mov	r5, r1
 800ded6:	4616      	mov	r6, r2
 800ded8:	4607      	mov	r7, r0
  int spiNum = spiToSpiNum(spi);
 800deda:	f001 fc25 	bl	800f728 <spiToSpiNum>
  if (spiNum != -1)
 800dede:	1c43      	adds	r3, r0, #1
 800dee0:	d069      	beq.n	800dfb6 <configureDMAforSPI+0xea>
 800dee2:	4681      	mov	r9, r0
    {
      //Discard old data
      (void)SPI_I2S_ReceiveData(spi);
 800dee4:	4638      	mov	r0, r7
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
 800dee6:	ea4f 07c9 	mov.w	r7, r9, lsl #3
 800deea:	f8df 8108 	ldr.w	r8, [pc, #264]	; 800dff4 <configureDMAforSPI+0x128>
 800deee:	ebc9 0a07 	rsb	sl, r9, r7
 800def2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
{
  int spiNum = spiToSpiNum(spi);
  if (spiNum != -1)
    {
      //Discard old data
      (void)SPI_I2S_ReceiveData(spi);
 800def6:	f003 fe4d 	bl	8011b94 <SPI_I2S_ReceiveData>
      DMA_InitTypeDef  DMA_InitStructure;
      /* Configure DMA Initialization Structure */
      DMA_InitStructure.DMA_BufferSize = size ;
 800defa:	9405      	str	r4, [sp, #20]
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
 800defc:	eb08 040a 	add.w	r4, r8, sl
 800df00:	f858 200a 	ldr.w	r2, [r8, sl]
      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
      /* Configure TX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
 800df04:	68e3      	ldr	r3, [r4, #12]
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)txBuffer ;
      DMA_Init(spiData[spiNum].txStream, &DMA_InitStructure);
 800df06:	6860      	ldr	r0, [r4, #4]
      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
      /* Configure TX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
 800df08:	9301      	str	r3, [sp, #4]
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
 800df0a:	320c      	adds	r2, #12
      DMA_InitStructure.DMA_BufferSize = size ;
      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable ;
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800df0c:	f44f 6380 	mov.w	r3, #1024	; 0x400
      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
      /* Configure TX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)txBuffer ;
 800df10:	9503      	str	r5, [sp, #12]
      DMA_Init(spiData[spiNum].txStream, &DMA_InitStructure);
 800df12:	a901      	add	r1, sp, #4
      //Discard old data
      (void)SPI_I2S_ReceiveData(spi);
      DMA_InitTypeDef  DMA_InitStructure;
      /* Configure DMA Initialization Structure */
      DMA_InitStructure.DMA_BufferSize = size ;
      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable ;
 800df14:	2500      	movs	r5, #0
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
 800df16:	9202      	str	r2, [sp, #8]
      DMA_InitStructure.DMA_BufferSize = size ;
      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable ;
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800df18:	9307      	str	r3, [sp, #28]
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800df1a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
      /* Configure TX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
 800df1e:	2340      	movs	r3, #64	; 0x40
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800df20:	920b      	str	r2, [sp, #44]	; 0x2c
      /* Configure TX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
 800df22:	9304      	str	r3, [sp, #16]
      //Discard old data
      (void)SPI_I2S_ReceiveData(spi);
      DMA_InitTypeDef  DMA_InitStructure;
      /* Configure DMA Initialization Structure */
      DMA_InitStructure.DMA_BufferSize = size ;
      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable ;
 800df24:	950c      	str	r5, [sp, #48]	; 0x30
      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull ;
 800df26:	950d      	str	r5, [sp, #52]	; 0x34
      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single ;
 800df28:	950e      	str	r5, [sp, #56]	; 0x38
      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800df2a:	9509      	str	r5, [sp, #36]	; 0x24
      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 800df2c:	950a      	str	r5, [sp, #40]	; 0x28
      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) (&(spiData[spiNum].SPIx->DR)) ;
      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 800df2e:	950f      	str	r5, [sp, #60]	; 0x3c
      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 800df30:	9508      	str	r5, [sp, #32]
      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800df32:	9506      	str	r5, [sp, #24]
      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
      /* Configure TX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)txBuffer ;
      DMA_Init(spiData[spiNum].txStream, &DMA_InitStructure);
 800df34:	f004 fc6c 	bl	8012810 <DMA_Init>
      /* Configure RX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].rxChannel ;
 800df38:	6923      	ldr	r3, [r4, #16]
      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)rxBuffer ;
      DMA_Init(spiData[spiNum].rxStream, &DMA_InitStructure);
 800df3a:	68a0      	ldr	r0, [r4, #8]
      DMA_InitStructure.DMA_Channel = spiData[spiNum].txChannel ;
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)txBuffer ;
      DMA_Init(spiData[spiNum].txStream, &DMA_InitStructure);
      /* Configure RX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].rxChannel ;
 800df3c:	9301      	str	r3, [sp, #4]
      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)rxBuffer ;
      DMA_Init(spiData[spiNum].rxStream, &DMA_InitStructure);
 800df3e:	a901      	add	r1, sp, #4
      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral ;
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)txBuffer ;
      DMA_Init(spiData[spiNum].txStream, &DMA_InitStructure);
      /* Configure RX DMA */
      DMA_InitStructure.DMA_Channel = spiData[spiNum].rxChannel ;
      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory ;
 800df40:	9504      	str	r5, [sp, #16]
      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)rxBuffer ;
 800df42:	9603      	str	r6, [sp, #12]
      DMA_Init(spiData[spiNum].rxStream, &DMA_InitStructure);
 800df44:	f004 fc64 	bl	8012810 <DMA_Init>


      DMA_ITConfig(spiData[spiNum].rxStream, DMA_IT_TC, ENABLE);
 800df48:	2201      	movs	r2, #1
 800df4a:	68a0      	ldr	r0, [r4, #8]
 800df4c:	2110      	movs	r1, #16
 800df4e:	f004 fd9d 	bl	8012a8c <DMA_ITConfig>
      DMA_Cmd(spiData[spiNum].rxStream, ENABLE);
 800df52:	68a0      	ldr	r0, [r4, #8]
 800df54:	2101      	movs	r1, #1
 800df56:	f004 fd49 	bl	80129ec <DMA_Cmd>
      DMA_Cmd(spiData[spiNum].txStream, ENABLE);
 800df5a:	6860      	ldr	r0, [r4, #4]
 800df5c:	2101      	movs	r1, #1
 800df5e:	f004 fd45 	bl	80129ec <DMA_Cmd>

      SPI_Cmd(spiData[spiNum].SPIx, ENABLE);
 800df62:	f858 000a 	ldr.w	r0, [r8, sl]
 800df66:	2101      	movs	r1, #1
 800df68:	f003 fddc 	bl	8011b24 <SPI_Cmd>

      //Wait for the end of transaction
      if(spiNoIRQ)
 800df6c:	4b1d      	ldr	r3, [pc, #116]	; (800dfe4 <configureDMAforSPI+0x118>)
 800df6e:	681b      	ldr	r3, [r3, #0]
 800df70:	b323      	cbz	r3, 800dfbc <configureDMAforSPI+0xf0>
        {
          while(!DMA_GetITStatus(spiData[spiNum].rxStream, spiData[spiNum].intMask));
 800df72:	6961      	ldr	r1, [r4, #20]
 800df74:	68a0      	ldr	r0, [r4, #8]
 800df76:	f004 fdf9 	bl	8012b6c <DMA_GetITStatus>
 800df7a:	2800      	cmp	r0, #0
 800df7c:	d0f9      	beq.n	800df72 <configureDMAforSPI+0xa6>
          DMA_ClearITPendingBit(spiData[spiNum].rxStream, spiData[spiNum].intMask);
 800df7e:	6961      	ldr	r1, [r4, #20]
 800df80:	68a0      	ldr	r0, [r4, #8]
 800df82:	f004 ff3b 	bl	8012dfc <DMA_ClearITPendingBit>
      else
        {
          massert(xSemaphoreTake(spiData[spiNum].xSemaphore, portMAX_DELAY ) == pdTRUE );
        }

      SPI_Cmd(spiData[spiNum].SPIx, DISABLE);
 800df86:	ebc9 0707 	rsb	r7, r9, r7
 800df8a:	00bf      	lsls	r7, r7, #2
 800df8c:	eb08 0407 	add.w	r4, r8, r7
 800df90:	f858 0007 	ldr.w	r0, [r8, r7]
 800df94:	2100      	movs	r1, #0
 800df96:	f003 fdc5 	bl	8011b24 <SPI_Cmd>

      DMA_Cmd(spiData[spiNum].rxStream, DISABLE);
 800df9a:	68a0      	ldr	r0, [r4, #8]
 800df9c:	2100      	movs	r1, #0
 800df9e:	f004 fd25 	bl	80129ec <DMA_Cmd>
      DMA_Cmd(spiData[spiNum].txStream, DISABLE);
 800dfa2:	6860      	ldr	r0, [r4, #4]
 800dfa4:	2100      	movs	r1, #0
 800dfa6:	f004 fd21 	bl	80129ec <DMA_Cmd>
      DMA_DeInit(spiData[spiNum].txStream);
 800dfaa:	6860      	ldr	r0, [r4, #4]
 800dfac:	f004 fb6a 	bl	8012684 <DMA_DeInit>
      DMA_DeInit(spiData[spiNum].rxStream);
 800dfb0:	68a0      	ldr	r0, [r4, #8]
 800dfb2:	f004 fb67 	bl	8012684 <DMA_DeInit>

    }
}
 800dfb6:	b010      	add	sp, #64	; 0x40
 800dfb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          while(!DMA_GetITStatus(spiData[spiNum].rxStream, spiData[spiNum].intMask));
          DMA_ClearITPendingBit(spiData[spiNum].rxStream, spiData[spiNum].intMask);
        }
      else
        {
          massert(xSemaphoreTake(spiData[spiNum].xSemaphore, portMAX_DELAY ) == pdTRUE );
 800dfbc:	69a0      	ldr	r0, [r4, #24]
 800dfbe:	4619      	mov	r1, r3
 800dfc0:	f04f 32ff 	mov.w	r2, #4294967295
 800dfc4:	f7fc fff0 	bl	800afa8 <xQueueGenericReceive>
 800dfc8:	2801      	cmp	r0, #1
 800dfca:	d0dc      	beq.n	800df86 <configureDMAforSPI+0xba>
 800dfcc:	4b06      	ldr	r3, [pc, #24]	; (800dfe8 <configureDMAforSPI+0x11c>)
 800dfce:	4907      	ldr	r1, [pc, #28]	; (800dfec <configureDMAforSPI+0x120>)
 800dfd0:	4807      	ldr	r0, [pc, #28]	; (800dff0 <configureDMAforSPI+0x124>)
 800dfd2:	225f      	movs	r2, #95	; 0x5f
 800dfd4:	f7fa fbc6 	bl	8008764 <xprintf>
 800dfd8:	2301      	movs	r3, #1
 800dfda:	9300      	str	r3, [sp, #0]
 800dfdc:	9b00      	ldr	r3, [sp, #0]
 800dfde:	2b00      	cmp	r3, #0
 800dfe0:	d1fc      	bne.n	800dfdc <configureDMAforSPI+0x110>
 800dfe2:	e7d0      	b.n	800df86 <configureDMAforSPI+0xba>
 800dfe4:	2001ad84 	.word	0x2001ad84
 800dfe8:	0801d758 	.word	0x0801d758
 800dfec:	0801d720 	.word	0x0801d720
 800dff0:	0801d7a0 	.word	0x0801d7a0
 800dff4:	2001aa84 	.word	0x2001aa84

0800dff8 <ADC_hwInit>:
extern int sensADC;
//Create IRQ handler for ADC
ADC_HANDLER(DMA2, 0, ADC_xSemaphore);

void ADC_hwInit(void)
{
 800dff8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dffa:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStructure;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
 800dffc:	a90e      	add	r1, sp, #56	; 0x38
 800dffe:	230f      	movs	r3, #15
void ADC_hwInit(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800e000:	2400      	movs	r4, #0
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
 800e002:	f841 3d30 	str.w	r3, [r1, #-48]!

void ADC_hwInit(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 800e006:	2603      	movs	r6, #3
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800e008:	4846      	ldr	r0, [pc, #280]	; (800e124 <ADC_hwInit+0x12c>)

void ADC_hwInit(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 800e00a:	f88d 600c 	strb.w	r6, [sp, #12]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800e00e:	f88d 400f 	strb.w	r4, [sp, #15]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800e012:	f002 feb7 	bl	8010d84 <GPIO_Init>

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
 800e016:	2101      	movs	r1, #1
 800e018:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800e01c:	f003 f8ca 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 800e020:	2101      	movs	r1, #1
 800e022:	2004      	movs	r0, #4
 800e024:	f003 f8c6 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 800e028:	2101      	movs	r1, #1
 800e02a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800e02e:	f003 f909 	bl	8011244 <RCC_APB2PeriphClockCmd>
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
  ADC_CommonInit(&ADC_CommonInitStructure);
 800e032:	a804      	add	r0, sp, #16

  /* ADC1 configuration ------------------------------------------------------*/
  ADC_InitTypeDef ADC_InitStructure;
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 800e034:	2501      	movs	r5, #1
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 4;
 800e036:	2704      	movs	r7, #4
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 800e038:	9404      	str	r4, [sp, #16]
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 800e03a:	9405      	str	r4, [sp, #20]
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 800e03c:	9406      	str	r4, [sp, #24]
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 800e03e:	9407      	str	r4, [sp, #28]
  ADC_CommonInit(&ADC_CommonInitStructure);
 800e040:	f004 ffc8 	bl	8012fd4 <ADC_CommonInit>
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 4;
  ADC_Init(ADC1, &ADC_InitStructure);
 800e044:	a908      	add	r1, sp, #32
 800e046:	4838      	ldr	r0, [pc, #224]	; (800e128 <ADC_hwInit+0x130>)
  ADC_CommonInit(&ADC_CommonInitStructure);

  /* ADC1 configuration ------------------------------------------------------*/
  ADC_InitTypeDef ADC_InitStructure;
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 800e048:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 800e04c:	f88d 5025 	strb.w	r5, [sp, #37]	; 0x25
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
  ADC_CommonInit(&ADC_CommonInitStructure);

  /* ADC1 configuration ------------------------------------------------------*/
  ADC_InitTypeDef ADC_InitStructure;
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 800e050:	9408      	str	r4, [sp, #32]
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 800e052:	940a      	str	r4, [sp, #40]	; 0x28
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800e054:	940b      	str	r4, [sp, #44]	; 0x2c
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 800e056:	940c      	str	r4, [sp, #48]	; 0x30
  ADC_InitStructure.ADC_NbrOfConversion = 4;
 800e058:	f88d 7034 	strb.w	r7, [sp, #52]	; 0x34
  ADC_Init(ADC1, &ADC_InitStructure);
 800e05c:	f004 ff38 	bl	8012ed0 <ADC_Init>


  /* ADC1 regular channel14 configuration */
  ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_28Cycles);
 800e060:	462a      	mov	r2, r5
 800e062:	2302      	movs	r3, #2
 800e064:	210a      	movs	r1, #10
 800e066:	4830      	ldr	r0, [pc, #192]	; (800e128 <ADC_hwInit+0x130>)
 800e068:	f005 f824 	bl	80130b4 <ADC_RegularChannelConfig>
  ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 2, ADC_SampleTime_28Cycles);
 800e06c:	2302      	movs	r3, #2
 800e06e:	461a      	mov	r2, r3
 800e070:	210b      	movs	r1, #11
 800e072:	482d      	ldr	r0, [pc, #180]	; (800e128 <ADC_hwInit+0x130>)
 800e074:	f005 f81e 	bl	80130b4 <ADC_RegularChannelConfig>
  ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 3, ADC_SampleTime_28Cycles);
 800e078:	2302      	movs	r3, #2
 800e07a:	4632      	mov	r2, r6
 800e07c:	210c      	movs	r1, #12
 800e07e:	482a      	ldr	r0, [pc, #168]	; (800e128 <ADC_hwInit+0x130>)
 800e080:	f005 f818 	bl	80130b4 <ADC_RegularChannelConfig>
  ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 4, ADC_SampleTime_28Cycles);
 800e084:	2302      	movs	r3, #2
 800e086:	463a      	mov	r2, r7
 800e088:	210d      	movs	r1, #13
 800e08a:	4827      	ldr	r0, [pc, #156]	; (800e128 <ADC_hwInit+0x130>)
 800e08c:	f005 f812 	bl	80130b4 <ADC_RegularChannelConfig>

  ADC_DMACmd(ADC1, ENABLE);
 800e090:	4629      	mov	r1, r5
 800e092:	4825      	ldr	r0, [pc, #148]	; (800e128 <ADC_hwInit+0x130>)
 800e094:	f005 f89e 	bl	80131d4 <ADC_DMACmd>
  ADC_DMARequestAfterLastTransferCmd(ADC1, ENABLE);
 800e098:	4629      	mov	r1, r5
 800e09a:	4823      	ldr	r0, [pc, #140]	; (800e128 <ADC_hwInit+0x130>)
 800e09c:	f005 f8c4 	bl	8013228 <ADC_DMARequestAfterLastTransferCmd>

  /* Enable ADC1 */
  ADC_Cmd(ADC1, ENABLE);
 800e0a0:	4629      	mov	r1, r5
 800e0a2:	4821      	ldr	r0, [pc, #132]	; (800e128 <ADC_hwInit+0x130>)
 800e0a4:	f004 ffdc 	bl	8013060 <ADC_Cmd>

  vSemaphoreCreateBinary(ADC_xSemaphore);
 800e0a8:	4628      	mov	r0, r5
 800e0aa:	4632      	mov	r2, r6
 800e0ac:	4621      	mov	r1, r4
 800e0ae:	f7fc fe53 	bl	800ad58 <xQueueGenericCreate>
 800e0b2:	4d1e      	ldr	r5, [pc, #120]	; (800e12c <ADC_hwInit+0x134>)
 800e0b4:	6028      	str	r0, [r5, #0]
 800e0b6:	b120      	cbz	r0, 800e0c2 <ADC_hwInit+0xca>
 800e0b8:	4623      	mov	r3, r4
 800e0ba:	4622      	mov	r2, r4
 800e0bc:	4621      	mov	r1, r4
 800e0be:	f7fc fe70 	bl	800ada2 <xQueueGenericSend>
  massert(ADC_xSemaphore != NULL);
 800e0c2:	682b      	ldr	r3, [r5, #0]
 800e0c4:	b14b      	cbz	r3, 800e0da <ADC_hwInit+0xe2>
  massert(xSemaphoreTake(ADC_xSemaphore, portMAX_DELAY ) == pdTRUE );
 800e0c6:	2300      	movs	r3, #0
 800e0c8:	f04f 32ff 	mov.w	r2, #4294967295
 800e0cc:	4619      	mov	r1, r3
 800e0ce:	6828      	ldr	r0, [r5, #0]
 800e0d0:	f7fc ff6a 	bl	800afa8 <xQueueGenericReceive>
 800e0d4:	2801      	cmp	r0, #1
 800e0d6:	d10c      	bne.n	800e0f2 <ADC_hwInit+0xfa>
 800e0d8:	e016      	b.n	800e108 <ADC_hwInit+0x110>

  /* Enable ADC1 */
  ADC_Cmd(ADC1, ENABLE);

  vSemaphoreCreateBinary(ADC_xSemaphore);
  massert(ADC_xSemaphore != NULL);
 800e0da:	4b15      	ldr	r3, [pc, #84]	; (800e130 <ADC_hwInit+0x138>)
 800e0dc:	4915      	ldr	r1, [pc, #84]	; (800e134 <ADC_hwInit+0x13c>)
 800e0de:	4816      	ldr	r0, [pc, #88]	; (800e138 <ADC_hwInit+0x140>)
 800e0e0:	229f      	movs	r2, #159	; 0x9f
 800e0e2:	f7fa fb3f 	bl	8008764 <xprintf>
 800e0e6:	2301      	movs	r3, #1
 800e0e8:	9300      	str	r3, [sp, #0]
 800e0ea:	9b00      	ldr	r3, [sp, #0]
 800e0ec:	2b00      	cmp	r3, #0
 800e0ee:	d1fc      	bne.n	800e0ea <ADC_hwInit+0xf2>
 800e0f0:	e7e9      	b.n	800e0c6 <ADC_hwInit+0xce>
  massert(xSemaphoreTake(ADC_xSemaphore, portMAX_DELAY ) == pdTRUE );
 800e0f2:	4b12      	ldr	r3, [pc, #72]	; (800e13c <ADC_hwInit+0x144>)
 800e0f4:	490f      	ldr	r1, [pc, #60]	; (800e134 <ADC_hwInit+0x13c>)
 800e0f6:	4810      	ldr	r0, [pc, #64]	; (800e138 <ADC_hwInit+0x140>)
 800e0f8:	22a0      	movs	r2, #160	; 0xa0
 800e0fa:	f7fa fb33 	bl	8008764 <xprintf>
 800e0fe:	2301      	movs	r3, #1
 800e100:	9301      	str	r3, [sp, #4]
 800e102:	9b01      	ldr	r3, [sp, #4]
 800e104:	2b00      	cmp	r3, #0
 800e106:	d1fc      	bne.n	800e102 <ADC_hwInit+0x10a>

  ADC_INIT_HANDLER(DMA2, 0);
 800e108:	490d      	ldr	r1, [pc, #52]	; (800e140 <ADC_hwInit+0x148>)
 800e10a:	2038      	movs	r0, #56	; 0x38
 800e10c:	f7fa f8ce 	bl	80082ac <registerIRQ>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800e110:	4b0c      	ldr	r3, [pc, #48]	; (800e144 <ADC_hwInit+0x14c>)
 800e112:	22f0      	movs	r2, #240	; 0xf0
 800e114:	f883 2338 	strb.w	r2, [r3, #824]	; 0x338
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800e118:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800e11c:	605a      	str	r2, [r3, #4]
}
 800e11e:	b00f      	add	sp, #60	; 0x3c
 800e120:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e122:	bf00      	nop
 800e124:	40020800 	.word	0x40020800
 800e128:	40012000 	.word	0x40012000
 800e12c:	2001ae50 	.word	0x2001ae50
 800e130:	0801d73e 	.word	0x0801d73e
 800e134:	0801d733 	.word	0x0801d733
 800e138:	0801d7a0 	.word	0x0801d7a0
 800e13c:	0801d634 	.word	0x0801d634
 800e140:	0800dd79 	.word	0x0800dd79
 800e144:	e000e100 	.word	0xe000e100

0800e148 <ADC_startConversion>:

void ADC_startConversion(uint16_t *buffer, int size)
{
 800e148:	b570      	push	{r4, r5, r6, lr}

  DMA_InitTypeDef       DMA_InitStructure;
  DMA_DeInit(DMA2_Stream0);
 800e14a:	4c1b      	ldr	r4, [pc, #108]	; (800e1b8 <ADC_startConversion+0x70>)

  ADC_INIT_HANDLER(DMA2, 0);
}

void ADC_startConversion(uint16_t *buffer, int size)
{
 800e14c:	b090      	sub	sp, #64	; 0x40
 800e14e:	4606      	mov	r6, r0

  DMA_InitTypeDef       DMA_InitStructure;
  DMA_DeInit(DMA2_Stream0);
 800e150:	4620      	mov	r0, r4

  ADC_INIT_HANDLER(DMA2, 0);
}

void ADC_startConversion(uint16_t *buffer, int size)
{
 800e152:	460d      	mov	r5, r1

  DMA_InitTypeDef       DMA_InitStructure;
  DMA_DeInit(DMA2_Stream0);
 800e154:	f004 fa96 	bl	8012684 <DMA_DeInit>
  DMA_InitStructure.DMA_Channel = ADC_Channel_0;
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
 800e158:	4a18      	ldr	r2, [pc, #96]	; (800e1bc <ADC_startConversion+0x74>)
 800e15a:	9202      	str	r2, [sp, #8]
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
  DMA_InitStructure.DMA_BufferSize = size / sizeof(uint16_t);
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800e15c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800e160:	9207      	str	r2, [sp, #28]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 800e162:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800e166:	9208      	str	r2, [sp, #32]
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 800e168:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800e16c:	9209      	str	r2, [sp, #36]	; 0x24
  DMA_DeInit(DMA2_Stream0);
  DMA_InitStructure.DMA_Channel = ADC_Channel_0;
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
  DMA_InitStructure.DMA_BufferSize = size / sizeof(uint16_t);
 800e16e:	086d      	lsrs	r5, r5, #1
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800e170:	f44f 7280 	mov.w	r2, #256	; 0x100
void ADC_startConversion(uint16_t *buffer, int size)
{

  DMA_InitTypeDef       DMA_InitStructure;
  DMA_DeInit(DMA2_Stream0);
  DMA_InitStructure.DMA_Channel = ADC_Channel_0;
 800e174:	2300      	movs	r3, #0
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
  DMA_InitStructure.DMA_BufferSize = size / sizeof(uint16_t);
 800e176:	9505      	str	r5, [sp, #20]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800e178:	920a      	str	r2, [sp, #40]	; 0x28
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
 800e17a:	2501      	movs	r5, #1
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800e17c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 800e180:	a901      	add	r1, sp, #4
 800e182:	4620      	mov	r0, r4
void ADC_startConversion(uint16_t *buffer, int size)
{

  DMA_InitTypeDef       DMA_InitStructure;
  DMA_DeInit(DMA2_Stream0);
  DMA_InitStructure.DMA_Channel = ADC_Channel_0;
 800e184:	9301      	str	r3, [sp, #4]
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 800e186:	9304      	str	r3, [sp, #16]
  DMA_InitStructure.DMA_BufferSize = size / sizeof(uint16_t);
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800e188:	9306      	str	r3, [sp, #24]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
 800e18a:	930c      	str	r3, [sp, #48]	; 0x30
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 800e18c:	930e      	str	r3, [sp, #56]	; 0x38
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 800e18e:	930f      	str	r3, [sp, #60]	; 0x3c
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 800e190:	920b      	str	r2, [sp, #44]	; 0x2c

  DMA_InitTypeDef       DMA_InitStructure;
  DMA_DeInit(DMA2_Stream0);
  DMA_InitStructure.DMA_Channel = ADC_Channel_0;
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
 800e192:	9603      	str	r6, [sp, #12]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
 800e194:	950d      	str	r5, [sp, #52]	; 0x34
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 800e196:	f004 fb3b 	bl	8012810 <DMA_Init>
  DMA_ITConfig(DMA2_Stream0, DMA_IT_TC | DMA_IT_HT, ENABLE);
 800e19a:	462a      	mov	r2, r5
 800e19c:	4620      	mov	r0, r4
 800e19e:	2118      	movs	r1, #24
 800e1a0:	f004 fc74 	bl	8012a8c <DMA_ITConfig>
  DMA_Cmd(DMA2_Stream0, ENABLE);
 800e1a4:	4629      	mov	r1, r5
 800e1a6:	4620      	mov	r0, r4
 800e1a8:	f004 fc20 	bl	80129ec <DMA_Cmd>

  ADC_SoftwareStartConv(ADC1);
 800e1ac:	4804      	ldr	r0, [pc, #16]	; (800e1c0 <ADC_startConversion+0x78>)
 800e1ae:	f004 fff5 	bl	801319c <ADC_SoftwareStartConv>
}
 800e1b2:	b010      	add	sp, #64	; 0x40
 800e1b4:	bd70      	pop	{r4, r5, r6, pc}
 800e1b6:	bf00      	nop
 800e1b8:	40026410 	.word	0x40026410
 800e1bc:	4001204c 	.word	0x4001204c
 800e1c0:	40012000 	.word	0x40012000

0800e1c4 <readPin>:
  APPLY_MASK(GPIOx->MODER, 3 * mask, GPIO_Mode_OUT * mask);
  GPIO_WriteBit(GPIOx, GPIO_Pin, state);
}

inline uint8_t readPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 800e1c4:	b570      	push	{r4, r5, r6, lr}
  uint32_t mask = GPIO_Pin * GPIO_Pin;
 800e1c6:	fb01 f501 	mul.w	r5, r1, r1
  APPLY_MASK(GPIOx->MODER, 3 * mask, GPIO_Mode_IN * mask);
 800e1ca:	006e      	lsls	r6, r5, #1
 800e1cc:	6802      	ldr	r2, [r0, #0]
 800e1ce:	4435      	add	r5, r6
 800e1d0:	43ed      	mvns	r5, r5
 800e1d2:	402a      	ands	r2, r5
 800e1d4:	6002      	str	r2, [r0, #0]
  APPLY_MASK(GPIOx->MODER, 3 * mask, GPIO_Mode_OUT * mask);
  GPIO_WriteBit(GPIOx, GPIO_Pin, state);
}

inline uint8_t readPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 800e1d6:	4604      	mov	r4, r0
  uint32_t mask = GPIO_Pin * GPIO_Pin;
  APPLY_MASK(GPIOx->MODER, 3 * mask, GPIO_Mode_IN * mask);
 800e1d8:	6803      	ldr	r3, [r0, #0]
 800e1da:	6003      	str	r3, [r0, #0]
  char status = GPIO_ReadInputDataBit(GPIOx, GPIO_Pin);
 800e1dc:	f002 fe70 	bl	8010ec0 <GPIO_ReadInputDataBit>
  APPLY_MASK(GPIOx->MODER, 3 * mask, GPIO_Mode_AF * mask);
 800e1e0:	6822      	ldr	r2, [r4, #0]
 800e1e2:	4015      	ands	r5, r2
 800e1e4:	6025      	str	r5, [r4, #0]
 800e1e6:	6823      	ldr	r3, [r4, #0]
 800e1e8:	4333      	orrs	r3, r6
 800e1ea:	6023      	str	r3, [r4, #0]

  return status;
}
 800e1ec:	bd70      	pop	{r4, r5, r6, pc}
	...

0800e1f0 <printfCommStats>:

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e1f0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i=0;
  portNum_t p;
  DPRINTF("Rx");
 800e1f4:	4c96      	ldr	r4, [pc, #600]	; (800e450 <printfCommStats+0x260>)
 800e1f6:	6823      	ldr	r3, [r4, #0]
 800e1f8:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e1fc:	da0b      	bge.n	800e216 <printfCommStats+0x26>
 800e1fe:	6860      	ldr	r0, [r4, #4]
 800e200:	4994      	ldr	r1, [pc, #592]	; (800e454 <printfCommStats+0x264>)
 800e202:	4418      	add	r0, r3
 800e204:	f7fa facc 	bl	80087a0 <xsprintf>
 800e208:	6825      	ldr	r5, [r4, #0]
 800e20a:	6860      	ldr	r0, [r4, #4]
 800e20c:	4428      	add	r0, r5
 800e20e:	f006 fa17 	bl	8014640 <strlen>
 800e212:	4428      	add	r0, r5
 800e214:	6020      	str	r0, [r4, #0]
  for(i = 0; i < MSG_TYPES_QTY; i++)
    {
      if(MSG_TYPES_TAB[i].code != 0)
 800e216:	f8df 9240 	ldr.w	r9, [pc, #576]	; 800e458 <printfCommStats+0x268>
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
 800e21a:	4e8d      	ldr	r6, [pc, #564]	; (800e450 <printfCommStats+0x260>)

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e21c:	2500      	movs	r5, #0
  int i=0;
  portNum_t p;
  DPRINTF("Rx");
  for(i = 0; i < MSG_TYPES_QTY; i++)
    {
      if(MSG_TYPES_TAB[i].code != 0)
 800e21e:	234c      	movs	r3, #76	; 0x4c
 800e220:	fb03 9305 	mla	r3, r3, r5, r9
 800e224:	4f8c      	ldr	r7, [pc, #560]	; (800e458 <printfCommStats+0x268>)
 800e226:	681a      	ldr	r2, [r3, #0]
 800e228:	b182      	cbz	r2, 800e24c <printfCommStats+0x5c>
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
 800e22a:	6820      	ldr	r0, [r4, #0]
 800e22c:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
 800e230:	da0c      	bge.n	800e24c <printfCommStats+0x5c>
 800e232:	6873      	ldr	r3, [r6, #4]
 800e234:	4989      	ldr	r1, [pc, #548]	; (800e45c <printfCommStats+0x26c>)
 800e236:	4418      	add	r0, r3
 800e238:	f7fa fab2 	bl	80087a0 <xsprintf>
 800e23c:	f8d6 8000 	ldr.w	r8, [r6]
 800e240:	6870      	ldr	r0, [r6, #4]
 800e242:	4440      	add	r0, r8
 800e244:	f006 f9fc 	bl	8014640 <strlen>
 800e248:	4440      	add	r0, r8
 800e24a:	6030      	str	r0, [r6, #0]
void printfCommStats(void)
{
  int i=0;
  portNum_t p;
  DPRINTF("Rx");
  for(i = 0; i < MSG_TYPES_QTY; i++)
 800e24c:	3501      	adds	r5, #1
 800e24e:	2d16      	cmp	r5, #22
 800e250:	d1e5      	bne.n	800e21e <printfCommStats+0x2e>
    {
      if(MSG_TYPES_TAB[i].code != 0)
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
    }
  DPRINTF(CLEAR_LINE"|\n");
 800e252:	6823      	ldr	r3, [r4, #0]
 800e254:	4d7e      	ldr	r5, [pc, #504]	; (800e450 <printfCommStats+0x260>)
 800e256:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e25a:	da0b      	bge.n	800e274 <printfCommStats+0x84>
 800e25c:	6868      	ldr	r0, [r5, #4]
 800e25e:	4980      	ldr	r1, [pc, #512]	; (800e460 <printfCommStats+0x270>)
 800e260:	4418      	add	r0, r3
 800e262:	f7fa fa9d 	bl	80087a0 <xsprintf>
 800e266:	682e      	ldr	r6, [r5, #0]
 800e268:	6868      	ldr	r0, [r5, #4]
 800e26a:	4430      	add	r0, r6
 800e26c:	f006 f9e8 	bl	8014640 <strlen>
 800e270:	4430      	add	r0, r6
 800e272:	6028      	str	r0, [r5, #0]
  for(p = 0; p < PORTS_NUM; p++)
    {
      if(portData[p].enabled == 0)
 800e274:	f8df a1fc 	ldr.w	sl, [pc, #508]	; 800e474 <printfCommStats+0x284>
        continue;

      DPRINTF(" %d|", p);
 800e278:	4d75      	ldr	r5, [pc, #468]	; (800e450 <printfCommStats+0x260>)

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e27a:	2600      	movs	r6, #0
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
    }
  DPRINTF(CLEAR_LINE"|\n");
  for(p = 0; p < PORTS_NUM; p++)
    {
      if(portData[p].enabled == 0)
 800e27c:	2350      	movs	r3, #80	; 0x50
 800e27e:	fb03 a306 	mla	r3, r3, r6, sl
 800e282:	f8df 81f0 	ldr.w	r8, [pc, #496]	; 800e474 <printfCommStats+0x284>
 800e286:	7edb      	ldrb	r3, [r3, #27]
 800e288:	2b00      	cmp	r3, #0
 800e28a:	d048      	beq.n	800e31e <printfCommStats+0x12e>
        continue;

      DPRINTF(" %d|", p);
 800e28c:	6820      	ldr	r0, [r4, #0]
 800e28e:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
 800e292:	da0d      	bge.n	800e2b0 <printfCommStats+0xc0>
 800e294:	686b      	ldr	r3, [r5, #4]
 800e296:	4973      	ldr	r1, [pc, #460]	; (800e464 <printfCommStats+0x274>)
 800e298:	4418      	add	r0, r3
 800e29a:	4632      	mov	r2, r6
 800e29c:	f7fa fa80 	bl	80087a0 <xsprintf>
 800e2a0:	f8d5 9000 	ldr.w	r9, [r5]
 800e2a4:	6868      	ldr	r0, [r5, #4]
 800e2a6:	4448      	add	r0, r9
 800e2a8:	f006 f9ca 	bl	8014640 <strlen>
 800e2ac:	4448      	add	r0, r9
 800e2ae:	6028      	str	r0, [r5, #0]
      for(i = 0; i < MSG_TYPES_QTY; i++)
        {
          if(MSG_TYPES_TAB[i].code != 0)
 800e2b0:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 800e458 <printfCommStats+0x268>

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e2b4:	f04f 0900 	mov.w	r9, #0
        continue;

      DPRINTF(" %d|", p);
      for(i = 0; i < MSG_TYPES_QTY; i++)
        {
          if(MSG_TYPES_TAB[i].code != 0)
 800e2b8:	234c      	movs	r3, #76	; 0x4c
 800e2ba:	fb03 7309 	mla	r3, r3, r9, r7
 800e2be:	681b      	ldr	r3, [r3, #0]
 800e2c0:	b1bb      	cbz	r3, 800e2f2 <printfCommStats+0x102>
            DPRINTF("%3d|", MSG_TYPES_TAB[i].received[p]);
 800e2c2:	6820      	ldr	r0, [r4, #0]
 800e2c4:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
 800e2c8:	da13      	bge.n	800e2f2 <printfCommStats+0x102>
 800e2ca:	2213      	movs	r2, #19
 800e2cc:	fb02 6209 	mla	r2, r2, r9, r6
 800e2d0:	686b      	ldr	r3, [r5, #4]
 800e2d2:	4965      	ldr	r1, [pc, #404]	; (800e468 <printfCommStats+0x278>)
 800e2d4:	320a      	adds	r2, #10
 800e2d6:	4418      	add	r0, r3
 800e2d8:	f85b 2022 	ldr.w	r2, [fp, r2, lsl #2]
 800e2dc:	f7fa fa60 	bl	80087a0 <xsprintf>
 800e2e0:	682b      	ldr	r3, [r5, #0]
 800e2e2:	6868      	ldr	r0, [r5, #4]
 800e2e4:	9301      	str	r3, [sp, #4]
 800e2e6:	4418      	add	r0, r3
 800e2e8:	f006 f9aa 	bl	8014640 <strlen>
 800e2ec:	9b01      	ldr	r3, [sp, #4]
 800e2ee:	4418      	add	r0, r3
 800e2f0:	6028      	str	r0, [r5, #0]
    {
      if(portData[p].enabled == 0)
        continue;

      DPRINTF(" %d|", p);
      for(i = 0; i < MSG_TYPES_QTY; i++)
 800e2f2:	f109 0901 	add.w	r9, r9, #1
 800e2f6:	f1b9 0f16 	cmp.w	r9, #22
 800e2fa:	d1dd      	bne.n	800e2b8 <printfCommStats+0xc8>
        {
          if(MSG_TYPES_TAB[i].code != 0)
            DPRINTF("%3d|", MSG_TYPES_TAB[i].received[p]);
        }
      DPRINTF(CLEAR_LINE"\n");
 800e2fc:	6823      	ldr	r3, [r4, #0]
 800e2fe:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e302:	da0c      	bge.n	800e31e <printfCommStats+0x12e>
 800e304:	6868      	ldr	r0, [r5, #4]
 800e306:	4959      	ldr	r1, [pc, #356]	; (800e46c <printfCommStats+0x27c>)
 800e308:	4418      	add	r0, r3
 800e30a:	f7fa fa49 	bl	80087a0 <xsprintf>
 800e30e:	f8d5 9000 	ldr.w	r9, [r5]
 800e312:	6868      	ldr	r0, [r5, #4]
 800e314:	4448      	add	r0, r9
 800e316:	f006 f993 	bl	8014640 <strlen>
 800e31a:	4448      	add	r0, r9
 800e31c:	6028      	str	r0, [r5, #0]
 800e31e:	3601      	adds	r6, #1
    {
      if(MSG_TYPES_TAB[i].code != 0)
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
    }
  DPRINTF(CLEAR_LINE"|\n");
  for(p = 0; p < PORTS_NUM; p++)
 800e320:	2e03      	cmp	r6, #3
 800e322:	d1ab      	bne.n	800e27c <printfCommStats+0x8c>
          if(MSG_TYPES_TAB[i].code != 0)
            DPRINTF("%3d|", MSG_TYPES_TAB[i].received[p]);
        }
      DPRINTF(CLEAR_LINE"\n");
    }
  DPRINTF("Tx");
 800e324:	6823      	ldr	r3, [r4, #0]
 800e326:	4d4a      	ldr	r5, [pc, #296]	; (800e450 <printfCommStats+0x260>)
 800e328:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e32c:	da0b      	bge.n	800e346 <printfCommStats+0x156>
 800e32e:	6868      	ldr	r0, [r5, #4]
 800e330:	494f      	ldr	r1, [pc, #316]	; (800e470 <printfCommStats+0x280>)
 800e332:	4418      	add	r0, r3
 800e334:	f7fa fa34 	bl	80087a0 <xsprintf>
 800e338:	682e      	ldr	r6, [r5, #0]
 800e33a:	6868      	ldr	r0, [r5, #4]
 800e33c:	4430      	add	r0, r6
 800e33e:	f006 f97f 	bl	8014640 <strlen>
 800e342:	4430      	add	r0, r6
 800e344:	6028      	str	r0, [r5, #0]
  for(i = 0; i < MSG_TYPES_QTY; i++)
    {
      if(MSG_TYPES_TAB[i].code != 0)
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
 800e346:	4e42      	ldr	r6, [pc, #264]	; (800e450 <printfCommStats+0x260>)

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e348:	2500      	movs	r5, #0
      DPRINTF(CLEAR_LINE"\n");
    }
  DPRINTF("Tx");
  for(i = 0; i < MSG_TYPES_QTY; i++)
    {
      if(MSG_TYPES_TAB[i].code != 0)
 800e34a:	f04f 0a4c 	mov.w	sl, #76	; 0x4c
 800e34e:	fb0a 7305 	mla	r3, sl, r5, r7
 800e352:	681a      	ldr	r2, [r3, #0]
 800e354:	b182      	cbz	r2, 800e378 <printfCommStats+0x188>
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
 800e356:	6820      	ldr	r0, [r4, #0]
 800e358:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
 800e35c:	da0c      	bge.n	800e378 <printfCommStats+0x188>
 800e35e:	6873      	ldr	r3, [r6, #4]
 800e360:	493e      	ldr	r1, [pc, #248]	; (800e45c <printfCommStats+0x26c>)
 800e362:	4418      	add	r0, r3
 800e364:	f7fa fa1c 	bl	80087a0 <xsprintf>
 800e368:	f8d6 9000 	ldr.w	r9, [r6]
 800e36c:	6870      	ldr	r0, [r6, #4]
 800e36e:	4448      	add	r0, r9
 800e370:	f006 f966 	bl	8014640 <strlen>
 800e374:	4448      	add	r0, r9
 800e376:	6030      	str	r0, [r6, #0]
            DPRINTF("%3d|", MSG_TYPES_TAB[i].received[p]);
        }
      DPRINTF(CLEAR_LINE"\n");
    }
  DPRINTF("Tx");
  for(i = 0; i < MSG_TYPES_QTY; i++)
 800e378:	3501      	adds	r5, #1
 800e37a:	2d16      	cmp	r5, #22
 800e37c:	d1e7      	bne.n	800e34e <printfCommStats+0x15e>
    {
      if(MSG_TYPES_TAB[i].code != 0)
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
    }
  DPRINTF(CLEAR_LINE"|\n");
 800e37e:	6823      	ldr	r3, [r4, #0]
 800e380:	4d33      	ldr	r5, [pc, #204]	; (800e450 <printfCommStats+0x260>)
 800e382:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e386:	da0b      	bge.n	800e3a0 <printfCommStats+0x1b0>
 800e388:	6868      	ldr	r0, [r5, #4]
 800e38a:	4935      	ldr	r1, [pc, #212]	; (800e460 <printfCommStats+0x270>)
 800e38c:	4418      	add	r0, r3
 800e38e:	f7fa fa07 	bl	80087a0 <xsprintf>
 800e392:	682e      	ldr	r6, [r5, #0]
 800e394:	6868      	ldr	r0, [r5, #4]
 800e396:	4430      	add	r0, r6
 800e398:	f006 f952 	bl	8014640 <strlen>
 800e39c:	4430      	add	r0, r6
 800e39e:	6028      	str	r0, [r5, #0]
  for(p = 0; p < PORTS_NUM; p++)
    {
      if(portData[p].enabled == 0)
        continue;

      DPRINTF(" %d|", p);
 800e3a0:	4d2b      	ldr	r5, [pc, #172]	; (800e450 <printfCommStats+0x260>)
      for(i = 0; i < MSG_TYPES_QTY; i++)
        {
          if(MSG_TYPES_TAB[i].code != 0)
 800e3a2:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 800e458 <printfCommStats+0x268>

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e3a6:	2600      	movs	r6, #0
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
    }
  DPRINTF(CLEAR_LINE"|\n");
  for(p = 0; p < PORTS_NUM; p++)
    {
      if(portData[p].enabled == 0)
 800e3a8:	2350      	movs	r3, #80	; 0x50
 800e3aa:	fb03 8306 	mla	r3, r3, r6, r8
 800e3ae:	7edb      	ldrb	r3, [r3, #27]
 800e3b0:	2b00      	cmp	r3, #0
 800e3b2:	d046      	beq.n	800e442 <printfCommStats+0x252>
        continue;

      DPRINTF(" %d|", p);
 800e3b4:	6820      	ldr	r0, [r4, #0]
 800e3b6:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
 800e3ba:	da0d      	bge.n	800e3d8 <printfCommStats+0x1e8>
 800e3bc:	686b      	ldr	r3, [r5, #4]
 800e3be:	4929      	ldr	r1, [pc, #164]	; (800e464 <printfCommStats+0x274>)
 800e3c0:	4418      	add	r0, r3
 800e3c2:	4632      	mov	r2, r6
 800e3c4:	f7fa f9ec 	bl	80087a0 <xsprintf>
 800e3c8:	f8d5 a000 	ldr.w	sl, [r5]
 800e3cc:	6868      	ldr	r0, [r5, #4]
 800e3ce:	4450      	add	r0, sl
 800e3d0:	f006 f936 	bl	8014640 <strlen>
 800e3d4:	4450      	add	r0, sl
 800e3d6:	6028      	str	r0, [r5, #0]

static char *bufPtr = NULL;
static int bSize = 0;
static int *bufSize = &bSize;
void printfCommStats(void)
{
 800e3d8:	f04f 0a00 	mov.w	sl, #0
        continue;

      DPRINTF(" %d|", p);
      for(i = 0; i < MSG_TYPES_QTY; i++)
        {
          if(MSG_TYPES_TAB[i].code != 0)
 800e3dc:	234c      	movs	r3, #76	; 0x4c
 800e3de:	fb03 730a 	mla	r3, r3, sl, r7
 800e3e2:	681b      	ldr	r3, [r3, #0]
 800e3e4:	b1bb      	cbz	r3, 800e416 <printfCommStats+0x226>
            DPRINTF("%3d|", MSG_TYPES_TAB[i].sent[p]);
 800e3e6:	6820      	ldr	r0, [r4, #0]
 800e3e8:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
 800e3ec:	da13      	bge.n	800e416 <printfCommStats+0x226>
 800e3ee:	2313      	movs	r3, #19
 800e3f0:	fb03 630a 	mla	r3, r3, sl, r6
 800e3f4:	330c      	adds	r3, #12
 800e3f6:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 800e3fa:	491b      	ldr	r1, [pc, #108]	; (800e468 <printfCommStats+0x278>)
 800e3fc:	685a      	ldr	r2, [r3, #4]
 800e3fe:	686b      	ldr	r3, [r5, #4]
 800e400:	4418      	add	r0, r3
 800e402:	f7fa f9cd 	bl	80087a0 <xsprintf>
 800e406:	f8d5 b000 	ldr.w	fp, [r5]
 800e40a:	6868      	ldr	r0, [r5, #4]
 800e40c:	4458      	add	r0, fp
 800e40e:	f006 f917 	bl	8014640 <strlen>
 800e412:	4458      	add	r0, fp
 800e414:	6028      	str	r0, [r5, #0]
    {
      if(portData[p].enabled == 0)
        continue;

      DPRINTF(" %d|", p);
      for(i = 0; i < MSG_TYPES_QTY; i++)
 800e416:	f10a 0a01 	add.w	sl, sl, #1
 800e41a:	f1ba 0f16 	cmp.w	sl, #22
 800e41e:	d1dd      	bne.n	800e3dc <printfCommStats+0x1ec>
        {
          if(MSG_TYPES_TAB[i].code != 0)
            DPRINTF("%3d|", MSG_TYPES_TAB[i].sent[p]);
        }
      DPRINTF(CLEAR_LINE"\n");
 800e420:	6823      	ldr	r3, [r4, #0]
 800e422:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e426:	da0c      	bge.n	800e442 <printfCommStats+0x252>
 800e428:	6868      	ldr	r0, [r5, #4]
 800e42a:	4910      	ldr	r1, [pc, #64]	; (800e46c <printfCommStats+0x27c>)
 800e42c:	4418      	add	r0, r3
 800e42e:	f7fa f9b7 	bl	80087a0 <xsprintf>
 800e432:	f8d5 a000 	ldr.w	sl, [r5]
 800e436:	6868      	ldr	r0, [r5, #4]
 800e438:	4450      	add	r0, sl
 800e43a:	f006 f901 	bl	8014640 <strlen>
 800e43e:	4450      	add	r0, sl
 800e440:	6028      	str	r0, [r5, #0]
 800e442:	3601      	adds	r6, #1
    {
      if(MSG_TYPES_TAB[i].code != 0)
        DPRINTF("| %02x", MSG_TYPES_TAB[i].code);
    }
  DPRINTF(CLEAR_LINE"|\n");
  for(p = 0; p < PORTS_NUM; p++)
 800e444:	2e03      	cmp	r6, #3
 800e446:	d1af      	bne.n	800e3a8 <printfCommStats+0x1b8>
          if(MSG_TYPES_TAB[i].code != 0)
            DPRINTF("%3d|", MSG_TYPES_TAB[i].sent[p]);
        }
      DPRINTF(CLEAR_LINE"\n");
    }
}
 800e448:	b003      	add	sp, #12
 800e44a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e44e:	bf00      	nop
 800e450:	2001ad88 	.word	0x2001ad88
 800e454:	0801d7c6 	.word	0x0801d7c6
 800e458:	2001a1e4 	.word	0x2001a1e4
 800e45c:	0801d7c9 	.word	0x0801d7c9
 800e460:	0801daec 	.word	0x0801daec
 800e464:	0801d7d0 	.word	0x0801d7d0
 800e468:	0801d7d5 	.word	0x0801d7d5
 800e46c:	08014a9c 	.word	0x08014a9c
 800e470:	0801d7da 	.word	0x0801d7da
 800e474:	2001aabc 	.word	0x2001aabc

0800e478 <dTask>:

#ifdef MADO
extern uint32_t usb_stats[10];
#endif
static void dTask(void *pvParameters)
{
 800e478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e47c:	b0b3      	sub	sp, #204	; 0xcc
  int i = 0;
 800e47e:	2300      	movs	r3, #0
 800e480:	4c16      	ldr	r4, [pc, #88]	; (800e4dc <dTask+0x64>)
 800e482:	9325      	str	r3, [sp, #148]	; 0x94
  while (1)
    {
      if(!cfg.stats)
 800e484:	4b16      	ldr	r3, [pc, #88]	; (800e4e0 <dTask+0x68>)
 800e486:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e488:	b933      	cbnz	r3, 800e498 <dTask+0x20>
        {
          vTaskDelay(100);
 800e48a:	2064      	movs	r0, #100	; 0x64
 800e48c:	f7fc fa00 	bl	800a890 <vTaskDelay>
#ifdef WATCHDOG_DEBUG
          wdogFeed(WATCHDOG_DEBUG());
 800e490:	2020      	movs	r0, #32
 800e492:	f000 fca5 	bl	800ede0 <wdogFeed>
#endif
          continue;
 800e496:	e7f5      	b.n	800e484 <dTask+0xc>
        }
#ifdef WATCHDOG_DEBUG
      if(i%10)
 800e498:	9925      	ldr	r1, [sp, #148]	; 0x94
 800e49a:	9a25      	ldr	r2, [sp, #148]	; 0x94
 800e49c:	230a      	movs	r3, #10
 800e49e:	fb92 f2f3 	sdiv	r2, r2, r3
 800e4a2:	fb03 1312 	mls	r3, r3, r2, r1
 800e4a6:	9326      	str	r3, [sp, #152]	; 0x98
 800e4a8:	b113      	cbz	r3, 800e4b0 <dTask+0x38>
        wdogFeed(WATCHDOG_DEBUG());
 800e4aa:	2020      	movs	r0, #32
 800e4ac:	f000 fc98 	bl	800ede0 <wdogFeed>
#endif

      vTaskDelay(1);
 800e4b0:	2001      	movs	r0, #1
 800e4b2:	f7fc f9ed 	bl	800a890 <vTaskDelay>
      if ((i % DISPLAY_INTERVAL) == 0 /* || refresh */)
 800e4b6:	9a25      	ldr	r2, [sp, #148]	; 0x94
 800e4b8:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800e4ba:	f241 3588 	movw	r5, #5000	; 0x1388
 800e4be:	fb93 f3f5 	sdiv	r3, r3, r5
 800e4c2:	fb05 2513 	mls	r5, r5, r3, r2
 800e4c6:	2d00      	cmp	r5, #0
 800e4c8:	f040 840e 	bne.w	800ece8 <dTask+0x870>
        {
          bufPtr = dAlloc(DBUFSIZE);
 800e4cc:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800e4d0:	f7ff f8ae 	bl	800d630 <bAlloc>
 800e4d4:	b130      	cbz	r0, 800e4e4 <dTask+0x6c>
 800e4d6:	3014      	adds	r0, #20
 800e4d8:	e005      	b.n	800e4e6 <dTask+0x6e>
 800e4da:	bf00      	nop
 800e4dc:	2001ad88 	.word	0x2001ad88
 800e4e0:	10001000 	.word	0x10001000
 800e4e4:	4628      	mov	r0, r5
          *bufSize = 0;

          DPRINTF(CUR_SAVE CUR_HOME(1) CLEAR_LINE"\n");
 800e4e6:	49a4      	ldr	r1, [pc, #656]	; (800e778 <dTask+0x300>)
#endif

      vTaskDelay(1);
      if ((i % DISPLAY_INTERVAL) == 0 /* || refresh */)
        {
          bufPtr = dAlloc(DBUFSIZE);
 800e4e8:	6060      	str	r0, [r4, #4]
          *bufSize = 0;
 800e4ea:	6025      	str	r5, [r4, #0]

          DPRINTF(CUR_SAVE CUR_HOME(1) CLEAR_LINE"\n");
 800e4ec:	f7fa f958 	bl	80087a0 <xsprintf>
 800e4f0:	e894 0060 	ldmia.w	r4, {r5, r6}
 800e4f4:	1970      	adds	r0, r6, r5
 800e4f6:	f006 f8a3 	bl	8014640 <strlen>
 800e4fa:	4428      	add	r0, r5
          DPRINTF("Build time %s %s revision:%s"CLEAR_LINE"\n", __DATE__, __TIME__, VERSION);
 800e4fc:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
      if ((i % DISPLAY_INTERVAL) == 0 /* || refresh */)
        {
          bufPtr = dAlloc(DBUFSIZE);
          *bufSize = 0;

          DPRINTF(CUR_SAVE CUR_HOME(1) CLEAR_LINE"\n");
 800e500:	6020      	str	r0, [r4, #0]
 800e502:	4d9e      	ldr	r5, [pc, #632]	; (800e77c <dTask+0x304>)
          DPRINTF("Build time %s %s revision:%s"CLEAR_LINE"\n", __DATE__, __TIME__, VERSION);
 800e504:	da0e      	bge.n	800e524 <dTask+0xac>
 800e506:	4b9e      	ldr	r3, [pc, #632]	; (800e780 <dTask+0x308>)
 800e508:	9300      	str	r3, [sp, #0]
 800e50a:	4430      	add	r0, r6
 800e50c:	4b9d      	ldr	r3, [pc, #628]	; (800e784 <dTask+0x30c>)
 800e50e:	4a9e      	ldr	r2, [pc, #632]	; (800e788 <dTask+0x310>)
 800e510:	499e      	ldr	r1, [pc, #632]	; (800e78c <dTask+0x314>)
 800e512:	f7fa f945 	bl	80087a0 <xsprintf>
 800e516:	6826      	ldr	r6, [r4, #0]
 800e518:	6860      	ldr	r0, [r4, #4]
 800e51a:	4430      	add	r0, r6
 800e51c:	f006 f890 	bl	8014640 <strlen>
 800e520:	4430      	add	r0, r6
 800e522:	6020      	str	r0, [r4, #0]
          if(cfg.stats&0x01)
 800e524:	4b9a      	ldr	r3, [pc, #616]	; (800e790 <dTask+0x318>)
 800e526:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e528:	07da      	lsls	r2, r3, #31
 800e52a:	f140 80cb 	bpl.w	800e6c4 <dTask+0x24c>
            {
              DPRINTF("heap: allocs:%d frees:%d allocated:%d last alloc size:%d "CLEAR_LINE"\n", heapAllocs, heapFrees, heapAllocated, heapLastSize);
 800e52e:	682e      	ldr	r6, [r5, #0]
 800e530:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e534:	da15      	bge.n	800e562 <dTask+0xea>
 800e536:	4b97      	ldr	r3, [pc, #604]	; (800e794 <dTask+0x31c>)
 800e538:	6860      	ldr	r0, [r4, #4]
 800e53a:	681b      	ldr	r3, [r3, #0]
 800e53c:	9301      	str	r3, [sp, #4]
 800e53e:	4b96      	ldr	r3, [pc, #600]	; (800e798 <dTask+0x320>)
 800e540:	4a96      	ldr	r2, [pc, #600]	; (800e79c <dTask+0x324>)
 800e542:	681b      	ldr	r3, [r3, #0]
 800e544:	9300      	str	r3, [sp, #0]
 800e546:	4b96      	ldr	r3, [pc, #600]	; (800e7a0 <dTask+0x328>)
 800e548:	6812      	ldr	r2, [r2, #0]
 800e54a:	681b      	ldr	r3, [r3, #0]
 800e54c:	4995      	ldr	r1, [pc, #596]	; (800e7a4 <dTask+0x32c>)
 800e54e:	4430      	add	r0, r6
 800e550:	f7fa f926 	bl	80087a0 <xsprintf>
 800e554:	6826      	ldr	r6, [r4, #0]
 800e556:	6860      	ldr	r0, [r4, #4]
 800e558:	4430      	add	r0, r6
 800e55a:	f006 f871 	bl	8014640 <strlen>
 800e55e:	4430      	add	r0, r6
 800e560:	6020      	str	r0, [r4, #0]
              DPRINTF("+----------queue+---count+-dequeue+-enqueue+-----max+----full+---empty+"CLEAR_LINE"\n");
 800e562:	682b      	ldr	r3, [r5, #0]
 800e564:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e568:	da0b      	bge.n	800e582 <dTask+0x10a>
 800e56a:	6860      	ldr	r0, [r4, #4]
 800e56c:	498e      	ldr	r1, [pc, #568]	; (800e7a8 <dTask+0x330>)
 800e56e:	4418      	add	r0, r3
 800e570:	f7fa f916 	bl	80087a0 <xsprintf>
 800e574:	6826      	ldr	r6, [r4, #0]
 800e576:	6860      	ldr	r0, [r4, #4]
 800e578:	4430      	add	r0, r6
 800e57a:	f006 f861 	bl	8014640 <strlen>
 800e57e:	4430      	add	r0, r6
 800e580:	6020      	str	r0, [r4, #0]
              QSTAT(inQueueTest);
              QSTAT(outQueueSAI1);
              QSTAT(outQueueSAI2);
              DPRINTF("+---------------+--------+--------+--------+--------+--------+--------+"CLEAR_LINE"\n");
#endif
              QSTAT(heap_1_32);
 800e582:	682e      	ldr	r6, [r5, #0]
 800e584:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e588:	da18      	bge.n	800e5bc <dTask+0x144>
 800e58a:	4a88      	ldr	r2, [pc, #544]	; (800e7ac <dTask+0x334>)
 800e58c:	6860      	ldr	r0, [r4, #4]
 800e58e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800e590:	6893      	ldr	r3, [r2, #8]
 800e592:	9104      	str	r1, [sp, #16]
 800e594:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800e596:	9103      	str	r1, [sp, #12]
 800e598:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800e59a:	9102      	str	r1, [sp, #8]
 800e59c:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800e59e:	9101      	str	r1, [sp, #4]
 800e5a0:	6a12      	ldr	r2, [r2, #32]
 800e5a2:	9200      	str	r2, [sp, #0]
 800e5a4:	4430      	add	r0, r6
 800e5a6:	4a82      	ldr	r2, [pc, #520]	; (800e7b0 <dTask+0x338>)
 800e5a8:	4982      	ldr	r1, [pc, #520]	; (800e7b4 <dTask+0x33c>)
 800e5aa:	f7fa f8f9 	bl	80087a0 <xsprintf>
 800e5ae:	6826      	ldr	r6, [r4, #0]
 800e5b0:	6860      	ldr	r0, [r4, #4]
 800e5b2:	4430      	add	r0, r6
 800e5b4:	f006 f844 	bl	8014640 <strlen>
 800e5b8:	4430      	add	r0, r6
 800e5ba:	6020      	str	r0, [r4, #0]
              QSTAT(heap_33_192);
 800e5bc:	682e      	ldr	r6, [r5, #0]
 800e5be:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e5c2:	da18      	bge.n	800e5f6 <dTask+0x17e>
 800e5c4:	4a7c      	ldr	r2, [pc, #496]	; (800e7b8 <dTask+0x340>)
 800e5c6:	6860      	ldr	r0, [r4, #4]
 800e5c8:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800e5ca:	6893      	ldr	r3, [r2, #8]
 800e5cc:	9104      	str	r1, [sp, #16]
 800e5ce:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800e5d0:	9103      	str	r1, [sp, #12]
 800e5d2:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800e5d4:	9102      	str	r1, [sp, #8]
 800e5d6:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800e5d8:	9101      	str	r1, [sp, #4]
 800e5da:	6a12      	ldr	r2, [r2, #32]
 800e5dc:	9200      	str	r2, [sp, #0]
 800e5de:	4430      	add	r0, r6
 800e5e0:	4a76      	ldr	r2, [pc, #472]	; (800e7bc <dTask+0x344>)
 800e5e2:	4974      	ldr	r1, [pc, #464]	; (800e7b4 <dTask+0x33c>)
 800e5e4:	f7fa f8dc 	bl	80087a0 <xsprintf>
 800e5e8:	6826      	ldr	r6, [r4, #0]
 800e5ea:	6860      	ldr	r0, [r4, #4]
 800e5ec:	4430      	add	r0, r6
 800e5ee:	f006 f827 	bl	8014640 <strlen>
 800e5f2:	4430      	add	r0, r6
 800e5f4:	6020      	str	r0, [r4, #0]
              QSTAT(heap_512_512);
 800e5f6:	682e      	ldr	r6, [r5, #0]
 800e5f8:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e5fc:	da18      	bge.n	800e630 <dTask+0x1b8>
 800e5fe:	4a70      	ldr	r2, [pc, #448]	; (800e7c0 <dTask+0x348>)
 800e600:	6860      	ldr	r0, [r4, #4]
 800e602:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800e604:	6893      	ldr	r3, [r2, #8]
 800e606:	9104      	str	r1, [sp, #16]
 800e608:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800e60a:	9103      	str	r1, [sp, #12]
 800e60c:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800e60e:	9102      	str	r1, [sp, #8]
 800e610:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800e612:	9101      	str	r1, [sp, #4]
 800e614:	6a12      	ldr	r2, [r2, #32]
 800e616:	9200      	str	r2, [sp, #0]
 800e618:	4430      	add	r0, r6
 800e61a:	4a6a      	ldr	r2, [pc, #424]	; (800e7c4 <dTask+0x34c>)
 800e61c:	4965      	ldr	r1, [pc, #404]	; (800e7b4 <dTask+0x33c>)
 800e61e:	f7fa f8bf 	bl	80087a0 <xsprintf>
 800e622:	6826      	ldr	r6, [r4, #0]
 800e624:	6860      	ldr	r0, [r4, #4]
 800e626:	4430      	add	r0, r6
 800e628:	f006 f80a 	bl	8014640 <strlen>
 800e62c:	4430      	add	r0, r6
 800e62e:	6020      	str	r0, [r4, #0]
              QSTAT(heap_513_1024);
 800e630:	682e      	ldr	r6, [r5, #0]
 800e632:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e636:	da18      	bge.n	800e66a <dTask+0x1f2>
 800e638:	4a63      	ldr	r2, [pc, #396]	; (800e7c8 <dTask+0x350>)
 800e63a:	6860      	ldr	r0, [r4, #4]
 800e63c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800e63e:	6893      	ldr	r3, [r2, #8]
 800e640:	9104      	str	r1, [sp, #16]
 800e642:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800e644:	9103      	str	r1, [sp, #12]
 800e646:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800e648:	9102      	str	r1, [sp, #8]
 800e64a:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800e64c:	9101      	str	r1, [sp, #4]
 800e64e:	6a12      	ldr	r2, [r2, #32]
 800e650:	9200      	str	r2, [sp, #0]
 800e652:	4430      	add	r0, r6
 800e654:	4a5d      	ldr	r2, [pc, #372]	; (800e7cc <dTask+0x354>)
 800e656:	4957      	ldr	r1, [pc, #348]	; (800e7b4 <dTask+0x33c>)
 800e658:	f7fa f8a2 	bl	80087a0 <xsprintf>
 800e65c:	6826      	ldr	r6, [r4, #0]
 800e65e:	6860      	ldr	r0, [r4, #4]
 800e660:	4430      	add	r0, r6
 800e662:	f005 ffed 	bl	8014640 <strlen>
 800e666:	4430      	add	r0, r6
 800e668:	6020      	str	r0, [r4, #0]
              QSTAT(heap_1025_2112);
 800e66a:	682e      	ldr	r6, [r5, #0]
 800e66c:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e670:	da18      	bge.n	800e6a4 <dTask+0x22c>
 800e672:	4a57      	ldr	r2, [pc, #348]	; (800e7d0 <dTask+0x358>)
 800e674:	6860      	ldr	r0, [r4, #4]
 800e676:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800e678:	6893      	ldr	r3, [r2, #8]
 800e67a:	9104      	str	r1, [sp, #16]
 800e67c:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800e67e:	9103      	str	r1, [sp, #12]
 800e680:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800e682:	9102      	str	r1, [sp, #8]
 800e684:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800e686:	9101      	str	r1, [sp, #4]
 800e688:	6a12      	ldr	r2, [r2, #32]
 800e68a:	9200      	str	r2, [sp, #0]
 800e68c:	4430      	add	r0, r6
 800e68e:	4a51      	ldr	r2, [pc, #324]	; (800e7d4 <dTask+0x35c>)
 800e690:	4948      	ldr	r1, [pc, #288]	; (800e7b4 <dTask+0x33c>)
 800e692:	f7fa f885 	bl	80087a0 <xsprintf>
 800e696:	6826      	ldr	r6, [r4, #0]
 800e698:	6860      	ldr	r0, [r4, #4]
 800e69a:	4430      	add	r0, r6
 800e69c:	f005 ffd0 	bl	8014640 <strlen>
 800e6a0:	4430      	add	r0, r6
 800e6a2:	6020      	str	r0, [r4, #0]
              DPRINTF("+---------------+--------+--------+--------+--------+--------+--------+"CLEAR_LINE"\n");
 800e6a4:	682b      	ldr	r3, [r5, #0]
 800e6a6:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e6aa:	da14      	bge.n	800e6d6 <dTask+0x25e>
 800e6ac:	6860      	ldr	r0, [r4, #4]
 800e6ae:	494a      	ldr	r1, [pc, #296]	; (800e7d8 <dTask+0x360>)
 800e6b0:	4418      	add	r0, r3
 800e6b2:	f7fa f875 	bl	80087a0 <xsprintf>
 800e6b6:	6826      	ldr	r6, [r4, #0]
 800e6b8:	6860      	ldr	r0, [r4, #4]
 800e6ba:	4430      	add	r0, r6
 800e6bc:	f005 ffc0 	bl	8014640 <strlen>
 800e6c0:	4430      	add	r0, r6
 800e6c2:	6020      	str	r0, [r4, #0]
            }
          DPRINTF(CUR_UNSAVE);
 800e6c4:	682b      	ldr	r3, [r5, #0]
 800e6c6:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e6ca:	da04      	bge.n	800e6d6 <dTask+0x25e>
 800e6cc:	6860      	ldr	r0, [r4, #4]
 800e6ce:	4943      	ldr	r1, [pc, #268]	; (800e7dc <dTask+0x364>)
 800e6d0:	4418      	add	r0, r3
 800e6d2:	f7fa f865 	bl	80087a0 <xsprintf>
          *bufSize = 0;
 800e6d6:	2300      	movs	r3, #0
          xprintf(bufPtr);
 800e6d8:	6868      	ldr	r0, [r5, #4]
              QSTAT(heap_513_1024);
              QSTAT(heap_1025_2112);
              DPRINTF("+---------------+--------+--------+--------+--------+--------+--------+"CLEAR_LINE"\n");
            }
          DPRINTF(CUR_UNSAVE);
          *bufSize = 0;
 800e6da:	602b      	str	r3, [r5, #0]
          xprintf(bufPtr);
 800e6dc:	f7fa f842 	bl	8008764 <xprintf>

          if(cfg.stats&0x01)
 800e6e0:	4b2b      	ldr	r3, [pc, #172]	; (800e790 <dTask+0x318>)
 800e6e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
            {
#ifdef MADO
              DPRINTF(CUR_SAVE CUR_HOME(19) CLEAR_LINE"\n");
#else
              DPRINTF(CUR_SAVE CUR_HOME(11) CLEAR_LINE"\n");
 800e6e4:	6823      	ldr	r3, [r4, #0]
#endif
            }
          else
            {
              DPRINTF(CUR_SAVE CUR_HOME(3) CLEAR_LINE"\n");
 800e6e6:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e6ea:	da0b      	bge.n	800e704 <dTask+0x28c>
 800e6ec:	6860      	ldr	r0, [r4, #4]
 800e6ee:	4922      	ldr	r1, [pc, #136]	; (800e778 <dTask+0x300>)
 800e6f0:	4418      	add	r0, r3
 800e6f2:	f7fa f855 	bl	80087a0 <xsprintf>
 800e6f6:	6826      	ldr	r6, [r4, #0]
 800e6f8:	6860      	ldr	r0, [r4, #4]
 800e6fa:	4430      	add	r0, r6
 800e6fc:	f005 ffa0 	bl	8014640 <strlen>
 800e700:	4430      	add	r0, r6
 800e702:	6020      	str	r0, [r4, #0]
            }
          if(cfg.stats&0x02)
 800e704:	4b22      	ldr	r3, [pc, #136]	; (800e790 <dTask+0x318>)
 800e706:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e708:	079b      	lsls	r3, r3, #30
 800e70a:	f140 8160 	bpl.w	800e9ce <dTask+0x556>
            {
              int m;
              for(m = 0; m < RADIO_MODULES; m++)
                DPRINTF("%d: devId=%08x manId=%08x prodId=%08x smplRate=%6dHz tsPeriod=%4dus dtxFull=%8d txNoConn=%8d status=%04x"CLEAR_LINE"\n", m,
 800e70e:	682e      	ldr	r6, [r5, #0]
 800e710:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800e714:	da1c      	bge.n	800e750 <dTask+0x2d8>
 800e716:	4a32      	ldr	r2, [pc, #200]	; (800e7e0 <dTask+0x368>)
 800e718:	6860      	ldr	r0, [r4, #4]
 800e71a:	8f11      	ldrh	r1, [r2, #56]	; 0x38
 800e71c:	69d3      	ldr	r3, [r2, #28]
 800e71e:	9106      	str	r1, [sp, #24]
 800e720:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800e722:	9105      	str	r1, [sp, #20]
 800e724:	6a91      	ldr	r1, [r2, #40]	; 0x28
 800e726:	9104      	str	r1, [sp, #16]
 800e728:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800e72a:	9103      	str	r1, [sp, #12]
 800e72c:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800e72e:	9102      	str	r1, [sp, #8]
 800e730:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800e732:	9101      	str	r1, [sp, #4]
 800e734:	6a12      	ldr	r2, [r2, #32]
 800e736:	9200      	str	r2, [sp, #0]
 800e738:	4430      	add	r0, r6
 800e73a:	2200      	movs	r2, #0
 800e73c:	4929      	ldr	r1, [pc, #164]	; (800e7e4 <dTask+0x36c>)
 800e73e:	f7fa f82f 	bl	80087a0 <xsprintf>
 800e742:	6826      	ldr	r6, [r4, #0]
 800e744:	6860      	ldr	r0, [r4, #4]
 800e746:	4430      	add	r0, r6
 800e748:	f005 ff7a 	bl	8014640 <strlen>
 800e74c:	4430      	add	r0, r6
 800e74e:	6020      	str	r0, [r4, #0]
                        radioModule[m].tsPeriod,
                        radioModule[m].txFull,
                        radioModule[m].txNoConn,
                        radioModule[m].status);

              DPRINTF("+----+---+--+--+--+-+-+----+--r.dev.+--r.man.+-r.prod.+-upConn-+upConnDa+-uptime-+lastSeen+txFullDr+dscRstRx+dscRstTx+"CLEAR_LINE"\n");
 800e750:	682b      	ldr	r3, [r5, #0]
 800e752:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e756:	da0b      	bge.n	800e770 <dTask+0x2f8>
 800e758:	6860      	ldr	r0, [r4, #4]
 800e75a:	4923      	ldr	r1, [pc, #140]	; (800e7e8 <dTask+0x370>)
 800e75c:	4418      	add	r0, r3
 800e75e:	f7fa f81f 	bl	80087a0 <xsprintf>
 800e762:	6825      	ldr	r5, [r4, #0]
 800e764:	6860      	ldr	r0, [r4, #4]
 800e766:	4428      	add	r0, r5
 800e768:	f005 ff6a 	bl	8014640 <strlen>
 800e76c:	4428      	add	r0, r5
 800e76e:	6020      	str	r0, [r4, #0]
 800e770:	4d1e      	ldr	r5, [pc, #120]	; (800e7ec <dTask+0x374>)
#endif

      vTaskDelay(1);
      if ((i % DISPLAY_INTERVAL) == 0 /* || refresh */)
        {
          bufPtr = dAlloc(DBUFSIZE);
 800e772:	f04f 0a00 	mov.w	sl, #0
 800e776:	e03b      	b.n	800e7f0 <dTask+0x378>
 800e778:	08014a9c 	.word	0x08014a9c
 800e77c:	2001ad88 	.word	0x2001ad88
 800e780:	0801d820 	.word	0x0801d820
 800e784:	0801d7ed 	.word	0x0801d7ed
 800e788:	0801d7f6 	.word	0x0801d7f6
 800e78c:	0801d802 	.word	0x0801d802
 800e790:	10001000 	.word	0x10001000
 800e794:	2001ad74 	.word	0x2001ad74
 800e798:	2001ad7c 	.word	0x2001ad7c
 800e79c:	2001ad78 	.word	0x2001ad78
 800e7a0:	2001ad80 	.word	0x2001ad80
 800e7a4:	0801d824 	.word	0x0801d824
 800e7a8:	0801d85f 	.word	0x0801d85f
 800e7ac:	2001a978 	.word	0x2001a978
 800e7b0:	0801d8a8 	.word	0x0801d8a8
 800e7b4:	0801d8b2 	.word	0x0801d8b2
 800e7b8:	2001a9ac 	.word	0x2001a9ac
 800e7bc:	0801d8d2 	.word	0x0801d8d2
 800e7c0:	2001a9e0 	.word	0x2001a9e0
 800e7c4:	0801d8de 	.word	0x0801d8de
 800e7c8:	2001aa14 	.word	0x2001aa14
 800e7cc:	0801d8eb 	.word	0x0801d8eb
 800e7d0:	2001aa48 	.word	0x2001aa48
 800e7d4:	0801d8f9 	.word	0x0801d8f9
 800e7d8:	0801d908 	.word	0x0801d908
 800e7dc:	08014a9d 	.word	0x08014a9d
 800e7e0:	2001add4 	.word	0x2001add4
 800e7e4:	0801d951 	.word	0x0801d951
 800e7e8:	0801d9bb 	.word	0x0801d9bb
 800e7ec:	2001aabc 	.word	0x2001aabc
  [DEV_CONN]  = 'F',
  [DEV_UCONN] = 'U',
};
static void portState(portNum_t p)
{
  if(portData[p].enabled == 0)
 800e7f0:	7eeb      	ldrb	r3, [r5, #27]
 800e7f2:	2b00      	cmp	r3, #0
 800e7f4:	f000 80d3 	beq.w	800e99e <dTask+0x526>
    return;

#ifdef MADO
  int myPipeNum = getPipeNum(portData[p].kond_pom);
#endif
  uint32_t now = xTaskGetTickCount();
 800e7f8:	f7fb ff54 	bl	800a6a4 <xTaskGetTickCount>
  uint32_t upConn = (now - portData[p].tsConnected)/1000;
 800e7fc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  uint32_t upConnDatagram = (now - portData[p].tsConnectedDatagram)/1000;
  uint32_t upTime = portData[p].uptime/1000;
 800e7fe:	6b6a      	ldr	r2, [r5, #52]	; 0x34
#ifdef MADO
  int myPipeNum = getPipeNum(portData[p].kond_pom);
#endif
  uint32_t now = xTaskGetTickCount();
  uint32_t upConn = (now - portData[p].tsConnected)/1000;
  uint32_t upConnDatagram = (now - portData[p].tsConnectedDatagram)/1000;
 800e800:	6b2f      	ldr	r7, [r5, #48]	; 0x30

#ifdef MADO
  int myPipeNum = getPipeNum(portData[p].kond_pom);
#endif
  uint32_t now = xTaskGetTickCount();
  uint32_t upConn = (now - portData[p].tsConnected)/1000;
 800e802:	1ac3      	subs	r3, r0, r3
 800e804:	f44f 797a 	mov.w	r9, #1000	; 0x3e8
 800e808:	fbb3 f3f9 	udiv	r3, r3, r9
 800e80c:	9327      	str	r3, [sp, #156]	; 0x9c
  uint32_t upConnDatagram = (now - portData[p].tsConnectedDatagram)/1000;
  uint32_t upTime = portData[p].uptime/1000;
  uint32_t lastSeen = portData[p].uptime?(now - portData[p].tsLastSeen)/1000:-1;
 800e80e:	b122      	cbz	r2, 800e81a <dTask+0x3a2>
 800e810:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800e812:	1ac3      	subs	r3, r0, r3
 800e814:	fbb3 f9f9 	udiv	r9, r3, r9
 800e818:	e001      	b.n	800e81e <dTask+0x3a6>
 800e81a:	f04f 39ff 	mov.w	r9, #4294967295
  switch(portData[p].connState)
 800e81e:	f895 6020 	ldrb.w	r6, [r5, #32]
 800e822:	b14e      	cbz	r6, 800e838 <dTask+0x3c0>
 800e824:	2e02      	cmp	r6, #2
 800e826:	d00a      	beq.n	800e83e <dTask+0x3c6>
#ifdef MADO
  int myPipeNum = getPipeNum(portData[p].kond_pom);
#endif
  uint32_t now = xTaskGetTickCount();
  uint32_t upConn = (now - portData[p].tsConnected)/1000;
  uint32_t upConnDatagram = (now - portData[p].tsConnectedDatagram)/1000;
 800e828:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800e82c:	1bc0      	subs	r0, r0, r7
 800e82e:	fbb0 f7f6 	udiv	r7, r0, r6
  uint32_t upTime = portData[p].uptime/1000;
 800e832:	fbb2 f6f6 	udiv	r6, r2, r6
 800e836:	e004      	b.n	800e842 <dTask+0x3ca>
  switch(portData[p].connState)
    {
    case DEV_NCONN:
      upConn = 0;
    case DEV_PCONN:
      upConnDatagram = 0;
 800e838:	4637      	mov	r7, r6
  uint32_t upTime = portData[p].uptime/1000;
  uint32_t lastSeen = portData[p].uptime?(now - portData[p].tsLastSeen)/1000:-1;
  switch(portData[p].connState)
    {
    case DEV_NCONN:
      upConn = 0;
 800e83a:	9627      	str	r6, [sp, #156]	; 0x9c
 800e83c:	e001      	b.n	800e842 <dTask+0x3ca>
    case DEV_PCONN:
      upConnDatagram = 0;
      upTime = 0;
 800e83e:	2600      	movs	r6, #0
  switch(portData[p].connState)
    {
    case DEV_NCONN:
      upConn = 0;
    case DEV_PCONN:
      upConnDatagram = 0;
 800e840:	4637      	mov	r7, r6
      upTime = 0;
      break;
    }
  spiHelper_t * helper = (spiHelper_t *)portData[p].SPIhelper;
  DPRINTF("|%4s|%c%c%c|%02x|%02x|", portStr[p],
 800e842:	6823      	ldr	r3, [r4, #0]
    case DEV_PCONN:
      upConnDatagram = 0;
      upTime = 0;
      break;
    }
  spiHelper_t * helper = (spiHelper_t *)portData[p].SPIhelper;
 800e844:	f8d5 8010 	ldr.w	r8, [r5, #16]
  DPRINTF("|%4s|%c%c%c|%02x|%02x|", portStr[p],
 800e848:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e84c:	f280 8094 	bge.w	800e978 <dTask+0x500>
 800e850:	6862      	ldr	r2, [r4, #4]
 800e852:	eb02 0b03 	add.w	fp, r2, r3
 800e856:	4b42      	ldr	r3, [pc, #264]	; (800e960 <dTask+0x4e8>)
 800e858:	f853 202a 	ldr.w	r2, [r3, sl, lsl #2]
 800e85c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 800e85e:	922a      	str	r2, [sp, #168]	; 0xa8
 800e860:	f503 539c 	add.w	r3, r3, #4992	; 0x1380
 800e864:	3308      	adds	r3, #8
 800e866:	9328      	str	r3, [sp, #160]	; 0xa0
 800e868:	f7fb ff1c 	bl	800a6a4 <xTaskGetTickCount>
 800e86c:	6c29      	ldr	r1, [r5, #64]	; 0x40
 800e86e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800e870:	f501 519c 	add.w	r1, r1, #4992	; 0x1380
 800e874:	4283      	cmp	r3, r0
 800e876:	bf94      	ite	ls
 800e878:	2320      	movls	r3, #32
 800e87a:	2355      	movhi	r3, #85	; 0x55
 800e87c:	3108      	adds	r1, #8
 800e87e:	9329      	str	r3, [sp, #164]	; 0xa4
 800e880:	9128      	str	r1, [sp, #160]	; 0xa0
 800e882:	f7fb ff0f 	bl	800a6a4 <xTaskGetTickCount>
 800e886:	9928      	ldr	r1, [sp, #160]	; 0xa0
 800e888:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 800e88a:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 800e88c:	4281      	cmp	r1, r0
 800e88e:	bf94      	ite	ls
 800e890:	2020      	movls	r0, #32
 800e892:	2053      	movhi	r0, #83	; 0x53
 800e894:	7e29      	ldrb	r1, [r5, #24]
 800e896:	2901      	cmp	r1, #1
 800e898:	d004      	beq.n	800e8a4 <dTask+0x42c>
 800e89a:	2900      	cmp	r1, #0
 800e89c:	bf14      	ite	ne
 800e89e:	214e      	movne	r1, #78	; 0x4e
 800e8a0:	2155      	moveq	r1, #85	; 0x55
 800e8a2:	e000      	b.n	800e8a6 <dTask+0x42e>
 800e8a4:	2153      	movs	r1, #83	; 0x53
 800e8a6:	f895 e01a 	ldrb.w	lr, [r5, #26]
 800e8aa:	f8cd e00c 	str.w	lr, [sp, #12]
 800e8ae:	f895 e019 	ldrb.w	lr, [r5, #25]
 800e8b2:	e88d 4003 	stmia.w	sp, {r0, r1, lr}
 800e8b6:	4658      	mov	r0, fp
 800e8b8:	492a      	ldr	r1, [pc, #168]	; (800e964 <dTask+0x4ec>)
 800e8ba:	f7f9 ff71 	bl	80087a0 <xsprintf>
 800e8be:	f8d4 b000 	ldr.w	fp, [r4]
 800e8c2:	6863      	ldr	r3, [r4, #4]
 800e8c4:	9328      	str	r3, [sp, #160]	; 0xa0
 800e8c6:	eb03 000b 	add.w	r0, r3, fp
 800e8ca:	f005 feb9 	bl	8014640 <strlen>
 800e8ce:	4458      	add	r0, fp
 800e8d0:	6020      	str	r0, [r4, #0]
          IS_CON_TYPE_ACTIVE(p, PORT_TYPE_USART)?'U':' ',
          IS_CON_TYPE_ACTIVE(p, PORT_TYPE_SPI)?'S':' ',
          (portData[p].portType == PORT_TYPE_SPI)?'S':((portData[p].portType == PORT_TYPE_USART)?'U':'N'),
          portData[p].kond_pom, portData[p].urzadzenie);
  if(helper)
 800e8d2:	f1b8 0f00 	cmp.w	r8, #0
 800e8d6:	d052      	beq.n	800e97e <dTask+0x506>
    {
      int prevConnState = portData[p].prevConnState;
      int connState = portData[p].connState;
      DPRINTF("%c%c|%c|%c|%04x|%08x|%08x|%08x|%8d|%8d|%8d|%8d|%8d|%8d|%8d|"CLEAR_LINE"\n" ,
 800e8d8:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
          IS_CON_TYPE_ACTIVE(p, PORT_TYPE_SPI)?'S':' ',
          (portData[p].portType == PORT_TYPE_SPI)?'S':((portData[p].portType == PORT_TYPE_USART)?'U':'N'),
          portData[p].kond_pom, portData[p].urzadzenie);
  if(helper)
    {
      int prevConnState = portData[p].prevConnState;
 800e8dc:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
      int connState = portData[p].connState;
 800e8e0:	f895 1020 	ldrb.w	r1, [r5, #32]
      DPRINTF("%c%c|%c|%c|%04x|%08x|%08x|%08x|%8d|%8d|%8d|%8d|%8d|%8d|%8d|"CLEAR_LINE"\n" ,
 800e8e4:	da5b      	bge.n	800e99e <dTask+0x526>
 800e8e6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800e8e8:	4418      	add	r0, r3
 800e8ea:	4b1f      	ldr	r3, [pc, #124]	; (800e968 <dTask+0x4f0>)
 800e8ec:	f813 b001 	ldrb.w	fp, [r3, r1]
 800e8f0:	491e      	ldr	r1, [pc, #120]	; (800e96c <dTask+0x4f4>)
 800e8f2:	5c9a      	ldrb	r2, [r3, r2]
 800e8f4:	6809      	ldr	r1, [r1, #0]
 800e8f6:	b131      	cbz	r1, 800e906 <dTask+0x48e>
 800e8f8:	2901      	cmp	r1, #1
 800e8fa:	bf14      	ite	ne
 800e8fc:	f04f 0e4e 	movne.w	lr, #78	; 0x4e
 800e900:	f04f 0e31 	moveq.w	lr, #49	; 0x31
 800e904:	e001      	b.n	800e90a <dTask+0x492>
 800e906:	f04f 0e30 	mov.w	lr, #48	; 0x30
 800e90a:	f8d8 110c 	ldr.w	r1, [r8, #268]	; 0x10c
 800e90e:	b131      	cbz	r1, 800e91e <dTask+0x4a6>
 800e910:	f8df c060 	ldr.w	ip, [pc, #96]	; 800e974 <dTask+0x4fc>
 800e914:	4561      	cmp	r1, ip
 800e916:	bf14      	ite	ne
 800e918:	2131      	movne	r1, #49	; 0x31
 800e91a:	2130      	moveq	r1, #48	; 0x30
 800e91c:	e000      	b.n	800e920 <dTask+0x4a8>
 800e91e:	214e      	movs	r1, #78	; 0x4e
 800e920:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800e922:	930c      	str	r3, [sp, #48]	; 0x30
 800e924:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800e926:	930b      	str	r3, [sp, #44]	; 0x2c
 800e928:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800e92a:	930a      	str	r3, [sp, #40]	; 0x28
 800e92c:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800e92e:	9306      	str	r3, [sp, #24]
 800e930:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 800e934:	9608      	str	r6, [sp, #32]
 800e936:	9707      	str	r7, [sp, #28]
 800e938:	f8d8 611d 	ldr.w	r6, [r8, #285]	; 0x11d
 800e93c:	9605      	str	r6, [sp, #20]
 800e93e:	f8d8 6119 	ldr.w	r6, [r8, #281]	; 0x119
 800e942:	9604      	str	r6, [sp, #16]
 800e944:	f8d8 6115 	ldr.w	r6, [r8, #277]	; 0x115
 800e948:	9603      	str	r6, [sp, #12]
 800e94a:	f8b8 6121 	ldrh.w	r6, [r8, #289]	; 0x121
 800e94e:	9602      	str	r6, [sp, #8]
 800e950:	9101      	str	r1, [sp, #4]
 800e952:	f8cd e000 	str.w	lr, [sp]
 800e956:	465b      	mov	r3, fp
 800e958:	4905      	ldr	r1, [pc, #20]	; (800e970 <dTask+0x4f8>)
 800e95a:	f7f9 ff21 	bl	80087a0 <xsprintf>
 800e95e:	e017      	b.n	800e990 <dTask+0x518>
 800e960:	2001abd8 	.word	0x2001abd8
 800e964:	0801da33 	.word	0x0801da33
 800e968:	0801d7b8 	.word	0x0801d7b8
 800e96c:	2001ac38 	.word	0x2001ac38
 800e970:	0801da4a 	.word	0x0801da4a
 800e974:	2001add4 	.word	0x2001add4
  DPRINTF("|%4s|%c%c%c|%02x|%02x|", portStr[p],
          IS_CON_TYPE_ACTIVE(p, PORT_TYPE_USART)?'U':' ',
          IS_CON_TYPE_ACTIVE(p, PORT_TYPE_SPI)?'S':' ',
          (portData[p].portType == PORT_TYPE_SPI)?'S':((portData[p].portType == PORT_TYPE_USART)?'U':'N'),
          portData[p].kond_pom, portData[p].urzadzenie);
  if(helper)
 800e978:	f1b8 0f00 	cmp.w	r8, #0
 800e97c:	d10f      	bne.n	800e99e <dTask+0x526>
              portData[p].txFullDrop,
              portData[p].dscResetRx,
              portData[p].dscResetTx);
    }
  else
    DPRINTF("  | | |    |        |        |        |        |        |        |        |        |        |        |"CLEAR_LINE"\n");
 800e97e:	6823      	ldr	r3, [r4, #0]
 800e980:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e984:	da0b      	bge.n	800e99e <dTask+0x526>
 800e986:	6860      	ldr	r0, [r4, #4]
 800e988:	49b2      	ldr	r1, [pc, #712]	; (800ec54 <dTask+0x7dc>)
 800e98a:	4418      	add	r0, r3
 800e98c:	f7f9 ff08 	bl	80087a0 <xsprintf>
 800e990:	6826      	ldr	r6, [r4, #0]
 800e992:	6860      	ldr	r0, [r4, #4]
 800e994:	4430      	add	r0, r6
 800e996:	f005 fe53 	bl	8014640 <strlen>
 800e99a:	4430      	add	r0, r6
 800e99c:	6020      	str	r0, [r4, #0]
 800e99e:	f10a 0a01 	add.w	sl, sl, #1
                        radioModule[m].txNoConn,
                        radioModule[m].status);

              DPRINTF("+----+---+--+--+--+-+-+----+--r.dev.+--r.man.+-r.prod.+-upConn-+upConnDa+-uptime-+lastSeen+txFullDr+dscRstRx+dscRstTx+"CLEAR_LINE"\n");
              portNum_t p;
              for(p=CEN_PORT; p < PORTS_NUM; p++) portState(p);
 800e9a2:	f1ba 0f03 	cmp.w	sl, #3
 800e9a6:	f105 0550 	add.w	r5, r5, #80	; 0x50
 800e9aa:	f47f af21 	bne.w	800e7f0 <dTask+0x378>
              DPRINTF("+----+---+--+--+--+-+-+----+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+"CLEAR_LINE"\n");
 800e9ae:	6823      	ldr	r3, [r4, #0]
 800e9b0:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800e9b4:	da0b      	bge.n	800e9ce <dTask+0x556>
 800e9b6:	6860      	ldr	r0, [r4, #4]
 800e9b8:	49a7      	ldr	r1, [pc, #668]	; (800ec58 <dTask+0x7e0>)
 800e9ba:	4418      	add	r0, r3
 800e9bc:	f7f9 fef0 	bl	80087a0 <xsprintf>
 800e9c0:	6825      	ldr	r5, [r4, #0]
 800e9c2:	6860      	ldr	r0, [r4, #4]
 800e9c4:	4428      	add	r0, r5
 800e9c6:	f005 fe3b 	bl	8014640 <strlen>
 800e9ca:	4428      	add	r0, r5
 800e9cc:	6020      	str	r0, [r4, #0]
            }
          if(cfg.stats&0x04)
 800e9ce:	4ba3      	ldr	r3, [pc, #652]	; (800ec5c <dTask+0x7e4>)
 800e9d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e9d2:	075f      	lsls	r7, r3, #29
 800e9d4:	d501      	bpl.n	800e9da <dTask+0x562>
            printfCommStats();
 800e9d6:	f7ff fc0b 	bl	800e1f0 <printfCommStats>
#ifdef SMOK
          taskENTER_CRITICAL();
 800e9da:	f7fb fbab 	bl	800a134 <vPortEnterCritical>
          int Uwe_val_local = Uwe_val;
 800e9de:	4ba0      	ldr	r3, [pc, #640]	; (800ec60 <dTask+0x7e8>)
 800e9e0:	681b      	ldr	r3, [r3, #0]
 800e9e2:	9327      	str	r3, [sp, #156]	; 0x9c
          int Uwy_val_local = Uwy_val;
 800e9e4:	4b9f      	ldr	r3, [pc, #636]	; (800ec64 <dTask+0x7ec>)
 800e9e6:	681e      	ldr	r6, [r3, #0]
          int meaniH_local = meaniH;
 800e9e8:	4b9f      	ldr	r3, [pc, #636]	; (800ec68 <dTask+0x7f0>)
 800e9ea:	681f      	ldr	r7, [r3, #0]
          int meaniL_local = meaniL;
 800e9ec:	4b9f      	ldr	r3, [pc, #636]	; (800ec6c <dTask+0x7f4>)
 800e9ee:	f8d3 a000 	ldr.w	sl, [r3]
          int UwyI_local = UwyI;
 800e9f2:	4b9f      	ldr	r3, [pc, #636]	; (800ec70 <dTask+0x7f8>)
 800e9f4:	f8d3 b000 	ldr.w	fp, [r3]
          int UweI_local = UweI;
 800e9f8:	4b9e      	ldr	r3, [pc, #632]	; (800ec74 <dTask+0x7fc>)
 800e9fa:	f8d3 9000 	ldr.w	r9, [r3]
          int sMaxiL_local = sMaxiL;
 800e9fe:	4b9e      	ldr	r3, [pc, #632]	; (800ec78 <dTask+0x800>)
 800ea00:	681b      	ldr	r3, [r3, #0]
 800ea02:	9328      	str	r3, [sp, #160]	; 0xa0
          int sMaxvL_local = sMaxvL;
 800ea04:	4b9d      	ldr	r3, [pc, #628]	; (800ec7c <dTask+0x804>)
 800ea06:	681b      	ldr	r3, [r3, #0]
 800ea08:	9329      	str	r3, [sp, #164]	; 0xa4
          int Uwy_k_local = Uwy_k;
 800ea0a:	4b9d      	ldr	r3, [pc, #628]	; (800ec80 <dTask+0x808>)
 800ea0c:	681b      	ldr	r3, [r3, #0]
 800ea0e:	932a      	str	r3, [sp, #168]	; 0xa8
          taskEXIT_CRITICAL();
 800ea10:	f7fb fba2 	bl	800a158 <vPortExitCritical>
          int Pwy = meaniL_local*UwyI_local;
          int Pdiff = Pwe-Pwy;
#define VF "%s%d.%03d"
#define VFV(arg_value, arg_div) ((arg_value)<0?"-":""), ABS((arg_value))/(arg_div), ABS((arg_value))%(arg_div)

          DPRINTF("%s Uwe_val:"VF"V, Uwy_val:"VF"V, meaniL:"VF"A, meaniH:"VF"A, UwyI:"VF"V, UweI:"VF"V, Pwy:"VF"W, Pwe:"VF"W, Pwe-Pwy:"VF"W, sMaxiL:"VF"A, sMaxvL:"VF"V k=%s@Uwy:"VF"V "CLEAR_LINE"\n", isOn()?"ON":"OFF",
 800ea14:	6822      	ldr	r2, [r4, #0]
 800ea16:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 800ea1a:	f280 80e8 	bge.w	800ebee <dTask+0x776>
 800ea1e:	6863      	ldr	r3, [r4, #4]
 800ea20:	4413      	add	r3, r2
 800ea22:	932b      	str	r3, [sp, #172]	; 0xac
 800ea24:	f7fa fe26 	bl	8009674 <isOn>
 800ea28:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 800ea2a:	4996      	ldr	r1, [pc, #600]	; (800ec84 <dTask+0x80c>)
 800ea2c:	4b96      	ldr	r3, [pc, #600]	; (800ec88 <dTask+0x810>)
 800ea2e:	f8df c288 	ldr.w	ip, [pc, #648]	; 800ecb8 <dTask+0x840>
 800ea32:	2a00      	cmp	r2, #0
 800ea34:	bfb8      	it	lt
 800ea36:	4252      	neglt	r2, r2
 800ea38:	4696      	mov	lr, r2
 800ea3a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800ea3e:	ea86 78e6 	eor.w	r8, r6, r6, asr #31
 800ea42:	fb9e f5f2 	sdiv	r5, lr, r2
 800ea46:	9500      	str	r5, [sp, #0]
 800ea48:	fb02 e515 	mls	r5, r2, r5, lr
 800ea4c:	eba8 78e6 	sub.w	r8, r8, r6, asr #31
 800ea50:	9501      	str	r5, [sp, #4]
 800ea52:	ea31 0526 	bics.w	r5, r1, r6, asr #32
 800ea56:	bf28      	it	cs
 800ea58:	461d      	movcs	r5, r3
 800ea5a:	9502      	str	r5, [sp, #8]
 800ea5c:	ea8a 7eea 	eor.w	lr, sl, sl, asr #31
 800ea60:	fb98 f5f2 	sdiv	r5, r8, r2
 800ea64:	9503      	str	r5, [sp, #12]
 800ea66:	fb02 8515 	mls	r5, r2, r5, r8
 800ea6a:	ebae 7eea 	sub.w	lr, lr, sl, asr #31
 800ea6e:	9504      	str	r5, [sp, #16]
 800ea70:	ea31 052a 	bics.w	r5, r1, sl, asr #32
 800ea74:	bf28      	it	cs
 800ea76:	461d      	movcs	r5, r3
 800ea78:	9505      	str	r5, [sp, #20]
 800ea7a:	fb9e f5f2 	sdiv	r5, lr, r2
 800ea7e:	9506      	str	r5, [sp, #24]
 800ea80:	fb02 e515 	mls	r5, r2, r5, lr
 800ea84:	ea87 7ee7 	eor.w	lr, r7, r7, asr #31
 800ea88:	ebae 7ee7 	sub.w	lr, lr, r7, asr #31
 800ea8c:	9507      	str	r5, [sp, #28]
 800ea8e:	ea31 0527 	bics.w	r5, r1, r7, asr #32
 800ea92:	bf28      	it	cs
 800ea94:	461d      	movcs	r5, r3
 800ea96:	9508      	str	r5, [sp, #32]
 800ea98:	fb9e f5f2 	sdiv	r5, lr, r2
 800ea9c:	9509      	str	r5, [sp, #36]	; 0x24
 800ea9e:	fb02 e515 	mls	r5, r2, r5, lr
 800eaa2:	ea8b 7eeb 	eor.w	lr, fp, fp, asr #31
 800eaa6:	ebae 7eeb 	sub.w	lr, lr, fp, asr #31
 800eaaa:	950a      	str	r5, [sp, #40]	; 0x28
 800eaac:	ea31 052b 	bics.w	r5, r1, fp, asr #32
 800eab0:	bf28      	it	cs
 800eab2:	461d      	movcs	r5, r3
 800eab4:	950b      	str	r5, [sp, #44]	; 0x2c
 800eab6:	fb9e f5f2 	sdiv	r5, lr, r2
 800eaba:	950c      	str	r5, [sp, #48]	; 0x30
 800eabc:	fb02 e515 	mls	r5, r2, r5, lr
 800eac0:	ea89 7ee9 	eor.w	lr, r9, r9, asr #31
 800eac4:	ebae 7ee9 	sub.w	lr, lr, r9, asr #31
 800eac8:	950d      	str	r5, [sp, #52]	; 0x34
 800eaca:	ea31 0529 	bics.w	r5, r1, r9, asr #32
 800eace:	bf28      	it	cs
 800ead0:	461d      	movcs	r5, r3
 800ead2:	950e      	str	r5, [sp, #56]	; 0x38
 800ead4:	fb9e f5f2 	sdiv	r5, lr, r2
 800ead8:	950f      	str	r5, [sp, #60]	; 0x3c
 800eada:	fb02 e515 	mls	r5, r2, r5, lr
 800eade:	9510      	str	r5, [sp, #64]	; 0x40
 800eae0:	4656      	mov	r6, sl
 800eae2:	465d      	mov	r5, fp
 800eae4:	4375      	muls	r5, r6
 800eae6:	46aa      	mov	sl, r5
 800eae8:	ea8a 7eea 	eor.w	lr, sl, sl, asr #31
 800eaec:	bf54      	ite	pl
 800eaee:	460d      	movpl	r5, r1
 800eaf0:	461d      	movmi	r5, r3
 800eaf2:	ebae 7eea 	sub.w	lr, lr, sl, asr #31
 800eaf6:	9511      	str	r5, [sp, #68]	; 0x44
 800eaf8:	fb9e fbfc 	sdiv	fp, lr, ip
 800eafc:	fb0c e51b 	mls	r5, ip, fp, lr
 800eb00:	9513      	str	r5, [sp, #76]	; 0x4c
 800eb02:	464d      	mov	r5, r9
 800eb04:	437d      	muls	r5, r7
 800eb06:	462f      	mov	r7, r5
 800eb08:	ea87 7ee7 	eor.w	lr, r7, r7, asr #31
 800eb0c:	bf54      	ite	pl
 800eb0e:	460d      	movpl	r5, r1
 800eb10:	461d      	movmi	r5, r3
 800eb12:	ebae 7ee7 	sub.w	lr, lr, r7, asr #31
 800eb16:	9514      	str	r5, [sp, #80]	; 0x50
 800eb18:	ebb7 070a 	subs.w	r7, r7, sl
 800eb1c:	fb9e f5fc 	sdiv	r5, lr, ip
 800eb20:	9515      	str	r5, [sp, #84]	; 0x54
 800eb22:	fb0c e515 	mls	r5, ip, r5, lr
 800eb26:	9516      	str	r5, [sp, #88]	; 0x58
 800eb28:	bf54      	ite	pl
 800eb2a:	460d      	movpl	r5, r1
 800eb2c:	461d      	movmi	r5, r3
 800eb2e:	9517      	str	r5, [sp, #92]	; 0x5c
 800eb30:	ea87 75e7 	eor.w	r5, r7, r7, asr #31
 800eb34:	eba5 75e7 	sub.w	r5, r5, r7, asr #31
 800eb38:	fb95 fefc 	sdiv	lr, r5, ip
 800eb3c:	fb0c 551e 	mls	r5, ip, lr, r5
 800eb40:	9519      	str	r5, [sp, #100]	; 0x64
 800eb42:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 800eb44:	4e51      	ldr	r6, [pc, #324]	; (800ec8c <dTask+0x814>)
 800eb46:	4f52      	ldr	r7, [pc, #328]	; (800ec90 <dTask+0x818>)
 800eb48:	ea31 0525 	bics.w	r5, r1, r5, asr #32
 800eb4c:	bf28      	it	cs
 800eb4e:	461d      	movcs	r5, r3
 800eb50:	951a      	str	r5, [sp, #104]	; 0x68
 800eb52:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 800eb54:	2d00      	cmp	r5, #0
 800eb56:	bfb8      	it	lt
 800eb58:	426d      	neglt	r5, r5
 800eb5a:	fb95 fcf2 	sdiv	ip, r5, r2
 800eb5e:	fb02 551c 	mls	r5, r2, ip, r5
 800eb62:	951c      	str	r5, [sp, #112]	; 0x70
 800eb64:	9d29      	ldr	r5, [sp, #164]	; 0xa4
 800eb66:	f8d6 9000 	ldr.w	r9, [r6]
 800eb6a:	4e4a      	ldr	r6, [pc, #296]	; (800ec94 <dTask+0x81c>)
 800eb6c:	ea31 0a25 	bics.w	sl, r1, r5, asr #32
 800eb70:	bf28      	it	cs
 800eb72:	469a      	movcs	sl, r3
 800eb74:	2d00      	cmp	r5, #0
 800eb76:	bfb8      	it	lt
 800eb78:	426d      	neglt	r5, r5
 800eb7a:	f1b9 0f00 	cmp.w	r9, #0
 800eb7e:	bf18      	it	ne
 800eb80:	4637      	movne	r7, r6
 800eb82:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 800eb84:	fb95 f8f2 	sdiv	r8, r5, r2
 800eb88:	ea31 0626 	bics.w	r6, r1, r6, asr #32
 800eb8c:	bf28      	it	cs
 800eb8e:	461e      	movcs	r6, r3
 800eb90:	9621      	str	r6, [sp, #132]	; 0x84
 800eb92:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 800eb94:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
 800eb98:	2e00      	cmp	r6, #0
 800eb9a:	bfb8      	it	lt
 800eb9c:	4276      	neglt	r6, r6
 800eb9e:	fb02 5518 	mls	r5, r2, r8, r5
 800eba2:	fb96 f9f2 	sdiv	r9, r6, r2
 800eba6:	fb02 6219 	mls	r2, r2, r9, r6
 800ebaa:	9223      	str	r2, [sp, #140]	; 0x8c
 800ebac:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 800ebae:	951f      	str	r5, [sp, #124]	; 0x7c
 800ebb0:	ea13 0322 	ands.w	r3, r3, r2, asr #32
 800ebb4:	bf38      	it	cc
 800ebb6:	460b      	movcc	r3, r1
 800ebb8:	4937      	ldr	r1, [pc, #220]	; (800ec98 <dTask+0x820>)
 800ebba:	4a38      	ldr	r2, [pc, #224]	; (800ec9c <dTask+0x824>)
 800ebbc:	f8cd c06c 	str.w	ip, [sp, #108]	; 0x6c
 800ebc0:	2800      	cmp	r0, #0
 800ebc2:	bf08      	it	eq
 800ebc4:	460a      	moveq	r2, r1
 800ebc6:	4936      	ldr	r1, [pc, #216]	; (800eca0 <dTask+0x828>)
 800ebc8:	982b      	ldr	r0, [sp, #172]	; 0xac
 800ebca:	f8cd e060 	str.w	lr, [sp, #96]	; 0x60
 800ebce:	f8cd 9088 	str.w	r9, [sp, #136]	; 0x88
 800ebd2:	9720      	str	r7, [sp, #128]	; 0x80
 800ebd4:	f8cd 8078 	str.w	r8, [sp, #120]	; 0x78
 800ebd8:	f8cd a074 	str.w	sl, [sp, #116]	; 0x74
 800ebdc:	f7f9 fde0 	bl	80087a0 <xsprintf>
 800ebe0:	6825      	ldr	r5, [r4, #0]
 800ebe2:	6860      	ldr	r0, [r4, #4]
 800ebe4:	4428      	add	r0, r5
 800ebe6:	f005 fd2b 	bl	8014640 <strlen>
 800ebea:	4428      	add	r0, r5
 800ebec:	6020      	str	r0, [r4, #0]
                  VFV(Pdiff, 1000000),
                  VFV(sMaxiL_local, 1000),
                  VFV(sMaxvL_local, 1000),
                  kSensADC?"33":"3.3",
                  VFV(Uwy_k_local, 1000));
          DPRINTF("temp1:%d.%dC, temp2:%d.%dC"CLEAR_LINE"\n", (temp1>>8),  (10*(temp1&0xFF)/256), (temp2>>8),  (10*(temp2&0xFF)/256));
 800ebee:	6826      	ldr	r6, [r4, #0]
 800ebf0:	4d2c      	ldr	r5, [pc, #176]	; (800eca4 <dTask+0x82c>)
 800ebf2:	f5b6 6f70 	cmp.w	r6, #3840	; 0xf00
 800ebf6:	da1c      	bge.n	800ec32 <dTask+0x7ba>
 800ebf8:	4b2b      	ldr	r3, [pc, #172]	; (800eca8 <dTask+0x830>)
 800ebfa:	6860      	ldr	r0, [r4, #4]
 800ebfc:	681a      	ldr	r2, [r3, #0]
 800ebfe:	4b2b      	ldr	r3, [pc, #172]	; (800ecac <dTask+0x834>)
 800ec00:	681f      	ldr	r7, [r3, #0]
 800ec02:	210a      	movs	r1, #10
 800ec04:	fa5f fe87 	uxtb.w	lr, r7
 800ec08:	b2d3      	uxtb	r3, r2
 800ec0a:	434b      	muls	r3, r1
 800ec0c:	fb01 f10e 	mul.w	r1, r1, lr
 800ec10:	1209      	asrs	r1, r1, #8
 800ec12:	123f      	asrs	r7, r7, #8
 800ec14:	4430      	add	r0, r6
 800ec16:	9101      	str	r1, [sp, #4]
 800ec18:	121b      	asrs	r3, r3, #8
 800ec1a:	1212      	asrs	r2, r2, #8
 800ec1c:	4924      	ldr	r1, [pc, #144]	; (800ecb0 <dTask+0x838>)
 800ec1e:	9700      	str	r7, [sp, #0]
 800ec20:	f7f9 fdbe 	bl	80087a0 <xsprintf>
 800ec24:	6826      	ldr	r6, [r4, #0]
 800ec26:	6860      	ldr	r0, [r4, #4]
 800ec28:	4430      	add	r0, r6
 800ec2a:	f005 fd09 	bl	8014640 <strlen>
 800ec2e:	4430      	add	r0, r6
 800ec30:	6020      	str	r0, [r4, #0]
          DPRINTF("USB In:%d, Out:%d, InIncplt:%d, OutIncmplt:%d, SOF:%d feedback:%06x:%d altSetting:%d xfer:%d"CLEAR_LINE"\n", usb_stats[0], usb_stats[1], usb_stats[2], usb_stats[3], usb_stats[4]
		  , usb_stats[5], ((usb_stats[5]>>14)*1000), usb_stats[7], usb_stats[6]);
          
          printPipes(bufSize, bufPtr);
#endif
          DPRINTF("---------------------------------------------------------------------------------"CLEAR_LINE"\n");
 800ec32:	682b      	ldr	r3, [r5, #0]
 800ec34:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800ec38:	da40      	bge.n	800ecbc <dTask+0x844>
 800ec3a:	6860      	ldr	r0, [r4, #4]
 800ec3c:	491d      	ldr	r1, [pc, #116]	; (800ecb4 <dTask+0x83c>)
 800ec3e:	4418      	add	r0, r3
 800ec40:	f7f9 fdae 	bl	80087a0 <xsprintf>
 800ec44:	6826      	ldr	r6, [r4, #0]
 800ec46:	6860      	ldr	r0, [r4, #4]
 800ec48:	4430      	add	r0, r6
 800ec4a:	f005 fcf9 	bl	8014640 <strlen>
 800ec4e:	4430      	add	r0, r6
 800ec50:	6020      	str	r0, [r4, #0]
 800ec52:	e033      	b.n	800ecbc <dTask+0x844>
 800ec54:	0801da87 	.word	0x0801da87
 800ec58:	0801daef 	.word	0x0801daef
 800ec5c:	10001000 	.word	0x10001000
 800ec60:	2001ae68 	.word	0x2001ae68
 800ec64:	2001ae48 	.word	0x2001ae48
 800ec68:	2001ae80 	.word	0x2001ae80
 800ec6c:	2001ae58 	.word	0x2001ae58
 800ec70:	2001ae4c 	.word	0x2001ae4c
 800ec74:	2001ae6c 	.word	0x2001ae6c
 800ec78:	2001ae1c 	.word	0x2001ae1c
 800ec7c:	2001ae54 	.word	0x2001ae54
 800ec80:	2001ae64 	.word	0x2001ae64
 800ec84:	08014a9d 	.word	0x08014a9d
 800ec88:	0801d7e4 	.word	0x0801d7e4
 800ec8c:	2001ad6c 	.word	0x2001ad6c
 800ec90:	0801d7e9 	.word	0x0801d7e9
 800ec94:	0801d7e6 	.word	0x0801d7e6
 800ec98:	0801d7e0 	.word	0x0801d7e0
 800ec9c:	0801d7dd 	.word	0x0801d7dd
 800eca0:	0801db67 	.word	0x0801db67
 800eca4:	2001ad88 	.word	0x2001ad88
 800eca8:	2001add0 	.word	0x2001add0
 800ecac:	2001adcc 	.word	0x2001adcc
 800ecb0:	0801dc49 	.word	0x0801dc49
 800ecb4:	0801dc65 	.word	0x0801dc65
 800ecb8:	000f4240 	.word	0x000f4240
          DPRINTF(CUR_UNSAVE);
 800ecbc:	682b      	ldr	r3, [r5, #0]
 800ecbe:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 800ecc2:	da04      	bge.n	800ecce <dTask+0x856>
 800ecc4:	6860      	ldr	r0, [r4, #4]
 800ecc6:	4927      	ldr	r1, [pc, #156]	; (800ed64 <dTask+0x8ec>)
 800ecc8:	4418      	add	r0, r3
 800ecca:	f7f9 fd69 	bl	80087a0 <xsprintf>
          *bufSize = 0;
 800ecce:	2300      	movs	r3, #0
          xprintf(bufPtr);
 800ecd0:	6868      	ldr	r0, [r5, #4]
          
          printPipes(bufSize, bufPtr);
#endif
          DPRINTF("---------------------------------------------------------------------------------"CLEAR_LINE"\n");
          DPRINTF(CUR_UNSAVE);
          *bufSize = 0;
 800ecd2:	602b      	str	r3, [r5, #0]
          xprintf(bufPtr);
 800ecd4:	f7f9 fd46 	bl	8008764 <xprintf>
          dFree(bufPtr);
 800ecd8:	6868      	ldr	r0, [r5, #4]
 800ecda:	3814      	subs	r0, #20
 800ecdc:	f7fe ff02 	bl	800dae4 <bFree>
          oldLEDsMask = -1;//Reprint LEDs
 800ece0:	4b21      	ldr	r3, [pc, #132]	; (800ed68 <dTask+0x8f0>)
 800ece2:	f04f 32ff 	mov.w	r2, #4294967295
 800ece6:	601a      	str	r2, [r3, #0]
        }

      if((i%10)==0 || refresh)
 800ece8:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800ecea:	b113      	cbz	r3, 800ecf2 <dTask+0x87a>
 800ecec:	7a23      	ldrb	r3, [r4, #8]
 800ecee:	2b00      	cmp	r3, #0
 800ecf0:	d033      	beq.n	800ed5a <dTask+0x8e2>
}
#endif
#ifdef SMOK
static void print_LED(void)
{
  if(LEDsMask != oldLEDsMask)
 800ecf2:	4f1d      	ldr	r7, [pc, #116]	; (800ed68 <dTask+0x8f0>)
 800ecf4:	68e2      	ldr	r2, [r4, #12]
 800ecf6:	683b      	ldr	r3, [r7, #0]
 800ecf8:	429a      	cmp	r2, r3
 800ecfa:	d02c      	beq.n	800ed56 <dTask+0x8de>
    {
      char LEDS[] = CUR_SAVE CUR_HOME(0) "DIODY: ["C_GREEN" "NO_COLOR"]["C_WHITE" "NO_COLOR"]["C_YELLOW" "NO_COLOR"]["C_BLUE" "NO_COLOR"]["C_RED" "NO_COLOR"]"CLEAR_LINE"\n"CUR_UNSAVE;
 800ecfc:	4b1b      	ldr	r3, [pc, #108]	; (800ed6c <dTask+0x8f4>)
 800ecfe:	ad2c      	add	r5, sp, #176	; 0xb0
 800ed00:	f103 0c18 	add.w	ip, r3, #24
 800ed04:	46ae      	mov	lr, r5
 800ed06:	6818      	ldr	r0, [r3, #0]
 800ed08:	6859      	ldr	r1, [r3, #4]
 800ed0a:	462e      	mov	r6, r5
 800ed0c:	c603      	stmia	r6!, {r0, r1}
 800ed0e:	3308      	adds	r3, #8
 800ed10:	4563      	cmp	r3, ip
 800ed12:	4635      	mov	r5, r6
 800ed14:	d1f7      	bne.n	800ed06 <dTask+0x88e>
      if(LEDsMask&LD1)LEDS[POS1]='1';
 800ed16:	07d6      	lsls	r6, r2, #31
 800ed18:	bf44      	itt	mi
 800ed1a:	2331      	movmi	r3, #49	; 0x31
 800ed1c:	f88d 30b8 	strbmi.w	r3, [sp, #184]	; 0xb8
      if(LEDsMask&LD2)LEDS[POS2]='1';
 800ed20:	0795      	lsls	r5, r2, #30
 800ed22:	bf44      	itt	mi
 800ed24:	2331      	movmi	r3, #49	; 0x31
 800ed26:	f88d 30bb 	strbmi.w	r3, [sp, #187]	; 0xbb
      if(LEDsMask&LD3)LEDS[POS3]='1';
 800ed2a:	0750      	lsls	r0, r2, #29
 800ed2c:	bf44      	itt	mi
 800ed2e:	2331      	movmi	r3, #49	; 0x31
 800ed30:	f88d 30be 	strbmi.w	r3, [sp, #190]	; 0xbe
      if(LEDsMask&LD4)LEDS[POS4]='1';
 800ed34:	0711      	lsls	r1, r2, #28
 800ed36:	bf44      	itt	mi
 800ed38:	2331      	movmi	r3, #49	; 0x31
 800ed3a:	f88d 30c1 	strbmi.w	r3, [sp, #193]	; 0xc1
      if(LEDsMask&LD5)LEDS[POS5]='1';
 800ed3e:	06d3      	lsls	r3, r2, #27
 800ed40:	bf48      	it	mi
 800ed42:	2331      	movmi	r3, #49	; 0x31
      xprintf("%s", LEDS);
 800ed44:	4671      	mov	r1, lr
 800ed46:	480a      	ldr	r0, [pc, #40]	; (800ed70 <dTask+0x8f8>)
      char LEDS[] = CUR_SAVE CUR_HOME(0) "DIODY: ["C_GREEN" "NO_COLOR"]["C_WHITE" "NO_COLOR"]["C_YELLOW" "NO_COLOR"]["C_BLUE" "NO_COLOR"]["C_RED" "NO_COLOR"]"CLEAR_LINE"\n"CUR_UNSAVE;
      if(LEDsMask&LD1)LEDS[POS1]='1';
      if(LEDsMask&LD2)LEDS[POS2]='1';
      if(LEDsMask&LD3)LEDS[POS3]='1';
      if(LEDsMask&LD4)LEDS[POS4]='1';
      if(LEDsMask&LD5)LEDS[POS5]='1';
 800ed48:	bf48      	it	mi
 800ed4a:	f88d 30c4 	strbmi.w	r3, [sp, #196]	; 0xc4
      xprintf("%s", LEDS);
 800ed4e:	f7f9 fd09 	bl	8008764 <xprintf>
      oldLEDsMask = LEDsMask;
 800ed52:	68e3      	ldr	r3, [r4, #12]
 800ed54:	603b      	str	r3, [r7, #0]
        }

      if((i%10)==0 || refresh)
        {
          print_LED();
          refresh = 0;
 800ed56:	2300      	movs	r3, #0
 800ed58:	7223      	strb	r3, [r4, #8]
            }
          taskEXIT_CRITICAL();

        }
#endif
      i++;
 800ed5a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800ed5c:	3301      	adds	r3, #1
 800ed5e:	9325      	str	r3, [sp, #148]	; 0x94
 800ed60:	f7ff bb90 	b.w	800e484 <dTask+0xc>
 800ed64:	08014a9d 	.word	0x08014a9d
 800ed68:	2001aa80 	.word	0x2001aa80
 800ed6c:	0801dcbb 	.word	0x0801dcbb
 800ed70:	0801dcb8 	.word	0x0801dcb8

0800ed74 <LED_print>:
    }
}
static int LEDsMask = 0;
static int oldLEDsMask = -1;
void LED_print(int LEDNum, int value)
{
 800ed74:	4a05      	ldr	r2, [pc, #20]	; (800ed8c <LED_print+0x18>)
 800ed76:	2301      	movs	r3, #1
  if(value)
    LEDsMask |= (1<<LEDNum);
 800ed78:	4083      	lsls	r3, r0
 800ed7a:	68d0      	ldr	r0, [r2, #12]
}
static int LEDsMask = 0;
static int oldLEDsMask = -1;
void LED_print(int LEDNum, int value)
{
  if(value)
 800ed7c:	b109      	cbz	r1, 800ed82 <LED_print+0xe>
    LEDsMask |= (1<<LEDNum);
 800ed7e:	4303      	orrs	r3, r0
 800ed80:	e001      	b.n	800ed86 <LED_print+0x12>
  else
    LEDsMask &= ~(1<<LEDNum);
 800ed82:	ea20 0303 	bic.w	r3, r0, r3
 800ed86:	60d3      	str	r3, [r2, #12]
 800ed88:	4770      	bx	lr
 800ed8a:	bf00      	nop
 800ed8c:	2001ad88 	.word	0x2001ad88

0800ed90 <debugInit>:
      i++;
    }
}

void debugInit(void)
{
 800ed90:	b510      	push	{r4, lr}
 800ed92:	b086      	sub	sp, #24
  massert(xTaskCreate(dTask, (signed char *)"D", 0x1000 / 4, NULL, 1, NULL) == pdPASS);
 800ed94:	2300      	movs	r3, #0
 800ed96:	2401      	movs	r4, #1
 800ed98:	9303      	str	r3, [sp, #12]
 800ed9a:	9302      	str	r3, [sp, #8]
 800ed9c:	9301      	str	r3, [sp, #4]
 800ed9e:	9400      	str	r4, [sp, #0]
 800eda0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800eda4:	4909      	ldr	r1, [pc, #36]	; (800edcc <debugInit+0x3c>)
 800eda6:	480a      	ldr	r0, [pc, #40]	; (800edd0 <debugInit+0x40>)
 800eda8:	f7fb fb7e 	bl	800a4a8 <xTaskGenericCreate>
 800edac:	42a0      	cmp	r0, r4
 800edae:	d00a      	beq.n	800edc6 <debugInit+0x36>
 800edb0:	4b08      	ldr	r3, [pc, #32]	; (800edd4 <debugInit+0x44>)
 800edb2:	4909      	ldr	r1, [pc, #36]	; (800edd8 <debugInit+0x48>)
 800edb4:	4809      	ldr	r0, [pc, #36]	; (800eddc <debugInit+0x4c>)
 800edb6:	f240 128f 	movw	r2, #399	; 0x18f
 800edba:	f7f9 fcd3 	bl	8008764 <xprintf>
 800edbe:	9405      	str	r4, [sp, #20]
 800edc0:	9b05      	ldr	r3, [sp, #20]
 800edc2:	2b00      	cmp	r3, #0
 800edc4:	d1fc      	bne.n	800edc0 <debugInit+0x30>
}
 800edc6:	b006      	add	sp, #24
 800edc8:	bd10      	pop	{r4, pc}
 800edca:	bf00      	nop
 800edcc:	0801e4ee 	.word	0x0801e4ee
 800edd0:	0800e479 	.word	0x0800e479
 800edd4:	0801dcd3 	.word	0x0801dcd3
 800edd8:	0801d7bc 	.word	0x0801d7bc
 800eddc:	080148f4 	.word	0x080148f4

0800ede0 <wdogFeed>:
#include <watchdog.h>
#include <cfg.h>

static int fedMask = 0;
void wdogFeed(int mask)
{
 800ede0:	b510      	push	{r4, lr}
 800ede2:	4604      	mov	r4, r0
  taskENTER_CRITICAL();
 800ede4:	f7fb f9a6 	bl	800a134 <vPortEnterCritical>
  fedMask |= mask;
 800ede8:	4b03      	ldr	r3, [pc, #12]	; (800edf8 <wdogFeed+0x18>)
 800edea:	6818      	ldr	r0, [r3, #0]
 800edec:	4304      	orrs	r4, r0
 800edee:	601c      	str	r4, [r3, #0]
  taskEXIT_CRITICAL();
}
 800edf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static int fedMask = 0;
void wdogFeed(int mask)
{
  taskENTER_CRITICAL();
  fedMask |= mask;
  taskEXIT_CRITICAL();
 800edf4:	f7fb b9b0 	b.w	800a158 <vPortExitCritical>
 800edf8:	2001ad98 	.word	0x2001ad98

0800edfc <watchdogReset>:
void __attribute__((weak))wdogAssert(int value)
{
}
static int resetActive = 0;
void watchdogReset(void)
{
 800edfc:	b508      	push	{r3, lr}
  IWDG_ReloadCounter();
 800edfe:	f004 fa71 	bl	80132e4 <IWDG_ReloadCounter>
  resetActive = 1;
 800ee02:	4b02      	ldr	r3, [pc, #8]	; (800ee0c <watchdogReset+0x10>)
 800ee04:	2201      	movs	r2, #1
 800ee06:	605a      	str	r2, [r3, #4]
 800ee08:	bd08      	pop	{r3, pc}
 800ee0a:	bf00      	nop
 800ee0c:	2001ad98 	.word	0x2001ad98

0800ee10 <watchdogTask>:
}

static void watchdogTask(void *pvParameters)
{
 800ee10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
 800ee12:	f245 5055 	movw	r0, #21845	; 0x5555
 800ee16:	f004 fa31 	bl	801327c <IWDG_WriteAccessCmd>
  IWDG_SetPrescaler(IWDG_Prescaler_256);
 800ee1a:	2006      	movs	r0, #6
 800ee1c:	f004 fa42 	bl	80132a4 <IWDG_SetPrescaler>
  IWDG_SetReload(2*256);
 800ee20:	f44f 7000 	mov.w	r0, #512	; 0x200
 800ee24:	f004 fa4e 	bl	80132c4 <IWDG_SetReload>
    {
      wdogAssert(0);
      mdelay(12);
      wdogAssert(1);
      mdelay(13);
      if(!resetActive)
 800ee28:	4d18      	ldr	r5, [pc, #96]	; (800ee8c <watchdogTask+0x7c>)
        IWDG_ReloadCounter();
      if(checkTime == 0)
        {
          if(fedMask != WATCHDOG_EXPECTED)
            {
              dprintf(LL_ERROR, "\n!!!!!!Some tasks did not respond (fed mask %x). Turn off the power!!!!!\n", fedMask);
 800ee2a:	4f19      	ldr	r7, [pc, #100]	; (800ee90 <watchdogTask+0x80>)
{

  IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
  IWDG_SetPrescaler(IWDG_Prescaler_256);
  IWDG_SetReload(2*256);
  IWDG_Enable();
 800ee2c:	f004 fa62 	bl	80132f4 <IWDG_Enable>
  IWDG_ReloadCounter();
 800ee30:	f004 fa58 	bl	80132e4 <IWDG_ReloadCounter>

  systemInit();
 800ee34:	f7f9 f9b4 	bl	80081a0 <systemInit>

  int checkTime = WATCHDOG_TIMEOUT*40;
 800ee38:	f44f 7448 	mov.w	r4, #800	; 0x320
 800ee3c:	462e      	mov	r6, r5
  while (1)
    {
      wdogAssert(0);
 800ee3e:	2000      	movs	r0, #0
 800ee40:	f000 fe96 	bl	800fb70 <wdogAssert>
      mdelay(12);
 800ee44:	200c      	movs	r0, #12
 800ee46:	f7fb fd23 	bl	800a890 <vTaskDelay>
      wdogAssert(1);
 800ee4a:	2001      	movs	r0, #1
 800ee4c:	f000 fe90 	bl	800fb70 <wdogAssert>
      mdelay(13);
 800ee50:	200d      	movs	r0, #13
 800ee52:	f7fb fd1d 	bl	800a890 <vTaskDelay>
      if(!resetActive)
 800ee56:	686b      	ldr	r3, [r5, #4]
 800ee58:	b90b      	cbnz	r3, 800ee5e <watchdogTask+0x4e>
        IWDG_ReloadCounter();
 800ee5a:	f004 fa43 	bl	80132e4 <IWDG_ReloadCounter>
      if(checkTime == 0)
 800ee5e:	b99c      	cbnz	r4, 800ee88 <watchdogTask+0x78>
        {
          if(fedMask != WATCHDOG_EXPECTED)
 800ee60:	6831      	ldr	r1, [r6, #0]
 800ee62:	293f      	cmp	r1, #63	; 0x3f
 800ee64:	d007      	beq.n	800ee76 <watchdogTask+0x66>
            {
              dprintf(LL_ERROR, "\n!!!!!!Some tasks did not respond (fed mask %x). Turn off the power!!!!!\n", fedMask);
 800ee66:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ee68:	2b00      	cmp	r3, #0
 800ee6a:	db02      	blt.n	800ee72 <watchdogTask+0x62>
 800ee6c:	4809      	ldr	r0, [pc, #36]	; (800ee94 <watchdogTask+0x84>)
 800ee6e:	f7f9 fc79 	bl	8008764 <xprintf>
              wdogFail();
 800ee72:	f7fa fbef 	bl	8009654 <wdogFail>
            }
          taskENTER_CRITICAL();
 800ee76:	f7fb f95d 	bl	800a134 <vPortEnterCritical>
          fedMask = 0;
 800ee7a:	2300      	movs	r3, #0
 800ee7c:	6033      	str	r3, [r6, #0]
          taskEXIT_CRITICAL();
          checkTime = WATCHDOG_TIMEOUT*40;
 800ee7e:	f44f 7448 	mov.w	r4, #800	; 0x320
              dprintf(LL_ERROR, "\n!!!!!!Some tasks did not respond (fed mask %x). Turn off the power!!!!!\n", fedMask);
              wdogFail();
            }
          taskENTER_CRITICAL();
          fedMask = 0;
          taskEXIT_CRITICAL();
 800ee82:	f7fb f969 	bl	800a158 <vPortExitCritical>
 800ee86:	e7da      	b.n	800ee3e <watchdogTask+0x2e>
          checkTime = WATCHDOG_TIMEOUT*40;
        }
      else
        checkTime--;
 800ee88:	3c01      	subs	r4, #1
 800ee8a:	e7d8      	b.n	800ee3e <watchdogTask+0x2e>
 800ee8c:	2001ad98 	.word	0x2001ad98
 800ee90:	10001000 	.word	0x10001000
 800ee94:	0801dd2c 	.word	0x0801dd2c

0800ee98 <watchdogInit>:
{
  while(1);
}

void watchdogInit(void)
{
 800ee98:	b510      	push	{r4, lr}
 800ee9a:	b086      	sub	sp, #24
  massert(xTaskCreate(watchdogTask, (signed char *)"Watchdog", 1024 / 4, NULL, 1, NULL) == pdPASS);
 800ee9c:	2300      	movs	r3, #0
 800ee9e:	2401      	movs	r4, #1
 800eea0:	9303      	str	r3, [sp, #12]
 800eea2:	9302      	str	r3, [sp, #8]
 800eea4:	9301      	str	r3, [sp, #4]
 800eea6:	9400      	str	r4, [sp, #0]
 800eea8:	f44f 7280 	mov.w	r2, #256	; 0x100
 800eeac:	4908      	ldr	r1, [pc, #32]	; (800eed0 <watchdogInit+0x38>)
 800eeae:	4809      	ldr	r0, [pc, #36]	; (800eed4 <watchdogInit+0x3c>)
 800eeb0:	f7fb fafa 	bl	800a4a8 <xTaskGenericCreate>
 800eeb4:	42a0      	cmp	r0, r4
 800eeb6:	d009      	beq.n	800eecc <watchdogInit+0x34>
 800eeb8:	4b07      	ldr	r3, [pc, #28]	; (800eed8 <watchdogInit+0x40>)
 800eeba:	4908      	ldr	r1, [pc, #32]	; (800eedc <watchdogInit+0x44>)
 800eebc:	4808      	ldr	r0, [pc, #32]	; (800eee0 <watchdogInit+0x48>)
 800eebe:	224c      	movs	r2, #76	; 0x4c
 800eec0:	f7f9 fc50 	bl	8008764 <xprintf>
 800eec4:	9405      	str	r4, [sp, #20]
 800eec6:	9b05      	ldr	r3, [sp, #20]
 800eec8:	2b00      	cmp	r3, #0
 800eeca:	d1fc      	bne.n	800eec6 <watchdogInit+0x2e>
}
 800eecc:	b006      	add	sp, #24
 800eece:	bd10      	pop	{r4, pc}
 800eed0:	0801dd76 	.word	0x0801dd76
 800eed4:	0800ee11 	.word	0x0800ee11
 800eed8:	0801dd7f 	.word	0x0801dd7f
 800eedc:	0801dd1f 	.word	0x0801dd1f
 800eee0:	080148f4 	.word	0x080148f4

0800eee4 <i2cInit>:

#define FLAG_TIMEOUT             ((uint32_t)2)
#define LONG_TIMEOUT             ((uint32_t)(10 * FLAG_TIMEOUT))

int i2cInit(I2C_TypeDef *i2c)
{
 800eee4:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
 800eee6:	2101      	movs	r1, #1

#define FLAG_TIMEOUT             ((uint32_t)2)
#define LONG_TIMEOUT             ((uint32_t)(10 * FLAG_TIMEOUT))

int i2cInit(I2C_TypeDef *i2c)
{
 800eee8:	b086      	sub	sp, #24
 800eeea:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
 800eeec:	2002      	movs	r0, #2
 800eeee:	f002 f961 	bl	80111b4 <RCC_AHB1PeriphClockCmd>

  if(i2c == I2C1)
 800eef2:	4b2d      	ldr	r3, [pc, #180]	; (800efa8 <i2cInit+0xc4>)

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 800eef4:	482d      	ldr	r0, [pc, #180]	; (800efac <i2cInit+0xc8>)
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable I2C GPIO clocks */
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);

  if(i2c == I2C1)
 800eef6:	429c      	cmp	r4, r3
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
 800eef8:	bf0c      	ite	eq
 800eefa:	23c0      	moveq	r3, #192	; 0xc0
  else
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 800eefc:	f44f 6340 	movne.w	r3, #3072	; 0xc00
 800ef00:	9300      	str	r3, [sp, #0]

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800ef02:	2302      	movs	r3, #2
 800ef04:	f88d 3004 	strb.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800ef08:	f88d 3005 	strb.w	r3, [sp, #5]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 800ef0c:	2501      	movs	r5, #1
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800ef0e:	2300      	movs	r3, #0
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 800ef10:	4669      	mov	r1, sp
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800ef12:	f88d 3007 	strb.w	r3, [sp, #7]
  else
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 800ef16:	f88d 5006 	strb.w	r5, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOB, &GPIO_InitStructure);
 800ef1a:	f001 ff33 	bl	8010d84 <GPIO_Init>

  /* Connect pins to I2C peripheral */
  if(i2c == I2C1)
 800ef1e:	4b22      	ldr	r3, [pc, #136]	; (800efa8 <i2cInit+0xc4>)
 800ef20:	429c      	cmp	r4, r3
    {
      GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);
 800ef22:	f04f 0204 	mov.w	r2, #4
  GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
  GPIO_Init(GPIOB, &GPIO_InitStructure);

  /* Connect pins to I2C peripheral */
  if(i2c == I2C1)
 800ef26:	d10c      	bne.n	800ef42 <i2cInit+0x5e>
    {
      GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);
 800ef28:	2106      	movs	r1, #6
 800ef2a:	4820      	ldr	r0, [pc, #128]	; (800efac <i2cInit+0xc8>)
 800ef2c:	f002 f8a4 	bl	8011078 <GPIO_PinAFConfig>
      GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_I2C1);
 800ef30:	2107      	movs	r1, #7
 800ef32:	481e      	ldr	r0, [pc, #120]	; (800efac <i2cInit+0xc8>)
 800ef34:	2204      	movs	r2, #4
 800ef36:	f002 f89f 	bl	8011078 <GPIO_PinAFConfig>
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
 800ef3a:	4629      	mov	r1, r5
 800ef3c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800ef40:	e00b      	b.n	800ef5a <i2cInit+0x76>
    }
  else
    {
      GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_I2C2);
 800ef42:	210a      	movs	r1, #10
 800ef44:	4819      	ldr	r0, [pc, #100]	; (800efac <i2cInit+0xc8>)
 800ef46:	f002 f897 	bl	8011078 <GPIO_PinAFConfig>
      GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_I2C2);
 800ef4a:	210b      	movs	r1, #11
 800ef4c:	4817      	ldr	r0, [pc, #92]	; (800efac <i2cInit+0xc8>)
 800ef4e:	2204      	movs	r2, #4
 800ef50:	f002 f892 	bl	8011078 <GPIO_PinAFConfig>
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);
 800ef54:	4629      	mov	r1, r5
 800ef56:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800ef5a:	f002 f94f 	bl	80111fc <RCC_APB1PeriphClockCmd>
    }

  I2C_InitTypeDef I2C_InitStructure;


  I2C_DeInit(i2c);
 800ef5e:	4620      	mov	r0, r4
 800ef60:	f003 f88c 	bl	801207c <I2C_DeInit>
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 800ef64:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 800ef68:	f8ad 300e 	strh.w	r3, [sp, #14]
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
 800ef6c:	2333      	movs	r3, #51	; 0x33
 800ef6e:	f8ad 3010 	strh.w	r3, [sp, #16]
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 800ef72:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ef76:	f8ad 3012 	strh.w	r3, [sp, #18]
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = 100000;
 800ef7a:	ad06      	add	r5, sp, #24
  I2C_DeInit(i2c);
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 800ef7c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800ef80:	f8ad 3014 	strh.w	r3, [sp, #20]
  I2C_InitStructure.I2C_ClockSpeed = 100000;
 800ef84:	4b0a      	ldr	r3, [pc, #40]	; (800efb0 <i2cInit+0xcc>)
 800ef86:	f845 3d10 	str.w	r3, [r5, #-16]!

  I2C_InitTypeDef I2C_InitStructure;


  I2C_DeInit(i2c);
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 800ef8a:	2600      	movs	r6, #0
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = 100000;
  /* Enable the I2C peripheral */
  I2C_Cmd(i2c, ENABLE);
 800ef8c:	4620      	mov	r0, r4
 800ef8e:	2101      	movs	r1, #1

  I2C_InitTypeDef I2C_InitStructure;


  I2C_DeInit(i2c);
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 800ef90:	f8ad 600c 	strh.w	r6, [sp, #12]
  I2C_InitStructure.I2C_OwnAddress1 = 0x33;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = 100000;
  /* Enable the I2C peripheral */
  I2C_Cmd(i2c, ENABLE);
 800ef94:	f003 f968 	bl	8012268 <I2C_Cmd>
  I2C_Init(i2c, &I2C_InitStructure);
 800ef98:	4620      	mov	r0, r4
 800ef9a:	4629      	mov	r1, r5
 800ef9c:	f003 f8a2 	bl	80120e4 <I2C_Init>
  return 0;
}
 800efa0:	4630      	mov	r0, r6
 800efa2:	b006      	add	sp, #24
 800efa4:	bd70      	pop	{r4, r5, r6, pc}
 800efa6:	bf00      	nop
 800efa8:	40005400 	.word	0x40005400
 800efac:	40020400 	.word	0x40020400
 800efb0:	000186a0 	.word	0x000186a0

0800efb4 <i2cWrite>:
  }						\
 else						\
   mdelay(1);

int i2cWrite(I2C_TypeDef *i2c, uint8_t addr, uint8_t *data, uint16_t size)
{
 800efb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800efb8:	4604      	mov	r4, r0
 800efba:	460d      	mov	r5, r1
 800efbc:	4617      	mov	r7, r2
 800efbe:	4698      	mov	r8, r3
  uint32_t timeout = 0;
  /*!< While the bus is busy */
  timeout = LONG_TIMEOUT;
  while (I2C_GetFlagStatus(i2c, I2C_FLAG_BUSY))
 800efc0:	2615      	movs	r6, #21
 800efc2:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 800efc6:	4620      	mov	r0, r4
 800efc8:	f003 fabc 	bl	8012544 <I2C_GetFlagStatus>
 800efcc:	b128      	cbz	r0, 800efda <i2cWrite+0x26>
    ERR_EXIT_IF_TMOUT(0);
 800efce:	3e01      	subs	r6, #1
 800efd0:	d06a      	beq.n	800f0a8 <i2cWrite+0xf4>
 800efd2:	2001      	movs	r0, #1
 800efd4:	f7fb fc5c 	bl	800a890 <vTaskDelay>
 800efd8:	e7f3      	b.n	800efc2 <i2cWrite+0xe>

  /* Start the config sequence */
  I2C_GenerateSTART(i2c, ENABLE);
 800efda:	2101      	movs	r1, #1
 800efdc:	4620      	mov	r0, r4
 800efde:	f003 f96f 	bl	80122c0 <I2C_GenerateSTART>

  /* Test on EV5 and clear it */
  timeout = FLAG_TIMEOUT;
  while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_MODE_SELECT))
 800efe2:	2603      	movs	r6, #3
 800efe4:	4933      	ldr	r1, [pc, #204]	; (800f0b4 <i2cWrite+0x100>)
 800efe6:	4620      	mov	r0, r4
 800efe8:	f003 fa48 	bl	801247c <I2C_CheckEvent>
 800efec:	b960      	cbnz	r0, 800f008 <i2cWrite+0x54>
    ERR_EXIT_IF_TMOUT(1);
 800efee:	3e01      	subs	r6, #1
 800eff0:	d106      	bne.n	800f000 <i2cWrite+0x4c>
 800eff2:	2101      	movs	r1, #1
 800eff4:	4620      	mov	r0, r4
 800eff6:	f003 f98f 	bl	8012318 <I2C_GenerateSTOP>
 800effa:	f06f 055d 	mvn.w	r5, #93	; 0x5d
 800effe:	e055      	b.n	800f0ac <i2cWrite+0xf8>
 800f000:	2001      	movs	r0, #1
 800f002:	f7fb fc45 	bl	800a890 <vTaskDelay>
 800f006:	e7ed      	b.n	800efe4 <i2cWrite+0x30>

  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(i2c, addr<<1, I2C_Direction_Transmitter);
 800f008:	0069      	lsls	r1, r5, #1
 800f00a:	2200      	movs	r2, #0
 800f00c:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 800f010:	4620      	mov	r0, r4
 800f012:	f003 f9ad 	bl	8012370 <I2C_Send7bitAddress>
 800f016:	2503      	movs	r5, #3

  /* Test on EV6 and clear it */
  timeout = FLAG_TIMEOUT;
  while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 800f018:	4927      	ldr	r1, [pc, #156]	; (800f0b8 <i2cWrite+0x104>)
 800f01a:	4620      	mov	r0, r4
 800f01c:	f003 fa2e 	bl	801247c <I2C_CheckEvent>
 800f020:	b960      	cbnz	r0, 800f03c <i2cWrite+0x88>
    ERR_EXIT_IF_TMOUT(1);
 800f022:	3d01      	subs	r5, #1
 800f024:	d106      	bne.n	800f034 <i2cWrite+0x80>
 800f026:	2101      	movs	r1, #1
 800f028:	4620      	mov	r0, r4
 800f02a:	f003 f975 	bl	8012318 <I2C_GenerateSTOP>
 800f02e:	f06f 0565 	mvn.w	r5, #101	; 0x65
 800f032:	e03b      	b.n	800f0ac <i2cWrite+0xf8>
 800f034:	2001      	movs	r0, #1
 800f036:	f7fb fc2b 	bl	800a890 <vTaskDelay>
 800f03a:	e7ed      	b.n	800f018 <i2cWrite+0x64>
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(i2c, addr<<1, I2C_Direction_Transmitter);

  /* Test on EV6 and clear it */
  timeout = FLAG_TIMEOUT;
  while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 800f03c:	463e      	mov	r6, r7
    ERR_EXIT_IF_TMOUT(1);

  int i;
  for(i = 0; i < size; i++)
 800f03e:	1bf3      	subs	r3, r6, r7
 800f040:	4598      	cmp	r8, r3
 800f042:	4645      	mov	r5, r8
 800f044:	dd18      	ble.n	800f078 <i2cWrite+0xc4>
    {
      /* Transmit the first address for write operation */
      I2C_SendData(i2c, data[i]);
 800f046:	f816 1b01 	ldrb.w	r1, [r6], #1
 800f04a:	4620      	mov	r0, r4
 800f04c:	f003 f9e4 	bl	8012418 <I2C_SendData>
 800f050:	2503      	movs	r5, #3

      /* Test on EV8 and clear it */
      timeout = FLAG_TIMEOUT;
      while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
 800f052:	491a      	ldr	r1, [pc, #104]	; (800f0bc <i2cWrite+0x108>)
 800f054:	4620      	mov	r0, r4
 800f056:	f003 fa11 	bl	801247c <I2C_CheckEvent>
 800f05a:	2800      	cmp	r0, #0
 800f05c:	d1ef      	bne.n	800f03e <i2cWrite+0x8a>
        ERR_EXIT_IF_TMOUT(1);
 800f05e:	3d01      	subs	r5, #1
 800f060:	d106      	bne.n	800f070 <i2cWrite+0xbc>
 800f062:	2101      	movs	r1, #1
 800f064:	4620      	mov	r0, r4
 800f066:	f003 f957 	bl	8012318 <I2C_GenerateSTOP>
 800f06a:	f06f 0570 	mvn.w	r5, #112	; 0x70
 800f06e:	e01d      	b.n	800f0ac <i2cWrite+0xf8>
 800f070:	2001      	movs	r0, #1
 800f072:	f7fb fc0d 	bl	800a890 <vTaskDelay>
 800f076:	e7ec      	b.n	800f052 <i2cWrite+0x9e>
  timeout = FLAG_TIMEOUT;
  while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    ERR_EXIT_IF_TMOUT(1);

  int i;
  for(i = 0; i < size; i++)
 800f078:	2615      	movs	r6, #21
        ERR_EXIT_IF_TMOUT(1);

    }
  /*!< Wait till all data have been physically transferred on the bus */
  timeout = LONG_TIMEOUT;
  while (!I2C_GetFlagStatus(i2c, I2C_FLAG_BTF))
 800f07a:	4911      	ldr	r1, [pc, #68]	; (800f0c0 <i2cWrite+0x10c>)
 800f07c:	4620      	mov	r0, r4
 800f07e:	f003 fa61 	bl	8012544 <I2C_GetFlagStatus>
 800f082:	b960      	cbnz	r0, 800f09e <i2cWrite+0xea>
    ERR_EXIT_IF_TMOUT(1);
 800f084:	3e01      	subs	r6, #1
 800f086:	d106      	bne.n	800f096 <i2cWrite+0xe2>
 800f088:	2101      	movs	r1, #1
 800f08a:	4620      	mov	r0, r4
 800f08c:	f003 f944 	bl	8012318 <I2C_GenerateSTOP>
 800f090:	f06f 0576 	mvn.w	r5, #118	; 0x76
 800f094:	e00a      	b.n	800f0ac <i2cWrite+0xf8>
 800f096:	2001      	movs	r0, #1
 800f098:	f7fb fbfa 	bl	800a890 <vTaskDelay>
 800f09c:	e7ed      	b.n	800f07a <i2cWrite+0xc6>

  /* End the configuration sequence */
  I2C_GenerateSTOP(i2c, ENABLE);
 800f09e:	2101      	movs	r1, #1
 800f0a0:	4620      	mov	r0, r4
 800f0a2:	f003 f939 	bl	8012318 <I2C_GenerateSTOP>
 800f0a6:	e001      	b.n	800f0ac <i2cWrite+0xf8>
{
  uint32_t timeout = 0;
  /*!< While the bus is busy */
  timeout = LONG_TIMEOUT;
  while (I2C_GetFlagStatus(i2c, I2C_FLAG_BUSY))
    ERR_EXIT_IF_TMOUT(0);
 800f0a8:	f06f 0555 	mvn.w	r5, #85	; 0x55
    ERR_EXIT_IF_TMOUT(1);

  /* End the configuration sequence */
  I2C_GenerateSTOP(i2c, ENABLE);
  return size;
}
 800f0ac:	4628      	mov	r0, r5
 800f0ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f0b2:	bf00      	nop
 800f0b4:	00030001 	.word	0x00030001
 800f0b8:	00070082 	.word	0x00070082
 800f0bc:	00070080 	.word	0x00070080
 800f0c0:	10000004 	.word	0x10000004

0800f0c4 <i2cRead>:

int i2cRead(I2C_TypeDef *i2c, uint8_t addr, uint8_t *data, uint16_t size)
{
 800f0c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f0c8:	4604      	mov	r4, r0
 800f0ca:	460d      	mov	r5, r1
 800f0cc:	4690      	mov	r8, r2
 800f0ce:	461f      	mov	r7, r3
  uint32_t timeout = 0;

  /*!< While the bus is busy */
  timeout = LONG_TIMEOUT;
  while (I2C_GetFlagStatus(i2c, I2C_FLAG_BUSY))
 800f0d0:	2615      	movs	r6, #21
 800f0d2:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 800f0d6:	4620      	mov	r0, r4
 800f0d8:	f003 fa34 	bl	8012544 <I2C_GetFlagStatus>
 800f0dc:	b128      	cbz	r0, 800f0ea <i2cRead+0x26>
    ERR_EXIT_IF_TMOUT(0);
 800f0de:	3e01      	subs	r6, #1
 800f0e0:	d068      	beq.n	800f1b4 <i2cRead+0xf0>
 800f0e2:	2001      	movs	r0, #1
 800f0e4:	f7fb fbd4 	bl	800a890 <vTaskDelay>
 800f0e8:	e7f3      	b.n	800f0d2 <i2cRead+0xe>

  /*!< Send START condition a second time */
  I2C_GenerateSTART(i2c, ENABLE);
 800f0ea:	2101      	movs	r1, #1
 800f0ec:	4620      	mov	r0, r4
 800f0ee:	f003 f8e7 	bl	80122c0 <I2C_GenerateSTART>

  /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
  timeout = FLAG_TIMEOUT;
  while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_MODE_SELECT))
 800f0f2:	2603      	movs	r6, #3
 800f0f4:	4932      	ldr	r1, [pc, #200]	; (800f1c0 <i2cRead+0xfc>)
 800f0f6:	4620      	mov	r0, r4
 800f0f8:	f003 f9c0 	bl	801247c <I2C_CheckEvent>
 800f0fc:	b960      	cbnz	r0, 800f118 <i2cRead+0x54>
    ERR_EXIT_IF_TMOUT(1);
 800f0fe:	3e01      	subs	r6, #1
 800f100:	d106      	bne.n	800f110 <i2cRead+0x4c>
 800f102:	2101      	movs	r1, #1
 800f104:	4620      	mov	r0, r4
 800f106:	f003 f907 	bl	8012318 <I2C_GenerateSTOP>
 800f10a:	f06f 058c 	mvn.w	r5, #140	; 0x8c
 800f10e:	e053      	b.n	800f1b8 <i2cRead+0xf4>
 800f110:	2001      	movs	r0, #1
 800f112:	f7fb fbbd 	bl	800a890 <vTaskDelay>
 800f116:	e7ed      	b.n	800f0f4 <i2cRead+0x30>

  /*!< Send TEMP_SENSOR address for read */
  I2C_Send7bitAddress(i2c, addr<<1, I2C_Direction_Receiver);
 800f118:	0069      	lsls	r1, r5, #1
 800f11a:	2201      	movs	r2, #1
 800f11c:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 800f120:	4620      	mov	r0, r4
 800f122:	f003 f925 	bl	8012370 <I2C_Send7bitAddress>
 800f126:	2503      	movs	r5, #3

  /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
  timeout = FLAG_TIMEOUT;
  while (I2C_GetFlagStatus(i2c, I2C_FLAG_ADDR) == RESET)
 800f128:	4926      	ldr	r1, [pc, #152]	; (800f1c4 <i2cRead+0x100>)
 800f12a:	4620      	mov	r0, r4
 800f12c:	f003 fa0a 	bl	8012544 <I2C_GetFlagStatus>
 800f130:	b960      	cbnz	r0, 800f14c <i2cRead+0x88>
    ERR_EXIT_IF_TMOUT(1);
 800f132:	3d01      	subs	r5, #1
 800f134:	d106      	bne.n	800f144 <i2cRead+0x80>
 800f136:	2101      	movs	r1, #1
 800f138:	4620      	mov	r0, r4
 800f13a:	f003 f8ed 	bl	8012318 <I2C_GenerateSTOP>
 800f13e:	f06f 0594 	mvn.w	r5, #148	; 0x94
 800f142:	e039      	b.n	800f1b8 <i2cRead+0xf4>
 800f144:	2001      	movs	r0, #1
 800f146:	f7fb fba3 	bl	800a890 <vTaskDelay>
 800f14a:	e7ed      	b.n	800f128 <i2cRead+0x64>

  /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
  (void)i2c->SR2;
 800f14c:	8b23      	ldrh	r3, [r4, #24]

  int i;
  for(i = 0; i < size; i++)
 800f14e:	2600      	movs	r6, #0
    {
      if(i == size -1)
 800f150:	f107 39ff 	add.w	r9, r7, #4294967295

  /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
  (void)i2c->SR2;

  int i;
  for(i = 0; i < size; i++)
 800f154:	42b7      	cmp	r7, r6
 800f156:	463d      	mov	r5, r7
 800f158:	dd23      	ble.n	800f1a2 <i2cRead+0xde>
    {
      if(i == size -1)
 800f15a:	45b1      	cmp	r9, r6
 800f15c:	d107      	bne.n	800f16e <i2cRead+0xaa>
        {
          //Last byte
          /*!< Disable Acknowledgment */
          I2C_AcknowledgeConfig(i2c, DISABLE);
 800f15e:	2100      	movs	r1, #0
 800f160:	4620      	mov	r0, r4
 800f162:	f003 f92d 	bl	80123c0 <I2C_AcknowledgeConfig>
          /*!< Send STOP Condition */
          I2C_GenerateSTOP(i2c, ENABLE);
 800f166:	2101      	movs	r1, #1
 800f168:	4620      	mov	r0, r4
 800f16a:	f003 f8d5 	bl	8012318 <I2C_GenerateSTOP>
  timeout = FLAG_TIMEOUT;
  while (!I2C_CheckEvent(i2c, I2C_EVENT_MASTER_MODE_SELECT))
    ERR_EXIT_IF_TMOUT(1);

  /*!< Send TEMP_SENSOR address for read */
  I2C_Send7bitAddress(i2c, addr<<1, I2C_Direction_Receiver);
 800f16e:	2503      	movs	r5, #3
          /*!< Send STOP Condition */
          I2C_GenerateSTOP(i2c, ENABLE);
        }
      /* Wait for the byte to be received */
      timeout = FLAG_TIMEOUT;
      while (I2C_GetFlagStatus(i2c, I2C_FLAG_RXNE) == RESET)
 800f170:	4915      	ldr	r1, [pc, #84]	; (800f1c8 <i2cRead+0x104>)
 800f172:	4620      	mov	r0, r4
 800f174:	f003 f9e6 	bl	8012544 <I2C_GetFlagStatus>
 800f178:	b960      	cbnz	r0, 800f194 <i2cRead+0xd0>
        ERR_EXIT_IF_TMOUT(1);
 800f17a:	3d01      	subs	r5, #1
 800f17c:	d106      	bne.n	800f18c <i2cRead+0xc8>
 800f17e:	2101      	movs	r1, #1
 800f180:	4620      	mov	r0, r4
 800f182:	f003 f8c9 	bl	8012318 <I2C_GenerateSTOP>
 800f186:	f06f 05a7 	mvn.w	r5, #167	; 0xa7
 800f18a:	e015      	b.n	800f1b8 <i2cRead+0xf4>
 800f18c:	2001      	movs	r0, #1
 800f18e:	f7fb fb7f 	bl	800a890 <vTaskDelay>
 800f192:	e7ed      	b.n	800f170 <i2cRead+0xac>

      /*!< Read the byte received from the TEMP_SENSOR */
      data[i] = I2C_ReceiveData(i2c);
 800f194:	4620      	mov	r0, r4
 800f196:	f003 f959 	bl	801244c <I2C_ReceiveData>
 800f19a:	f808 0006 	strb.w	r0, [r8, r6]

  /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
  (void)i2c->SR2;

  int i;
  for(i = 0; i < size; i++)
 800f19e:	3601      	adds	r6, #1
 800f1a0:	e7d8      	b.n	800f154 <i2cRead+0x90>
      /*!< Read the byte received from the TEMP_SENSOR */
      data[i] = I2C_ReceiveData(i2c);
    }

  /*!< Re-Enable Acknowledgment to be ready for another reception */
  I2C_AcknowledgeConfig(i2c, ENABLE);
 800f1a2:	4620      	mov	r0, r4
 800f1a4:	2101      	movs	r1, #1
 800f1a6:	f003 f90b 	bl	80123c0 <I2C_AcknowledgeConfig>

  /* Clear AF flag for next communication */
  I2C_ClearFlag(i2c, I2C_FLAG_AF);
 800f1aa:	4908      	ldr	r1, [pc, #32]	; (800f1cc <i2cRead+0x108>)
 800f1ac:	4620      	mov	r0, r4
 800f1ae:	f003 fa67 	bl	8012680 <I2C_ClearFlag>
 800f1b2:	e001      	b.n	800f1b8 <i2cRead+0xf4>
  uint32_t timeout = 0;

  /*!< While the bus is busy */
  timeout = LONG_TIMEOUT;
  while (I2C_GetFlagStatus(i2c, I2C_FLAG_BUSY))
    ERR_EXIT_IF_TMOUT(0);
 800f1b4:	f06f 0584 	mvn.w	r5, #132	; 0x84

  /* Clear AF flag for next communication */
  I2C_ClearFlag(i2c, I2C_FLAG_AF);

  return size;
}
 800f1b8:	4628      	mov	r0, r5
 800f1ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800f1be:	bf00      	nop
 800f1c0:	00030001 	.word	0x00030001
 800f1c4:	10000002 	.word	0x10000002
 800f1c8:	10000040 	.word	0x10000040
 800f1cc:	10000400 	.word	0x10000400

0800f1d0 <i2cTransfer>:

int i2cTransfer(I2C_TypeDef *i2c, uint8_t addr, uint8_t *txData, uint16_t txSize, uint8_t *rxData, uint16_t rxSize)
{
 800f1d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f1d4:	9d06      	ldr	r5, [sp, #24]
 800f1d6:	f8bd 601c 	ldrh.w	r6, [sp, #28]
 800f1da:	4607      	mov	r7, r0
 800f1dc:	4688      	mov	r8, r1
  int ret = 0;
  if(txSize && txData)
 800f1de:	469e      	mov	lr, r3
 800f1e0:	b11b      	cbz	r3, 800f1ea <i2cTransfer+0x1a>
 800f1e2:	b122      	cbz	r2, 800f1ee <i2cTransfer+0x1e>
    ret = i2cWrite(i2c, addr, txData, txSize);
 800f1e4:	f7ff fee6 	bl	800efb4 <i2cWrite>
 800f1e8:	e002      	b.n	800f1f0 <i2cTransfer+0x20>
  return size;
}

int i2cTransfer(I2C_TypeDef *i2c, uint8_t addr, uint8_t *txData, uint16_t txSize, uint8_t *rxData, uint16_t rxSize)
{
  int ret = 0;
 800f1ea:	4618      	mov	r0, r3
 800f1ec:	e000      	b.n	800f1f0 <i2cTransfer+0x20>
 800f1ee:	4610      	mov	r0, r2
  if(txSize && txData)
    ret = i2cWrite(i2c, addr, txData, txSize);
  if(rxSize && rxData && ret > 0)
 800f1f0:	b156      	cbz	r6, 800f208 <i2cTransfer+0x38>
 800f1f2:	b14d      	cbz	r5, 800f208 <i2cTransfer+0x38>
 800f1f4:	2800      	cmp	r0, #0
 800f1f6:	dd07      	ble.n	800f208 <i2cTransfer+0x38>
    ret = i2cRead(i2c, addr, rxData, rxSize);
 800f1f8:	4633      	mov	r3, r6
 800f1fa:	462a      	mov	r2, r5
 800f1fc:	4641      	mov	r1, r8
 800f1fe:	4638      	mov	r0, r7
  return ret;
}
 800f200:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
{
  int ret = 0;
  if(txSize && txData)
    ret = i2cWrite(i2c, addr, txData, txSize);
  if(rxSize && rxData && ret > 0)
    ret = i2cRead(i2c, addr, rxData, rxSize);
 800f204:	f7ff bf5e 	b.w	800f0c4 <i2cRead>
  return ret;
}
 800f208:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800f20c <m25p20Program>:

#define WAIT_FOR_NOWIP(arg_timeout) WAIT_FOR(arg_timeout, (rx->rwStatus.data & (1<<M25P20_STATUS_WIP)))
#define WAIT_FOR_WEL(arg_timeout)   WAIT_FOR(arg_timeout, !(rx->rwStatus.data & (1<<M25P20_STATUS_WEL)))

int m25p20Program(const uint8_t *src, int size)
{
 800f20c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  dprintf(LL_INFO, "Sharc image programming....\n");
 800f210:	4fb0      	ldr	r7, [pc, #704]	; (800f4d4 <m25p20Program+0x2c8>)

#define WAIT_FOR_NOWIP(arg_timeout) WAIT_FOR(arg_timeout, (rx->rwStatus.data & (1<<M25P20_STATUS_WIP)))
#define WAIT_FOR_WEL(arg_timeout)   WAIT_FOR(arg_timeout, !(rx->rwStatus.data & (1<<M25P20_STATUS_WEL)))

int m25p20Program(const uint8_t *src, int size)
{
 800f212:	9101      	str	r1, [sp, #4]
  dprintf(LL_INFO, "Sharc image programming....\n");
 800f214:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f216:	2b01      	cmp	r3, #1

#define WAIT_FOR_NOWIP(arg_timeout) WAIT_FOR(arg_timeout, (rx->rwStatus.data & (1<<M25P20_STATUS_WIP)))
#define WAIT_FOR_WEL(arg_timeout)   WAIT_FOR(arg_timeout, !(rx->rwStatus.data & (1<<M25P20_STATUS_WEL)))

int m25p20Program(const uint8_t *src, int size)
{
 800f218:	4682      	mov	sl, r0
  dprintf(LL_INFO, "Sharc image programming....\n");
 800f21a:	dd02      	ble.n	800f222 <m25p20Program+0x16>
 800f21c:	48ae      	ldr	r0, [pc, #696]	; (800f4d8 <m25p20Program+0x2cc>)
 800f21e:	f7f9 faa1 	bl	8008764 <xprintf>

  m25p20_cmd_t *tx = dAlloc(sizeof(m25p20_cmd_t));
 800f222:	f44f 7082 	mov.w	r0, #260	; 0x104
 800f226:	f7fe fa03 	bl	800d630 <bAlloc>
 800f22a:	b110      	cbz	r0, 800f232 <m25p20Program+0x26>
 800f22c:	f100 0414 	add.w	r4, r0, #20
 800f230:	e000      	b.n	800f234 <m25p20Program+0x28>
 800f232:	4604      	mov	r4, r0
  m25p20_cmd_t *rx = dAlloc(sizeof(m25p20_cmd_t));
 800f234:	f44f 7082 	mov.w	r0, #260	; 0x104
 800f238:	f7fe f9fa 	bl	800d630 <bAlloc>
 800f23c:	239f      	movs	r3, #159	; 0x9f
 800f23e:	4605      	mov	r5, r0
 800f240:	2800      	cmp	r0, #0
 800f242:	f000 813b 	beq.w	800f4bc <m25p20Program+0x2b0>
 800f246:	f100 0614 	add.w	r6, r0, #20

  //check ID
  tx->cmd = M25P20_CMD_READ_ID;
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rId));
 800f24a:	4631      	mov	r1, r6

  m25p20_cmd_t *tx = dAlloc(sizeof(m25p20_cmd_t));
  m25p20_cmd_t *rx = dAlloc(sizeof(m25p20_cmd_t));

  //check ID
  tx->cmd = M25P20_CMD_READ_ID;
 800f24c:	7023      	strb	r3, [r4, #0]
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rId));
 800f24e:	2215      	movs	r2, #21
 800f250:	4620      	mov	r0, r4
 800f252:	f000 fa8d 	bl	800f770 <sharcTransfer>
  if(rx->rId.manufacturerId != 0x20 || rx->rId.memoryType != 0x20 || rx->rId.memoryCapacity < 0x12)
 800f256:	7d69      	ldrb	r1, [r5, #21]
 800f258:	2920      	cmp	r1, #32
 800f25a:	d105      	bne.n	800f268 <m25p20Program+0x5c>
 800f25c:	7daa      	ldrb	r2, [r5, #22]
 800f25e:	2a20      	cmp	r2, #32
 800f260:	d102      	bne.n	800f268 <m25p20Program+0x5c>
 800f262:	7deb      	ldrb	r3, [r5, #23]
 800f264:	2b11      	cmp	r3, #17
 800f266:	d809      	bhi.n	800f27c <m25p20Program+0x70>
    {
      dprintf(LL_ERROR, "Unrecognized flash chip for sharc (manId=%02x memType=%02x memCap=%02x\n",
 800f268:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f26a:	2b00      	cmp	r3, #0
 800f26c:	f2c0 8107 	blt.w	800f47e <m25p20Program+0x272>
 800f270:	7deb      	ldrb	r3, [r5, #23]
 800f272:	7daa      	ldrb	r2, [r5, #22]
 800f274:	4899      	ldr	r0, [pc, #612]	; (800f4dc <m25p20Program+0x2d0>)
 800f276:	f7f9 fa75 	bl	8008764 <xprintf>
 800f27a:	e100      	b.n	800f47e <m25p20Program+0x272>
              rx->rId.manufacturerId, rx->rId.memoryType, rx->rId.memoryCapacity);
      dFree(tx);
      dFree(rx);
      return 1;
    }
  dprintf(LL_INFO, "Found flash chip for sharc (manId=%02x memType=%02x memCap=%02x\n",
 800f27c:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800f27e:	2901      	cmp	r1, #1
 800f280:	dd03      	ble.n	800f28a <m25p20Program+0x7e>
 800f282:	4611      	mov	r1, r2
 800f284:	4896      	ldr	r0, [pc, #600]	; (800f4e0 <m25p20Program+0x2d4>)
 800f286:	f7f9 fa6d 	bl	8008764 <xprintf>
	  rx->rId.manufacturerId, rx->rId.memoryType, rx->rId.memoryCapacity);

  //Unprotect the chip
  tx->cmd = M25P20_CMD_WRITE_ENABLE;
 800f28a:	2306      	movs	r3, #6
 800f28c:	7023      	strb	r3, [r4, #0]
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
 800f28e:	2201      	movs	r2, #1
 800f290:	4631      	mov	r1, r6
 800f292:	4620      	mov	r0, r4
 800f294:	f000 fa6c 	bl	800f770 <sharcTransfer>
 800f298:	f04f 0864 	mov.w	r8, #100	; 0x64
  WAIT_FOR_WEL(100);
 800f29c:	f04f 0905 	mov.w	r9, #5
 800f2a0:	4631      	mov	r1, r6
 800f2a2:	f884 9000 	strb.w	r9, [r4]
 800f2a6:	2202      	movs	r2, #2
 800f2a8:	4620      	mov	r0, r4
 800f2aa:	f000 fa61 	bl	800f770 <sharcTransfer>
 800f2ae:	7d6b      	ldrb	r3, [r5, #21]
 800f2b0:	0799      	lsls	r1, r3, #30
 800f2b2:	d50d      	bpl.n	800f2d0 <m25p20Program+0xc4>
  tx->cmd = M25P20_CMD_WRITE_STATUS;
 800f2b4:	2301      	movs	r3, #1
 800f2b6:	7023      	strb	r3, [r4, #0]
  tx->rwStatus.data = 0;
 800f2b8:	2300      	movs	r3, #0
 800f2ba:	7063      	strb	r3, [r4, #1]
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rwStatus));
 800f2bc:	2202      	movs	r2, #2
 800f2be:	4631      	mov	r1, r6
 800f2c0:	4620      	mov	r0, r4
 800f2c2:	f000 fa55 	bl	800f770 <sharcTransfer>
 800f2c6:	f04f 0864 	mov.w	r8, #100	; 0x64
  WAIT_FOR_NOWIP(100);
 800f2ca:	f04f 0905 	mov.w	r9, #5
 800f2ce:	e00c      	b.n	800f2ea <m25p20Program+0xde>
	  rx->rId.manufacturerId, rx->rId.memoryType, rx->rId.memoryCapacity);

  //Unprotect the chip
  tx->cmd = M25P20_CMD_WRITE_ENABLE;
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
  WAIT_FOR_WEL(100);
 800f2d0:	2001      	movs	r0, #1
 800f2d2:	f7fb fadd 	bl	800a890 <vTaskDelay>
 800f2d6:	f1b8 0801 	subs.w	r8, r8, #1
 800f2da:	d1e1      	bne.n	800f2a0 <m25p20Program+0x94>
 800f2dc:	e7ea      	b.n	800f2b4 <m25p20Program+0xa8>
  tx->cmd = M25P20_CMD_WRITE_STATUS;
  tx->rwStatus.data = 0;
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rwStatus));
  WAIT_FOR_NOWIP(100);
 800f2de:	2001      	movs	r0, #1
 800f2e0:	f7fb fad6 	bl	800a890 <vTaskDelay>
 800f2e4:	f1b8 0801 	subs.w	r8, r8, #1
 800f2e8:	d009      	beq.n	800f2fe <m25p20Program+0xf2>
 800f2ea:	2202      	movs	r2, #2
 800f2ec:	f884 9000 	strb.w	r9, [r4]
 800f2f0:	4631      	mov	r1, r6
 800f2f2:	4620      	mov	r0, r4
 800f2f4:	f000 fa3c 	bl	800f770 <sharcTransfer>
 800f2f8:	7d6b      	ldrb	r3, [r5, #21]
 800f2fa:	07da      	lsls	r2, r3, #31
 800f2fc:	d4ef      	bmi.n	800f2de <m25p20Program+0xd2>

  //write Enable & bulk erase
  tx->cmd = M25P20_CMD_WRITE_ENABLE;
 800f2fe:	2306      	movs	r3, #6
 800f300:	7023      	strb	r3, [r4, #0]
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
 800f302:	2201      	movs	r2, #1
 800f304:	4631      	mov	r1, r6
 800f306:	4620      	mov	r0, r4
 800f308:	f000 fa32 	bl	800f770 <sharcTransfer>
 800f30c:	f04f 0864 	mov.w	r8, #100	; 0x64
  WAIT_FOR_WEL(100);
 800f310:	f04f 0905 	mov.w	r9, #5
 800f314:	e005      	b.n	800f322 <m25p20Program+0x116>
 800f316:	2001      	movs	r0, #1
 800f318:	f7fb faba 	bl	800a890 <vTaskDelay>
 800f31c:	f1b8 0801 	subs.w	r8, r8, #1
 800f320:	d009      	beq.n	800f336 <m25p20Program+0x12a>
 800f322:	f884 9000 	strb.w	r9, [r4]
 800f326:	2202      	movs	r2, #2
 800f328:	4631      	mov	r1, r6
 800f32a:	4620      	mov	r0, r4
 800f32c:	f000 fa20 	bl	800f770 <sharcTransfer>
 800f330:	7d6b      	ldrb	r3, [r5, #21]
 800f332:	079b      	lsls	r3, r3, #30
 800f334:	d5ef      	bpl.n	800f316 <m25p20Program+0x10a>
  tx->cmd = M25P20_CMD_BULK_ERASE;
 800f336:	23c7      	movs	r3, #199	; 0xc7
 800f338:	7023      	strb	r3, [r4, #0]
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
 800f33a:	2201      	movs	r2, #1
 800f33c:	4631      	mov	r1, r6
 800f33e:	4620      	mov	r0, r4
 800f340:	f000 fa16 	bl	800f770 <sharcTransfer>
 800f344:	f241 3888 	movw	r8, #5000	; 0x1388
  WAIT_FOR_NOWIP(5000);
 800f348:	f04f 0905 	mov.w	r9, #5
 800f34c:	e005      	b.n	800f35a <m25p20Program+0x14e>
 800f34e:	2001      	movs	r0, #1
 800f350:	f7fb fa9e 	bl	800a890 <vTaskDelay>
 800f354:	f1b8 0801 	subs.w	r8, r8, #1
 800f358:	d009      	beq.n	800f36e <m25p20Program+0x162>
 800f35a:	4620      	mov	r0, r4
 800f35c:	f884 9000 	strb.w	r9, [r4]
 800f360:	2202      	movs	r2, #2
 800f362:	4631      	mov	r1, r6
 800f364:	f000 fa04 	bl	800f770 <sharcTransfer>
 800f368:	7d6b      	ldrb	r3, [r5, #21]
 800f36a:	07d8      	lsls	r0, r3, #31
 800f36c:	d4ef      	bmi.n	800f34e <m25p20Program+0x142>
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
      WAIT_FOR_WEL(100);
      tx->cmd = M25P20_CMD_PAGE_PROGRAM;
      memcpy(tx->programPage.data, &src[offset], 256);
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, programPage));
 800f36e:	f04f 0800 	mov.w	r8, #0
  for(offset =0; offset < size; offset += 256)
    {
      //write Enable & page program
      tx->cmd = M25P20_CMD_WRITE_ENABLE;
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
      WAIT_FOR_WEL(100);
 800f372:	f04f 0b05 	mov.w	fp, #5
 800f376:	e035      	b.n	800f3e4 <m25p20Program+0x1d8>
 800f378:	2001      	movs	r0, #1
 800f37a:	f7fb fa89 	bl	800a890 <vTaskDelay>
 800f37e:	f1b9 0901 	subs.w	r9, r9, #1
 800f382:	d009      	beq.n	800f398 <m25p20Program+0x18c>
 800f384:	4631      	mov	r1, r6
 800f386:	f884 b000 	strb.w	fp, [r4]
 800f38a:	2202      	movs	r2, #2
 800f38c:	4620      	mov	r0, r4
 800f38e:	f000 f9ef 	bl	800f770 <sharcTransfer>
 800f392:	7d6b      	ldrb	r3, [r5, #21]
 800f394:	0799      	lsls	r1, r3, #30
 800f396:	d5ef      	bpl.n	800f378 <m25p20Program+0x16c>
      tx->cmd = M25P20_CMD_PAGE_PROGRAM;
 800f398:	4620      	mov	r0, r4
 800f39a:	2302      	movs	r3, #2
 800f39c:	f800 3b04 	strb.w	r3, [r0], #4
      memcpy(tx->programPage.data, &src[offset], 256);
 800f3a0:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f3a4:	eb0a 0108 	add.w	r1, sl, r8
 800f3a8:	f005 f852 	bl	8014450 <memcpy>
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
 800f3ac:	2300      	movs	r3, #0
 800f3ae:	70e3      	strb	r3, [r4, #3]
 800f3b0:	ea4f 2328 	mov.w	r3, r8, asr #8
 800f3b4:	70a3      	strb	r3, [r4, #2]
 800f3b6:	ea4f 4328 	mov.w	r3, r8, asr #16
 800f3ba:	7063      	strb	r3, [r4, #1]
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, programPage));
 800f3bc:	f44f 7282 	mov.w	r2, #260	; 0x104
 800f3c0:	4631      	mov	r1, r6
 800f3c2:	4620      	mov	r0, r4
 800f3c4:	f000 f9d4 	bl	800f770 <sharcTransfer>
 800f3c8:	f241 3988 	movw	r9, #5000	; 0x1388
      WAIT_FOR_NOWIP(5000);
 800f3cc:	2202      	movs	r2, #2
 800f3ce:	f884 b000 	strb.w	fp, [r4]
 800f3d2:	4631      	mov	r1, r6
 800f3d4:	4620      	mov	r0, r4
 800f3d6:	f000 f9cb 	bl	800f770 <sharcTransfer>
 800f3da:	7d6b      	ldrb	r3, [r5, #21]
 800f3dc:	07da      	lsls	r2, r3, #31
 800f3de:	d40f      	bmi.n	800f400 <m25p20Program+0x1f4>
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
  WAIT_FOR_NOWIP(5000);

  //Program chip
  int offset = 0;
  for(offset =0; offset < size; offset += 256)
 800f3e0:	f508 7880 	add.w	r8, r8, #256	; 0x100
 800f3e4:	9b01      	ldr	r3, [sp, #4]
 800f3e6:	4598      	cmp	r8, r3
 800f3e8:	da11      	bge.n	800f40e <m25p20Program+0x202>
    {
      //write Enable & page program
      tx->cmd = M25P20_CMD_WRITE_ENABLE;
 800f3ea:	f04f 0306 	mov.w	r3, #6
 800f3ee:	7023      	strb	r3, [r4, #0]
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, 1);
 800f3f0:	2201      	movs	r2, #1
 800f3f2:	4631      	mov	r1, r6
 800f3f4:	4620      	mov	r0, r4
 800f3f6:	f000 f9bb 	bl	800f770 <sharcTransfer>
 800f3fa:	f04f 0964 	mov.w	r9, #100	; 0x64
 800f3fe:	e7c1      	b.n	800f384 <m25p20Program+0x178>
      WAIT_FOR_WEL(100);
      tx->cmd = M25P20_CMD_PAGE_PROGRAM;
      memcpy(tx->programPage.data, &src[offset], 256);
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, programPage));
      WAIT_FOR_NOWIP(5000);
 800f400:	2001      	movs	r0, #1
 800f402:	f7fb fa45 	bl	800a890 <vTaskDelay>
 800f406:	f1b9 0901 	subs.w	r9, r9, #1
 800f40a:	d1df      	bne.n	800f3cc <m25p20Program+0x1c0>
 800f40c:	e7e8      	b.n	800f3e0 <m25p20Program+0x1d4>
 800f40e:	f04f 0900 	mov.w	r9, #0
  for(offset =0; offset < size; offset += 256)
    {
      tx->cmd = M25P20_CMD_READ_DATA;
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rData));
      WAIT_FOR_NOWIP(5000);
 800f412:	f04f 0b05 	mov.w	fp, #5
 800f416:	e001      	b.n	800f41c <m25p20Program+0x210>
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, programPage));
      WAIT_FOR_NOWIP(5000);
    }

  //Verify chip
  for(offset =0; offset < size; offset += 256)
 800f418:	f509 7980 	add.w	r9, r9, #256	; 0x100
 800f41c:	9b01      	ldr	r3, [sp, #4]
 800f41e:	4599      	cmp	r9, r3
 800f420:	da3d      	bge.n	800f49e <m25p20Program+0x292>
    {
      tx->cmd = M25P20_CMD_READ_DATA;
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
 800f422:	2200      	movs	r2, #0
 800f424:	70e2      	strb	r2, [r4, #3]
 800f426:	ea4f 2229 	mov.w	r2, r9, asr #8
    }

  //Verify chip
  for(offset =0; offset < size; offset += 256)
    {
      tx->cmd = M25P20_CMD_READ_DATA;
 800f42a:	f04f 0303 	mov.w	r3, #3
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
 800f42e:	70a2      	strb	r2, [r4, #2]
 800f430:	ea4f 4229 	mov.w	r2, r9, asr #16
 800f434:	7062      	strb	r2, [r4, #1]
    }

  //Verify chip
  for(offset =0; offset < size; offset += 256)
    {
      tx->cmd = M25P20_CMD_READ_DATA;
 800f436:	7023      	strb	r3, [r4, #0]
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rData));
 800f438:	f44f 7282 	mov.w	r2, #260	; 0x104
 800f43c:	4631      	mov	r1, r6
 800f43e:	4620      	mov	r0, r4
 800f440:	f000 f996 	bl	800f770 <sharcTransfer>
 800f444:	f241 3888 	movw	r8, #5000	; 0x1388
      WAIT_FOR_NOWIP(5000);
 800f448:	2202      	movs	r2, #2
 800f44a:	f884 b000 	strb.w	fp, [r4]
 800f44e:	4631      	mov	r1, r6
 800f450:	4620      	mov	r0, r4
 800f452:	f000 f98d 	bl	800f770 <sharcTransfer>
 800f456:	7d6a      	ldrb	r2, [r5, #21]
 800f458:	07d3      	lsls	r3, r2, #31
 800f45a:	d419      	bmi.n	800f490 <m25p20Program+0x284>
      if(memcmp(rx->rData.data, &src[offset], 256))
 800f45c:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f460:	eb0a 0109 	add.w	r1, sl, r9
 800f464:	f105 0018 	add.w	r0, r5, #24
 800f468:	f004 ffc0 	bl	80143ec <memcmp>
 800f46c:	2800      	cmp	r0, #0
 800f46e:	d0d3      	beq.n	800f418 <m25p20Program+0x20c>
        {
          dprintf(LL_ERROR, "Sharc image verification failed at 0x%06x\n", offset);
 800f470:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800f472:	2a00      	cmp	r2, #0
 800f474:	db03      	blt.n	800f47e <m25p20Program+0x272>
 800f476:	4649      	mov	r1, r9
 800f478:	481a      	ldr	r0, [pc, #104]	; (800f4e4 <m25p20Program+0x2d8>)
 800f47a:	f7f9 f973 	bl	8008764 <xprintf>
          dFree(tx);
 800f47e:	f1a4 0014 	sub.w	r0, r4, #20
 800f482:	f7fe fb2f 	bl	800dae4 <bFree>
          dFree(rx);
 800f486:	4628      	mov	r0, r5
 800f488:	f7fe fb2c 	bl	800dae4 <bFree>
          return 1;
 800f48c:	2001      	movs	r0, #1
 800f48e:	e01d      	b.n	800f4cc <m25p20Program+0x2c0>
  for(offset =0; offset < size; offset += 256)
    {
      tx->cmd = M25P20_CMD_READ_DATA;
      M25P20_XFER_ADDRESS(tx->programPage.address, offset);
      sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rData));
      WAIT_FOR_NOWIP(5000);
 800f490:	2001      	movs	r0, #1
 800f492:	f7fb f9fd 	bl	800a890 <vTaskDelay>
 800f496:	f1b8 0801 	subs.w	r8, r8, #1
 800f49a:	d1d5      	bne.n	800f448 <m25p20Program+0x23c>
 800f49c:	e7de      	b.n	800f45c <m25p20Program+0x250>
          dFree(rx);
          return 1;
        }

    }
  dprintf(LL_INFO, "Sharc image programming success\n");
 800f49e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f4a0:	2b01      	cmp	r3, #1
 800f4a2:	dd02      	ble.n	800f4aa <m25p20Program+0x29e>
 800f4a4:	4810      	ldr	r0, [pc, #64]	; (800f4e8 <m25p20Program+0x2dc>)
 800f4a6:	f7f9 f95d 	bl	8008764 <xprintf>

  dFree(tx);
 800f4aa:	f1a4 0014 	sub.w	r0, r4, #20
 800f4ae:	f7fe fb19 	bl	800dae4 <bFree>
  dFree(rx);
 800f4b2:	4628      	mov	r0, r5
 800f4b4:	f7fe fb16 	bl	800dae4 <bFree>
  return 0;
 800f4b8:	2000      	movs	r0, #0
 800f4ba:	e007      	b.n	800f4cc <m25p20Program+0x2c0>

  m25p20_cmd_t *tx = dAlloc(sizeof(m25p20_cmd_t));
  m25p20_cmd_t *rx = dAlloc(sizeof(m25p20_cmd_t));

  //check ID
  tx->cmd = M25P20_CMD_READ_ID;
 800f4bc:	7023      	strb	r3, [r4, #0]
  sharcTransfer((uint8_t*)tx, (uint8_t*)rx, M25P20_XFER_SIZE(rx, rId));
 800f4be:	4601      	mov	r1, r0
 800f4c0:	2215      	movs	r2, #21
 800f4c2:	4620      	mov	r0, r4
 800f4c4:	f000 f954 	bl	800f770 <sharcTransfer>
  if(rx->rId.manufacturerId != 0x20 || rx->rId.memoryType != 0x20 || rx->rId.memoryCapacity < 0x12)
 800f4c8:	786b      	ldrb	r3, [r5, #1]
 800f4ca:	deff      	udf	#255	; 0xff
  dprintf(LL_INFO, "Sharc image programming success\n");

  dFree(tx);
  dFree(rx);
  return 0;
}
 800f4cc:	b003      	add	sp, #12
 800f4ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f4d2:	bf00      	nop
 800f4d4:	10001000 	.word	0x10001000
 800f4d8:	0801ddd7 	.word	0x0801ddd7
 800f4dc:	0801ddf4 	.word	0x0801ddf4
 800f4e0:	0801de3c 	.word	0x0801de3c
 800f4e4:	0801de7d 	.word	0x0801de7d
 800f4e8:	0801dea8 	.word	0x0801dea8

0800f4ec <DMA1_Stream3_IRQHandler>:
USART_HANDLER(PER2_PORT, USART3);

SPI_HANDLER(SPI1, 0);

//Sharc
SPI_DMA_HANDLER(DMA1, 3, 1);
 800f4ec:	b513      	push	{r0, r1, r4, lr}
 800f4ee:	2400      	movs	r4, #0
 800f4f0:	490c      	ldr	r1, [pc, #48]	; (800f524 <DMA1_Stream3_IRQHandler+0x38>)
 800f4f2:	480d      	ldr	r0, [pc, #52]	; (800f528 <DMA1_Stream3_IRQHandler+0x3c>)
 800f4f4:	9401      	str	r4, [sp, #4]
 800f4f6:	f003 fb39 	bl	8012b6c <DMA_GetITStatus>
 800f4fa:	b180      	cbz	r0, 800f51e <DMA1_Stream3_IRQHandler+0x32>
 800f4fc:	4909      	ldr	r1, [pc, #36]	; (800f524 <DMA1_Stream3_IRQHandler+0x38>)
 800f4fe:	480a      	ldr	r0, [pc, #40]	; (800f528 <DMA1_Stream3_IRQHandler+0x3c>)
 800f500:	f003 fc7c 	bl	8012dfc <DMA_ClearITPendingBit>
 800f504:	4809      	ldr	r0, [pc, #36]	; (800f52c <DMA1_Stream3_IRQHandler+0x40>)
 800f506:	4623      	mov	r3, r4
 800f508:	aa01      	add	r2, sp, #4
 800f50a:	4621      	mov	r1, r4
 800f50c:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800f50e:	f7fb fcfe 	bl	800af0e <xQueueGenericSendFromISR>
 800f512:	9b01      	ldr	r3, [sp, #4]
 800f514:	b11b      	cbz	r3, 800f51e <DMA1_Stream3_IRQHandler+0x32>
 800f516:	4b06      	ldr	r3, [pc, #24]	; (800f530 <DMA1_Stream3_IRQHandler+0x44>)
 800f518:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800f51c:	601a      	str	r2, [r3, #0]
 800f51e:	b002      	add	sp, #8
 800f520:	bd10      	pop	{r4, pc}
 800f522:	bf00      	nop
 800f524:	18008000 	.word	0x18008000
 800f528:	40026058 	.word	0x40026058
 800f52c:	2001aa84 	.word	0x2001aa84
 800f530:	e000ed04 	.word	0xe000ed04

0800f534 <SPI1_IRQHandler>:
//Utworz handlery przerwan dla SPI i UART
USART_HANDLER(CEN_PORT, UART4);
USART_HANDLER(PER1_PORT, USART2);
USART_HANDLER(PER2_PORT, USART3);

SPI_HANDLER(SPI1, 0);
 800f534:	b513      	push	{r0, r1, r4, lr}
 800f536:	2400      	movs	r4, #0
 800f538:	2171      	movs	r1, #113	; 0x71
 800f53a:	480c      	ldr	r0, [pc, #48]	; (800f56c <SPI1_IRQHandler+0x38>)
 800f53c:	9401      	str	r4, [sp, #4]
 800f53e:	f002 fc5b 	bl	8011df8 <SPI_I2S_GetITStatus>
 800f542:	b188      	cbz	r0, 800f568 <SPI1_IRQHandler+0x34>
 800f544:	4622      	mov	r2, r4
 800f546:	2171      	movs	r1, #113	; 0x71
 800f548:	4808      	ldr	r0, [pc, #32]	; (800f56c <SPI1_IRQHandler+0x38>)
 800f54a:	f002 fbbf 	bl	8011ccc <SPI_I2S_ITConfig>
 800f54e:	4808      	ldr	r0, [pc, #32]	; (800f570 <SPI1_IRQHandler+0x3c>)
 800f550:	4623      	mov	r3, r4
 800f552:	aa01      	add	r2, sp, #4
 800f554:	4621      	mov	r1, r4
 800f556:	6980      	ldr	r0, [r0, #24]
 800f558:	f7fb fcd9 	bl	800af0e <xQueueGenericSendFromISR>
 800f55c:	9b01      	ldr	r3, [sp, #4]
 800f55e:	b11b      	cbz	r3, 800f568 <SPI1_IRQHandler+0x34>
 800f560:	4b04      	ldr	r3, [pc, #16]	; (800f574 <SPI1_IRQHandler+0x40>)
 800f562:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800f566:	601a      	str	r2, [r3, #0]
 800f568:	b002      	add	sp, #8
 800f56a:	bd10      	pop	{r4, pc}
 800f56c:	40013000 	.word	0x40013000
 800f570:	2001aa84 	.word	0x2001aa84
 800f574:	e000ed04 	.word	0xe000ed04

0800f578 <USART3_IRQHandler>:
///////////////////////////////////////////////////////////////////////////////////////

//Utworz handlery przerwan dla SPI i UART
USART_HANDLER(CEN_PORT, UART4);
USART_HANDLER(PER1_PORT, USART2);
USART_HANDLER(PER2_PORT, USART3);
 800f578:	b570      	push	{r4, r5, r6, lr}
 800f57a:	f240 7127 	movw	r1, #1831	; 0x727
 800f57e:	481e      	ldr	r0, [pc, #120]	; (800f5f8 <USART3_IRQHandler+0x80>)
 800f580:	f002 f946 	bl	8011810 <USART_GetITStatus>
 800f584:	b198      	cbz	r0, 800f5ae <USART3_IRQHandler+0x36>
 800f586:	4b1d      	ldr	r3, [pc, #116]	; (800f5fc <USART3_IRQHandler+0x84>)
 800f588:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
 800f58c:	f7fc fbcc 	bl	800bd28 <rrGet>
 800f590:	1e01      	subs	r1, r0, #0
 800f592:	db04      	blt.n	800f59e <USART3_IRQHandler+0x26>
 800f594:	b289      	uxth	r1, r1
 800f596:	4818      	ldr	r0, [pc, #96]	; (800f5f8 <USART3_IRQHandler+0x80>)
 800f598:	f001 ffda 	bl	8011550 <USART_SendData>
 800f59c:	e005      	b.n	800f5aa <USART3_IRQHandler+0x32>
 800f59e:	2200      	movs	r2, #0
 800f5a0:	f240 7127 	movw	r1, #1831	; 0x727
 800f5a4:	4814      	ldr	r0, [pc, #80]	; (800f5f8 <USART3_IRQHandler+0x80>)
 800f5a6:	f002 f837 	bl	8011618 <USART_ITConfig>
 800f5aa:	2401      	movs	r4, #1
 800f5ac:	e000      	b.n	800f5b0 <USART3_IRQHandler+0x38>
 800f5ae:	4604      	mov	r4, r0
 800f5b0:	4e12      	ldr	r6, [pc, #72]	; (800f5fc <USART3_IRQHandler+0x84>)
 800f5b2:	4811      	ldr	r0, [pc, #68]	; (800f5f8 <USART3_IRQHandler+0x80>)
 800f5b4:	f240 5125 	movw	r1, #1317	; 0x525
 800f5b8:	f002 f92a 	bl	8011810 <USART_GetITStatus>
 800f5bc:	4601      	mov	r1, r0
 800f5be:	b190      	cbz	r0, 800f5e6 <USART3_IRQHandler+0x6e>
 800f5c0:	f8d6 50ec 	ldr.w	r5, [r6, #236]	; 0xec
 800f5c4:	b15d      	cbz	r5, 800f5de <USART3_IRQHandler+0x66>
 800f5c6:	480c      	ldr	r0, [pc, #48]	; (800f5f8 <USART3_IRQHandler+0x80>)
 800f5c8:	f001 fffa 	bl	80115c0 <USART_ReceiveData>
 800f5cc:	f044 0402 	orr.w	r4, r4, #2
 800f5d0:	b2c1      	uxtb	r1, r0
 800f5d2:	f505 7086 	add.w	r0, r5, #268	; 0x10c
 800f5d6:	b2e4      	uxtb	r4, r4
 800f5d8:	f7fc fbc6 	bl	800bd68 <rrPut>
 800f5dc:	e7e9      	b.n	800f5b2 <USART3_IRQHandler+0x3a>
 800f5de:	4806      	ldr	r0, [pc, #24]	; (800f5f8 <USART3_IRQHandler+0x80>)
 800f5e0:	f001 ffee 	bl	80115c0 <USART_ReceiveData>
 800f5e4:	e7e5      	b.n	800f5b2 <USART3_IRQHandler+0x3a>
 800f5e6:	b12c      	cbz	r4, 800f5f4 <USART3_IRQHandler+0x7c>
 800f5e8:	4622      	mov	r2, r4
 800f5ea:	2002      	movs	r0, #2
 800f5ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800f5f0:	f7fc bb1c 	b.w	800bc2c <portDataTxRxComplete>
 800f5f4:	bd70      	pop	{r4, r5, r6, pc}
 800f5f6:	bf00      	nop
 800f5f8:	40004800 	.word	0x40004800
 800f5fc:	2001aa84 	.word	0x2001aa84

0800f600 <USART2_IRQHandler>:
//Definicje handlerow przerwan
///////////////////////////////////////////////////////////////////////////////////////

//Utworz handlery przerwan dla SPI i UART
USART_HANDLER(CEN_PORT, UART4);
USART_HANDLER(PER1_PORT, USART2);
 800f600:	b570      	push	{r4, r5, r6, lr}
 800f602:	f240 7127 	movw	r1, #1831	; 0x727
 800f606:	481e      	ldr	r0, [pc, #120]	; (800f680 <USART2_IRQHandler+0x80>)
 800f608:	f002 f902 	bl	8011810 <USART_GetITStatus>
 800f60c:	b198      	cbz	r0, 800f636 <USART2_IRQHandler+0x36>
 800f60e:	4b1d      	ldr	r3, [pc, #116]	; (800f684 <USART2_IRQHandler+0x84>)
 800f610:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
 800f614:	f7fc fb88 	bl	800bd28 <rrGet>
 800f618:	1e01      	subs	r1, r0, #0
 800f61a:	db04      	blt.n	800f626 <USART2_IRQHandler+0x26>
 800f61c:	b289      	uxth	r1, r1
 800f61e:	4818      	ldr	r0, [pc, #96]	; (800f680 <USART2_IRQHandler+0x80>)
 800f620:	f001 ff96 	bl	8011550 <USART_SendData>
 800f624:	e005      	b.n	800f632 <USART2_IRQHandler+0x32>
 800f626:	2200      	movs	r2, #0
 800f628:	f240 7127 	movw	r1, #1831	; 0x727
 800f62c:	4814      	ldr	r0, [pc, #80]	; (800f680 <USART2_IRQHandler+0x80>)
 800f62e:	f001 fff3 	bl	8011618 <USART_ITConfig>
 800f632:	2401      	movs	r4, #1
 800f634:	e000      	b.n	800f638 <USART2_IRQHandler+0x38>
 800f636:	4604      	mov	r4, r0
 800f638:	4e12      	ldr	r6, [pc, #72]	; (800f684 <USART2_IRQHandler+0x84>)
 800f63a:	4811      	ldr	r0, [pc, #68]	; (800f680 <USART2_IRQHandler+0x80>)
 800f63c:	f240 5125 	movw	r1, #1317	; 0x525
 800f640:	f002 f8e6 	bl	8011810 <USART_GetITStatus>
 800f644:	4601      	mov	r1, r0
 800f646:	b190      	cbz	r0, 800f66e <USART2_IRQHandler+0x6e>
 800f648:	f8d6 509c 	ldr.w	r5, [r6, #156]	; 0x9c
 800f64c:	b15d      	cbz	r5, 800f666 <USART2_IRQHandler+0x66>
 800f64e:	480c      	ldr	r0, [pc, #48]	; (800f680 <USART2_IRQHandler+0x80>)
 800f650:	f001 ffb6 	bl	80115c0 <USART_ReceiveData>
 800f654:	f044 0402 	orr.w	r4, r4, #2
 800f658:	b2c1      	uxtb	r1, r0
 800f65a:	f505 7086 	add.w	r0, r5, #268	; 0x10c
 800f65e:	b2e4      	uxtb	r4, r4
 800f660:	f7fc fb82 	bl	800bd68 <rrPut>
 800f664:	e7e9      	b.n	800f63a <USART2_IRQHandler+0x3a>
 800f666:	4806      	ldr	r0, [pc, #24]	; (800f680 <USART2_IRQHandler+0x80>)
 800f668:	f001 ffaa 	bl	80115c0 <USART_ReceiveData>
 800f66c:	e7e5      	b.n	800f63a <USART2_IRQHandler+0x3a>
 800f66e:	b12c      	cbz	r4, 800f67c <USART2_IRQHandler+0x7c>
 800f670:	4622      	mov	r2, r4
 800f672:	2001      	movs	r0, #1
 800f674:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800f678:	f7fc bad8 	b.w	800bc2c <portDataTxRxComplete>
 800f67c:	bd70      	pop	{r4, r5, r6, pc}
 800f67e:	bf00      	nop
 800f680:	40004400 	.word	0x40004400
 800f684:	2001aa84 	.word	0x2001aa84

0800f688 <UART4_IRQHandler>:
///////////////////////////////////////////////////////////////////////////////////////
//Definicje handlerow przerwan
///////////////////////////////////////////////////////////////////////////////////////

//Utworz handlery przerwan dla SPI i UART
USART_HANDLER(CEN_PORT, UART4);
 800f688:	b570      	push	{r4, r5, r6, lr}
 800f68a:	f240 7127 	movw	r1, #1831	; 0x727
 800f68e:	481c      	ldr	r0, [pc, #112]	; (800f700 <UART4_IRQHandler+0x78>)
 800f690:	f002 f8be 	bl	8011810 <USART_GetITStatus>
 800f694:	b190      	cbz	r0, 800f6bc <UART4_IRQHandler+0x34>
 800f696:	4b1b      	ldr	r3, [pc, #108]	; (800f704 <UART4_IRQHandler+0x7c>)
 800f698:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 800f69a:	f7fc fb45 	bl	800bd28 <rrGet>
 800f69e:	1e01      	subs	r1, r0, #0
 800f6a0:	db04      	blt.n	800f6ac <UART4_IRQHandler+0x24>
 800f6a2:	b289      	uxth	r1, r1
 800f6a4:	4816      	ldr	r0, [pc, #88]	; (800f700 <UART4_IRQHandler+0x78>)
 800f6a6:	f001 ff53 	bl	8011550 <USART_SendData>
 800f6aa:	e005      	b.n	800f6b8 <UART4_IRQHandler+0x30>
 800f6ac:	2200      	movs	r2, #0
 800f6ae:	f240 7127 	movw	r1, #1831	; 0x727
 800f6b2:	4813      	ldr	r0, [pc, #76]	; (800f700 <UART4_IRQHandler+0x78>)
 800f6b4:	f001 ffb0 	bl	8011618 <USART_ITConfig>
 800f6b8:	2401      	movs	r4, #1
 800f6ba:	e000      	b.n	800f6be <UART4_IRQHandler+0x36>
 800f6bc:	4604      	mov	r4, r0
 800f6be:	4e11      	ldr	r6, [pc, #68]	; (800f704 <UART4_IRQHandler+0x7c>)
 800f6c0:	480f      	ldr	r0, [pc, #60]	; (800f700 <UART4_IRQHandler+0x78>)
 800f6c2:	f240 5125 	movw	r1, #1317	; 0x525
 800f6c6:	f002 f8a3 	bl	8011810 <USART_GetITStatus>
 800f6ca:	4601      	mov	r1, r0
 800f6cc:	b188      	cbz	r0, 800f6f2 <UART4_IRQHandler+0x6a>
 800f6ce:	6cf5      	ldr	r5, [r6, #76]	; 0x4c
 800f6d0:	b15d      	cbz	r5, 800f6ea <UART4_IRQHandler+0x62>
 800f6d2:	480b      	ldr	r0, [pc, #44]	; (800f700 <UART4_IRQHandler+0x78>)
 800f6d4:	f001 ff74 	bl	80115c0 <USART_ReceiveData>
 800f6d8:	f044 0402 	orr.w	r4, r4, #2
 800f6dc:	b2c1      	uxtb	r1, r0
 800f6de:	f505 7086 	add.w	r0, r5, #268	; 0x10c
 800f6e2:	b2e4      	uxtb	r4, r4
 800f6e4:	f7fc fb40 	bl	800bd68 <rrPut>
 800f6e8:	e7ea      	b.n	800f6c0 <UART4_IRQHandler+0x38>
 800f6ea:	4805      	ldr	r0, [pc, #20]	; (800f700 <UART4_IRQHandler+0x78>)
 800f6ec:	f001 ff68 	bl	80115c0 <USART_ReceiveData>
 800f6f0:	e7e6      	b.n	800f6c0 <UART4_IRQHandler+0x38>
 800f6f2:	b124      	cbz	r4, 800f6fe <UART4_IRQHandler+0x76>
 800f6f4:	4622      	mov	r2, r4
 800f6f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800f6fa:	f7fc ba97 	b.w	800bc2c <portDataTxRxComplete>
 800f6fe:	bd70      	pop	{r4, r5, r6, pc}
 800f700:	40004c00 	.word	0x40004c00
 800f704:	2001aa84 	.word	0x2001aa84

0800f708 <radioIntIRQ>:
}


//radio interrupts
void radioIntIRQ(void)
{
 800f708:	b508      	push	{r3, lr}
  // void EXTI0_IRQHandler(void)
  if (EXTI_GetITStatus(EXTI_Line4) != RESET)
 800f70a:	2010      	movs	r0, #16
 800f70c:	f002 fc30 	bl	8011f70 <EXTI_GetITStatus>
 800f710:	b140      	cbz	r0, 800f724 <radioIntIRQ+0x1c>
    {
      SPIevent(CEN_PORT, SPI_EV_TYPE_DATA_READY);
 800f712:	2100      	movs	r1, #0
 800f714:	4608      	mov	r0, r1
 800f716:	f7fc fca1 	bl	800c05c <SPIevent>
      /* Clear the EXTI line 0 pending bit */
      EXTI_ClearITPendingBit(EXTI_Line4);
 800f71a:	2010      	movs	r0, #16
    }
}
 800f71c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  // void EXTI0_IRQHandler(void)
  if (EXTI_GetITStatus(EXTI_Line4) != RESET)
    {
      SPIevent(CEN_PORT, SPI_EV_TYPE_DATA_READY);
      /* Clear the EXTI line 0 pending bit */
      EXTI_ClearITPendingBit(EXTI_Line4);
 800f720:	f002 bc72 	b.w	8012008 <EXTI_ClearITPendingBit>
 800f724:	bd08      	pop	{r3, pc}
	...

0800f728 <spiToSpiNum>:

//Funckja mapujaca SPI (SPI1,SPI2,SPI3) na index w tabeli spiData[]
int spiToSpiNum(void *spi)
{
  int spiNum = -1;
  switch ((uint32_t)spi)
 800f728:	4b0d      	ldr	r3, [pc, #52]	; (800f760 <spiToSpiNum+0x38>)
 800f72a:	4298      	cmp	r0, r3
  [1] = {SPI2, DMA1_Stream4, DMA1_Stream3, DMA_Channel_0, DMA_Channel_0, DMA_IT_TCIF3},
};

//Funckja mapujaca SPI (SPI1,SPI2,SPI3) na index w tabeli spiData[]
int spiToSpiNum(void *spi)
{
 800f72c:	b507      	push	{r0, r1, r2, lr}
  int spiNum = -1;
  switch ((uint32_t)spi)
 800f72e:	d005      	beq.n	800f73c <spiToSpiNum+0x14>
 800f730:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 800f734:	4298      	cmp	r0, r3
 800f736:	d103      	bne.n	800f740 <spiToSpiNum+0x18>
    {
    case (uint32_t)SPI1:
      spiNum = 0;
 800f738:	2000      	movs	r0, #0
    case (uint32_t)SPI2:
      spiNum = 1;
      break;
    }
  massert(spiNum >= 0);
  return spiNum;
 800f73a:	e00e      	b.n	800f75a <spiToSpiNum+0x32>
    {
    case (uint32_t)SPI1:
      spiNum = 0;
      break;
    case (uint32_t)SPI2:
      spiNum = 1;
 800f73c:	2001      	movs	r0, #1
 800f73e:	e00c      	b.n	800f75a <spiToSpiNum+0x32>
      break;
    }
  massert(spiNum >= 0);
 800f740:	4b08      	ldr	r3, [pc, #32]	; (800f764 <spiToSpiNum+0x3c>)
 800f742:	4909      	ldr	r1, [pc, #36]	; (800f768 <spiToSpiNum+0x40>)
 800f744:	4809      	ldr	r0, [pc, #36]	; (800f76c <spiToSpiNum+0x44>)
 800f746:	2268      	movs	r2, #104	; 0x68
 800f748:	f7f9 f80c 	bl	8008764 <xprintf>
 800f74c:	2301      	movs	r3, #1
 800f74e:	9301      	str	r3, [sp, #4]
 800f750:	9b01      	ldr	r3, [sp, #4]
 800f752:	2b00      	cmp	r3, #0
 800f754:	d1fc      	bne.n	800f750 <spiToSpiNum+0x28>
};

//Funckja mapujaca SPI (SPI1,SPI2,SPI3) na index w tabeli spiData[]
int spiToSpiNum(void *spi)
{
  int spiNum = -1;
 800f756:	f04f 30ff 	mov.w	r0, #4294967295
      spiNum = 1;
      break;
    }
  massert(spiNum >= 0);
  return spiNum;
}
 800f75a:	b003      	add	sp, #12
 800f75c:	f85d fb04 	ldr.w	pc, [sp], #4
 800f760:	40003800 	.word	0x40003800
 800f764:	0801df5f 	.word	0x0801df5f
 800f768:	0801dec9 	.word	0x0801dec9
 800f76c:	080148f4 	.word	0x080148f4

0800f770 <sharcTransfer>:
//Sharc
SPI_DMA_HANDLER(DMA1, 3, 1);
static spi_t sharcSpi;

void sharcTransfer(uint8_t *txBuffer, uint8_t *rxBuffer, int size)
{
 800f770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  //CS low
  GPIO_WriteBit(GPIOB, GPIO_Pin_12, 0);
 800f772:	4c0f      	ldr	r4, [pc, #60]	; (800f7b0 <sharcTransfer+0x40>)
//Sharc
SPI_DMA_HANDLER(DMA1, 3, 1);
static spi_t sharcSpi;

void sharcTransfer(uint8_t *txBuffer, uint8_t *rxBuffer, int size)
{
 800f774:	4605      	mov	r5, r0
 800f776:	460e      	mov	r6, r1
 800f778:	4617      	mov	r7, r2

  //CS low
  GPIO_WriteBit(GPIOB, GPIO_Pin_12, 0);
 800f77a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800f77e:	2200      	movs	r2, #0
 800f780:	4620      	mov	r0, r4
 800f782:	f001 fc07 	bl	8010f94 <GPIO_WriteBit>
  mdelay(1);
 800f786:	2001      	movs	r0, #1
 800f788:	f7fb f882 	bl	800a890 <vTaskDelay>
  configureDMAforSPI(sharcSpi.spi, txBuffer, rxBuffer, size);
 800f78c:	4809      	ldr	r0, [pc, #36]	; (800f7b4 <sharcTransfer+0x44>)
 800f78e:	4632      	mov	r2, r6
 800f790:	4629      	mov	r1, r5
 800f792:	463b      	mov	r3, r7
 800f794:	6800      	ldr	r0, [r0, #0]
 800f796:	f7fe fb99 	bl	800decc <configureDMAforSPI>
  mdelay(1);
 800f79a:	2001      	movs	r0, #1
 800f79c:	f7fb f878 	bl	800a890 <vTaskDelay>

  //CS high
  GPIO_WriteBit(GPIOB, GPIO_Pin_12, 1);
 800f7a0:	4620      	mov	r0, r4
 800f7a2:	2201      	movs	r2, #1
 800f7a4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
}
 800f7a8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  mdelay(1);
  configureDMAforSPI(sharcSpi.spi, txBuffer, rxBuffer, size);
  mdelay(1);

  //CS high
  GPIO_WriteBit(GPIOB, GPIO_Pin_12, 1);
 800f7ac:	f001 bbf2 	b.w	8010f94 <GPIO_WriteBit>
 800f7b0:	40020400 	.word	0x40020400
 800f7b4:	2001ada0 	.word	0x2001ada0

0800f7b8 <sharc_spi_init>:
}

void sharc_spi_init(void)
{
 800f7b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  //Sharck SPI
  int prescaler;
  switch(cfg.sharcSPISpeed)
 800f7ba:	4b6c      	ldr	r3, [pc, #432]	; (800f96c <sharc_spi_init+0x1b4>)
      prescaler = SPI_BaudRatePrescaler_256;
      break;
    }


  SPI_INIT_DMA_HANDLER(DMA1, 3);
 800f7bc:	496c      	ldr	r1, [pc, #432]	; (800f970 <sharc_spi_init+0x1b8>)

void sharc_spi_init(void)
{
  //Sharck SPI
  int prescaler;
  switch(cfg.sharcSPISpeed)
 800f7be:	6d5b      	ldr	r3, [r3, #84]	; 0x54
      break;
    }


  SPI_INIT_DMA_HANDLER(DMA1, 3);
  SPI_INIT_DMA_MODULE(sharcSpi,
 800f7c0:	4c6c      	ldr	r4, [pc, #432]	; (800f974 <sharc_spi_init+0x1bc>)
 800f7c2:	3b01      	subs	r3, #1
 800f7c4:	2b06      	cmp	r3, #6
 800f7c6:	bf9c      	itt	ls
 800f7c8:	4a6b      	ldrls	r2, [pc, #428]	; (800f978 <sharc_spi_init+0x1c0>)
 800f7ca:	189b      	addls	r3, r3, r2
  //CS high
  GPIO_WriteBit(GPIOB, GPIO_Pin_12, 1);
}

void sharc_spi_init(void)
{
 800f7cc:	b08b      	sub	sp, #44	; 0x2c
      prescaler = SPI_BaudRatePrescaler_256;
      break;
    }


  SPI_INIT_DMA_HANDLER(DMA1, 3);
 800f7ce:	f04f 000e 	mov.w	r0, #14
 800f7d2:	bf94      	ite	ls
 800f7d4:	f993 700c 	ldrsbls.w	r7, [r3, #12]

void sharc_spi_init(void)
{
  //Sharck SPI
  int prescaler;
  switch(cfg.sharcSPISpeed)
 800f7d8:	2738      	movhi	r7, #56	; 0x38
      prescaler = SPI_BaudRatePrescaler_256;
      break;
    }


  SPI_INIT_DMA_HANDLER(DMA1, 3);
 800f7da:	f7f8 fd67 	bl	80082ac <registerIRQ>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800f7de:	4b67      	ldr	r3, [pc, #412]	; (800f97c <sharc_spi_init+0x1c4>)
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800f7e0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800f7e4:	22f0      	movs	r2, #240	; 0xf0
 800f7e6:	f883 230e 	strb.w	r2, [r3, #782]	; 0x30e
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800f7ea:	6018      	str	r0, [r3, #0]
  SPI_INIT_DMA_MODULE(sharcSpi,
 800f7ec:	2338      	movs	r3, #56	; 0x38
 800f7ee:	7063      	strb	r3, [r4, #1]
 800f7f0:	2340      	movs	r3, #64	; 0x40
 800f7f2:	2600      	movs	r6, #0
 800f7f4:	2502      	movs	r5, #2
 800f7f6:	2204      	movs	r2, #4
 800f7f8:	70e3      	strb	r3, [r4, #3]
 800f7fa:	74e3      	strb	r3, [r4, #19]
 800f7fc:	7563      	strb	r3, [r4, #21]
 800f7fe:	7363      	strb	r3, [r4, #13]
 800f800:	2101      	movs	r1, #1
 800f802:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 800f806:	73e3      	strb	r3, [r4, #15]
 800f808:	7462      	strb	r2, [r4, #17]
 800f80a:	72e2      	strb	r2, [r4, #11]
 800f80c:	74a5      	strb	r5, [r4, #18]
 800f80e:	7325      	strb	r5, [r4, #12]
 800f810:	7026      	strb	r6, [r4, #0]
 800f812:	70a6      	strb	r6, [r4, #2]
 800f814:	7426      	strb	r6, [r4, #16]
 800f816:	7526      	strb	r6, [r4, #20]
 800f818:	72a6      	strb	r6, [r4, #10]
 800f81a:	73a6      	strb	r6, [r4, #14]
 800f81c:	f001 fcee 	bl	80111fc <RCC_APB1PeriphClockCmd>
 800f820:	4628      	mov	r0, r5
 800f822:	2101      	movs	r1, #1
 800f824:	f001 fcc6 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800f828:	2205      	movs	r2, #5
 800f82a:	210e      	movs	r1, #14
 800f82c:	4854      	ldr	r0, [pc, #336]	; (800f980 <sharc_spi_init+0x1c8>)
 800f82e:	f001 fc23 	bl	8011078 <GPIO_PinAFConfig>
 800f832:	2205      	movs	r2, #5
 800f834:	210f      	movs	r1, #15
 800f836:	4852      	ldr	r0, [pc, #328]	; (800f980 <sharc_spi_init+0x1c8>)
 800f838:	f001 fc1e 	bl	8011078 <GPIO_PinAFConfig>
 800f83c:	2205      	movs	r2, #5
 800f83e:	210d      	movs	r1, #13
 800f840:	484f      	ldr	r0, [pc, #316]	; (800f980 <sharc_spi_init+0x1c8>)
 800f842:	f001 fc19 	bl	8011078 <GPIO_PinAFConfig>
 800f846:	a90a      	add	r1, sp, #40	; 0x28
 800f848:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 800f84c:	f841 3d1c 	str.w	r3, [r1, #-28]!
 800f850:	484b      	ldr	r0, [pc, #300]	; (800f980 <sharc_spi_init+0x1c8>)
 800f852:	f88d 5011 	strb.w	r5, [sp, #17]
 800f856:	f88d 5010 	strb.w	r5, [sp, #16]
 800f85a:	f88d 5013 	strb.w	r5, [sp, #19]
 800f85e:	f88d 6012 	strb.w	r6, [sp, #18]
 800f862:	f001 fa8f 	bl	8010d84 <GPIO_Init>
 800f866:	4847      	ldr	r0, [pc, #284]	; (800f984 <sharc_spi_init+0x1cc>)
 800f868:	f002 f866 	bl	8011938 <SPI_I2S_DeInit>
 800f86c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800f870:	f8ad 301e 	strh.w	r3, [sp, #30]
 800f874:	2307      	movs	r3, #7
 800f876:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
 800f87a:	a905      	add	r1, sp, #20
 800f87c:	f44f 7382 	mov.w	r3, #260	; 0x104
 800f880:	4840      	ldr	r0, [pc, #256]	; (800f984 <sharc_spi_init+0x1cc>)
 800f882:	f8ad 3016 	strh.w	r3, [sp, #22]
 800f886:	f8ad 6014 	strh.w	r6, [sp, #20]
 800f88a:	f8ad 6018 	strh.w	r6, [sp, #24]
 800f88e:	f8ad 601a 	strh.w	r6, [sp, #26]
 800f892:	f8ad 601c 	strh.w	r6, [sp, #28]
 800f896:	f8ad 7020 	strh.w	r7, [sp, #32]
 800f89a:	f8ad 6022 	strh.w	r6, [sp, #34]	; 0x22
 800f89e:	f002 f8a7 	bl	80119f0 <SPI_Init>
 800f8a2:	4629      	mov	r1, r5
 800f8a4:	2201      	movs	r2, #1
 800f8a6:	4837      	ldr	r0, [pc, #220]	; (800f984 <sharc_spi_init+0x1cc>)
 800f8a8:	4d37      	ldr	r5, [pc, #220]	; (800f988 <sharc_spi_init+0x1d0>)
 800f8aa:	f002 f9c9 	bl	8011c40 <SPI_I2S_DMACmd>
 800f8ae:	2201      	movs	r2, #1
 800f8b0:	4611      	mov	r1, r2
 800f8b2:	4834      	ldr	r0, [pc, #208]	; (800f984 <sharc_spi_init+0x1cc>)
 800f8b4:	f002 f9c4 	bl	8011c40 <SPI_I2S_DMACmd>
 800f8b8:	2101      	movs	r1, #1
 800f8ba:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800f8be:	f001 fc79 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800f8c2:	2203      	movs	r2, #3
 800f8c4:	4631      	mov	r1, r6
 800f8c6:	2001      	movs	r0, #1
 800f8c8:	f7fb fa46 	bl	800ad58 <xQueueGenericCreate>
 800f8cc:	6368      	str	r0, [r5, #52]	; 0x34
 800f8ce:	b120      	cbz	r0, 800f8da <sharc_spi_init+0x122>
 800f8d0:	4633      	mov	r3, r6
 800f8d2:	4632      	mov	r2, r6
 800f8d4:	4631      	mov	r1, r6
 800f8d6:	f7fb fa64 	bl	800ada2 <xQueueGenericSend>
 800f8da:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800f8dc:	b14b      	cbz	r3, 800f8f2 <sharc_spi_init+0x13a>
 800f8de:	2300      	movs	r3, #0
 800f8e0:	f04f 32ff 	mov.w	r2, #4294967295
 800f8e4:	4619      	mov	r1, r3
 800f8e6:	6b68      	ldr	r0, [r5, #52]	; 0x34
 800f8e8:	f7fb fb5e 	bl	800afa8 <xQueueGenericReceive>
 800f8ec:	2801      	cmp	r0, #1
 800f8ee:	d10c      	bne.n	800f90a <sharc_spi_init+0x152>
 800f8f0:	e016      	b.n	800f920 <sharc_spi_init+0x168>
 800f8f2:	4b26      	ldr	r3, [pc, #152]	; (800f98c <sharc_spi_init+0x1d4>)
 800f8f4:	4926      	ldr	r1, [pc, #152]	; (800f990 <sharc_spi_init+0x1d8>)
 800f8f6:	4827      	ldr	r0, [pc, #156]	; (800f994 <sharc_spi_init+0x1dc>)
 800f8f8:	22ae      	movs	r2, #174	; 0xae
 800f8fa:	f7f8 ff33 	bl	8008764 <xprintf>
 800f8fe:	2301      	movs	r3, #1
 800f900:	9301      	str	r3, [sp, #4]
 800f902:	9b01      	ldr	r3, [sp, #4]
 800f904:	2b00      	cmp	r3, #0
 800f906:	d1fc      	bne.n	800f902 <sharc_spi_init+0x14a>
 800f908:	e7e9      	b.n	800f8de <sharc_spi_init+0x126>
 800f90a:	4b23      	ldr	r3, [pc, #140]	; (800f998 <sharc_spi_init+0x1e0>)
 800f90c:	4920      	ldr	r1, [pc, #128]	; (800f990 <sharc_spi_init+0x1d8>)
 800f90e:	4821      	ldr	r0, [pc, #132]	; (800f994 <sharc_spi_init+0x1dc>)
 800f910:	22ae      	movs	r2, #174	; 0xae
 800f912:	f7f8 ff27 	bl	8008764 <xprintf>
 800f916:	2301      	movs	r3, #1
 800f918:	9302      	str	r3, [sp, #8]
 800f91a:	9b02      	ldr	r3, [sp, #8]
 800f91c:	2b00      	cmp	r3, #0
 800f91e:	d1fc      	bne.n	800f91a <sharc_spi_init+0x162>
                      SPI2, 1,
                      B, 13, 14, 15,
                      8, prescaler,
                      DMA1);
  SPI_CS_INIT_MODULE(sharcSpi, B, 12);
 800f920:	2304      	movs	r3, #4
 800f922:	2602      	movs	r6, #2
 800f924:	7163      	strb	r3, [r4, #5]
 800f926:	2340      	movs	r3, #64	; 0x40
 800f928:	2500      	movs	r5, #0
 800f92a:	71e3      	strb	r3, [r4, #7]
 800f92c:	4630      	mov	r0, r6
 800f92e:	2310      	movs	r3, #16
 800f930:	2101      	movs	r1, #1
 800f932:	7263      	strb	r3, [r4, #9]
 800f934:	7125      	strb	r5, [r4, #4]
 800f936:	71a6      	strb	r6, [r4, #6]
 800f938:	7225      	strb	r5, [r4, #8]
 800f93a:	f001 fc3b 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800f93e:	2401      	movs	r4, #1
 800f940:	f88d 501a 	strb.w	r5, [sp, #26]
 800f944:	a905      	add	r1, sp, #20
 800f946:	f44f 5580 	mov.w	r5, #4096	; 0x1000
 800f94a:	480d      	ldr	r0, [pc, #52]	; (800f980 <sharc_spi_init+0x1c8>)
 800f94c:	f88d 4018 	strb.w	r4, [sp, #24]
 800f950:	f88d 6019 	strb.w	r6, [sp, #25]
 800f954:	f88d 401b 	strb.w	r4, [sp, #27]
 800f958:	9505      	str	r5, [sp, #20]
 800f95a:	f001 fa13 	bl	8010d84 <GPIO_Init>
 800f95e:	4622      	mov	r2, r4
 800f960:	4629      	mov	r1, r5
 800f962:	4807      	ldr	r0, [pc, #28]	; (800f980 <sharc_spi_init+0x1c8>)
 800f964:	f001 fb16 	bl	8010f94 <GPIO_WriteBit>


}
 800f968:	b00b      	add	sp, #44	; 0x2c
 800f96a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f96c:	10001000 	.word	0x10001000
 800f970:	0800f4ed 	.word	0x0800f4ed
 800f974:	2001ada0 	.word	0x2001ada0
 800f978:	0801dec9 	.word	0x0801dec9
 800f97c:	e000e100 	.word	0xe000e100
 800f980:	40020400 	.word	0x40020400
 800f984:	40003800 	.word	0x40003800
 800f988:	2001aa84 	.word	0x2001aa84
 800f98c:	0801df6b 	.word	0x0801df6b
 800f990:	0801dedc 	.word	0x0801dedc
 800f994:	080148f4 	.word	0x080148f4
 800f998:	0801dfc8 	.word	0x0801dfc8

0800f99c <pll_set>:
  return status;
}

static int lastPLLSet = -1;
int pll_set(int audioOutputType, int force)
{
 800f99c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(cfg.flags&FLAGS_OMIT_PLL_MASK)
 800f9a0:	4b5c      	ldr	r3, [pc, #368]	; (800fb14 <pll_set+0x178>)
 800f9a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800f9a4:	f012 0f40 	tst.w	r2, #64	; 0x40
 800f9a8:	461d      	mov	r5, r3
 800f9aa:	f040 80a3 	bne.w	800faf4 <pll_set+0x158>
    return 1;

  if(cfg.fout22 && !force)
 800f9ae:	68db      	ldr	r3, [r3, #12]
 800f9b0:	b113      	cbz	r3, 800f9b8 <pll_set+0x1c>
 800f9b2:	2900      	cmp	r1, #0
 800f9b4:	f000 809e 	beq.w	800faf4 <pll_set+0x158>
 800f9b8:	2814      	cmp	r0, #20
 800f9ba:	f200 8094 	bhi.w	800fae6 <pll_set+0x14a>
 800f9be:	2401      	movs	r4, #1
 800f9c0:	4b55      	ldr	r3, [pc, #340]	; (800fb18 <pll_set+0x17c>)
 800f9c2:	fa04 f200 	lsl.w	r2, r4, r0
 800f9c6:	4013      	ands	r3, r2
 800f9c8:	2b00      	cmp	r3, #0
 800f9ca:	d141      	bne.n	800fa50 <pll_set+0xb4>
 800f9cc:	4b53      	ldr	r3, [pc, #332]	; (800fb1c <pll_set+0x180>)
 800f9ce:	4013      	ands	r3, r2
 800f9d0:	b913      	cbnz	r3, 800f9d8 <pll_set+0x3c>
 800f9d2:	2800      	cmp	r0, #0
 800f9d4:	d07b      	beq.n	800face <pll_set+0x132>
 800f9d6:	e086      	b.n	800fae6 <pll_set+0x14a>
    case 0x01:
    case 0x0A:
    case 0x0C:
    case 0x11:
    case 0x13:
      if(lastPLLSet != PLL_44)
 800f9d8:	4e51      	ldr	r6, [pc, #324]	; (800fb20 <pll_set+0x184>)
        {
          dprintf(LL_INFO, "Setting PLL freq to 22.5792MHz\n");
 800f9da:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    case 0x01:
    case 0x0A:
    case 0x0C:
    case 0x11:
    case 0x13:
      if(lastPLLSet != PLL_44)
 800f9dc:	f8d6 4128 	ldr.w	r4, [r6, #296]	; 0x128
 800f9e0:	2c01      	cmp	r4, #1
 800f9e2:	d031      	beq.n	800fa48 <pll_set+0xac>
        {
          dprintf(LL_INFO, "Setting PLL freq to 22.5792MHz\n");
 800f9e4:	2b01      	cmp	r3, #1
 800f9e6:	dd02      	ble.n	800f9ee <pll_set+0x52>
 800f9e8:	484e      	ldr	r0, [pc, #312]	; (800fb24 <pll_set+0x188>)
 800f9ea:	f7f8 febb 	bl	8008764 <xprintf>
          if(status>0) status = i2cWrite((cfg.plli2c==1)?I2C1:I2C2, 0x65, (void*)config1[cfg.ckin141?1:0][PLL_44], sizeof(config1[0][PLL_44]));
 800f9ee:	f8d5 00d8 	ldr.w	r0, [r5, #216]	; 0xd8
 800f9f2:	692a      	ldr	r2, [r5, #16]
 800f9f4:	f8df 914c 	ldr.w	r9, [pc, #332]	; 800fb44 <pll_set+0x1a8>
 800f9f8:	f8df 814c 	ldr.w	r8, [pc, #332]	; 800fb48 <pll_set+0x1ac>
 800f9fc:	4f4a      	ldr	r7, [pc, #296]	; (800fb28 <pll_set+0x18c>)
 800f9fe:	2a00      	cmp	r2, #0
 800fa00:	bf14      	ite	ne
 800fa02:	2218      	movne	r2, #24
 800fa04:	2208      	moveq	r2, #8
 800fa06:	2801      	cmp	r0, #1
 800fa08:	bf0c      	ite	eq
 800fa0a:	4648      	moveq	r0, r9
 800fa0c:	4640      	movne	r0, r8
 800fa0e:	2308      	movs	r3, #8
 800fa10:	443a      	add	r2, r7
 800fa12:	2165      	movs	r1, #101	; 0x65
 800fa14:	f7ff face 	bl	800efb4 <i2cWrite>
          if(status>0) status = i2cWrite((cfg.plli2c==1)?I2C1:I2C2, 0x65, (void*)config2[cfg.ckin141?1:0][PLL_44], sizeof(config2[0][PLL_44]));
 800fa18:	1e04      	subs	r4, r0, #0
 800fa1a:	dd6e      	ble.n	800fafa <pll_set+0x15e>
 800fa1c:	4b3d      	ldr	r3, [pc, #244]	; (800fb14 <pll_set+0x178>)
 800fa1e:	f8d3 00d8 	ldr.w	r0, [r3, #216]	; 0xd8
 800fa22:	692a      	ldr	r2, [r5, #16]
 800fa24:	3720      	adds	r7, #32
 800fa26:	2a00      	cmp	r2, #0
 800fa28:	bf14      	ite	ne
 800fa2a:	2236      	movne	r2, #54	; 0x36
 800fa2c:	2212      	moveq	r2, #18
 800fa2e:	2801      	cmp	r0, #1
 800fa30:	bf0c      	ite	eq
 800fa32:	4648      	moveq	r0, r9
 800fa34:	4640      	movne	r0, r8
 800fa36:	2312      	movs	r3, #18
 800fa38:	443a      	add	r2, r7
 800fa3a:	2165      	movs	r1, #101	; 0x65
 800fa3c:	f7ff faba 	bl	800efb4 <i2cWrite>
          if(status>0) lastPLLSet = PLL_44;
 800fa40:	1e04      	subs	r4, r0, #0
 800fa42:	dd5a      	ble.n	800fafa <pll_set+0x15e>
 800fa44:	2301      	movs	r3, #1
 800fa46:	e03a      	b.n	800fabe <pll_set+0x122>
        }
      else
        {
          dprintf(LL_INFO, "PLL freq already set to 22.5792MHz\n");
 800fa48:	2b01      	cmp	r3, #1
 800fa4a:	dd5e      	ble.n	800fb0a <pll_set+0x16e>
 800fa4c:	4837      	ldr	r0, [pc, #220]	; (800fb2c <pll_set+0x190>)
 800fa4e:	e047      	b.n	800fae0 <pll_set+0x144>
    case 0x02:
    case 0x0B:
    case 0x0D:
    case 0x12:
    case 0x14:
      if(lastPLLSet != PLL_48)
 800fa50:	4e33      	ldr	r6, [pc, #204]	; (800fb20 <pll_set+0x184>)
 800fa52:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
 800fa56:	2b00      	cmp	r3, #0
 800fa58:	d034      	beq.n	800fac4 <pll_set+0x128>
        {
          dprintf(LL_INFO, "Setting PLL freq to 24.576MHz\n");
 800fa5a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800fa5c:	2b01      	cmp	r3, #1
 800fa5e:	dd02      	ble.n	800fa66 <pll_set+0xca>
 800fa60:	4833      	ldr	r0, [pc, #204]	; (800fb30 <pll_set+0x194>)
 800fa62:	f7f8 fe7f 	bl	8008764 <xprintf>
          if(status>0) status = i2cWrite((cfg.plli2c==1)?I2C1:I2C2, 0x65, (void*)config1[cfg.ckin141?1:0][PLL_48], sizeof(config1[0][PLL_48]));
 800fa66:	f8d5 00d8 	ldr.w	r0, [r5, #216]	; 0xd8
 800fa6a:	692a      	ldr	r2, [r5, #16]
 800fa6c:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 800fb44 <pll_set+0x1a8>
 800fa70:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 800fb48 <pll_set+0x1ac>
 800fa74:	4f2c      	ldr	r7, [pc, #176]	; (800fb28 <pll_set+0x18c>)
 800fa76:	3200      	adds	r2, #0
 800fa78:	bf18      	it	ne
 800fa7a:	2201      	movne	r2, #1
 800fa7c:	2308      	movs	r3, #8
 800fa7e:	2801      	cmp	r0, #1
 800fa80:	bf0c      	ite	eq
 800fa82:	4648      	moveq	r0, r9
 800fa84:	4640      	movne	r0, r8
 800fa86:	eb07 1202 	add.w	r2, r7, r2, lsl #4
 800fa8a:	2165      	movs	r1, #101	; 0x65
 800fa8c:	f7ff fa92 	bl	800efb4 <i2cWrite>
          if(status>0) status = i2cWrite((cfg.plli2c==1)?I2C1:I2C2, 0x65, (void*)config2[cfg.ckin141?1:0][PLL_48], sizeof(config2[0][PLL_48]));
 800fa90:	1e04      	subs	r4, r0, #0
 800fa92:	dd32      	ble.n	800fafa <pll_set+0x15e>
 800fa94:	4b1f      	ldr	r3, [pc, #124]	; (800fb14 <pll_set+0x178>)
 800fa96:	f8d3 00d8 	ldr.w	r0, [r3, #216]	; 0xd8
 800fa9a:	692a      	ldr	r2, [r5, #16]
 800fa9c:	3720      	adds	r7, #32
 800fa9e:	2a00      	cmp	r2, #0
 800faa0:	bf14      	ite	ne
 800faa2:	2224      	movne	r2, #36	; 0x24
 800faa4:	2200      	moveq	r2, #0
 800faa6:	2801      	cmp	r0, #1
 800faa8:	bf0c      	ite	eq
 800faaa:	4648      	moveq	r0, r9
 800faac:	4640      	movne	r0, r8
 800faae:	2312      	movs	r3, #18
 800fab0:	443a      	add	r2, r7
 800fab2:	2165      	movs	r1, #101	; 0x65
 800fab4:	f7ff fa7e 	bl	800efb4 <i2cWrite>
          if(status>0) lastPLLSet = PLL_48;
 800fab8:	1e04      	subs	r4, r0, #0
 800faba:	dd1e      	ble.n	800fafa <pll_set+0x15e>
 800fabc:	2300      	movs	r3, #0
 800fabe:	f8c6 3128 	str.w	r3, [r6, #296]	; 0x128
 800fac2:	e023      	b.n	800fb0c <pll_set+0x170>
        }
      else
        {
          dprintf(LL_INFO, "PLL freq already set to 24.576MHz\n");
 800fac4:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800fac6:	2b01      	cmp	r3, #1
 800fac8:	dd1f      	ble.n	800fb0a <pll_set+0x16e>
 800faca:	481a      	ldr	r0, [pc, #104]	; (800fb34 <pll_set+0x198>)
 800facc:	e008      	b.n	800fae0 <pll_set+0x144>
        }
      break;
    case 0x00:
      lastPLLSet = -1;
 800face:	4b14      	ldr	r3, [pc, #80]	; (800fb20 <pll_set+0x184>)
 800fad0:	f04f 32ff 	mov.w	r2, #4294967295
 800fad4:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
      dprintf(LL_INFO, "PLL reset.\n");
 800fad8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800fada:	2b01      	cmp	r3, #1
 800fadc:	dd15      	ble.n	800fb0a <pll_set+0x16e>
 800fade:	4816      	ldr	r0, [pc, #88]	; (800fb38 <pll_set+0x19c>)
 800fae0:	f7f8 fe40 	bl	8008764 <xprintf>
 800fae4:	e012      	b.n	800fb0c <pll_set+0x170>
      break;
    default:
      dprintf(LL_INFO, "Wrong frequency chosen\n");
 800fae6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800fae8:	2b01      	cmp	r3, #1
 800faea:	dd0e      	ble.n	800fb0a <pll_set+0x16e>
 800faec:	4813      	ldr	r0, [pc, #76]	; (800fb3c <pll_set+0x1a0>)
 800faee:	f7f8 fe39 	bl	8008764 <xprintf>
 800faf2:	e00a      	b.n	800fb0a <pll_set+0x16e>

static int lastPLLSet = -1;
int pll_set(int audioOutputType, int force)
{
  if(cfg.flags&FLAGS_OMIT_PLL_MASK)
    return 1;
 800faf4:	2001      	movs	r0, #1
 800faf6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    default:
      dprintf(LL_INFO, "Wrong frequency chosen\n");

    }
  if(status <= 0)
    dprintf(LL_ERROR, "PLL error (%d)!\n", -status);
 800fafa:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800fafc:	2b00      	cmp	r3, #0
 800fafe:	db05      	blt.n	800fb0c <pll_set+0x170>
 800fb00:	4261      	negs	r1, r4
 800fb02:	480f      	ldr	r0, [pc, #60]	; (800fb40 <pll_set+0x1a4>)
 800fb04:	f7f8 fe2e 	bl	8008764 <xprintf>
 800fb08:	e000      	b.n	800fb0c <pll_set+0x170>
  if(cfg.flags&FLAGS_OMIT_PLL_MASK)
    return 1;

  if(cfg.fout22 && !force)
    return 1;
  int status = 1;
 800fb0a:	2401      	movs	r4, #1
    default:
      dprintf(LL_INFO, "Wrong frequency chosen\n");

    }
  if(status <= 0)
    dprintf(LL_ERROR, "PLL error (%d)!\n", -status);
 800fb0c:	4620      	mov	r0, r4

  return status;
}
 800fb0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800fb12:	bf00      	nop
 800fb14:	10001000 	.word	0x10001000
 800fb18:	00142804 	.word	0x00142804
 800fb1c:	000a1402 	.word	0x000a1402
 800fb20:	2001aa84 	.word	0x2001aa84
 800fb24:	0801e047 	.word	0x0801e047
 800fb28:	0801deeb 	.word	0x0801deeb
 800fb2c:	0801e067 	.word	0x0801e067
 800fb30:	0801e08b 	.word	0x0801e08b
 800fb34:	0801e0aa 	.word	0x0801e0aa
 800fb38:	0801e0cd 	.word	0x0801e0cd
 800fb3c:	0801e0d9 	.word	0x0801e0d9
 800fb40:	0801e0f1 	.word	0x0801e0f1
 800fb44:	40005400 	.word	0x40005400
 800fb48:	40005800 	.word	0x40005800

0800fb4c <pll_set_retry>:
  },
};


int pll_set_retry(int audioOutputType, int force, int retryNUm)
{
 800fb4c:	b570      	push	{r4, r5, r6, lr}
 800fb4e:	4605      	mov	r5, r0
 800fb50:	460e      	mov	r6, r1
 800fb52:	4614      	mov	r4, r2

  while(retryNUm > 0 && status < 0)
    {
      retryNUm--;
      mdelay(200);
      status = pll_set(audioOutputType, force);
 800fb54:	f7ff ff22 	bl	800f99c <pll_set>

int pll_set_retry(int audioOutputType, int force, int retryNUm)
{
  int status = pll_set(audioOutputType, force);

  while(retryNUm > 0 && status < 0)
 800fb58:	2c00      	cmp	r4, #0
 800fb5a:	dd08      	ble.n	800fb6e <pll_set_retry+0x22>
 800fb5c:	2800      	cmp	r0, #0
 800fb5e:	da06      	bge.n	800fb6e <pll_set_retry+0x22>
    {
      retryNUm--;
      mdelay(200);
 800fb60:	20c8      	movs	r0, #200	; 0xc8
 800fb62:	f7fa fe95 	bl	800a890 <vTaskDelay>
{
  int status = pll_set(audioOutputType, force);

  while(retryNUm > 0 && status < 0)
    {
      retryNUm--;
 800fb66:	3c01      	subs	r4, #1
      mdelay(200);
      status = pll_set(audioOutputType, force);
 800fb68:	4631      	mov	r1, r6
 800fb6a:	4628      	mov	r0, r5
 800fb6c:	e7f2      	b.n	800fb54 <pll_set_retry+0x8>
    }
  return status;
}
 800fb6e:	bd70      	pop	{r4, r5, r6, pc}

0800fb70 <wdogAssert>:
}

static int wdogActive = 0;
void wdogAssert(int value)
{
  if(wdogActive)
 800fb70:	4b05      	ldr	r3, [pc, #20]	; (800fb88 <wdogAssert+0x18>)
 800fb72:	69db      	ldr	r3, [r3, #28]
 800fb74:	b10b      	cbz	r3, 800fb7a <wdogAssert+0xa>
    {
      GPIO_WriteBit(GPIOE, GPIO_Pin_8, value);
 800fb76:	b2c2      	uxtb	r2, r0
 800fb78:	e000      	b.n	800fb7c <wdogAssert+0xc>
    }
  else
    {
      GPIO_WriteBit(GPIOE, GPIO_Pin_8, 1);
 800fb7a:	2201      	movs	r2, #1
 800fb7c:	f44f 7180 	mov.w	r1, #256	; 0x100
 800fb80:	4802      	ldr	r0, [pc, #8]	; (800fb8c <wdogAssert+0x1c>)
 800fb82:	f001 ba07 	b.w	8010f94 <GPIO_WriteBit>
 800fb86:	bf00      	nop
 800fb88:	2001ada0 	.word	0x2001ada0
 800fb8c:	40021000 	.word	0x40021000

0800fb90 <ampEnable>:
    }
}

void ampEnable(int enable)
{
  if(!cfg.no_rst_amp)
 800fb90:	4b04      	ldr	r3, [pc, #16]	; (800fba4 <ampEnable+0x14>)
 800fb92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800fb94:	b92b      	cbnz	r3, 800fba2 <ampEnable+0x12>
    {
      GPIO_WriteBit(GPIOA, GPIO_Pin_11, enable);
 800fb96:	b2c2      	uxtb	r2, r0
 800fb98:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800fb9c:	4802      	ldr	r0, [pc, #8]	; (800fba8 <ampEnable+0x18>)
 800fb9e:	f001 b9f9 	b.w	8010f94 <GPIO_WriteBit>
 800fba2:	4770      	bx	lr
 800fba4:	10001000 	.word	0x10001000
 800fba8:	40020000 	.word	0x40020000

0800fbac <powerON1>:
}

void powerON1(void)
{
  //Activate watchdog
  wdogActive = 1;
 800fbac:	4b01      	ldr	r3, [pc, #4]	; (800fbb4 <powerON1+0x8>)
 800fbae:	2201      	movs	r2, #1
 800fbb0:	61da      	str	r2, [r3, #28]
 800fbb2:	4770      	bx	lr
 800fbb4:	2001ada0 	.word	0x2001ada0

0800fbb8 <powerON2>:
}

void powerON2(void)
{
  //SPK SW
  GPIO_WriteBit(GPIOA, GPIO_Pin_9, 1);
 800fbb8:	2201      	movs	r2, #1
 800fbba:	f44f 7100 	mov.w	r1, #512	; 0x200
 800fbbe:	4801      	ldr	r0, [pc, #4]	; (800fbc4 <powerON2+0xc>)
 800fbc0:	f001 b9e8 	b.w	8010f94 <GPIO_WriteBit>
 800fbc4:	40020000 	.word	0x40020000

0800fbc8 <powerON3>:
}

void powerON3(void)
{
 800fbc8:	b510      	push	{r4, lr}
  //POWER_ON pulse
  GPIO_WriteBit(GPIOC, GPIO_Pin_11, 0);
 800fbca:	4c09      	ldr	r4, [pc, #36]	; (800fbf0 <powerON3+0x28>)
 800fbcc:	2200      	movs	r2, #0
 800fbce:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800fbd2:	4620      	mov	r0, r4
 800fbd4:	f001 f9de 	bl	8010f94 <GPIO_WriteBit>
  mdelay(5);
 800fbd8:	2005      	movs	r0, #5
 800fbda:	f7fa fe59 	bl	800a890 <vTaskDelay>
  GPIO_WriteBit(GPIOC, GPIO_Pin_11, 1);
 800fbde:	4620      	mov	r0, r4
 800fbe0:	2201      	movs	r2, #1
 800fbe2:	f44f 6100 	mov.w	r1, #2048	; 0x800
}
 800fbe6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void powerON3(void)
{
  //POWER_ON pulse
  GPIO_WriteBit(GPIOC, GPIO_Pin_11, 0);
  mdelay(5);
  GPIO_WriteBit(GPIOC, GPIO_Pin_11, 1);
 800fbea:	f001 b9d3 	b.w	8010f94 <GPIO_WriteBit>
 800fbee:	bf00      	nop
 800fbf0:	40020800 	.word	0x40020800

0800fbf4 <powerON4>:


void powerON4(void)
{
  //RST_AMP
  GPIO_WriteBit(GPIOA, GPIO_Pin_11, 1);
 800fbf4:	2201      	movs	r2, #1
 800fbf6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800fbfa:	4801      	ldr	r0, [pc, #4]	; (800fc00 <powerON4+0xc>)
 800fbfc:	f001 b9ca 	b.w	8010f94 <GPIO_WriteBit>
 800fc00:	40020000 	.word	0x40020000

0800fc04 <powerOFF1>:
}

void powerOFF1(void)
{
  ampEnable(0);
 800fc04:	2000      	movs	r0, #0
 800fc06:	f7ff bfc3 	b.w	800fb90 <ampEnable>
	...

0800fc0c <powerOFF2>:
}

void powerOFF2(void)
{
  //Disable watchdog
  wdogActive = 0;
 800fc0c:	4b01      	ldr	r3, [pc, #4]	; (800fc14 <powerOFF2+0x8>)
 800fc0e:	2200      	movs	r2, #0
 800fc10:	61da      	str	r2, [r3, #28]
 800fc12:	4770      	bx	lr
 800fc14:	2001ada0 	.word	0x2001ada0

0800fc18 <powerOFF3>:
}

void powerOFF3(void)
{
  //SPK SW
  GPIO_WriteBit(GPIOA, GPIO_Pin_9, 0);
 800fc18:	2200      	movs	r2, #0
 800fc1a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800fc1e:	4801      	ldr	r0, [pc, #4]	; (800fc24 <powerOFF3+0xc>)
 800fc20:	f001 b9b8 	b.w	8010f94 <GPIO_WriteBit>
 800fc24:	40020000 	.word	0x40020000

0800fc28 <hwBoardInit>:
//Inicjalizacja sprzetow specyficzna dla konfiguracji projektu (GPIO, DMA, SPI, UARTy)
///////////////////////////////////////////////////////////////////////////////////////
//USART_INIT(uart, apb, gpio, arg_tx, arg_rx, arg_speed)
//SPI_INIT(spi, apb, gpio, clk, miso, mosi, cs, dma)
void hwBoardInit(void)
{
 800fc28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fc2c:	b08d      	sub	sp, #52	; 0x34
  //SPI pullups
  GPIO_INIT(B, 12, IN, UP);
 800fc2e:	ae0c      	add	r6, sp, #48	; 0x30
 800fc30:	f44f 5880 	mov.w	r8, #4096	; 0x1000
 800fc34:	2501      	movs	r5, #1
 800fc36:	f846 8d14 	str.w	r8, [r6, #-20]!
 800fc3a:	2400      	movs	r4, #0
 800fc3c:	2703      	movs	r7, #3
 800fc3e:	4629      	mov	r1, r5
 800fc40:	2002      	movs	r0, #2
 800fc42:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 800fc46:	f88d 4020 	strb.w	r4, [sp, #32]
 800fc4a:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 800fc4e:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 800fc52:	f001 faaf 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fc56:	4631      	mov	r1, r6
 800fc58:	48db      	ldr	r0, [pc, #876]	; (800ffc8 <hwBoardInit+0x3a0>)
 800fc5a:	f001 f893 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(B, 13, IN, UP);
 800fc5e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800fc62:	4629      	mov	r1, r5
 800fc64:	2002      	movs	r0, #2
 800fc66:	9307      	str	r3, [sp, #28]
 800fc68:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 800fc6c:	f88d 4020 	strb.w	r4, [sp, #32]
 800fc70:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 800fc74:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 800fc78:	f001 fa9c 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fc7c:	4631      	mov	r1, r6
 800fc7e:	48d2      	ldr	r0, [pc, #840]	; (800ffc8 <hwBoardInit+0x3a0>)
 800fc80:	f001 f880 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(B, 14, IN, UP);
 800fc84:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800fc88:	4629      	mov	r1, r5
 800fc8a:	2002      	movs	r0, #2
 800fc8c:	9307      	str	r3, [sp, #28]
 800fc8e:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 800fc92:	f88d 4020 	strb.w	r4, [sp, #32]
 800fc96:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 800fc9a:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 800fc9e:	f001 fa89 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fca2:	4631      	mov	r1, r6
 800fca4:	48c8      	ldr	r0, [pc, #800]	; (800ffc8 <hwBoardInit+0x3a0>)
 800fca6:	f001 f86d 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(B, 15, IN, UP);
 800fcaa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800fcae:	4629      	mov	r1, r5
 800fcb0:	2002      	movs	r0, #2
 800fcb2:	9307      	str	r3, [sp, #28]
 800fcb4:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 800fcb8:	f88d 4020 	strb.w	r4, [sp, #32]
 800fcbc:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 800fcc0:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 800fcc4:	f001 fa76 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fcc8:	4631      	mov	r1, r6
 800fcca:	48bf      	ldr	r0, [pc, #764]	; (800ffc8 <hwBoardInit+0x3a0>)
 800fccc:	f001 f85a 	bl	8010d84 <GPIO_Init>


  //Load config into ram
  cfgInit();
 800fcd0:	f7f0 fa74 	bl	80001bc <cfgInit>

  USART_INIT(UART5, 1, C, 12, D, 2, 921600); //DEBUG
 800fcd4:	4629      	mov	r1, r5
 800fcd6:	2004      	movs	r0, #4
 800fcd8:	f001 fa6c 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fcdc:	4629      	mov	r1, r5
 800fcde:	2008      	movs	r0, #8
 800fce0:	f001 fa68 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fce4:	4629      	mov	r1, r5
 800fce6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800fcea:	f001 fa87 	bl	80111fc <RCC_APB1PeriphClockCmd>
 800fcee:	af0c      	add	r7, sp, #48	; 0x30
 800fcf0:	2208      	movs	r2, #8
 800fcf2:	210c      	movs	r1, #12
 800fcf4:	48b5      	ldr	r0, [pc, #724]	; (800ffcc <hwBoardInit+0x3a4>)
 800fcf6:	f001 f9bf 	bl	8011078 <GPIO_PinAFConfig>
 800fcfa:	2208      	movs	r2, #8
 800fcfc:	2102      	movs	r1, #2
 800fcfe:	48b4      	ldr	r0, [pc, #720]	; (800ffd0 <hwBoardInit+0x3a8>)
 800fd00:	f001 f9ba 	bl	8011078 <GPIO_PinAFConfig>
 800fd04:	f847 8d1c 	str.w	r8, [r7, #-28]!
 800fd08:	2302      	movs	r3, #2
 800fd0a:	4639      	mov	r1, r7
 800fd0c:	48af      	ldr	r0, [pc, #700]	; (800ffcc <hwBoardInit+0x3a4>)
 800fd0e:	f88d 3018 	strb.w	r3, [sp, #24]
 800fd12:	f88d 3019 	strb.w	r3, [sp, #25]
 800fd16:	f88d 401a 	strb.w	r4, [sp, #26]
 800fd1a:	f88d 501b 	strb.w	r5, [sp, #27]
 800fd1e:	f001 f831 	bl	8010d84 <GPIO_Init>
 800fd22:	2304      	movs	r3, #4
 800fd24:	4639      	mov	r1, r7
 800fd26:	48aa      	ldr	r0, [pc, #680]	; (800ffd0 <hwBoardInit+0x3a8>)
 800fd28:	9305      	str	r3, [sp, #20]
 800fd2a:	f001 f82b 	bl	8010d84 <GPIO_Init>
 800fd2e:	f44f 2361 	mov.w	r3, #921600	; 0xe1000
 800fd32:	9307      	str	r3, [sp, #28]
 800fd34:	4631      	mov	r1, r6
 800fd36:	230c      	movs	r3, #12
 800fd38:	48a6      	ldr	r0, [pc, #664]	; (800ffd4 <hwBoardInit+0x3ac>)
 800fd3a:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
 800fd3e:	f8ad 4020 	strh.w	r4, [sp, #32]
 800fd42:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
 800fd46:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
 800fd4a:	f8ad 4028 	strh.w	r4, [sp, #40]	; 0x28
 800fd4e:	f001 fae5 	bl	801131c <USART_Init>
 800fd52:	4629      	mov	r1, r5
 800fd54:	489f      	ldr	r0, [pc, #636]	; (800ffd4 <hwBoardInit+0x3ac>)
 800fd56:	f001 fbbb 	bl	80114d0 <USART_Cmd>
  xprintf_init(sendChar);
 800fd5a:	489f      	ldr	r0, [pc, #636]	; (800ffd8 <hwBoardInit+0x3b0>)
 800fd5c:	f7f8 fbfc 	bl	8008558 <xprintf_init>
  xprintf(CLEAR_SCREEN CUR_HOME(19) "\n");
 800fd60:	489e      	ldr	r0, [pc, #632]	; (800ffdc <hwBoardInit+0x3b4>)
 800fd62:	f7f8 fcff 	bl	8008764 <xprintf>

  //Inicjalizacja LED
  LEDS_INIT_ON_GPIO(C);
 800fd66:	499e      	ldr	r1, [pc, #632]	; (800ffe0 <hwBoardInit+0x3b8>)
 800fd68:	4898      	ldr	r0, [pc, #608]	; (800ffcc <hwBoardInit+0x3a4>)
 800fd6a:	9407      	str	r4, [sp, #28]
 800fd6c:	4622      	mov	r2, r4
 800fd6e:	4623      	mov	r3, r4
 800fd70:	585d      	ldr	r5, [r3, r1]
 800fd72:	4285      	cmp	r5, r0
 800fd74:	bf08      	it	eq
 800fd76:	18cc      	addeq	r4, r1, r3
 800fd78:	f103 0308 	add.w	r3, r3, #8
 800fd7c:	bf02      	ittt	eq
 800fd7e:	88a4      	ldrheq	r4, [r4, #4]
 800fd80:	4322      	orreq	r2, r4
 800fd82:	2401      	moveq	r4, #1
 800fd84:	2b28      	cmp	r3, #40	; 0x28
 800fd86:	d1f3      	bne.n	800fd70 <hwBoardInit+0x148>
 800fd88:	b104      	cbz	r4, 800fd8c <hwBoardInit+0x164>
 800fd8a:	9207      	str	r2, [sp, #28]
 800fd8c:	9b07      	ldr	r3, [sp, #28]
 800fd8e:	b18b      	cbz	r3, 800fdb4 <hwBoardInit+0x18c>
 800fd90:	2101      	movs	r1, #1
 800fd92:	2300      	movs	r3, #0
 800fd94:	2203      	movs	r2, #3
 800fd96:	2004      	movs	r0, #4
 800fd98:	f88d 1020 	strb.w	r1, [sp, #32]
 800fd9c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
 800fda0:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
 800fda4:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800fda8:	f001 fa04 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fdac:	4631      	mov	r1, r6
 800fdae:	4887      	ldr	r0, [pc, #540]	; (800ffcc <hwBoardInit+0x3a4>)
 800fdb0:	f000 ffe8 	bl	8010d84 <GPIO_Init>

  //POWER_ON
  GPIO_WriteBit(GPIOC, GPIO_Pin_11, 1);
 800fdb4:	2201      	movs	r2, #1
 800fdb6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800fdba:	4884      	ldr	r0, [pc, #528]	; (800ffcc <hwBoardInit+0x3a4>)
  GPIO_INIT(C, 11, OUT, NOPULL);
 800fdbc:	2501      	movs	r5, #1

  //Inicjalizacja LED
  LEDS_INIT_ON_GPIO(C);

  //POWER_ON
  GPIO_WriteBit(GPIOC, GPIO_Pin_11, 1);
 800fdbe:	f001 f8e9 	bl	8010f94 <GPIO_WriteBit>
  GPIO_INIT(C, 11, OUT, NOPULL);
 800fdc2:	f44f 6400 	mov.w	r4, #2048	; 0x800
 800fdc6:	2300      	movs	r3, #0
 800fdc8:	2203      	movs	r2, #3
 800fdca:	4629      	mov	r1, r5
 800fdcc:	2004      	movs	r0, #4
 800fdce:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
 800fdd2:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
 800fdd6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800fdda:	f88d 5020 	strb.w	r5, [sp, #32]
 800fdde:	9407      	str	r4, [sp, #28]
 800fde0:	f001 f9e8 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fde4:	4631      	mov	r1, r6
 800fde6:	4879      	ldr	r0, [pc, #484]	; (800ffcc <hwBoardInit+0x3a4>)
 800fde8:	f000 ffcc 	bl	8010d84 <GPIO_Init>

  //RST AMP
  if(!cfg.no_rst_amp)
 800fdec:	4b7d      	ldr	r3, [pc, #500]	; (800ffe4 <hwBoardInit+0x3bc>)
 800fdee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800fdf0:	b102      	cbz	r2, 800fdf4 <hwBoardInit+0x1cc>
    {
      GPIO_WriteBit(GPIOA, GPIO_Pin_11, 0);
    }
  else
    {
      GPIO_WriteBit(GPIOA, GPIO_Pin_11, 1);
 800fdf2:	462a      	mov	r2, r5
 800fdf4:	4621      	mov	r1, r4
 800fdf6:	487c      	ldr	r0, [pc, #496]	; (800ffe8 <hwBoardInit+0x3c0>)

  xprintf("Wait 1000ms to stabilize power before external devices configuration\n");
  mdelay(1000);

  //inicjalizacja UARTow i SPI
  memset((void *)&CEN_SPIhelper, 0, sizeof(CEN_SPIhelper));
 800fdf8:	4e7c      	ldr	r6, [pc, #496]	; (800ffec <hwBoardInit+0x3c4>)
    {
      GPIO_WriteBit(GPIOA, GPIO_Pin_11, 0);
    }
  else
    {
      GPIO_WriteBit(GPIOA, GPIO_Pin_11, 1);
 800fdfa:	f001 f8cb 	bl	8010f94 <GPIO_WriteBit>
    }

  powerOFF1();
 800fdfe:	f7ff ff01 	bl	800fc04 <powerOFF1>
}

void powerOFF2(void)
{
  //Disable watchdog
  wdogActive = 0;
 800fe02:	4b7b      	ldr	r3, [pc, #492]	; (800fff0 <hwBoardInit+0x3c8>)
 800fe04:	2400      	movs	r4, #0

  powerOFF1();
  powerOFF2();
  powerOFF3();

  GPIO_INIT(A, 11, OUT, NOPULL);
 800fe06:	af0c      	add	r7, sp, #48	; 0x30
}

void powerOFF2(void)
{
  //Disable watchdog
  wdogActive = 0;
 800fe08:	61dc      	str	r4, [r3, #28]
      GPIO_WriteBit(GPIOA, GPIO_Pin_11, 1);
    }

  powerOFF1();
  powerOFF2();
  powerOFF3();
 800fe0a:	f7ff ff05 	bl	800fc18 <powerOFF3>

  GPIO_INIT(A, 11, OUT, NOPULL);
 800fe0e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800fe12:	2501      	movs	r5, #1
 800fe14:	f847 3d14 	str.w	r3, [r7, #-20]!
 800fe18:	f04f 0903 	mov.w	r9, #3
 800fe1c:	4629      	mov	r1, r5
 800fe1e:	4628      	mov	r0, r5
 800fe20:	f88d 5020 	strb.w	r5, [sp, #32]
 800fe24:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 800fe28:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 800fe2c:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
 800fe30:	f001 f9c0 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fe34:	4639      	mov	r1, r7
 800fe36:	486c      	ldr	r0, [pc, #432]	; (800ffe8 <hwBoardInit+0x3c0>)
 800fe38:	f000 ffa4 	bl	8010d84 <GPIO_Init>
  //SPK SWITCH
  GPIO_INIT(A, 9, OUT, NOPULL);
 800fe3c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800fe40:	4629      	mov	r1, r5
 800fe42:	4628      	mov	r0, r5
 800fe44:	9307      	str	r3, [sp, #28]
 800fe46:	f88d 5020 	strb.w	r5, [sp, #32]
 800fe4a:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 800fe4e:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 800fe52:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
 800fe56:	f001 f9ad 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fe5a:	4639      	mov	r1, r7
 800fe5c:	4862      	ldr	r0, [pc, #392]	; (800ffe8 <hwBoardInit+0x3c0>)
 800fe5e:	f000 ff91 	bl	8010d84 <GPIO_Init>

  xprintf("Wait 1000ms to stabilize power before external devices configuration\n");
 800fe62:	4864      	ldr	r0, [pc, #400]	; (800fff4 <hwBoardInit+0x3cc>)
 800fe64:	f7f8 fc7e 	bl	8008764 <xprintf>
  mdelay(1000);
 800fe68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fe6c:	f7fa fd10 	bl	800a890 <vTaskDelay>

  //inicjalizacja UARTow i SPI
  memset((void *)&CEN_SPIhelper, 0, sizeof(CEN_SPIhelper));
 800fe70:	f240 1243 	movw	r2, #323	; 0x143
 800fe74:	4621      	mov	r1, r4
 800fe76:	4630      	mov	r0, r6
 800fe78:	f004 fb84 	bl	8014584 <memset>
  memset((void *)&CEN_UARThelper, 0, sizeof(CEN_UARThelper));
 800fe7c:	f44f 7207 	mov.w	r2, #540	; 0x21c
 800fe80:	4621      	mov	r1, r4
 800fe82:	f206 1043 	addw	r0, r6, #323	; 0x143
 800fe86:	f004 fb7d 	bl	8014584 <memset>
  memset((void *)&PER1_UARThelper, 0, sizeof(PER1_UARThelper));
 800fe8a:	f44f 7207 	mov.w	r2, #540	; 0x21c
 800fe8e:	4621      	mov	r1, r4
 800fe90:	f206 305f 	addw	r0, r6, #863	; 0x35f
 800fe94:	f004 fb76 	bl	8014584 <memset>
  memset((void *)&PER2_UARThelper, 0, sizeof(PER2_UARThelper));
 800fe98:	f44f 7207 	mov.w	r2, #540	; 0x21c
 800fe9c:	4621      	mov	r1, r4
 800fe9e:	f206 507b 	addw	r0, r6, #1403	; 0x57b
 800fea2:	f004 fb6f 	bl	8014584 <memset>

  CEN_UARThelper.usart = UART4;
 800fea6:	f04f 0b40 	mov.w	fp, #64	; 0x40
 800feaa:	234c      	movs	r3, #76	; 0x4c
  USART_INIT(UART4, 1, A, 0, A, 1, UART_SPEED); //CEN
 800feac:	4629      	mov	r1, r5
 800feae:	4628      	mov	r0, r5
  memset((void *)&CEN_SPIhelper, 0, sizeof(CEN_SPIhelper));
  memset((void *)&CEN_UARThelper, 0, sizeof(CEN_UARThelper));
  memset((void *)&PER1_UARThelper, 0, sizeof(PER1_UARThelper));
  memset((void *)&PER2_UARThelper, 0, sizeof(PER2_UARThelper));

  CEN_UARThelper.usart = UART4;
 800feb0:	f886 335c 	strb.w	r3, [r6, #860]	; 0x35c
 800feb4:	f886 435b 	strb.w	r4, [r6, #859]	; 0x35b
 800feb8:	f886 435d 	strb.w	r4, [r6, #861]	; 0x35d
 800febc:	f886 b35e 	strb.w	fp, [r6, #862]	; 0x35e
  USART_INIT(UART4, 1, A, 0, A, 1, UART_SPEED); //CEN
 800fec0:	f001 f978 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fec4:	4629      	mov	r1, r5
 800fec6:	4628      	mov	r0, r5
 800fec8:	f001 f974 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800fecc:	4629      	mov	r1, r5
 800fece:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800fed2:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
 800fed6:	f001 f991 	bl	80111fc <RCC_APB1PeriphClockCmd>
 800feda:	2208      	movs	r2, #8
 800fedc:	4621      	mov	r1, r4
 800fede:	4842      	ldr	r0, [pc, #264]	; (800ffe8 <hwBoardInit+0x3c0>)
 800fee0:	f001 f8ca 	bl	8011078 <GPIO_PinAFConfig>
 800fee4:	2208      	movs	r2, #8
 800fee6:	4629      	mov	r1, r5
 800fee8:	483f      	ldr	r0, [pc, #252]	; (800ffe8 <hwBoardInit+0x3c0>)
 800feea:	f001 f8c5 	bl	8011078 <GPIO_PinAFConfig>
 800feee:	f84a 5d1c 	str.w	r5, [sl, #-28]!
 800fef2:	f04f 0802 	mov.w	r8, #2
 800fef6:	4651      	mov	r1, sl
 800fef8:	483b      	ldr	r0, [pc, #236]	; (800ffe8 <hwBoardInit+0x3c0>)
 800fefa:	f88d 401a 	strb.w	r4, [sp, #26]
 800fefe:	f88d 501b 	strb.w	r5, [sp, #27]
 800ff02:	f88d 8018 	strb.w	r8, [sp, #24]
 800ff06:	f88d 8019 	strb.w	r8, [sp, #25]
 800ff0a:	f000 ff3b 	bl	8010d84 <GPIO_Init>
 800ff0e:	4651      	mov	r1, sl
 800ff10:	4835      	ldr	r0, [pc, #212]	; (800ffe8 <hwBoardInit+0x3c0>)
 800ff12:	f8cd 8014 	str.w	r8, [sp, #20]
 800ff16:	f000 ff35 	bl	8010d84 <GPIO_Init>
 800ff1a:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 800ff1e:	9307      	str	r3, [sp, #28]
 800ff20:	4639      	mov	r1, r7
 800ff22:	f04f 030c 	mov.w	r3, #12
 800ff26:	4834      	ldr	r0, [pc, #208]	; (800fff8 <hwBoardInit+0x3d0>)
 800ff28:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
 800ff2c:	f8ad 4020 	strh.w	r4, [sp, #32]
 800ff30:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
 800ff34:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
 800ff38:	f8ad 4028 	strh.w	r4, [sp, #40]	; 0x28
 800ff3c:	f001 f9ee 	bl	801131c <USART_Init>
 800ff40:	4629      	mov	r1, r5
 800ff42:	482d      	ldr	r0, [pc, #180]	; (800fff8 <hwBoardInit+0x3d0>)
 800ff44:	f001 fac4 	bl	80114d0 <USART_Cmd>
  USART_INIT_HANDLER(UART4);
 800ff48:	492c      	ldr	r1, [pc, #176]	; (800fffc <hwBoardInit+0x3d4>)
 800ff4a:	2034      	movs	r0, #52	; 0x34
 800ff4c:	f7f8 f9ae 	bl	80082ac <registerIRQ>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800ff50:	4b2b      	ldr	r3, [pc, #172]	; (8010000 <hwBoardInit+0x3d8>)
 800ff52:	4829      	ldr	r0, [pc, #164]	; (800fff8 <hwBoardInit+0x3d0>)
 800ff54:	f06f 020f 	mvn.w	r2, #15
 800ff58:	f883 2334 	strb.w	r2, [r3, #820]	; 0x334
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800ff5c:	4a28      	ldr	r2, [pc, #160]	; (8010000 <hwBoardInit+0x3d8>)
 800ff5e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800ff62:	6053      	str	r3, [r2, #4]
 800ff64:	f240 5125 	movw	r1, #1317	; 0x525
 800ff68:	462a      	mov	r2, r5
 800ff6a:	f001 fb55 	bl	8011618 <USART_ITConfig>

  PER1_UARThelper.usart = USART2;
 800ff6e:	2344      	movs	r3, #68	; 0x44
 800ff70:	f886 3578 	strb.w	r3, [r6, #1400]	; 0x578
  PER2_UARThelper.usart = USART3;
  USART_INIT(USART2, 1, A, 2, A, 3, UART_SPEED); //PER1
 800ff74:	4629      	mov	r1, r5
  CEN_UARThelper.usart = UART4;
  USART_INIT(UART4, 1, A, 0, A, 1, UART_SPEED); //CEN
  USART_INIT_HANDLER(UART4);

  PER1_UARThelper.usart = USART2;
  PER2_UARThelper.usart = USART3;
 800ff76:	2348      	movs	r3, #72	; 0x48
  USART_INIT(USART2, 1, A, 2, A, 3, UART_SPEED); //PER1
 800ff78:	4628      	mov	r0, r5
  CEN_UARThelper.usart = UART4;
  USART_INIT(UART4, 1, A, 0, A, 1, UART_SPEED); //CEN
  USART_INIT_HANDLER(UART4);

  PER1_UARThelper.usart = USART2;
  PER2_UARThelper.usart = USART3;
 800ff7a:	f886 3794 	strb.w	r3, [r6, #1940]	; 0x794

  CEN_UARThelper.usart = UART4;
  USART_INIT(UART4, 1, A, 0, A, 1, UART_SPEED); //CEN
  USART_INIT_HANDLER(UART4);

  PER1_UARThelper.usart = USART2;
 800ff7e:	f886 4577 	strb.w	r4, [r6, #1399]	; 0x577
 800ff82:	f886 4579 	strb.w	r4, [r6, #1401]	; 0x579
 800ff86:	f886 b57a 	strb.w	fp, [r6, #1402]	; 0x57a
  PER2_UARThelper.usart = USART3;
 800ff8a:	f886 4793 	strb.w	r4, [r6, #1939]	; 0x793
 800ff8e:	f886 4795 	strb.w	r4, [r6, #1941]	; 0x795
 800ff92:	f886 b796 	strb.w	fp, [r6, #1942]	; 0x796
  USART_INIT(USART2, 1, A, 2, A, 3, UART_SPEED); //PER1
 800ff96:	f001 f90d 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800ff9a:	4629      	mov	r1, r5
 800ff9c:	4628      	mov	r0, r5
 800ff9e:	f001 f909 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 800ffa2:	4629      	mov	r1, r5
 800ffa4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800ffa8:	f001 f928 	bl	80111fc <RCC_APB1PeriphClockCmd>
 800ffac:	2207      	movs	r2, #7
 800ffae:	4641      	mov	r1, r8
 800ffb0:	480d      	ldr	r0, [pc, #52]	; (800ffe8 <hwBoardInit+0x3c0>)
 800ffb2:	f001 f861 	bl	8011078 <GPIO_PinAFConfig>
 800ffb6:	2207      	movs	r2, #7
 800ffb8:	4649      	mov	r1, r9
 800ffba:	480b      	ldr	r0, [pc, #44]	; (800ffe8 <hwBoardInit+0x3c0>)
 800ffbc:	f001 f85c 	bl	8011078 <GPIO_PinAFConfig>
 800ffc0:	2304      	movs	r3, #4
 800ffc2:	4651      	mov	r1, sl
 800ffc4:	e01e      	b.n	8010004 <hwBoardInit+0x3dc>
 800ffc6:	bf00      	nop
 800ffc8:	40020400 	.word	0x40020400
 800ffcc:	40020800 	.word	0x40020800
 800ffd0:	40020c00 	.word	0x40020c00
 800ffd4:	40005000 	.word	0x40005000
 800ffd8:	08008511 	.word	0x08008511
 800ffdc:	08014a9c 	.word	0x08014a9c
 800ffe0:	2001abb0 	.word	0x2001abb0
 800ffe4:	10001000 	.word	0x10001000
 800ffe8:	40020000 	.word	0x40020000
 800ffec:	20019a38 	.word	0x20019a38
 800fff0:	2001ada0 	.word	0x2001ada0
 800fff4:	0801e102 	.word	0x0801e102
 800fff8:	40004c00 	.word	0x40004c00
 800fffc:	0800f689 	.word	0x0800f689
 8010000:	e000e100 	.word	0xe000e100
 8010004:	48c7      	ldr	r0, [pc, #796]	; (8010324 <hwBoardInit+0x6fc>)
 8010006:	9305      	str	r3, [sp, #20]
 8010008:	f88d 401a 	strb.w	r4, [sp, #26]
 801000c:	f88d 501b 	strb.w	r5, [sp, #27]
 8010010:	f88d 8018 	strb.w	r8, [sp, #24]
 8010014:	f88d 8019 	strb.w	r8, [sp, #25]
 8010018:	f000 feb4 	bl	8010d84 <GPIO_Init>
 801001c:	2308      	movs	r3, #8
 801001e:	4651      	mov	r1, sl
 8010020:	48c0      	ldr	r0, [pc, #768]	; (8010324 <hwBoardInit+0x6fc>)
 8010022:	9305      	str	r3, [sp, #20]
 8010024:	f000 feae 	bl	8010d84 <GPIO_Init>
 8010028:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 801002c:	9307      	str	r3, [sp, #28]
 801002e:	4639      	mov	r1, r7
 8010030:	f04f 030c 	mov.w	r3, #12
 8010034:	48bc      	ldr	r0, [pc, #752]	; (8010328 <hwBoardInit+0x700>)
 8010036:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
 801003a:	f8ad 4020 	strh.w	r4, [sp, #32]
 801003e:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
 8010042:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
 8010046:	f8ad 4028 	strh.w	r4, [sp, #40]	; 0x28
 801004a:	f001 f967 	bl	801131c <USART_Init>
 801004e:	4629      	mov	r1, r5
 8010050:	48b5      	ldr	r0, [pc, #724]	; (8010328 <hwBoardInit+0x700>)
 8010052:	f001 fa3d 	bl	80114d0 <USART_Cmd>
  USART_INIT_HANDLER(USART2);
 8010056:	49b5      	ldr	r1, [pc, #724]	; (801032c <hwBoardInit+0x704>)
 8010058:	2026      	movs	r0, #38	; 0x26
 801005a:	f7f8 f927 	bl	80082ac <registerIRQ>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 801005e:	4bb4      	ldr	r3, [pc, #720]	; (8010330 <hwBoardInit+0x708>)
 8010060:	48b1      	ldr	r0, [pc, #708]	; (8010328 <hwBoardInit+0x700>)
 8010062:	f06f 020f 	mvn.w	r2, #15
 8010066:	f883 2326 	strb.w	r2, [r3, #806]	; 0x326
 801006a:	f240 5125 	movw	r1, #1317	; 0x525
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 801006e:	f8c3 b004 	str.w	fp, [r3, #4]
 8010072:	462a      	mov	r2, r5
 8010074:	f001 fad0 	bl	8011618 <USART_ITConfig>
  USART_INIT(USART3, 1, D, 8, D, 9, UART_SPEED); //PER2
 8010078:	4629      	mov	r1, r5
 801007a:	2008      	movs	r0, #8
 801007c:	f001 f89a 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010080:	4629      	mov	r1, r5
 8010082:	2008      	movs	r0, #8
 8010084:	f001 f896 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010088:	4629      	mov	r1, r5
 801008a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 801008e:	f001 f8b5 	bl	80111fc <RCC_APB1PeriphClockCmd>
 8010092:	2207      	movs	r2, #7
 8010094:	2108      	movs	r1, #8
 8010096:	48a7      	ldr	r0, [pc, #668]	; (8010334 <hwBoardInit+0x70c>)
 8010098:	f000 ffee 	bl	8011078 <GPIO_PinAFConfig>
 801009c:	2207      	movs	r2, #7
 801009e:	2109      	movs	r1, #9
 80100a0:	48a4      	ldr	r0, [pc, #656]	; (8010334 <hwBoardInit+0x70c>)
 80100a2:	f000 ffe9 	bl	8011078 <GPIO_PinAFConfig>
 80100a6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80100aa:	4651      	mov	r1, sl
 80100ac:	48a1      	ldr	r0, [pc, #644]	; (8010334 <hwBoardInit+0x70c>)
 80100ae:	9305      	str	r3, [sp, #20]
 80100b0:	9300      	str	r3, [sp, #0]
 80100b2:	f88d 401a 	strb.w	r4, [sp, #26]
 80100b6:	f88d 501b 	strb.w	r5, [sp, #27]
 80100ba:	f88d 8018 	strb.w	r8, [sp, #24]
 80100be:	f88d 8019 	strb.w	r8, [sp, #25]
 80100c2:	f000 fe5f 	bl	8010d84 <GPIO_Init>
 80100c6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80100ca:	4651      	mov	r1, sl
 80100cc:	4899      	ldr	r0, [pc, #612]	; (8010334 <hwBoardInit+0x70c>)
 80100ce:	9305      	str	r3, [sp, #20]
 80100d0:	f000 fe58 	bl	8010d84 <GPIO_Init>
 80100d4:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80100d8:	9307      	str	r3, [sp, #28]
 80100da:	4639      	mov	r1, r7
 80100dc:	f04f 030c 	mov.w	r3, #12
 80100e0:	4895      	ldr	r0, [pc, #596]	; (8010338 <hwBoardInit+0x710>)
 80100e2:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
 80100e6:	f8ad 4020 	strh.w	r4, [sp, #32]
 80100ea:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
 80100ee:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
 80100f2:	f8ad 4028 	strh.w	r4, [sp, #40]	; 0x28
 80100f6:	f001 f911 	bl	801131c <USART_Init>
 80100fa:	4629      	mov	r1, r5
 80100fc:	488e      	ldr	r0, [pc, #568]	; (8010338 <hwBoardInit+0x710>)
 80100fe:	f001 f9e7 	bl	80114d0 <USART_Cmd>
  USART_INIT_HANDLER(USART3);
 8010102:	498e      	ldr	r1, [pc, #568]	; (801033c <hwBoardInit+0x714>)
 8010104:	2027      	movs	r0, #39	; 0x27
 8010106:	f7f8 f8d1 	bl	80082ac <registerIRQ>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 801010a:	4b89      	ldr	r3, [pc, #548]	; (8010330 <hwBoardInit+0x708>)
 801010c:	488a      	ldr	r0, [pc, #552]	; (8010338 <hwBoardInit+0x710>)
 801010e:	f06f 020f 	mvn.w	r2, #15
 8010112:	f883 2327 	strb.w	r2, [r3, #807]	; 0x327
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8010116:	2280      	movs	r2, #128	; 0x80
 8010118:	605a      	str	r2, [r3, #4]
 801011a:	f240 5125 	movw	r1, #1317	; 0x525
 801011e:	462a      	mov	r2, r5
 8010120:	f001 fa7a 	bl	8011618 <USART_ITConfig>

  //ADC sens
  GPIO_INIT(B, 1, OUT, NOPULL);
 8010124:	4629      	mov	r1, r5
 8010126:	4640      	mov	r0, r8
 8010128:	f88d 5020 	strb.w	r5, [sp, #32]
 801012c:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 8010130:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 8010134:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
 8010138:	f8cd 801c 	str.w	r8, [sp, #28]
 801013c:	f001 f83a 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010140:	4639      	mov	r1, r7
 8010142:	487f      	ldr	r0, [pc, #508]	; (8010340 <hwBoardInit+0x718>)
 8010144:	f000 fe1e 	bl	8010d84 <GPIO_Init>

  //Watchdog
  GPIO_INIT(E, 8, OUT, NOPULL);
 8010148:	9b00      	ldr	r3, [sp, #0]
 801014a:	9307      	str	r3, [sp, #28]
 801014c:	4629      	mov	r1, r5
 801014e:	2010      	movs	r0, #16
 8010150:	f88d 5020 	strb.w	r5, [sp, #32]
 8010154:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 8010158:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 801015c:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
 8010160:	f001 f828 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010164:	4639      	mov	r1, r7
 8010166:	4877      	ldr	r0, [pc, #476]	; (8010344 <hwBoardInit+0x71c>)
 8010168:	f000 fe0c 	bl	8010d84 <GPIO_Init>
  wdogAssert(1);
 801016c:	4628      	mov	r0, r5
 801016e:	f7ff fcff 	bl	800fb70 <wdogAssert>

  //Polar1/2
  PIN_SET(E, 14, ((cfg.polar>>0)&1));//Polar1
 8010172:	4b75      	ldr	r3, [pc, #468]	; (8010348 <hwBoardInit+0x720>)
 8010174:	4873      	ldr	r0, [pc, #460]	; (8010344 <hwBoardInit+0x71c>)
 8010176:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 801017a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 801017e:	402a      	ands	r2, r5
 8010180:	f000 ff08 	bl	8010f94 <GPIO_WriteBit>
  GPIO_INIT(E, 14, OUT, NOPULL);
 8010184:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8010188:	4629      	mov	r1, r5
 801018a:	2010      	movs	r0, #16
 801018c:	9307      	str	r3, [sp, #28]
 801018e:	9301      	str	r3, [sp, #4]
 8010190:	f88d 5020 	strb.w	r5, [sp, #32]
 8010194:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 8010198:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 801019c:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
 80101a0:	f001 f808 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80101a4:	4639      	mov	r1, r7
 80101a6:	4867      	ldr	r0, [pc, #412]	; (8010344 <hwBoardInit+0x71c>)
 80101a8:	f000 fdec 	bl	8010d84 <GPIO_Init>
  PIN_SET(E, 15, ((cfg.polar>>1)&1));//Polar2
 80101ac:	4b66      	ldr	r3, [pc, #408]	; (8010348 <hwBoardInit+0x720>)
 80101ae:	4865      	ldr	r0, [pc, #404]	; (8010344 <hwBoardInit+0x71c>)
 80101b0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80101b4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80101b8:	f3c2 0240 	ubfx	r2, r2, #1, #1
 80101bc:	f000 feea 	bl	8010f94 <GPIO_WriteBit>
  GPIO_INIT(E, 15, OUT, NOPULL);
 80101c0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80101c4:	4629      	mov	r1, r5
 80101c6:	2010      	movs	r0, #16
 80101c8:	9207      	str	r2, [sp, #28]
 80101ca:	9200      	str	r2, [sp, #0]
 80101cc:	f88d 5020 	strb.w	r5, [sp, #32]
 80101d0:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 80101d4:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 80101d8:	f88d 4023 	strb.w	r4, [sp, #35]	; 0x23
 80101dc:	f000 ffea 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80101e0:	4639      	mov	r1, r7
 80101e2:	4858      	ldr	r0, [pc, #352]	; (8010344 <hwBoardInit+0x71c>)
 80101e4:	f000 fdce 	bl	8010d84 <GPIO_Init>

  //PWM_STAT and other PWM status lines
  GPIO_INIT(A, 12, IN, UP);
 80101e8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80101ec:	4629      	mov	r1, r5
 80101ee:	4628      	mov	r0, r5
 80101f0:	9307      	str	r3, [sp, #28]
 80101f2:	f88d 4020 	strb.w	r4, [sp, #32]
 80101f6:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 80101fa:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 80101fe:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 8010202:	f000 ffd7 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010206:	4639      	mov	r1, r7
 8010208:	4846      	ldr	r0, [pc, #280]	; (8010324 <hwBoardInit+0x6fc>)
 801020a:	f000 fdbb 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(B, 3, IN, UP);
 801020e:	2308      	movs	r3, #8
 8010210:	4629      	mov	r1, r5
 8010212:	4640      	mov	r0, r8
 8010214:	9307      	str	r3, [sp, #28]
 8010216:	f88d 4020 	strb.w	r4, [sp, #32]
 801021a:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 801021e:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 8010222:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 8010226:	f000 ffc5 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 801022a:	4639      	mov	r1, r7
 801022c:	4844      	ldr	r0, [pc, #272]	; (8010340 <hwBoardInit+0x718>)
 801022e:	f000 fda9 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(B, 9, IN, UP);
 8010232:	f44f 7300 	mov.w	r3, #512	; 0x200
 8010236:	4629      	mov	r1, r5
 8010238:	4640      	mov	r0, r8
 801023a:	9307      	str	r3, [sp, #28]
 801023c:	f88d 4020 	strb.w	r4, [sp, #32]
 8010240:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 8010244:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 8010248:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 801024c:	f000 ffb2 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010250:	4639      	mov	r1, r7
 8010252:	483b      	ldr	r0, [pc, #236]	; (8010340 <hwBoardInit+0x718>)
 8010254:	f000 fd96 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(C, 14, IN, UP);
 8010258:	9b01      	ldr	r3, [sp, #4]
 801025a:	9307      	str	r3, [sp, #28]
 801025c:	4629      	mov	r1, r5
 801025e:	2004      	movs	r0, #4
 8010260:	f88d 4020 	strb.w	r4, [sp, #32]
 8010264:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 8010268:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 801026c:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 8010270:	f000 ffa0 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010274:	4639      	mov	r1, r7
 8010276:	4835      	ldr	r0, [pc, #212]	; (801034c <hwBoardInit+0x724>)
 8010278:	f000 fd84 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(C, 15, IN, UP);
 801027c:	9a00      	ldr	r2, [sp, #0]
 801027e:	9207      	str	r2, [sp, #28]
 8010280:	4629      	mov	r1, r5
 8010282:	2004      	movs	r0, #4
 8010284:	f88d 4020 	strb.w	r4, [sp, #32]
 8010288:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 801028c:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 8010290:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 8010294:	f000 ff8e 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010298:	4639      	mov	r1, r7
 801029a:	482c      	ldr	r0, [pc, #176]	; (801034c <hwBoardInit+0x724>)
 801029c:	f000 fd72 	bl	8010d84 <GPIO_Init>
  GPIO_INIT(E, 13, IN, UP);
 80102a0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80102a4:	4629      	mov	r1, r5
 80102a6:	2010      	movs	r0, #16
 80102a8:	9307      	str	r3, [sp, #28]
 80102aa:	f88d 4020 	strb.w	r4, [sp, #32]
 80102ae:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 80102b2:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 80102b6:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
 80102ba:	f000 ff7b 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80102be:	4639      	mov	r1, r7
 80102c0:	4820      	ldr	r0, [pc, #128]	; (8010344 <hwBoardInit+0x71c>)
 80102c2:	f000 fd5f 	bl	8010d84 <GPIO_Init>

  {
    CEN_SPIhelper.moduleNum = 0;
    CEN_SPIhelper.radioModule = &radioModule[0];
 80102c6:	4b22      	ldr	r3, [pc, #136]	; (8010350 <hwBoardInit+0x728>)
    CEN_SPIhelper.connDev.devID  = 0x0;
    CEN_SPIhelper.connDev.manID  = 0x0;
    CEN_SPIhelper.connDev.prodID = 0x0;

    //Radio SPI
    SPI_INIT_HANDLER(SPI1);
 80102c8:	4922      	ldr	r1, [pc, #136]	; (8010354 <hwBoardInit+0x72c>)
  GPIO_INIT(C, 15, IN, UP);
  GPIO_INIT(E, 13, IN, UP);

  {
    CEN_SPIhelper.moduleNum = 0;
    CEN_SPIhelper.radioModule = &radioModule[0];
 80102ca:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
    CEN_SPIhelper.connDev.devID  = 0x0;
    CEN_SPIhelper.connDev.manID  = 0x0;
    CEN_SPIhelper.connDev.prodID = 0x0;

    //Radio SPI
    SPI_INIT_HANDLER(SPI1);
 80102ce:	2023      	movs	r0, #35	; 0x23
  GPIO_INIT(C, 15, IN, UP);
  GPIO_INIT(E, 13, IN, UP);

  {
    CEN_SPIhelper.moduleNum = 0;
    CEN_SPIhelper.radioModule = &radioModule[0];
 80102d0:	9300      	str	r3, [sp, #0]
  GPIO_INIT(C, 14, IN, UP);
  GPIO_INIT(C, 15, IN, UP);
  GPIO_INIT(E, 13, IN, UP);

  {
    CEN_SPIhelper.moduleNum = 0;
 80102d2:	f886 4110 	strb.w	r4, [r6, #272]	; 0x110
 80102d6:	f886 4111 	strb.w	r4, [r6, #273]	; 0x111
 80102da:	f886 4112 	strb.w	r4, [r6, #274]	; 0x112
 80102de:	f886 4113 	strb.w	r4, [r6, #275]	; 0x113
    CEN_SPIhelper.radioModule = &radioModule[0];
    CEN_SPIhelper.master = 0;
 80102e2:	f886 4114 	strb.w	r4, [r6, #276]	; 0x114

    //Remote radio chip connected (master/slave):
    CEN_SPIhelper.connDev.devID  = 0x0;
 80102e6:	f886 4115 	strb.w	r4, [r6, #277]	; 0x115
 80102ea:	f886 4116 	strb.w	r4, [r6, #278]	; 0x116
 80102ee:	f886 4117 	strb.w	r4, [r6, #279]	; 0x117
 80102f2:	f886 4118 	strb.w	r4, [r6, #280]	; 0x118
    CEN_SPIhelper.connDev.manID  = 0x0;
 80102f6:	f886 4119 	strb.w	r4, [r6, #281]	; 0x119
 80102fa:	f886 411a 	strb.w	r4, [r6, #282]	; 0x11a
 80102fe:	f886 411b 	strb.w	r4, [r6, #283]	; 0x11b
 8010302:	f886 411c 	strb.w	r4, [r6, #284]	; 0x11c
    CEN_SPIhelper.connDev.prodID = 0x0;
 8010306:	f886 411d 	strb.w	r4, [r6, #285]	; 0x11d
 801030a:	f886 411e 	strb.w	r4, [r6, #286]	; 0x11e
 801030e:	f886 411f 	strb.w	r4, [r6, #287]	; 0x11f
 8010312:	f886 4120 	strb.w	r4, [r6, #288]	; 0x120

    //Radio SPI
    SPI_INIT_HANDLER(SPI1);
 8010316:	f7f7 ffc9 	bl	80082ac <registerIRQ>
 801031a:	42a0      	cmp	r0, r4
 801031c:	9b00      	ldr	r3, [sp, #0]
 801031e:	da1b      	bge.n	8010358 <hwBoardInit+0x730>
 8010320:	e7fe      	b.n	8010320 <hwBoardInit+0x6f8>
 8010322:	bf00      	nop
 8010324:	40020000 	.word	0x40020000
 8010328:	40004400 	.word	0x40004400
 801032c:	0800f601 	.word	0x0800f601
 8010330:	e000e100 	.word	0xe000e100
 8010334:	40020c00 	.word	0x40020c00
 8010338:	40004800 	.word	0x40004800
 801033c:	0800f579 	.word	0x0800f579
 8010340:	40020400 	.word	0x40020400
 8010344:	40021000 	.word	0x40021000
 8010348:	10001000 	.word	0x10001000
 801034c:	40020800 	.word	0x40020800
 8010350:	2001add4 	.word	0x2001add4
 8010354:	0800f535 	.word	0x0800f535
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8010358:	4a6c      	ldr	r2, [pc, #432]	; (801050c <hwBoardInit+0x8e4>)
 801035a:	f06f 010f 	mvn.w	r1, #15
 801035e:	f882 1323 	strb.w	r1, [r2, #803]	; 0x323
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8010362:	2108      	movs	r1, #8
 8010364:	6051      	str	r1, [r2, #4]
    SPI_INIT_MODULE(radioModule[0].spi,
 8010366:	2230      	movs	r2, #48	; 0x30
 8010368:	705a      	strb	r2, [r3, #1]
 801036a:	f06f 027f 	mvn.w	r2, #127	; 0x7f
 801036e:	709d      	strb	r5, [r3, #2]
 8010370:	739a      	strb	r2, [r3, #14]
 8010372:	701c      	strb	r4, [r3, #0]
 8010374:	f883 b003 	strb.w	fp, [r3, #3]
 8010378:	741c      	strb	r4, [r3, #16]
 801037a:	745c      	strb	r4, [r3, #17]
 801037c:	f883 8012 	strb.w	r8, [r3, #18]
 8010380:	f883 b013 	strb.w	fp, [r3, #19]
 8010384:	f883 b014 	strb.w	fp, [r3, #20]
 8010388:	755c      	strb	r4, [r3, #21]
 801038a:	729c      	strb	r4, [r3, #10]
 801038c:	72dc      	strb	r4, [r3, #11]
 801038e:	f883 800c 	strb.w	r8, [r3, #12]
 8010392:	f883 b00d 	strb.w	fp, [r3, #13]
 8010396:	73dc      	strb	r4, [r3, #15]
 8010398:	4629      	mov	r1, r5
 801039a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 801039e:	f000 ff51 	bl	8011244 <RCC_APB2PeriphClockCmd>
 80103a2:	4629      	mov	r1, r5
 80103a4:	4628      	mov	r0, r5
 80103a6:	f000 ff05 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80103aa:	4629      	mov	r1, r5
 80103ac:	4628      	mov	r0, r5
 80103ae:	f000 ff01 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80103b2:	4629      	mov	r1, r5
 80103b4:	4628      	mov	r0, r5
 80103b6:	f000 fefd 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80103ba:	2205      	movs	r2, #5
 80103bc:	2106      	movs	r1, #6
 80103be:	4854      	ldr	r0, [pc, #336]	; (8010510 <hwBoardInit+0x8e8>)
 80103c0:	f000 fe5a 	bl	8011078 <GPIO_PinAFConfig>
 80103c4:	2205      	movs	r2, #5
 80103c6:	2107      	movs	r1, #7
 80103c8:	4851      	ldr	r0, [pc, #324]	; (8010510 <hwBoardInit+0x8e8>)
 80103ca:	f000 fe55 	bl	8011078 <GPIO_PinAFConfig>
 80103ce:	2205      	movs	r2, #5
 80103d0:	4611      	mov	r1, r2
 80103d2:	484f      	ldr	r0, [pc, #316]	; (8010510 <hwBoardInit+0x8e8>)
 80103d4:	f000 fe50 	bl	8011078 <GPIO_PinAFConfig>
 80103d8:	2620      	movs	r6, #32
 80103da:	4651      	mov	r1, sl
 80103dc:	484c      	ldr	r0, [pc, #304]	; (8010510 <hwBoardInit+0x8e8>)
 80103de:	f88d 8019 	strb.w	r8, [sp, #25]
 80103e2:	f88d 401a 	strb.w	r4, [sp, #26]
 80103e6:	f88d 8018 	strb.w	r8, [sp, #24]
 80103ea:	f88d 801b 	strb.w	r8, [sp, #27]
 80103ee:	9605      	str	r6, [sp, #20]
 80103f0:	f000 fcc8 	bl	8010d84 <GPIO_Init>
 80103f4:	4651      	mov	r1, sl
 80103f6:	4846      	ldr	r0, [pc, #280]	; (8010510 <hwBoardInit+0x8e8>)
 80103f8:	f8cd b014 	str.w	fp, [sp, #20]
 80103fc:	f000 fcc2 	bl	8010d84 <GPIO_Init>
 8010400:	2380      	movs	r3, #128	; 0x80
 8010402:	4651      	mov	r1, sl
 8010404:	4842      	ldr	r0, [pc, #264]	; (8010510 <hwBoardInit+0x8e8>)
 8010406:	9305      	str	r3, [sp, #20]
 8010408:	f000 fcbc 	bl	8010d84 <GPIO_Init>
 801040c:	4841      	ldr	r0, [pc, #260]	; (8010514 <hwBoardInit+0x8ec>)
 801040e:	f001 fa93 	bl	8011938 <SPI_I2S_DeInit>
 8010412:	f44f 7300 	mov.w	r3, #512	; 0x200
 8010416:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
 801041a:	2307      	movs	r3, #7
 801041c:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
 8010420:	4639      	mov	r1, r7
 8010422:	f44f 7382 	mov.w	r3, #260	; 0x104
 8010426:	483b      	ldr	r0, [pc, #236]	; (8010514 <hwBoardInit+0x8ec>)
 8010428:	f8ad 301e 	strh.w	r3, [sp, #30]
 801042c:	f8ad 401c 	strh.w	r4, [sp, #28]
 8010430:	f8ad 4020 	strh.w	r4, [sp, #32]
 8010434:	f8ad 4022 	strh.w	r4, [sp, #34]	; 0x22
 8010438:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
 801043c:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
 8010440:	f8ad 402a 	strh.w	r4, [sp, #42]	; 0x2a
 8010444:	f001 fad4 	bl	80119f0 <SPI_Init>
 8010448:	4628      	mov	r0, r5
 801044a:	464a      	mov	r2, r9
 801044c:	4621      	mov	r1, r4
 801044e:	f7fa fc83 	bl	800ad58 <xQueueGenericCreate>
 8010452:	4d31      	ldr	r5, [pc, #196]	; (8010518 <hwBoardInit+0x8f0>)
 8010454:	61a8      	str	r0, [r5, #24]
 8010456:	b120      	cbz	r0, 8010462 <hwBoardInit+0x83a>
 8010458:	4623      	mov	r3, r4
 801045a:	4622      	mov	r2, r4
 801045c:	4621      	mov	r1, r4
 801045e:	f7fa fca0 	bl	800ada2 <xQueueGenericSend>
 8010462:	69ab      	ldr	r3, [r5, #24]
 8010464:	b14b      	cbz	r3, 801047a <hwBoardInit+0x852>
 8010466:	2300      	movs	r3, #0
 8010468:	f04f 32ff 	mov.w	r2, #4294967295
 801046c:	4619      	mov	r1, r3
 801046e:	69a8      	ldr	r0, [r5, #24]
 8010470:	f7fa fd9a 	bl	800afa8 <xQueueGenericReceive>
 8010474:	2801      	cmp	r0, #1
 8010476:	d10d      	bne.n	8010494 <hwBoardInit+0x86c>
 8010478:	e018      	b.n	80104ac <hwBoardInit+0x884>
 801047a:	4b28      	ldr	r3, [pc, #160]	; (801051c <hwBoardInit+0x8f4>)
 801047c:	4928      	ldr	r1, [pc, #160]	; (8010520 <hwBoardInit+0x8f8>)
 801047e:	4829      	ldr	r0, [pc, #164]	; (8010524 <hwBoardInit+0x8fc>)
 8010480:	f240 121b 	movw	r2, #283	; 0x11b
 8010484:	f7f8 f96e 	bl	8008764 <xprintf>
 8010488:	2301      	movs	r3, #1
 801048a:	9303      	str	r3, [sp, #12]
 801048c:	9b03      	ldr	r3, [sp, #12]
 801048e:	2b00      	cmp	r3, #0
 8010490:	d1fc      	bne.n	801048c <hwBoardInit+0x864>
 8010492:	e7e8      	b.n	8010466 <hwBoardInit+0x83e>
 8010494:	4b24      	ldr	r3, [pc, #144]	; (8010528 <hwBoardInit+0x900>)
 8010496:	4922      	ldr	r1, [pc, #136]	; (8010520 <hwBoardInit+0x8f8>)
 8010498:	4822      	ldr	r0, [pc, #136]	; (8010524 <hwBoardInit+0x8fc>)
 801049a:	f240 121b 	movw	r2, #283	; 0x11b
 801049e:	f7f8 f961 	bl	8008764 <xprintf>
 80104a2:	2301      	movs	r3, #1
 80104a4:	9304      	str	r3, [sp, #16]
 80104a6:	9b04      	ldr	r3, [sp, #16]
 80104a8:	2b00      	cmp	r3, #0
 80104aa:	d1fc      	bne.n	80104a6 <hwBoardInit+0x87e>
                    SPI1, 2,
                    A, 5,
                    A, 6,
                    A, 7,
                    8, 32);
    if(!(cfg.proto&0x1))
 80104ac:	4c1f      	ldr	r4, [pc, #124]	; (801052c <hwBoardInit+0x904>)
    CEN_SPIhelper.connDev.manID  = 0x0;
    CEN_SPIhelper.connDev.prodID = 0x0;

    //Radio SPI
    SPI_INIT_HANDLER(SPI1);
    SPI_INIT_MODULE(radioModule[0].spi,
 80104ae:	4819      	ldr	r0, [pc, #100]	; (8010514 <hwBoardInit+0x8ec>)
 80104b0:	2101      	movs	r1, #1
 80104b2:	f001 fb37 	bl	8011b24 <SPI_Cmd>
                    SPI1, 2,
                    A, 5,
                    A, 6,
                    A, 7,
                    8, 32);
    if(!(cfg.proto&0x1))
 80104b6:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
 80104b8:	4b1d      	ldr	r3, [pc, #116]	; (8010530 <hwBoardInit+0x908>)
 80104ba:	f016 0601 	ands.w	r6, r6, #1
 80104be:	d139      	bne.n	8010534 <hwBoardInit+0x90c>
      {
        SPI_CS_INIT_MODULE(radioModule[0].spi, A, 15);
 80104c0:	2240      	movs	r2, #64	; 0x40
 80104c2:	71da      	strb	r2, [r3, #7]
 80104c4:	2101      	movs	r1, #1
 80104c6:	f06f 027f 	mvn.w	r2, #127	; 0x7f
 80104ca:	f04f 0902 	mov.w	r9, #2
 80104ce:	711e      	strb	r6, [r3, #4]
 80104d0:	715e      	strb	r6, [r3, #5]
 80104d2:	721e      	strb	r6, [r3, #8]
 80104d4:	725a      	strb	r2, [r3, #9]
 80104d6:	4608      	mov	r0, r1
 80104d8:	f883 9006 	strb.w	r9, [r3, #6]
 80104dc:	f000 fe6a 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 80104e0:	f04f 0801 	mov.w	r8, #1
 80104e4:	f88d 6022 	strb.w	r6, [sp, #34]	; 0x22
 80104e8:	4639      	mov	r1, r7
 80104ea:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 80104ee:	4808      	ldr	r0, [pc, #32]	; (8010510 <hwBoardInit+0x8e8>)
 80104f0:	f88d 8020 	strb.w	r8, [sp, #32]
 80104f4:	f88d 9021 	strb.w	r9, [sp, #33]	; 0x21
 80104f8:	f88d 8023 	strb.w	r8, [sp, #35]	; 0x23
 80104fc:	9607      	str	r6, [sp, #28]
 80104fe:	f000 fc41 	bl	8010d84 <GPIO_Init>
 8010502:	4642      	mov	r2, r8
 8010504:	4631      	mov	r1, r6
 8010506:	4802      	ldr	r0, [pc, #8]	; (8010510 <hwBoardInit+0x8e8>)
 8010508:	e037      	b.n	801057a <hwBoardInit+0x952>
 801050a:	bf00      	nop
 801050c:	e000e100 	.word	0xe000e100
 8010510:	40020000 	.word	0x40020000
 8010514:	40013000 	.word	0x40013000
 8010518:	2001aa84 	.word	0x2001aa84
 801051c:	0801e148 	.word	0x0801e148
 8010520:	0801df53 	.word	0x0801df53
 8010524:	080148f4 	.word	0x080148f4
 8010528:	0801e1b4 	.word	0x0801e1b4
 801052c:	10001000 	.word	0x10001000
 8010530:	2001add4 	.word	0x2001add4
      }
    else
      {
        SPI_CS_INIT_MODULE(radioModule[0].spi, C, 1);
 8010534:	2208      	movs	r2, #8
 8010536:	2602      	movs	r6, #2
 8010538:	f04f 0900 	mov.w	r9, #0
 801053c:	715a      	strb	r2, [r3, #5]
 801053e:	2240      	movs	r2, #64	; 0x40
 8010540:	71da      	strb	r2, [r3, #7]
 8010542:	f883 9004 	strb.w	r9, [r3, #4]
 8010546:	719e      	strb	r6, [r3, #6]
 8010548:	721e      	strb	r6, [r3, #8]
 801054a:	f883 9009 	strb.w	r9, [r3, #9]
 801054e:	2101      	movs	r1, #1
 8010550:	2004      	movs	r0, #4
 8010552:	f000 fe2f 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010556:	f04f 0801 	mov.w	r8, #1
 801055a:	4639      	mov	r1, r7
 801055c:	48bc      	ldr	r0, [pc, #752]	; (8010850 <hwBoardInit+0xc28>)
 801055e:	f88d 8020 	strb.w	r8, [sp, #32]
 8010562:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
 8010566:	f88d 9022 	strb.w	r9, [sp, #34]	; 0x22
 801056a:	f88d 8023 	strb.w	r8, [sp, #35]	; 0x23
 801056e:	9607      	str	r6, [sp, #28]
 8010570:	f000 fc08 	bl	8010d84 <GPIO_Init>
 8010574:	48b6      	ldr	r0, [pc, #728]	; (8010850 <hwBoardInit+0xc28>)
 8010576:	4642      	mov	r2, r8
 8010578:	4631      	mov	r1, r6
 801057a:	f000 fd0b 	bl	8010f94 <GPIO_WriteBit>
      }

    SETUP_EXTI(B, 4, EXTI4_IRQn, radioIntIRQ);
 801057e:	2101      	movs	r1, #1
 8010580:	2002      	movs	r0, #2
 8010582:	f000 fe17 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 8010586:	2101      	movs	r1, #1
 8010588:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 801058c:	f000 fe5a 	bl	8011244 <RCC_APB2PeriphClockCmd>
 8010590:	2601      	movs	r6, #1
 8010592:	f04f 0800 	mov.w	r8, #0
 8010596:	f04f 0910 	mov.w	r9, #16
 801059a:	4651      	mov	r1, sl
 801059c:	48ad      	ldr	r0, [pc, #692]	; (8010854 <hwBoardInit+0xc2c>)
 801059e:	f88d 8018 	strb.w	r8, [sp, #24]
 80105a2:	f88d 601b 	strb.w	r6, [sp, #27]
 80105a6:	f8cd 9014 	str.w	r9, [sp, #20]
 80105aa:	f000 fbeb 	bl	8010d84 <GPIO_Init>
 80105ae:	2104      	movs	r1, #4
 80105b0:	4630      	mov	r0, r6
 80105b2:	f001 fd3b 	bl	801202c <SYSCFG_EXTILineConfig>
 80105b6:	230c      	movs	r3, #12
 80105b8:	4638      	mov	r0, r7
 80105ba:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
 80105be:	f8cd 901c 	str.w	r9, [sp, #28]
 80105c2:	f88d 8020 	strb.w	r8, [sp, #32]
 80105c6:	f88d 6022 	strb.w	r6, [sp, #34]	; 0x22
 80105ca:	f001 fc65 	bl	8011e98 <EXTI_Init>
 80105ce:	49a2      	ldr	r1, [pc, #648]	; (8010858 <hwBoardInit+0xc30>)
 80105d0:	200a      	movs	r0, #10
 80105d2:	f7f7 fe6b 	bl	80082ac <registerIRQ>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 80105d6:	4ba1      	ldr	r3, [pc, #644]	; (801085c <hwBoardInit+0xc34>)
  }

  portData[CEN_PORT].kond_pom = cfg.kondPom;
  portData[CEN_PORT].urzadzenie = URZADZENIE;

  i2cInit(I2C1);
 80105d8:	48a1      	ldr	r0, [pc, #644]	; (8010860 <hwBoardInit+0xc38>)
 80105da:	22f0      	movs	r2, #240	; 0xf0
 80105dc:	f883 230a 	strb.w	r2, [r3, #778]	; 0x30a
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 80105e0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80105e4:	601a      	str	r2, [r3, #0]
      }

    SETUP_EXTI(B, 4, EXTI4_IRQn, radioIntIRQ);
  }

  portData[CEN_PORT].kond_pom = cfg.kondPom;
 80105e6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80105e8:	f885 3051 	strb.w	r3, [r5, #81]	; 0x51
  portData[CEN_PORT].urzadzenie = URZADZENIE;
 80105ec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80105ee:	f013 0f01 	tst.w	r3, #1
 80105f2:	bf14      	ite	ne
 80105f4:	2302      	movne	r3, #2
 80105f6:	4633      	moveq	r3, r6
 80105f8:	f885 3052 	strb.w	r3, [r5, #82]	; 0x52

  i2cInit(I2C1);
 80105fc:	f7fe fc72 	bl	800eee4 <i2cInit>
  i2cInit(I2C2);
 8010600:	4898      	ldr	r0, [pc, #608]	; (8010864 <hwBoardInit+0xc3c>)
 8010602:	f7fe fc6f 	bl	800eee4 <i2cInit>

  if(cfg.flags&FLAGS_POWER_CYCLE_VARI_MASK)
 8010606:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8010608:	061b      	lsls	r3, r3, #24
 801060a:	d51f      	bpl.n	801064c <hwBoardInit+0xa24>
    {
      GPIO_INIT(E, 5, OUT, NOPULL);
 801060c:	2303      	movs	r3, #3
 801060e:	2520      	movs	r5, #32
 8010610:	4631      	mov	r1, r6
 8010612:	4648      	mov	r0, r9
 8010614:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
 8010618:	f88d 6020 	strb.w	r6, [sp, #32]
 801061c:	f88d 8022 	strb.w	r8, [sp, #34]	; 0x22
 8010620:	f88d 8023 	strb.w	r8, [sp, #35]	; 0x23
 8010624:	9507      	str	r5, [sp, #28]
 8010626:	f000 fdc5 	bl	80111b4 <RCC_AHB1PeriphClockCmd>
 801062a:	4639      	mov	r1, r7
 801062c:	488e      	ldr	r0, [pc, #568]	; (8010868 <hwBoardInit+0xc40>)
 801062e:	f000 fba9 	bl	8010d84 <GPIO_Init>
      GPIO_WriteBit(GPIOE, GPIO_Pin_5, 1);
 8010632:	4632      	mov	r2, r6
 8010634:	4629      	mov	r1, r5
 8010636:	488c      	ldr	r0, [pc, #560]	; (8010868 <hwBoardInit+0xc40>)
 8010638:	f000 fcac 	bl	8010f94 <GPIO_WriteBit>
      mdelay(100);
 801063c:	2064      	movs	r0, #100	; 0x64
 801063e:	f7fa f927 	bl	800a890 <vTaskDelay>
      GPIO_WriteBit(GPIOE, GPIO_Pin_5, 0);
 8010642:	4642      	mov	r2, r8
 8010644:	4629      	mov	r1, r5
 8010646:	4888      	ldr	r0, [pc, #544]	; (8010868 <hwBoardInit+0xc40>)
 8010648:	f000 fca4 	bl	8010f94 <GPIO_WriteBit>
    }
  CONFIG_PRINT();
 801064c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801064e:	2b00      	cmp	r3, #0
 8010650:	dd05      	ble.n	801065e <hwBoardInit+0xa36>
 8010652:	4b86      	ldr	r3, [pc, #536]	; (801086c <hwBoardInit+0xc44>)
 8010654:	4986      	ldr	r1, [pc, #536]	; (8010870 <hwBoardInit+0xc48>)
 8010656:	681a      	ldr	r2, [r3, #0]
 8010658:	4886      	ldr	r0, [pc, #536]	; (8010874 <hwBoardInit+0xc4c>)
 801065a:	f7f8 f883 	bl	8008764 <xprintf>
 801065e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010660:	2b00      	cmp	r3, #0
 8010662:	dd05      	ble.n	8010670 <hwBoardInit+0xa48>
 8010664:	4b81      	ldr	r3, [pc, #516]	; (801086c <hwBoardInit+0xc44>)
 8010666:	4984      	ldr	r1, [pc, #528]	; (8010878 <hwBoardInit+0xc50>)
 8010668:	685a      	ldr	r2, [r3, #4]
 801066a:	4882      	ldr	r0, [pc, #520]	; (8010874 <hwBoardInit+0xc4c>)
 801066c:	f7f8 f87a 	bl	8008764 <xprintf>
 8010670:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010672:	2b00      	cmp	r3, #0
 8010674:	dd05      	ble.n	8010682 <hwBoardInit+0xa5a>
 8010676:	4b7d      	ldr	r3, [pc, #500]	; (801086c <hwBoardInit+0xc44>)
 8010678:	4980      	ldr	r1, [pc, #512]	; (801087c <hwBoardInit+0xc54>)
 801067a:	689a      	ldr	r2, [r3, #8]
 801067c:	487d      	ldr	r0, [pc, #500]	; (8010874 <hwBoardInit+0xc4c>)
 801067e:	f7f8 f871 	bl	8008764 <xprintf>
 8010682:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010684:	2b00      	cmp	r3, #0
 8010686:	dd05      	ble.n	8010694 <hwBoardInit+0xa6c>
 8010688:	4b78      	ldr	r3, [pc, #480]	; (801086c <hwBoardInit+0xc44>)
 801068a:	497d      	ldr	r1, [pc, #500]	; (8010880 <hwBoardInit+0xc58>)
 801068c:	68da      	ldr	r2, [r3, #12]
 801068e:	4879      	ldr	r0, [pc, #484]	; (8010874 <hwBoardInit+0xc4c>)
 8010690:	f7f8 f868 	bl	8008764 <xprintf>
 8010694:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010696:	2b00      	cmp	r3, #0
 8010698:	dd05      	ble.n	80106a6 <hwBoardInit+0xa7e>
 801069a:	4b74      	ldr	r3, [pc, #464]	; (801086c <hwBoardInit+0xc44>)
 801069c:	4979      	ldr	r1, [pc, #484]	; (8010884 <hwBoardInit+0xc5c>)
 801069e:	691a      	ldr	r2, [r3, #16]
 80106a0:	4874      	ldr	r0, [pc, #464]	; (8010874 <hwBoardInit+0xc4c>)
 80106a2:	f7f8 f85f 	bl	8008764 <xprintf>
 80106a6:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80106a8:	2b00      	cmp	r3, #0
 80106aa:	dd05      	ble.n	80106b8 <hwBoardInit+0xa90>
 80106ac:	4b6f      	ldr	r3, [pc, #444]	; (801086c <hwBoardInit+0xc44>)
 80106ae:	4976      	ldr	r1, [pc, #472]	; (8010888 <hwBoardInit+0xc60>)
 80106b0:	695a      	ldr	r2, [r3, #20]
 80106b2:	4870      	ldr	r0, [pc, #448]	; (8010874 <hwBoardInit+0xc4c>)
 80106b4:	f7f8 f856 	bl	8008764 <xprintf>
 80106b8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80106ba:	2b00      	cmp	r3, #0
 80106bc:	dd05      	ble.n	80106ca <hwBoardInit+0xaa2>
 80106be:	4b6b      	ldr	r3, [pc, #428]	; (801086c <hwBoardInit+0xc44>)
 80106c0:	4972      	ldr	r1, [pc, #456]	; (801088c <hwBoardInit+0xc64>)
 80106c2:	699a      	ldr	r2, [r3, #24]
 80106c4:	486b      	ldr	r0, [pc, #428]	; (8010874 <hwBoardInit+0xc4c>)
 80106c6:	f7f8 f84d 	bl	8008764 <xprintf>
 80106ca:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80106cc:	2b00      	cmp	r3, #0
 80106ce:	dd05      	ble.n	80106dc <hwBoardInit+0xab4>
 80106d0:	4b66      	ldr	r3, [pc, #408]	; (801086c <hwBoardInit+0xc44>)
 80106d2:	496f      	ldr	r1, [pc, #444]	; (8010890 <hwBoardInit+0xc68>)
 80106d4:	69da      	ldr	r2, [r3, #28]
 80106d6:	4867      	ldr	r0, [pc, #412]	; (8010874 <hwBoardInit+0xc4c>)
 80106d8:	f7f8 f844 	bl	8008764 <xprintf>
 80106dc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80106de:	2b00      	cmp	r3, #0
 80106e0:	dd05      	ble.n	80106ee <hwBoardInit+0xac6>
 80106e2:	4b62      	ldr	r3, [pc, #392]	; (801086c <hwBoardInit+0xc44>)
 80106e4:	496b      	ldr	r1, [pc, #428]	; (8010894 <hwBoardInit+0xc6c>)
 80106e6:	6a1a      	ldr	r2, [r3, #32]
 80106e8:	4862      	ldr	r0, [pc, #392]	; (8010874 <hwBoardInit+0xc4c>)
 80106ea:	f7f8 f83b 	bl	8008764 <xprintf>
 80106ee:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80106f0:	2b00      	cmp	r3, #0
 80106f2:	dd05      	ble.n	8010700 <hwBoardInit+0xad8>
 80106f4:	4b5d      	ldr	r3, [pc, #372]	; (801086c <hwBoardInit+0xc44>)
 80106f6:	4968      	ldr	r1, [pc, #416]	; (8010898 <hwBoardInit+0xc70>)
 80106f8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80106fa:	485e      	ldr	r0, [pc, #376]	; (8010874 <hwBoardInit+0xc4c>)
 80106fc:	f7f8 f832 	bl	8008764 <xprintf>
 8010700:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010702:	2b00      	cmp	r3, #0
 8010704:	dd05      	ble.n	8010712 <hwBoardInit+0xaea>
 8010706:	4b59      	ldr	r3, [pc, #356]	; (801086c <hwBoardInit+0xc44>)
 8010708:	4964      	ldr	r1, [pc, #400]	; (801089c <hwBoardInit+0xc74>)
 801070a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801070c:	4859      	ldr	r0, [pc, #356]	; (8010874 <hwBoardInit+0xc4c>)
 801070e:	f7f8 f829 	bl	8008764 <xprintf>
 8010712:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010714:	2b00      	cmp	r3, #0
 8010716:	dd05      	ble.n	8010724 <hwBoardInit+0xafc>
 8010718:	4b54      	ldr	r3, [pc, #336]	; (801086c <hwBoardInit+0xc44>)
 801071a:	4961      	ldr	r1, [pc, #388]	; (80108a0 <hwBoardInit+0xc78>)
 801071c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801071e:	4855      	ldr	r0, [pc, #340]	; (8010874 <hwBoardInit+0xc4c>)
 8010720:	f7f8 f820 	bl	8008764 <xprintf>
 8010724:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010726:	2b00      	cmp	r3, #0
 8010728:	dd05      	ble.n	8010736 <hwBoardInit+0xb0e>
 801072a:	4b50      	ldr	r3, [pc, #320]	; (801086c <hwBoardInit+0xc44>)
 801072c:	495d      	ldr	r1, [pc, #372]	; (80108a4 <hwBoardInit+0xc7c>)
 801072e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8010730:	4850      	ldr	r0, [pc, #320]	; (8010874 <hwBoardInit+0xc4c>)
 8010732:	f7f8 f817 	bl	8008764 <xprintf>
 8010736:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010738:	2b00      	cmp	r3, #0
 801073a:	dd05      	ble.n	8010748 <hwBoardInit+0xb20>
 801073c:	4b4b      	ldr	r3, [pc, #300]	; (801086c <hwBoardInit+0xc44>)
 801073e:	495a      	ldr	r1, [pc, #360]	; (80108a8 <hwBoardInit+0xc80>)
 8010740:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8010742:	484c      	ldr	r0, [pc, #304]	; (8010874 <hwBoardInit+0xc4c>)
 8010744:	f7f8 f80e 	bl	8008764 <xprintf>
 8010748:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801074a:	2b00      	cmp	r3, #0
 801074c:	dd05      	ble.n	801075a <hwBoardInit+0xb32>
 801074e:	4b47      	ldr	r3, [pc, #284]	; (801086c <hwBoardInit+0xc44>)
 8010750:	4956      	ldr	r1, [pc, #344]	; (80108ac <hwBoardInit+0xc84>)
 8010752:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8010754:	4847      	ldr	r0, [pc, #284]	; (8010874 <hwBoardInit+0xc4c>)
 8010756:	f7f8 f805 	bl	8008764 <xprintf>
 801075a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801075c:	2b00      	cmp	r3, #0
 801075e:	dd05      	ble.n	801076c <hwBoardInit+0xb44>
 8010760:	4b42      	ldr	r3, [pc, #264]	; (801086c <hwBoardInit+0xc44>)
 8010762:	4953      	ldr	r1, [pc, #332]	; (80108b0 <hwBoardInit+0xc88>)
 8010764:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8010766:	4843      	ldr	r0, [pc, #268]	; (8010874 <hwBoardInit+0xc4c>)
 8010768:	f7f7 fffc 	bl	8008764 <xprintf>
 801076c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801076e:	2b00      	cmp	r3, #0
 8010770:	dd05      	ble.n	801077e <hwBoardInit+0xb56>
 8010772:	4b3e      	ldr	r3, [pc, #248]	; (801086c <hwBoardInit+0xc44>)
 8010774:	494f      	ldr	r1, [pc, #316]	; (80108b4 <hwBoardInit+0xc8c>)
 8010776:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8010778:	483e      	ldr	r0, [pc, #248]	; (8010874 <hwBoardInit+0xc4c>)
 801077a:	f7f7 fff3 	bl	8008764 <xprintf>
 801077e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010780:	2b00      	cmp	r3, #0
 8010782:	dd05      	ble.n	8010790 <hwBoardInit+0xb68>
 8010784:	4b39      	ldr	r3, [pc, #228]	; (801086c <hwBoardInit+0xc44>)
 8010786:	494c      	ldr	r1, [pc, #304]	; (80108b8 <hwBoardInit+0xc90>)
 8010788:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801078a:	483a      	ldr	r0, [pc, #232]	; (8010874 <hwBoardInit+0xc4c>)
 801078c:	f7f7 ffea 	bl	8008764 <xprintf>
 8010790:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010792:	2b00      	cmp	r3, #0
 8010794:	dd05      	ble.n	80107a2 <hwBoardInit+0xb7a>
 8010796:	4b35      	ldr	r3, [pc, #212]	; (801086c <hwBoardInit+0xc44>)
 8010798:	4948      	ldr	r1, [pc, #288]	; (80108bc <hwBoardInit+0xc94>)
 801079a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 801079c:	4835      	ldr	r0, [pc, #212]	; (8010874 <hwBoardInit+0xc4c>)
 801079e:	f7f7 ffe1 	bl	8008764 <xprintf>
 80107a2:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80107a4:	2b00      	cmp	r3, #0
 80107a6:	dd05      	ble.n	80107b4 <hwBoardInit+0xb8c>
 80107a8:	4b30      	ldr	r3, [pc, #192]	; (801086c <hwBoardInit+0xc44>)
 80107aa:	4945      	ldr	r1, [pc, #276]	; (80108c0 <hwBoardInit+0xc98>)
 80107ac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80107ae:	4831      	ldr	r0, [pc, #196]	; (8010874 <hwBoardInit+0xc4c>)
 80107b0:	f7f7 ffd8 	bl	8008764 <xprintf>
 80107b4:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80107b6:	2b00      	cmp	r3, #0
 80107b8:	dd05      	ble.n	80107c6 <hwBoardInit+0xb9e>
 80107ba:	4b2c      	ldr	r3, [pc, #176]	; (801086c <hwBoardInit+0xc44>)
 80107bc:	4941      	ldr	r1, [pc, #260]	; (80108c4 <hwBoardInit+0xc9c>)
 80107be:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80107c0:	482c      	ldr	r0, [pc, #176]	; (8010874 <hwBoardInit+0xc4c>)
 80107c2:	f7f7 ffcf 	bl	8008764 <xprintf>
 80107c6:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80107c8:	2b00      	cmp	r3, #0
 80107ca:	dd05      	ble.n	80107d8 <hwBoardInit+0xbb0>
 80107cc:	4b27      	ldr	r3, [pc, #156]	; (801086c <hwBoardInit+0xc44>)
 80107ce:	493e      	ldr	r1, [pc, #248]	; (80108c8 <hwBoardInit+0xca0>)
 80107d0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80107d2:	4828      	ldr	r0, [pc, #160]	; (8010874 <hwBoardInit+0xc4c>)
 80107d4:	f7f7 ffc6 	bl	8008764 <xprintf>
 80107d8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80107da:	2b00      	cmp	r3, #0
 80107dc:	dd05      	ble.n	80107ea <hwBoardInit+0xbc2>
 80107de:	4b23      	ldr	r3, [pc, #140]	; (801086c <hwBoardInit+0xc44>)
 80107e0:	493a      	ldr	r1, [pc, #232]	; (80108cc <hwBoardInit+0xca4>)
 80107e2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80107e4:	4823      	ldr	r0, [pc, #140]	; (8010874 <hwBoardInit+0xc4c>)
 80107e6:	f7f7 ffbd 	bl	8008764 <xprintf>
 80107ea:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80107ec:	2b00      	cmp	r3, #0
 80107ee:	dd05      	ble.n	80107fc <hwBoardInit+0xbd4>
 80107f0:	4b1e      	ldr	r3, [pc, #120]	; (801086c <hwBoardInit+0xc44>)
 80107f2:	4937      	ldr	r1, [pc, #220]	; (80108d0 <hwBoardInit+0xca8>)
 80107f4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80107f6:	481f      	ldr	r0, [pc, #124]	; (8010874 <hwBoardInit+0xc4c>)
 80107f8:	f7f7 ffb4 	bl	8008764 <xprintf>
 80107fc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80107fe:	2b00      	cmp	r3, #0
 8010800:	dd05      	ble.n	801080e <hwBoardInit+0xbe6>
 8010802:	4b1a      	ldr	r3, [pc, #104]	; (801086c <hwBoardInit+0xc44>)
 8010804:	4933      	ldr	r1, [pc, #204]	; (80108d4 <hwBoardInit+0xcac>)
 8010806:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8010808:	481a      	ldr	r0, [pc, #104]	; (8010874 <hwBoardInit+0xc4c>)
 801080a:	f7f7 ffab 	bl	8008764 <xprintf>
 801080e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010810:	2b00      	cmp	r3, #0
 8010812:	dd05      	ble.n	8010820 <hwBoardInit+0xbf8>
 8010814:	4b15      	ldr	r3, [pc, #84]	; (801086c <hwBoardInit+0xc44>)
 8010816:	4930      	ldr	r1, [pc, #192]	; (80108d8 <hwBoardInit+0xcb0>)
 8010818:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 801081a:	4816      	ldr	r0, [pc, #88]	; (8010874 <hwBoardInit+0xc4c>)
 801081c:	f7f7 ffa2 	bl	8008764 <xprintf>
 8010820:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010822:	2b00      	cmp	r3, #0
 8010824:	dd05      	ble.n	8010832 <hwBoardInit+0xc0a>
 8010826:	4b11      	ldr	r3, [pc, #68]	; (801086c <hwBoardInit+0xc44>)
 8010828:	492c      	ldr	r1, [pc, #176]	; (80108dc <hwBoardInit+0xcb4>)
 801082a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 801082c:	4811      	ldr	r0, [pc, #68]	; (8010874 <hwBoardInit+0xc4c>)
 801082e:	f7f7 ff99 	bl	8008764 <xprintf>
 8010832:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010834:	2b00      	cmp	r3, #0
 8010836:	dd05      	ble.n	8010844 <hwBoardInit+0xc1c>
 8010838:	4b0c      	ldr	r3, [pc, #48]	; (801086c <hwBoardInit+0xc44>)
 801083a:	4929      	ldr	r1, [pc, #164]	; (80108e0 <hwBoardInit+0xcb8>)
 801083c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 801083e:	480d      	ldr	r0, [pc, #52]	; (8010874 <hwBoardInit+0xc4c>)
 8010840:	f7f7 ff90 	bl	8008764 <xprintf>
 8010844:	4c09      	ldr	r4, [pc, #36]	; (801086c <hwBoardInit+0xc44>)
 8010846:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010848:	2b00      	cmp	r3, #0
 801084a:	dd50      	ble.n	80108ee <hwBoardInit+0xcc6>
 801084c:	e04a      	b.n	80108e4 <hwBoardInit+0xcbc>
 801084e:	bf00      	nop
 8010850:	40020800 	.word	0x40020800
 8010854:	40020400 	.word	0x40020400
 8010858:	0800f709 	.word	0x0800f709
 801085c:	e000e100 	.word	0xe000e100
 8010860:	40005400 	.word	0x40005400
 8010864:	40005800 	.word	0x40005800
 8010868:	40021000 	.word	0x40021000
 801086c:	10001000 	.word	0x10001000
 8010870:	0801e242 	.word	0x0801e242
 8010874:	0801e248 	.word	0x0801e248
 8010878:	0801e258 	.word	0x0801e258
 801087c:	0801e25d 	.word	0x0801e25d
 8010880:	0801e263 	.word	0x0801e263
 8010884:	0801e26a 	.word	0x0801e26a
 8010888:	0801e272 	.word	0x0801e272
 801088c:	0801e281 	.word	0x0801e281
 8010890:	0801e28f 	.word	0x0801e28f
 8010894:	0801e29e 	.word	0x0801e29e
 8010898:	0801e2a8 	.word	0x0801e2a8
 801089c:	0801e2b3 	.word	0x0801e2b3
 80108a0:	0801e2c6 	.word	0x0801e2c6
 80108a4:	0801e2d1 	.word	0x0801e2d1
 80108a8:	0801e2d7 	.word	0x0801e2d7
 80108ac:	0801e2df 	.word	0x0801e2df
 80108b0:	0801e2e5 	.word	0x0801e2e5
 80108b4:	0801e2ee 	.word	0x0801e2ee
 80108b8:	0801e2f8 	.word	0x0801e2f8
 80108bc:	0801e2fe 	.word	0x0801e2fe
 80108c0:	0801e307 	.word	0x0801e307
 80108c4:	0801e30d 	.word	0x0801e30d
 80108c8:	0801e314 	.word	0x0801e314
 80108cc:	0801e322 	.word	0x0801e322
 80108d0:	0801e334 	.word	0x0801e334
 80108d4:	0801e33e 	.word	0x0801e33e
 80108d8:	0801e348 	.word	0x0801e348
 80108dc:	0801e357 	.word	0x0801e357
 80108e0:	0801e366 	.word	0x0801e366
 80108e4:	6f22      	ldr	r2, [r4, #112]	; 0x70
 80108e6:	4993      	ldr	r1, [pc, #588]	; (8010b34 <hwBoardInit+0xf0c>)
 80108e8:	4893      	ldr	r0, [pc, #588]	; (8010b38 <hwBoardInit+0xf10>)
 80108ea:	f7f7 ff3b 	bl	8008764 <xprintf>
 80108ee:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80108f0:	2b00      	cmp	r3, #0
 80108f2:	dd05      	ble.n	8010900 <hwBoardInit+0xcd8>
 80108f4:	4b91      	ldr	r3, [pc, #580]	; (8010b3c <hwBoardInit+0xf14>)
 80108f6:	4992      	ldr	r1, [pc, #584]	; (8010b40 <hwBoardInit+0xf18>)
 80108f8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80108fa:	488f      	ldr	r0, [pc, #572]	; (8010b38 <hwBoardInit+0xf10>)
 80108fc:	f7f7 ff32 	bl	8008764 <xprintf>
 8010900:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010902:	2b00      	cmp	r3, #0
 8010904:	dd05      	ble.n	8010912 <hwBoardInit+0xcea>
 8010906:	4b8d      	ldr	r3, [pc, #564]	; (8010b3c <hwBoardInit+0xf14>)
 8010908:	498e      	ldr	r1, [pc, #568]	; (8010b44 <hwBoardInit+0xf1c>)
 801090a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 801090c:	488a      	ldr	r0, [pc, #552]	; (8010b38 <hwBoardInit+0xf10>)
 801090e:	f7f7 ff29 	bl	8008764 <xprintf>
 8010912:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010914:	2b00      	cmp	r3, #0
 8010916:	dd05      	ble.n	8010924 <hwBoardInit+0xcfc>
 8010918:	4b88      	ldr	r3, [pc, #544]	; (8010b3c <hwBoardInit+0xf14>)
 801091a:	498b      	ldr	r1, [pc, #556]	; (8010b48 <hwBoardInit+0xf20>)
 801091c:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 801091e:	4886      	ldr	r0, [pc, #536]	; (8010b38 <hwBoardInit+0xf10>)
 8010920:	f7f7 ff20 	bl	8008764 <xprintf>
 8010924:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010926:	2b00      	cmp	r3, #0
 8010928:	dd06      	ble.n	8010938 <hwBoardInit+0xd10>
 801092a:	4b84      	ldr	r3, [pc, #528]	; (8010b3c <hwBoardInit+0xf14>)
 801092c:	4987      	ldr	r1, [pc, #540]	; (8010b4c <hwBoardInit+0xf24>)
 801092e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8010932:	4881      	ldr	r0, [pc, #516]	; (8010b38 <hwBoardInit+0xf10>)
 8010934:	f7f7 ff16 	bl	8008764 <xprintf>
 8010938:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801093a:	2b00      	cmp	r3, #0
 801093c:	dd06      	ble.n	801094c <hwBoardInit+0xd24>
 801093e:	4b7f      	ldr	r3, [pc, #508]	; (8010b3c <hwBoardInit+0xf14>)
 8010940:	4983      	ldr	r1, [pc, #524]	; (8010b50 <hwBoardInit+0xf28>)
 8010942:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8010946:	487c      	ldr	r0, [pc, #496]	; (8010b38 <hwBoardInit+0xf10>)
 8010948:	f7f7 ff0c 	bl	8008764 <xprintf>
 801094c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801094e:	2b00      	cmp	r3, #0
 8010950:	dd06      	ble.n	8010960 <hwBoardInit+0xd38>
 8010952:	4b7a      	ldr	r3, [pc, #488]	; (8010b3c <hwBoardInit+0xf14>)
 8010954:	497f      	ldr	r1, [pc, #508]	; (8010b54 <hwBoardInit+0xf2c>)
 8010956:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801095a:	4877      	ldr	r0, [pc, #476]	; (8010b38 <hwBoardInit+0xf10>)
 801095c:	f7f7 ff02 	bl	8008764 <xprintf>
 8010960:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010962:	2b00      	cmp	r3, #0
 8010964:	dd06      	ble.n	8010974 <hwBoardInit+0xd4c>
 8010966:	4b75      	ldr	r3, [pc, #468]	; (8010b3c <hwBoardInit+0xf14>)
 8010968:	497b      	ldr	r1, [pc, #492]	; (8010b58 <hwBoardInit+0xf30>)
 801096a:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 801096e:	4872      	ldr	r0, [pc, #456]	; (8010b38 <hwBoardInit+0xf10>)
 8010970:	f7f7 fef8 	bl	8008764 <xprintf>
 8010974:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010976:	2b00      	cmp	r3, #0
 8010978:	dd06      	ble.n	8010988 <hwBoardInit+0xd60>
 801097a:	4b70      	ldr	r3, [pc, #448]	; (8010b3c <hwBoardInit+0xf14>)
 801097c:	4977      	ldr	r1, [pc, #476]	; (8010b5c <hwBoardInit+0xf34>)
 801097e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8010982:	486d      	ldr	r0, [pc, #436]	; (8010b38 <hwBoardInit+0xf10>)
 8010984:	f7f7 feee 	bl	8008764 <xprintf>
 8010988:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801098a:	2b00      	cmp	r3, #0
 801098c:	dd06      	ble.n	801099c <hwBoardInit+0xd74>
 801098e:	4b6b      	ldr	r3, [pc, #428]	; (8010b3c <hwBoardInit+0xf14>)
 8010990:	4973      	ldr	r1, [pc, #460]	; (8010b60 <hwBoardInit+0xf38>)
 8010992:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8010996:	4868      	ldr	r0, [pc, #416]	; (8010b38 <hwBoardInit+0xf10>)
 8010998:	f7f7 fee4 	bl	8008764 <xprintf>
 801099c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 801099e:	2b00      	cmp	r3, #0
 80109a0:	dd06      	ble.n	80109b0 <hwBoardInit+0xd88>
 80109a2:	4b66      	ldr	r3, [pc, #408]	; (8010b3c <hwBoardInit+0xf14>)
 80109a4:	496f      	ldr	r1, [pc, #444]	; (8010b64 <hwBoardInit+0xf3c>)
 80109a6:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80109aa:	4863      	ldr	r0, [pc, #396]	; (8010b38 <hwBoardInit+0xf10>)
 80109ac:	f7f7 feda 	bl	8008764 <xprintf>
 80109b0:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80109b2:	2b00      	cmp	r3, #0
 80109b4:	dd06      	ble.n	80109c4 <hwBoardInit+0xd9c>
 80109b6:	4b61      	ldr	r3, [pc, #388]	; (8010b3c <hwBoardInit+0xf14>)
 80109b8:	496b      	ldr	r1, [pc, #428]	; (8010b68 <hwBoardInit+0xf40>)
 80109ba:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80109be:	485e      	ldr	r0, [pc, #376]	; (8010b38 <hwBoardInit+0xf10>)
 80109c0:	f7f7 fed0 	bl	8008764 <xprintf>
 80109c4:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80109c6:	2b00      	cmp	r3, #0
 80109c8:	dd06      	ble.n	80109d8 <hwBoardInit+0xdb0>
 80109ca:	4b5c      	ldr	r3, [pc, #368]	; (8010b3c <hwBoardInit+0xf14>)
 80109cc:	4967      	ldr	r1, [pc, #412]	; (8010b6c <hwBoardInit+0xf44>)
 80109ce:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 80109d2:	4859      	ldr	r0, [pc, #356]	; (8010b38 <hwBoardInit+0xf10>)
 80109d4:	f7f7 fec6 	bl	8008764 <xprintf>
 80109d8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80109da:	2b00      	cmp	r3, #0
 80109dc:	dd06      	ble.n	80109ec <hwBoardInit+0xdc4>
 80109de:	4b57      	ldr	r3, [pc, #348]	; (8010b3c <hwBoardInit+0xf14>)
 80109e0:	4963      	ldr	r1, [pc, #396]	; (8010b70 <hwBoardInit+0xf48>)
 80109e2:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 80109e6:	4854      	ldr	r0, [pc, #336]	; (8010b38 <hwBoardInit+0xf10>)
 80109e8:	f7f7 febc 	bl	8008764 <xprintf>
 80109ec:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80109ee:	2b00      	cmp	r3, #0
 80109f0:	dd06      	ble.n	8010a00 <hwBoardInit+0xdd8>
 80109f2:	4b52      	ldr	r3, [pc, #328]	; (8010b3c <hwBoardInit+0xf14>)
 80109f4:	495f      	ldr	r1, [pc, #380]	; (8010b74 <hwBoardInit+0xf4c>)
 80109f6:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 80109fa:	484f      	ldr	r0, [pc, #316]	; (8010b38 <hwBoardInit+0xf10>)
 80109fc:	f7f7 feb2 	bl	8008764 <xprintf>
 8010a00:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a02:	2b00      	cmp	r3, #0
 8010a04:	dd06      	ble.n	8010a14 <hwBoardInit+0xdec>
 8010a06:	4b4d      	ldr	r3, [pc, #308]	; (8010b3c <hwBoardInit+0xf14>)
 8010a08:	495b      	ldr	r1, [pc, #364]	; (8010b78 <hwBoardInit+0xf50>)
 8010a0a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8010a0e:	484a      	ldr	r0, [pc, #296]	; (8010b38 <hwBoardInit+0xf10>)
 8010a10:	f7f7 fea8 	bl	8008764 <xprintf>
 8010a14:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a16:	2b00      	cmp	r3, #0
 8010a18:	dd06      	ble.n	8010a28 <hwBoardInit+0xe00>
 8010a1a:	4b48      	ldr	r3, [pc, #288]	; (8010b3c <hwBoardInit+0xf14>)
 8010a1c:	4957      	ldr	r1, [pc, #348]	; (8010b7c <hwBoardInit+0xf54>)
 8010a1e:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 8010a22:	4845      	ldr	r0, [pc, #276]	; (8010b38 <hwBoardInit+0xf10>)
 8010a24:	f7f7 fe9e 	bl	8008764 <xprintf>
 8010a28:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a2a:	2b00      	cmp	r3, #0
 8010a2c:	dd06      	ble.n	8010a3c <hwBoardInit+0xe14>
 8010a2e:	4b43      	ldr	r3, [pc, #268]	; (8010b3c <hwBoardInit+0xf14>)
 8010a30:	4953      	ldr	r1, [pc, #332]	; (8010b80 <hwBoardInit+0xf58>)
 8010a32:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8010a36:	4840      	ldr	r0, [pc, #256]	; (8010b38 <hwBoardInit+0xf10>)
 8010a38:	f7f7 fe94 	bl	8008764 <xprintf>
 8010a3c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a3e:	2b00      	cmp	r3, #0
 8010a40:	dd06      	ble.n	8010a50 <hwBoardInit+0xe28>
 8010a42:	4b3e      	ldr	r3, [pc, #248]	; (8010b3c <hwBoardInit+0xf14>)
 8010a44:	494f      	ldr	r1, [pc, #316]	; (8010b84 <hwBoardInit+0xf5c>)
 8010a46:	f8d3 20b8 	ldr.w	r2, [r3, #184]	; 0xb8
 8010a4a:	483b      	ldr	r0, [pc, #236]	; (8010b38 <hwBoardInit+0xf10>)
 8010a4c:	f7f7 fe8a 	bl	8008764 <xprintf>
 8010a50:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a52:	2b00      	cmp	r3, #0
 8010a54:	dd06      	ble.n	8010a64 <hwBoardInit+0xe3c>
 8010a56:	4b39      	ldr	r3, [pc, #228]	; (8010b3c <hwBoardInit+0xf14>)
 8010a58:	494b      	ldr	r1, [pc, #300]	; (8010b88 <hwBoardInit+0xf60>)
 8010a5a:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 8010a5e:	4836      	ldr	r0, [pc, #216]	; (8010b38 <hwBoardInit+0xf10>)
 8010a60:	f7f7 fe80 	bl	8008764 <xprintf>
 8010a64:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a66:	2b00      	cmp	r3, #0
 8010a68:	dd06      	ble.n	8010a78 <hwBoardInit+0xe50>
 8010a6a:	4b34      	ldr	r3, [pc, #208]	; (8010b3c <hwBoardInit+0xf14>)
 8010a6c:	4947      	ldr	r1, [pc, #284]	; (8010b8c <hwBoardInit+0xf64>)
 8010a6e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 8010a72:	4831      	ldr	r0, [pc, #196]	; (8010b38 <hwBoardInit+0xf10>)
 8010a74:	f7f7 fe76 	bl	8008764 <xprintf>
 8010a78:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a7a:	2b00      	cmp	r3, #0
 8010a7c:	dd06      	ble.n	8010a8c <hwBoardInit+0xe64>
 8010a7e:	4b2f      	ldr	r3, [pc, #188]	; (8010b3c <hwBoardInit+0xf14>)
 8010a80:	4943      	ldr	r1, [pc, #268]	; (8010b90 <hwBoardInit+0xf68>)
 8010a82:	f8d3 20c4 	ldr.w	r2, [r3, #196]	; 0xc4
 8010a86:	482c      	ldr	r0, [pc, #176]	; (8010b38 <hwBoardInit+0xf10>)
 8010a88:	f7f7 fe6c 	bl	8008764 <xprintf>
 8010a8c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010a8e:	2b00      	cmp	r3, #0
 8010a90:	dd06      	ble.n	8010aa0 <hwBoardInit+0xe78>
 8010a92:	4b2a      	ldr	r3, [pc, #168]	; (8010b3c <hwBoardInit+0xf14>)
 8010a94:	493f      	ldr	r1, [pc, #252]	; (8010b94 <hwBoardInit+0xf6c>)
 8010a96:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 8010a9a:	4827      	ldr	r0, [pc, #156]	; (8010b38 <hwBoardInit+0xf10>)
 8010a9c:	f7f7 fe62 	bl	8008764 <xprintf>
 8010aa0:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010aa2:	2b00      	cmp	r3, #0
 8010aa4:	dd06      	ble.n	8010ab4 <hwBoardInit+0xe8c>
 8010aa6:	4b25      	ldr	r3, [pc, #148]	; (8010b3c <hwBoardInit+0xf14>)
 8010aa8:	493b      	ldr	r1, [pc, #236]	; (8010b98 <hwBoardInit+0xf70>)
 8010aaa:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 8010aae:	4822      	ldr	r0, [pc, #136]	; (8010b38 <hwBoardInit+0xf10>)
 8010ab0:	f7f7 fe58 	bl	8008764 <xprintf>
 8010ab4:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010ab6:	2b00      	cmp	r3, #0
 8010ab8:	dd06      	ble.n	8010ac8 <hwBoardInit+0xea0>
 8010aba:	4b20      	ldr	r3, [pc, #128]	; (8010b3c <hwBoardInit+0xf14>)
 8010abc:	4937      	ldr	r1, [pc, #220]	; (8010b9c <hwBoardInit+0xf74>)
 8010abe:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 8010ac2:	481d      	ldr	r0, [pc, #116]	; (8010b38 <hwBoardInit+0xf10>)
 8010ac4:	f7f7 fe4e 	bl	8008764 <xprintf>
 8010ac8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010aca:	2b00      	cmp	r3, #0
 8010acc:	dd06      	ble.n	8010adc <hwBoardInit+0xeb4>
 8010ace:	4b1b      	ldr	r3, [pc, #108]	; (8010b3c <hwBoardInit+0xf14>)
 8010ad0:	4933      	ldr	r1, [pc, #204]	; (8010ba0 <hwBoardInit+0xf78>)
 8010ad2:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 8010ad6:	4818      	ldr	r0, [pc, #96]	; (8010b38 <hwBoardInit+0xf10>)
 8010ad8:	f7f7 fe44 	bl	8008764 <xprintf>
 8010adc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010ade:	2b00      	cmp	r3, #0
 8010ae0:	dd06      	ble.n	8010af0 <hwBoardInit+0xec8>
 8010ae2:	4b16      	ldr	r3, [pc, #88]	; (8010b3c <hwBoardInit+0xf14>)
 8010ae4:	492f      	ldr	r1, [pc, #188]	; (8010ba4 <hwBoardInit+0xf7c>)
 8010ae6:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 8010aea:	4813      	ldr	r0, [pc, #76]	; (8010b38 <hwBoardInit+0xf10>)
 8010aec:	f7f7 fe3a 	bl	8008764 <xprintf>
 8010af0:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010af2:	2b00      	cmp	r3, #0
 8010af4:	dd06      	ble.n	8010b04 <hwBoardInit+0xedc>
 8010af6:	4b11      	ldr	r3, [pc, #68]	; (8010b3c <hwBoardInit+0xf14>)
 8010af8:	492b      	ldr	r1, [pc, #172]	; (8010ba8 <hwBoardInit+0xf80>)
 8010afa:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 8010afe:	480e      	ldr	r0, [pc, #56]	; (8010b38 <hwBoardInit+0xf10>)
 8010b00:	f7f7 fe30 	bl	8008764 <xprintf>
 8010b04:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010b06:	2b00      	cmp	r3, #0
 8010b08:	dd06      	ble.n	8010b18 <hwBoardInit+0xef0>
 8010b0a:	4b0c      	ldr	r3, [pc, #48]	; (8010b3c <hwBoardInit+0xf14>)
 8010b0c:	4927      	ldr	r1, [pc, #156]	; (8010bac <hwBoardInit+0xf84>)
 8010b0e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8010b12:	4809      	ldr	r0, [pc, #36]	; (8010b38 <hwBoardInit+0xf10>)
 8010b14:	f7f7 fe26 	bl	8008764 <xprintf>
 8010b18:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8010b1a:	2b00      	cmp	r3, #0
 8010b1c:	dd06      	ble.n	8010b2c <hwBoardInit+0xf04>
 8010b1e:	4b07      	ldr	r3, [pc, #28]	; (8010b3c <hwBoardInit+0xf14>)
 8010b20:	4923      	ldr	r1, [pc, #140]	; (8010bb0 <hwBoardInit+0xf88>)
 8010b22:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
 8010b26:	4804      	ldr	r0, [pc, #16]	; (8010b38 <hwBoardInit+0xf10>)
 8010b28:	f7f7 fe1c 	bl	8008764 <xprintf>
}
 8010b2c:	b00d      	add	sp, #52	; 0x34
 8010b2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010b32:	bf00      	nop
 8010b34:	0801e376 	.word	0x0801e376
 8010b38:	0801e248 	.word	0x0801e248
 8010b3c:	10001000 	.word	0x10001000
 8010b40:	0801e386 	.word	0x0801e386
 8010b44:	0801e390 	.word	0x0801e390
 8010b48:	0801e39a 	.word	0x0801e39a
 8010b4c:	0801e3a4 	.word	0x0801e3a4
 8010b50:	0801e3ae 	.word	0x0801e3ae
 8010b54:	0801e3b9 	.word	0x0801e3b9
 8010b58:	0801e3c4 	.word	0x0801e3c4
 8010b5c:	0801e3cf 	.word	0x0801e3cf
 8010b60:	0801e3da 	.word	0x0801e3da
 8010b64:	0801e3e5 	.word	0x0801e3e5
 8010b68:	0801e3f0 	.word	0x0801e3f0
 8010b6c:	0801e3fb 	.word	0x0801e3fb
 8010b70:	0801e405 	.word	0x0801e405
 8010b74:	0801e40f 	.word	0x0801e40f
 8010b78:	0801e419 	.word	0x0801e419
 8010b7c:	0801e422 	.word	0x0801e422
 8010b80:	0801e42c 	.word	0x0801e42c
 8010b84:	0801e436 	.word	0x0801e436
 8010b88:	0801e43c 	.word	0x0801e43c
 8010b8c:	0801e442 	.word	0x0801e442
 8010b90:	0801e489 	.word	0x0801e489
 8010b94:	0801e444 	.word	0x0801e444
 8010b98:	0801e451 	.word	0x0801e451
 8010b9c:	0801e462 	.word	0x0801e462
 8010ba0:	0801e473 	.word	0x0801e473
 8010ba4:	0801e484 	.word	0x0801e484
 8010ba8:	0801e48b 	.word	0x0801e48b
 8010bac:	0801e497 	.word	0x0801e497
 8010bb0:	0801e49d 	.word	0x0801e49d

08010bb4 <adcSens>:
    }
}

void adcSens(int enable)
{
  if(enable)
 8010bb4:	4602      	mov	r2, r0
 8010bb6:	b100      	cbz	r0, 8010bba <adcSens+0x6>
    GPIO_WriteBit(GPIOB, GPIO_Pin_1, 1);
 8010bb8:	2201      	movs	r2, #1
  else
    GPIO_WriteBit(GPIOB, GPIO_Pin_1, 0);
 8010bba:	2102      	movs	r1, #2
 8010bbc:	4801      	ldr	r0, [pc, #4]	; (8010bc4 <adcSens+0x10>)
 8010bbe:	f000 b9e9 	b.w	8010f94 <GPIO_WriteBit>
 8010bc2:	bf00      	nop
 8010bc4:	40020400 	.word	0x40020400

08010bc8 <pwmStatus>:

}


uint8_t pwmStatus(void)
{
 8010bc8:	b570      	push	{r4, r5, r6, lr}
  return 0
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
 8010bca:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8010bce:	4817      	ldr	r0, [pc, #92]	; (8010c2c <pwmStatus+0x64>)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
 8010bd0:	4e17      	ldr	r6, [pc, #92]	; (8010c30 <pwmStatus+0x68>)


uint8_t pwmStatus(void)
{
  return 0
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
 8010bd2:	f000 f975 	bl	8010ec0 <GPIO_ReadInputDataBit>
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
 8010bd6:	2108      	movs	r1, #8


uint8_t pwmStatus(void)
{
  return 0
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
 8010bd8:	4605      	mov	r5, r0
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
 8010bda:	4630      	mov	r0, r6
 8010bdc:	f000 f970 	bl	8010ec0 <GPIO_ReadInputDataBit>
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)<<2)
 8010be0:	f44f 7100 	mov.w	r1, #512	; 0x200

uint8_t pwmStatus(void)
{
  return 0
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
 8010be4:	4604      	mov	r4, r0
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)<<2)
 8010be6:	4630      	mov	r0, r6
 8010be8:	f000 f96a 	bl	8010ec0 <GPIO_ReadInputDataBit>
}


uint8_t pwmStatus(void)
{
  return 0
 8010bec:	0080      	lsls	r0, r0, #2
 8010bee:	ea40 0444 	orr.w	r4, r0, r4, lsl #1
 8010bf2:	432c      	orrs	r4, r5
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)<<2)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14)<<3)
 8010bf4:	4d0f      	ldr	r5, [pc, #60]	; (8010c34 <pwmStatus+0x6c>)
 8010bf6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8010bfa:	4628      	mov	r0, r5
 8010bfc:	f000 f960 	bl	8010ec0 <GPIO_ReadInputDataBit>
}


uint8_t pwmStatus(void)
{
  return 0
 8010c00:	b264      	sxtb	r4, r4
 8010c02:	ea44 00c0 	orr.w	r0, r4, r0, lsl #3
 8010c06:	b244      	sxtb	r4, r0
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)<<2)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14)<<3)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15)<<4)
 8010c08:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8010c0c:	4628      	mov	r0, r5
 8010c0e:	f000 f957 	bl	8010ec0 <GPIO_ReadInputDataBit>
}


uint8_t pwmStatus(void)
{
  return 0
 8010c12:	ea44 1000 	orr.w	r0, r4, r0, lsl #4
 8010c16:	b244      	sxtb	r4, r0
         | (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)<<0)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3)<<1)
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)<<2)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14)<<3)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15)<<4)
         | (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_13)<<5)
 8010c18:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8010c1c:	4806      	ldr	r0, [pc, #24]	; (8010c38 <pwmStatus+0x70>)
 8010c1e:	f000 f94f 	bl	8010ec0 <GPIO_ReadInputDataBit>
}


uint8_t pwmStatus(void)
{
  return 0
 8010c22:	ea44 1040 	orr.w	r0, r4, r0, lsl #5
         | (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)<<2)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14)<<3)
         | (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15)<<4)
         | (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_13)<<5)
         ;
}
 8010c26:	b2c0      	uxtb	r0, r0
 8010c28:	bd70      	pop	{r4, r5, r6, pc}
 8010c2a:	bf00      	nop
 8010c2c:	40020000 	.word	0x40020000
 8010c30:	40020400 	.word	0x40020400
 8010c34:	40020800 	.word	0x40020800
 8010c38:	40021000 	.word	0x40021000

08010c3c <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8010c3c:	4a17      	ldr	r2, [pc, #92]	; (8010c9c <SystemCoreClockUpdate+0x60>)
 8010c3e:	4918      	ldr	r1, [pc, #96]	; (8010ca0 <SystemCoreClockUpdate+0x64>)
 8010c40:	6893      	ldr	r3, [r2, #8]

  switch (tmp)
 8010c42:	f003 030c 	and.w	r3, r3, #12
 8010c46:	2b04      	cmp	r3, #4
 8010c48:	d003      	beq.n	8010c52 <SystemCoreClockUpdate+0x16>
 8010c4a:	2b08      	cmp	r3, #8
 8010c4c:	d003      	beq.n	8010c56 <SystemCoreClockUpdate+0x1a>
 8010c4e:	4b15      	ldr	r3, [pc, #84]	; (8010ca4 <SystemCoreClockUpdate+0x68>)
 8010c50:	e018      	b.n	8010c84 <SystemCoreClockUpdate+0x48>
    {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8010c52:	4b15      	ldr	r3, [pc, #84]	; (8010ca8 <SystemCoreClockUpdate+0x6c>)
 8010c54:	e016      	b.n	8010c84 <SystemCoreClockUpdate+0x48>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8010c56:	6850      	ldr	r0, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8010c58:	6853      	ldr	r3, [r2, #4]

      if (pllsource != 0)
 8010c5a:	f410 0f80 	tst.w	r0, #4194304	; 0x400000

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8010c5e:	f003 033f 	and.w	r3, r3, #63	; 0x3f

      if (pllsource != 0)
        {
          /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8010c62:	6850      	ldr	r0, [r2, #4]
 8010c64:	bf14      	ite	ne
 8010c66:	4a10      	ldrne	r2, [pc, #64]	; (8010ca8 <SystemCoreClockUpdate+0x6c>)
        }
      else
        {
          /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8010c68:	4a0e      	ldreq	r2, [pc, #56]	; (8010ca4 <SystemCoreClockUpdate+0x68>)
 8010c6a:	fbb2 f3f3 	udiv	r3, r2, r3
        }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8010c6e:	4a0b      	ldr	r2, [pc, #44]	; (8010c9c <SystemCoreClockUpdate+0x60>)
 8010c70:	6852      	ldr	r2, [r2, #4]
      SystemCoreClock = pllvco/pllp;
 8010c72:	f3c2 4201 	ubfx	r2, r2, #16, #2
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;

      if (pllsource != 0)
        {
          /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8010c76:	f3c0 1088 	ubfx	r0, r0, #6, #9
          /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
        }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      SystemCoreClock = pllvco/pllp;
 8010c7a:	3201      	adds	r2, #1
          pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
        }
      else
        {
          /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8010c7c:	4343      	muls	r3, r0
        }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      SystemCoreClock = pllvco/pllp;
 8010c7e:	0052      	lsls	r2, r2, #1
 8010c80:	fbb3 f3f2 	udiv	r3, r3, r2
 8010c84:	600b      	str	r3, [r1, #0]
      SystemCoreClock = HSI_VALUE;
      break;
    }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8010c86:	4b05      	ldr	r3, [pc, #20]	; (8010c9c <SystemCoreClockUpdate+0x60>)
 8010c88:	689b      	ldr	r3, [r3, #8]
 8010c8a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8010c8e:	440b      	add	r3, r1
 8010c90:	791a      	ldrb	r2, [r3, #4]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 8010c92:	680b      	ldr	r3, [r1, #0]
 8010c94:	40d3      	lsrs	r3, r2
 8010c96:	600b      	str	r3, [r1, #0]
 8010c98:	4770      	bx	lr
 8010c9a:	bf00      	nop
 8010c9c:	40023800 	.word	0x40023800
 8010ca0:	2001abe4 	.word	0x2001abe4
 8010ca4:	00f42400 	.word	0x00f42400
 8010ca8:	007a1200 	.word	0x007a1200

08010cac <SystemInit>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8010cac:	4b21      	ldr	r3, [pc, #132]	; (8010d34 <SystemInit+0x88>)
 8010cae:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8010cb0:	2100      	movs	r1, #0
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8010cb2:	f042 0201 	orr.w	r2, r2, #1
 8010cb6:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8010cb8:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8010cba:	681a      	ldr	r2, [r3, #0]
 8010cbc:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8010cc0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8010cc4:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8010cc6:	4a1c      	ldr	r2, [pc, #112]	; (8010d38 <SystemInit+0x8c>)
 8010cc8:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8010cca:	681a      	ldr	r2, [r3, #0]
 8010ccc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8010cd0:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8010cd2:	60d9      	str	r1, [r3, #12]
  /******************************************************************************/

  /* At this stage the HSI is already enabled and used as System clock source */

  /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
  RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8010cd4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  PWR->CR |= PWR_CR_VOS;
 8010cd6:	4919      	ldr	r1, [pc, #100]	; (8010d3c <SystemInit+0x90>)
  /******************************************************************************/

  /* At this stage the HSI is already enabled and used as System clock source */

  /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
  RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8010cd8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8010cdc:	641a      	str	r2, [r3, #64]	; 0x40
  PWR->CR |= PWR_CR_VOS;
 8010cde:	680a      	ldr	r2, [r1, #0]
 8010ce0:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8010ce4:	600a      	str	r2, [r1, #0]

  /* HCLK = SYSCLK / 1*/
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8010ce6:	689a      	ldr	r2, [r3, #8]
 8010ce8:	609a      	str	r2, [r3, #8]

  /* PCLK2 = HCLK / 2*/
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8010cea:	689a      	ldr	r2, [r3, #8]
 8010cec:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8010cf0:	609a      	str	r2, [r3, #8]

  /* PCLK1 = HCLK / 1*/
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8010cf2:	689a      	ldr	r2, [r3, #8]
 8010cf4:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8010cf8:	609a      	str	r2, [r3, #8]

  /* Configure the main PLL */
  RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8010cfa:	4a11      	ldr	r2, [pc, #68]	; (8010d40 <SystemInit+0x94>)
 8010cfc:	605a      	str	r2, [r3, #4]
                 (RCC_PLLCFGR_PLLSRC_HSI) | (PLL_Q << 24);

  /* Enable the main PLL */
  RCC->CR |= RCC_CR_PLLON;
 8010cfe:	681a      	ldr	r2, [r3, #0]
 8010d00:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8010d04:	601a      	str	r2, [r3, #0]

  /* Wait till the main PLL is ready */
  while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8010d06:	6819      	ldr	r1, [r3, #0]
 8010d08:	4a0a      	ldr	r2, [pc, #40]	; (8010d34 <SystemInit+0x88>)
 8010d0a:	0189      	lsls	r1, r1, #6
 8010d0c:	d5fb      	bpl.n	8010d06 <SystemInit+0x5a>
    {
    }

  /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
  FLASH->ACR = FLASH_ACR_PRFTEN |FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8010d0e:	4b0d      	ldr	r3, [pc, #52]	; (8010d44 <SystemInit+0x98>)
 8010d10:	f240 7105 	movw	r1, #1797	; 0x705
 8010d14:	6019      	str	r1, [r3, #0]

  /* Select the main PLL as system clock source */
  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8010d16:	6893      	ldr	r3, [r2, #8]
 8010d18:	f023 0303 	bic.w	r3, r3, #3
 8010d1c:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SW_PLL;
 8010d1e:	6893      	ldr	r3, [r2, #8]
 8010d20:	f043 0302 	orr.w	r3, r3, #2
 8010d24:	6093      	str	r3, [r2, #8]

  /* Wait till the main PLL is used as system clock source */
  while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL)
 8010d26:	6893      	ldr	r3, [r2, #8]
 8010d28:	f003 030c 	and.w	r3, r3, #12
 8010d2c:	2b08      	cmp	r3, #8
 8010d2e:	d1fa      	bne.n	8010d26 <SystemInit+0x7a>
#endif /* DATA_IN_ExtSRAM */

  /* Configure the System clock source, PLL Multiplier and Divider factors,
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
  SystemCoreClockUpdate();
 8010d30:	f7ff bf84 	b.w	8010c3c <SystemCoreClockUpdate>
 8010d34:	40023800 	.word	0x40023800
 8010d38:	24003010 	.word	0x24003010
 8010d3c:	40007000 	.word	0x40007000
 8010d40:	07005410 	.word	0x07005410
 8010d44:	40023c00 	.word	0x40023c00

08010d48 <NVIC_PriorityGroupConfig>:
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
 8010d48:	f5b0 6fc0 	cmp.w	r0, #1536	; 0x600
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 8010d4c:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
 8010d4e:	d107      	bne.n	8010d60 <NVIC_PriorityGroupConfig+0x18>
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8010d50:	4b0b      	ldr	r3, [pc, #44]	; (8010d80 <NVIC_PriorityGroupConfig+0x38>)
 8010d52:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8010d56:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8010d5a:	60d8      	str	r0, [r3, #12]
}
 8010d5c:	b002      	add	sp, #8
 8010d5e:	4770      	bx	lr
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
 8010d60:	f420 7380 	bic.w	r3, r0, #256	; 0x100
 8010d64:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8010d68:	d0f2      	beq.n	8010d50 <NVIC_PriorityGroupConfig+0x8>
 8010d6a:	f420 6380 	bic.w	r3, r0, #1024	; 0x400
 8010d6e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8010d72:	d0ed      	beq.n	8010d50 <NVIC_PriorityGroupConfig+0x8>
 8010d74:	2301      	movs	r3, #1
 8010d76:	9301      	str	r3, [sp, #4]
 8010d78:	9b01      	ldr	r3, [sp, #4]
 8010d7a:	2b00      	cmp	r3, #0
 8010d7c:	d1fc      	bne.n	8010d78 <NVIC_PriorityGroupConfig+0x30>
 8010d7e:	e7e7      	b.n	8010d50 <NVIC_PriorityGroupConfig+0x8>
 8010d80:	e000ed00 	.word	0xe000ed00

08010d84 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8010d84:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010d86:	4b4c      	ldr	r3, [pc, #304]	; (8010eb8 <GPIO_Init+0x134>)
 8010d88:	4298      	cmp	r0, r3
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8010d8a:	b087      	sub	sp, #28
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010d8c:	d102      	bne.n	8010d94 <GPIO_Init+0x10>
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
 8010d8e:	680b      	ldr	r3, [r1, #0]
 8010d90:	b36b      	cbz	r3, 8010dee <GPIO_Init+0x6a>
 8010d92:	e031      	b.n	8010df8 <GPIO_Init+0x74>
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010d94:	4b49      	ldr	r3, [pc, #292]	; (8010ebc <GPIO_Init+0x138>)
 8010d96:	4298      	cmp	r0, r3
 8010d98:	d0f9      	beq.n	8010d8e <GPIO_Init+0xa>
 8010d9a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010d9e:	4298      	cmp	r0, r3
 8010da0:	d0f5      	beq.n	8010d8e <GPIO_Init+0xa>
 8010da2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010da6:	4298      	cmp	r0, r3
 8010da8:	d0f1      	beq.n	8010d8e <GPIO_Init+0xa>
 8010daa:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010dae:	4298      	cmp	r0, r3
 8010db0:	d0ed      	beq.n	8010d8e <GPIO_Init+0xa>
 8010db2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010db6:	4298      	cmp	r0, r3
 8010db8:	d0e9      	beq.n	8010d8e <GPIO_Init+0xa>
 8010dba:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010dbe:	4298      	cmp	r0, r3
 8010dc0:	d0e5      	beq.n	8010d8e <GPIO_Init+0xa>
 8010dc2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010dc6:	4298      	cmp	r0, r3
 8010dc8:	d0e1      	beq.n	8010d8e <GPIO_Init+0xa>
 8010dca:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010dce:	4298      	cmp	r0, r3
 8010dd0:	d0dd      	beq.n	8010d8e <GPIO_Init+0xa>
 8010dd2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010dd6:	4298      	cmp	r0, r3
 8010dd8:	d0d9      	beq.n	8010d8e <GPIO_Init+0xa>
 8010dda:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010dde:	4298      	cmp	r0, r3
 8010de0:	d0d5      	beq.n	8010d8e <GPIO_Init+0xa>
 8010de2:	2301      	movs	r3, #1
 8010de4:	9300      	str	r3, [sp, #0]
 8010de6:	9b00      	ldr	r3, [sp, #0]
 8010de8:	2b00      	cmp	r3, #0
 8010dea:	d1fc      	bne.n	8010de6 <GPIO_Init+0x62>
 8010dec:	e7cf      	b.n	8010d8e <GPIO_Init+0xa>
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
 8010dee:	2301      	movs	r3, #1
 8010df0:	9301      	str	r3, [sp, #4]
 8010df2:	9b01      	ldr	r3, [sp, #4]
 8010df4:	2b00      	cmp	r3, #0
 8010df6:	d1fc      	bne.n	8010df2 <GPIO_Init+0x6e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
 8010df8:	790b      	ldrb	r3, [r1, #4]
 8010dfa:	2b03      	cmp	r3, #3
 8010dfc:	d904      	bls.n	8010e08 <GPIO_Init+0x84>
 8010dfe:	2301      	movs	r3, #1
 8010e00:	9302      	str	r3, [sp, #8]
 8010e02:	9b02      	ldr	r3, [sp, #8]
 8010e04:	2b00      	cmp	r3, #0
 8010e06:	d1fc      	bne.n	8010e02 <GPIO_Init+0x7e>
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
 8010e08:	79cb      	ldrb	r3, [r1, #7]
 8010e0a:	2b02      	cmp	r3, #2
 8010e0c:	d904      	bls.n	8010e18 <GPIO_Init+0x94>
 8010e0e:	2301      	movs	r3, #1
 8010e10:	9303      	str	r3, [sp, #12]
 8010e12:	9b03      	ldr	r3, [sp, #12]
 8010e14:	2b00      	cmp	r3, #0
 8010e16:	d1fc      	bne.n	8010e12 <GPIO_Init+0x8e>
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8010e18:	2300      	movs	r3, #0

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8010e1a:	2501      	movs	r5, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8010e1c:	2703      	movs	r7, #3
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 8010e1e:	680c      	ldr	r4, [r1, #0]

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8010e20:	fa05 f203 	lsl.w	r2, r5, r3
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 8010e24:	43a2      	bics	r2, r4
 8010e26:	d142      	bne.n	8010eae <GPIO_Init+0x12a>
 8010e28:	005a      	lsls	r2, r3, #1
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8010e2a:	6806      	ldr	r6, [r0, #0]
 8010e2c:	fa07 f402 	lsl.w	r4, r7, r2
 8010e30:	43e4      	mvns	r4, r4
 8010e32:	4026      	ands	r6, r4
 8010e34:	6006      	str	r6, [r0, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8010e36:	f891 e004 	ldrb.w	lr, [r1, #4]
 8010e3a:	6806      	ldr	r6, [r0, #0]
 8010e3c:	fa0e fe02 	lsl.w	lr, lr, r2
 8010e40:	ea4e 0606 	orr.w	r6, lr, r6
 8010e44:	6006      	str	r6, [r0, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8010e46:	790e      	ldrb	r6, [r1, #4]
 8010e48:	3e01      	subs	r6, #1
 8010e4a:	2e01      	cmp	r6, #1
 8010e4c:	d823      	bhi.n	8010e96 <GPIO_Init+0x112>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
 8010e4e:	794e      	ldrb	r6, [r1, #5]
 8010e50:	2e03      	cmp	r6, #3
 8010e52:	d80b      	bhi.n	8010e6c <GPIO_Init+0xe8>

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8010e54:	6886      	ldr	r6, [r0, #8]
 8010e56:	4034      	ands	r4, r6
 8010e58:	6084      	str	r4, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8010e5a:	794c      	ldrb	r4, [r1, #5]
 8010e5c:	6886      	ldr	r6, [r0, #8]
 8010e5e:	4094      	lsls	r4, r2
 8010e60:	4334      	orrs	r4, r6
 8010e62:	6084      	str	r4, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
 8010e64:	798c      	ldrb	r4, [r1, #6]
 8010e66:	2c01      	cmp	r4, #1
 8010e68:	d805      	bhi.n	8010e76 <GPIO_Init+0xf2>
 8010e6a:	e008      	b.n	8010e7e <GPIO_Init+0xfa>
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
 8010e6c:	9504      	str	r5, [sp, #16]
 8010e6e:	9e04      	ldr	r6, [sp, #16]
 8010e70:	2e00      	cmp	r6, #0
 8010e72:	d1fc      	bne.n	8010e6e <GPIO_Init+0xea>
 8010e74:	e7ee      	b.n	8010e54 <GPIO_Init+0xd0>
        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
 8010e76:	9505      	str	r5, [sp, #20]
 8010e78:	9c05      	ldr	r4, [sp, #20]
 8010e7a:	2c00      	cmp	r4, #0
 8010e7c:	d1fc      	bne.n	8010e78 <GPIO_Init+0xf4>

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8010e7e:	6844      	ldr	r4, [r0, #4]
 8010e80:	fa05 f603 	lsl.w	r6, r5, r3
 8010e84:	ea24 0406 	bic.w	r4, r4, r6
 8010e88:	6044      	str	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8010e8a:	798c      	ldrb	r4, [r1, #6]
 8010e8c:	6846      	ldr	r6, [r0, #4]
 8010e8e:	409c      	lsls	r4, r3
 8010e90:	b2a4      	uxth	r4, r4
 8010e92:	4334      	orrs	r4, r6
 8010e94:	6044      	str	r4, [r0, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8010e96:	68c4      	ldr	r4, [r0, #12]
 8010e98:	fa07 f602 	lsl.w	r6, r7, r2
 8010e9c:	ea24 0406 	bic.w	r4, r4, r6
 8010ea0:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8010ea2:	79ce      	ldrb	r6, [r1, #7]
 8010ea4:	68c4      	ldr	r4, [r0, #12]
 8010ea6:	fa06 f202 	lsl.w	r2, r6, r2
 8010eaa:	4322      	orrs	r2, r4
 8010eac:	60c2      	str	r2, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8010eae:	3301      	adds	r3, #1
 8010eb0:	2b10      	cmp	r3, #16
 8010eb2:	d1b4      	bne.n	8010e1e <GPIO_Init+0x9a>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8010eb4:	b007      	add	sp, #28
 8010eb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010eb8:	40020000 	.word	0x40020000
 8010ebc:	40020400 	.word	0x40020400

08010ec0 <GPIO_ReadInputDataBit>:
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  uint8_t bitstatus = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010ec0:	4b31      	ldr	r3, [pc, #196]	; (8010f88 <GPIO_ReadInputDataBit+0xc8>)
 8010ec2:	4298      	cmp	r0, r3
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8010ec4:	b082      	sub	sp, #8
  uint8_t bitstatus = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010ec6:	d104      	bne.n	8010ed2 <GPIO_ReadInputDataBit+0x12>
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
 8010ec8:	1e4b      	subs	r3, r1, #1
 8010eca:	b29b      	uxth	r3, r3
 8010ecc:	2b1f      	cmp	r3, #31
 8010ece:	d852      	bhi.n	8010f76 <GPIO_ReadInputDataBit+0xb6>
 8010ed0:	e02c      	b.n	8010f2c <GPIO_ReadInputDataBit+0x6c>
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  uint8_t bitstatus = 0x00;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010ed2:	4b2e      	ldr	r3, [pc, #184]	; (8010f8c <GPIO_ReadInputDataBit+0xcc>)
 8010ed4:	4298      	cmp	r0, r3
 8010ed6:	d0f7      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010ed8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010edc:	4298      	cmp	r0, r3
 8010ede:	d0f3      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010ee0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010ee4:	4298      	cmp	r0, r3
 8010ee6:	d0ef      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010ee8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010eec:	4298      	cmp	r0, r3
 8010eee:	d0eb      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010ef0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010ef4:	4298      	cmp	r0, r3
 8010ef6:	d0e7      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010ef8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010efc:	4298      	cmp	r0, r3
 8010efe:	d0e3      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010f00:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010f04:	4298      	cmp	r0, r3
 8010f06:	d0df      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010f08:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010f0c:	4298      	cmp	r0, r3
 8010f0e:	d0db      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010f10:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010f14:	4298      	cmp	r0, r3
 8010f16:	d0d7      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010f18:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010f1c:	4298      	cmp	r0, r3
 8010f1e:	d0d3      	beq.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
 8010f20:	2301      	movs	r3, #1
 8010f22:	9300      	str	r3, [sp, #0]
 8010f24:	9b00      	ldr	r3, [sp, #0]
 8010f26:	2b00      	cmp	r3, #0
 8010f28:	d1fc      	bne.n	8010f24 <GPIO_ReadInputDataBit+0x64>
 8010f2a:	e7cd      	b.n	8010ec8 <GPIO_ReadInputDataBit+0x8>
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
 8010f2c:	4a18      	ldr	r2, [pc, #96]	; (8010f90 <GPIO_ReadInputDataBit+0xd0>)
 8010f2e:	fa22 f303 	lsr.w	r3, r2, r3
 8010f32:	07db      	lsls	r3, r3, #31
 8010f34:	d421      	bmi.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f36:	2980      	cmp	r1, #128	; 0x80
 8010f38:	d01f      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f3a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8010f3e:	d01c      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f40:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8010f44:	d019      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f46:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8010f4a:	d016      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f4c:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8010f50:	d013      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f52:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8010f56:	d010      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f58:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 8010f5c:	d00d      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f5e:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8010f62:	d00a      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f64:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8010f68:	d007      	beq.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f6a:	2301      	movs	r3, #1
 8010f6c:	9301      	str	r3, [sp, #4]
 8010f6e:	9b01      	ldr	r3, [sp, #4]
 8010f70:	2b00      	cmp	r3, #0
 8010f72:	d1fc      	bne.n	8010f6e <GPIO_ReadInputDataBit+0xae>
 8010f74:	e001      	b.n	8010f7a <GPIO_ReadInputDataBit+0xba>
 8010f76:	2940      	cmp	r1, #64	; 0x40
 8010f78:	d1dd      	bne.n	8010f36 <GPIO_ReadInputDataBit+0x76>

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8010f7a:	6903      	ldr	r3, [r0, #16]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8010f7c:	4219      	tst	r1, r3
 8010f7e:	bf14      	ite	ne
 8010f80:	2001      	movne	r0, #1
 8010f82:	2000      	moveq	r0, #0
}
 8010f84:	b002      	add	sp, #8
 8010f86:	4770      	bx	lr
 8010f88:	40020000 	.word	0x40020000
 8010f8c:	40020400 	.word	0x40020400
 8010f90:	8000808b 	.word	0x8000808b

08010f94 <GPIO_WriteBit>:
  *            @arg Bit_RESET: to clear the port pin
  *            @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8010f94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010f96:	4b35      	ldr	r3, [pc, #212]	; (801106c <GPIO_WriteBit+0xd8>)
 8010f98:	4298      	cmp	r0, r3
 8010f9a:	d104      	bne.n	8010fa6 <GPIO_WriteBit+0x12>
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
 8010f9c:	1e4b      	subs	r3, r1, #1
 8010f9e:	b29b      	uxth	r3, r3
 8010fa0:	2b1f      	cmp	r3, #31
 8010fa2:	d837      	bhi.n	8011014 <GPIO_WriteBit+0x80>
 8010fa4:	e02c      	b.n	8011000 <GPIO_WriteBit+0x6c>
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8010fa6:	4b32      	ldr	r3, [pc, #200]	; (8011070 <GPIO_WriteBit+0xdc>)
 8010fa8:	4298      	cmp	r0, r3
 8010faa:	d0f7      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fac:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fb0:	4298      	cmp	r0, r3
 8010fb2:	d0f3      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fb4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fb8:	4298      	cmp	r0, r3
 8010fba:	d0ef      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fbc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fc0:	4298      	cmp	r0, r3
 8010fc2:	d0eb      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fc4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fc8:	4298      	cmp	r0, r3
 8010fca:	d0e7      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fcc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fd0:	4298      	cmp	r0, r3
 8010fd2:	d0e3      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fd4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fd8:	4298      	cmp	r0, r3
 8010fda:	d0df      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fdc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fe0:	4298      	cmp	r0, r3
 8010fe2:	d0db      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fe4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010fe8:	4298      	cmp	r0, r3
 8010fea:	d0d7      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010fec:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010ff0:	4298      	cmp	r0, r3
 8010ff2:	d0d3      	beq.n	8010f9c <GPIO_WriteBit+0x8>
 8010ff4:	2301      	movs	r3, #1
 8010ff6:	9301      	str	r3, [sp, #4]
 8010ff8:	9b01      	ldr	r3, [sp, #4]
 8010ffa:	2b00      	cmp	r3, #0
 8010ffc:	d1fc      	bne.n	8010ff8 <GPIO_WriteBit+0x64>
 8010ffe:	e7cd      	b.n	8010f9c <GPIO_WriteBit+0x8>
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
 8011000:	4c1c      	ldr	r4, [pc, #112]	; (8011074 <GPIO_WriteBit+0xe0>)
 8011002:	fa24 f303 	lsr.w	r3, r4, r3
 8011006:	07db      	lsls	r3, r3, #31
 8011008:	d506      	bpl.n	8011018 <GPIO_WriteBit+0x84>
  assert_param(IS_GPIO_BIT_ACTION(BitVal));
 801100a:	2a01      	cmp	r2, #1
 801100c:	d929      	bls.n	8011062 <GPIO_WriteBit+0xce>
 801100e:	2301      	movs	r3, #1
 8011010:	9303      	str	r3, [sp, #12]
 8011012:	e021      	b.n	8011058 <GPIO_WriteBit+0xc4>
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
 8011014:	2940      	cmp	r1, #64	; 0x40
 8011016:	d0f8      	beq.n	801100a <GPIO_WriteBit+0x76>
 8011018:	2980      	cmp	r1, #128	; 0x80
 801101a:	d0f6      	beq.n	801100a <GPIO_WriteBit+0x76>
 801101c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8011020:	d0f3      	beq.n	801100a <GPIO_WriteBit+0x76>
 8011022:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8011026:	d0f0      	beq.n	801100a <GPIO_WriteBit+0x76>
 8011028:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 801102c:	d0ed      	beq.n	801100a <GPIO_WriteBit+0x76>
 801102e:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8011032:	d0ea      	beq.n	801100a <GPIO_WriteBit+0x76>
 8011034:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8011038:	d0e7      	beq.n	801100a <GPIO_WriteBit+0x76>
 801103a:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 801103e:	d0e4      	beq.n	801100a <GPIO_WriteBit+0x76>
 8011040:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8011044:	d0e1      	beq.n	801100a <GPIO_WriteBit+0x76>
 8011046:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 801104a:	d0de      	beq.n	801100a <GPIO_WriteBit+0x76>
 801104c:	2301      	movs	r3, #1
 801104e:	9302      	str	r3, [sp, #8]
 8011050:	9b02      	ldr	r3, [sp, #8]
 8011052:	2b00      	cmp	r3, #0
 8011054:	d1fc      	bne.n	8011050 <GPIO_WriteBit+0xbc>
 8011056:	e7d8      	b.n	801100a <GPIO_WriteBit+0x76>
  assert_param(IS_GPIO_BIT_ACTION(BitVal));
 8011058:	9b03      	ldr	r3, [sp, #12]
 801105a:	2b00      	cmp	r3, #0
 801105c:	d1fc      	bne.n	8011058 <GPIO_WriteBit+0xc4>

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 801105e:	8301      	strh	r1, [r0, #24]
 8011060:	e002      	b.n	8011068 <GPIO_WriteBit+0xd4>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8011062:	2a00      	cmp	r2, #0
 8011064:	d1fb      	bne.n	801105e <GPIO_WriteBit+0xca>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8011066:	8341      	strh	r1, [r0, #26]
  }
}
 8011068:	b004      	add	sp, #16
 801106a:	bd10      	pop	{r4, pc}
 801106c:	40020000 	.word	0x40020000
 8011070:	40020400 	.word	0x40020400
 8011074:	8000808b 	.word	0x8000808b

08011078 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. 
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8011078:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t temp = 0x00;
  uint32_t temp_2 = 0x00;
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 801107a:	4b2a      	ldr	r3, [pc, #168]	; (8011124 <GPIO_PinAFConfig+0xac>)
 801107c:	4298      	cmp	r0, r3
 801107e:	d102      	bne.n	8011086 <GPIO_PinAFConfig+0xe>
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
 8011080:	290f      	cmp	r1, #15
 8011082:	d82d      	bhi.n	80110e0 <GPIO_PinAFConfig+0x68>
 8011084:	e031      	b.n	80110ea <GPIO_PinAFConfig+0x72>
{
  uint32_t temp = 0x00;
  uint32_t temp_2 = 0x00;
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
 8011086:	4b28      	ldr	r3, [pc, #160]	; (8011128 <GPIO_PinAFConfig+0xb0>)
 8011088:	4298      	cmp	r0, r3
 801108a:	d0f9      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 801108c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011090:	4298      	cmp	r0, r3
 8011092:	d0f5      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 8011094:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011098:	4298      	cmp	r0, r3
 801109a:	d0f1      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 801109c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110a0:	4298      	cmp	r0, r3
 80110a2:	d0ed      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110a8:	4298      	cmp	r0, r3
 80110aa:	d0e9      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110ac:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110b0:	4298      	cmp	r0, r3
 80110b2:	d0e5      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110b4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110b8:	4298      	cmp	r0, r3
 80110ba:	d0e1      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110bc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110c0:	4298      	cmp	r0, r3
 80110c2:	d0dd      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110c4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110c8:	4298      	cmp	r0, r3
 80110ca:	d0d9      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110cc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110d0:	4298      	cmp	r0, r3
 80110d2:	d0d5      	beq.n	8011080 <GPIO_PinAFConfig+0x8>
 80110d4:	2301      	movs	r3, #1
 80110d6:	9301      	str	r3, [sp, #4]
 80110d8:	9b01      	ldr	r3, [sp, #4]
 80110da:	2b00      	cmp	r3, #0
 80110dc:	d1fc      	bne.n	80110d8 <GPIO_PinAFConfig+0x60>
 80110de:	e7cf      	b.n	8011080 <GPIO_PinAFConfig+0x8>
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
 80110e0:	2301      	movs	r3, #1
 80110e2:	9302      	str	r3, [sp, #8]
 80110e4:	9b02      	ldr	r3, [sp, #8]
 80110e6:	2b00      	cmp	r3, #0
 80110e8:	d1fc      	bne.n	80110e4 <GPIO_PinAFConfig+0x6c>
  assert_param(IS_GPIO_AF(GPIO_AF));
 80110ea:	2a0d      	cmp	r2, #13
 80110ec:	d906      	bls.n	80110fc <GPIO_PinAFConfig+0x84>
 80110ee:	2a0f      	cmp	r2, #15
 80110f0:	d004      	beq.n	80110fc <GPIO_PinAFConfig+0x84>
 80110f2:	2301      	movs	r3, #1
 80110f4:	9303      	str	r3, [sp, #12]
 80110f6:	9b03      	ldr	r3, [sp, #12]
 80110f8:	2b00      	cmp	r3, #0
 80110fa:	d1fc      	bne.n	80110f6 <GPIO_PinAFConfig+0x7e>
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80110fc:	f001 0407 	and.w	r4, r1, #7
 8011100:	08c9      	lsrs	r1, r1, #3
 8011102:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8011106:	00a3      	lsls	r3, r4, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8011108:	210f      	movs	r1, #15
 801110a:	6a04      	ldr	r4, [r0, #32]
 801110c:	4099      	lsls	r1, r3
 801110e:	ea24 0101 	bic.w	r1, r4, r1
 8011112:	6201      	str	r1, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8011114:	6a01      	ldr	r1, [r0, #32]
 8011116:	fa02 f303 	lsl.w	r3, r2, r3
 801111a:	430b      	orrs	r3, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 801111c:	6203      	str	r3, [r0, #32]
}
 801111e:	b004      	add	sp, #16
 8011120:	bd10      	pop	{r4, pc}
 8011122:	bf00      	nop
 8011124:	40020000 	.word	0x40020000
 8011128:	40020400 	.word	0x40020400

0801112c <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 801112c:	b510      	push	{r4, lr}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 801112e:	4a1d      	ldr	r2, [pc, #116]	; (80111a4 <RCC_GetClocksFreq+0x78>)
 8011130:	6893      	ldr	r3, [r2, #8]

  switch (tmp)
 8011132:	f003 030c 	and.w	r3, r3, #12
 8011136:	2b04      	cmp	r3, #4
 8011138:	d003      	beq.n	8011142 <RCC_GetClocksFreq+0x16>
 801113a:	2b08      	cmp	r3, #8
 801113c:	d003      	beq.n	8011146 <RCC_GetClocksFreq+0x1a>
 801113e:	4b1a      	ldr	r3, [pc, #104]	; (80111a8 <RCC_GetClocksFreq+0x7c>)
 8011140:	e018      	b.n	8011174 <RCC_GetClocksFreq+0x48>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8011142:	4b1a      	ldr	r3, [pc, #104]	; (80111ac <RCC_GetClocksFreq+0x80>)
 8011144:	e016      	b.n	8011174 <RCC_GetClocksFreq+0x48>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8011146:	6851      	ldr	r1, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8011148:	6853      	ldr	r3, [r2, #4]
      
      if (pllsource != 0)
 801114a:	f411 0f80 	tst.w	r1, #4194304	; 0x400000

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 801114e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8011152:	6851      	ldr	r1, [r2, #4]
 8011154:	bf14      	ite	ne
 8011156:	4a15      	ldrne	r2, [pc, #84]	; (80111ac <RCC_GetClocksFreq+0x80>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8011158:	4a13      	ldreq	r2, [pc, #76]	; (80111a8 <RCC_GetClocksFreq+0x7c>)
 801115a:	fbb2 f3f3 	udiv	r3, r2, r3
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 801115e:	4a11      	ldr	r2, [pc, #68]	; (80111a4 <RCC_GetClocksFreq+0x78>)
 8011160:	6852      	ldr	r2, [r2, #4]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8011162:	f3c2 4201 	ubfx	r2, r2, #16, #2
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8011166:	f3c1 1188 	ubfx	r1, r1, #6, #9
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 801116a:	3201      	adds	r2, #1
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 801116c:	434b      	muls	r3, r1
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 801116e:	0052      	lsls	r2, r2, #1
 8011170:	fbb3 f3f2 	udiv	r3, r3, r2
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8011174:	4a0b      	ldr	r2, [pc, #44]	; (80111a4 <RCC_GetClocksFreq+0x78>)
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8011176:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8011178:	6893      	ldr	r3, [r2, #8]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 801117a:	490d      	ldr	r1, [pc, #52]	; (80111b0 <RCC_GetClocksFreq+0x84>)
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
  tmp = tmp >> 4;
 801117c:	f3c3 1303 	ubfx	r3, r3, #4, #4
  presc = APBAHBPrescTable[tmp];
 8011180:	5ccc      	ldrb	r4, [r1, r3]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8011182:	6803      	ldr	r3, [r0, #0]
 8011184:	40e3      	lsrs	r3, r4
 8011186:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8011188:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 10;
 801118a:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 801118e:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8011190:	fa23 f404 	lsr.w	r4, r3, r4
 8011194:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8011196:	6892      	ldr	r2, [r2, #8]
  tmp = tmp >> 13;
 8011198:	f3c2 3242 	ubfx	r2, r2, #13, #3
  presc = APBAHBPrescTable[tmp];
 801119c:	5c8a      	ldrb	r2, [r1, r2]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 801119e:	40d3      	lsrs	r3, r2
 80111a0:	60c3      	str	r3, [r0, #12]
 80111a2:	bd10      	pop	{r4, pc}
 80111a4:	40023800 	.word	0x40023800
 80111a8:	00f42400 	.word	0x00f42400
 80111ac:	007a1200 	.word	0x007a1200
 80111b0:	2001abf8 	.word	0x2001abf8

080111b4 <RCC_AHB1PeriphClockCmd>:
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
 80111b4:	4b0f      	ldr	r3, [pc, #60]	; (80111f4 <RCC_AHB1PeriphClockCmd+0x40>)
 80111b6:	4003      	ands	r3, r0
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 80111b8:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
 80111ba:	b92b      	cbnz	r3, 80111c8 <RCC_AHB1PeriphClockCmd+0x14>
 80111bc:	b120      	cbz	r0, 80111c8 <RCC_AHB1PeriphClockCmd+0x14>

  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80111be:	2901      	cmp	r1, #1
 80111c0:	d90f      	bls.n	80111e2 <RCC_AHB1PeriphClockCmd+0x2e>
 80111c2:	2301      	movs	r3, #1
 80111c4:	9301      	str	r3, [sp, #4]
 80111c6:	e005      	b.n	80111d4 <RCC_AHB1PeriphClockCmd+0x20>
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
 80111c8:	2301      	movs	r3, #1
 80111ca:	9300      	str	r3, [sp, #0]
 80111cc:	9b00      	ldr	r3, [sp, #0]
 80111ce:	2b00      	cmp	r3, #0
 80111d0:	d1fc      	bne.n	80111cc <RCC_AHB1PeriphClockCmd+0x18>
 80111d2:	e7f4      	b.n	80111be <RCC_AHB1PeriphClockCmd+0xa>

  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80111d4:	9b01      	ldr	r3, [sp, #4]
 80111d6:	2b00      	cmp	r3, #0
 80111d8:	d1fc      	bne.n	80111d4 <RCC_AHB1PeriphClockCmd+0x20>
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80111da:	4a07      	ldr	r2, [pc, #28]	; (80111f8 <RCC_AHB1PeriphClockCmd+0x44>)
 80111dc:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80111de:	4318      	orrs	r0, r3
 80111e0:	e005      	b.n	80111ee <RCC_AHB1PeriphClockCmd+0x3a>
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80111e2:	2900      	cmp	r1, #0
 80111e4:	d1f9      	bne.n	80111da <RCC_AHB1PeriphClockCmd+0x26>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80111e6:	4a04      	ldr	r2, [pc, #16]	; (80111f8 <RCC_AHB1PeriphClockCmd+0x44>)
 80111e8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80111ea:	ea23 0000 	bic.w	r0, r3, r0
 80111ee:	6310      	str	r0, [r2, #48]	; 0x30
  }
}
 80111f0:	b002      	add	sp, #8
 80111f2:	4770      	bx	lr
 80111f4:	810be800 	.word	0x810be800
 80111f8:	40023800 	.word	0x40023800

080111fc <RCC_APB1PeriphClockCmd>:
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
 80111fc:	4b0f      	ldr	r3, [pc, #60]	; (801123c <RCC_APB1PeriphClockCmd+0x40>)
 80111fe:	4003      	ands	r3, r0
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8011200:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
 8011202:	b92b      	cbnz	r3, 8011210 <RCC_APB1PeriphClockCmd+0x14>
 8011204:	b120      	cbz	r0, 8011210 <RCC_APB1PeriphClockCmd+0x14>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011206:	2901      	cmp	r1, #1
 8011208:	d90f      	bls.n	801122a <RCC_APB1PeriphClockCmd+0x2e>
 801120a:	2301      	movs	r3, #1
 801120c:	9301      	str	r3, [sp, #4]
 801120e:	e005      	b.n	801121c <RCC_APB1PeriphClockCmd+0x20>
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
 8011210:	2301      	movs	r3, #1
 8011212:	9300      	str	r3, [sp, #0]
 8011214:	9b00      	ldr	r3, [sp, #0]
 8011216:	2b00      	cmp	r3, #0
 8011218:	d1fc      	bne.n	8011214 <RCC_APB1PeriphClockCmd+0x18>
 801121a:	e7f4      	b.n	8011206 <RCC_APB1PeriphClockCmd+0xa>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 801121c:	9b01      	ldr	r3, [sp, #4]
 801121e:	2b00      	cmp	r3, #0
 8011220:	d1fc      	bne.n	801121c <RCC_APB1PeriphClockCmd+0x20>

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8011222:	4a07      	ldr	r2, [pc, #28]	; (8011240 <RCC_APB1PeriphClockCmd+0x44>)
 8011224:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8011226:	4318      	orrs	r0, r3
 8011228:	e005      	b.n	8011236 <RCC_APB1PeriphClockCmd+0x3a>
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 801122a:	2900      	cmp	r1, #0
 801122c:	d1f9      	bne.n	8011222 <RCC_APB1PeriphClockCmd+0x26>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 801122e:	4a04      	ldr	r2, [pc, #16]	; (8011240 <RCC_APB1PeriphClockCmd+0x44>)
 8011230:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8011232:	ea23 0000 	bic.w	r0, r3, r0
 8011236:	6410      	str	r0, [r2, #64]	; 0x40
  }
}
 8011238:	b002      	add	sp, #8
 801123a:	4770      	bx	lr
 801123c:	09013600 	.word	0x09013600
 8011240:	40023800 	.word	0x40023800

08011244 <RCC_APB2PeriphClockCmd>:
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
 8011244:	4b0f      	ldr	r3, [pc, #60]	; (8011284 <RCC_APB2PeriphClockCmd+0x40>)
 8011246:	4003      	ands	r3, r0
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8011248:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
 801124a:	b92b      	cbnz	r3, 8011258 <RCC_APB2PeriphClockCmd+0x14>
 801124c:	b120      	cbz	r0, 8011258 <RCC_APB2PeriphClockCmd+0x14>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 801124e:	2901      	cmp	r1, #1
 8011250:	d90f      	bls.n	8011272 <RCC_APB2PeriphClockCmd+0x2e>
 8011252:	2301      	movs	r3, #1
 8011254:	9301      	str	r3, [sp, #4]
 8011256:	e005      	b.n	8011264 <RCC_APB2PeriphClockCmd+0x20>
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
 8011258:	2301      	movs	r3, #1
 801125a:	9300      	str	r3, [sp, #0]
 801125c:	9b00      	ldr	r3, [sp, #0]
 801125e:	2b00      	cmp	r3, #0
 8011260:	d1fc      	bne.n	801125c <RCC_APB2PeriphClockCmd+0x18>
 8011262:	e7f4      	b.n	801124e <RCC_APB2PeriphClockCmd+0xa>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011264:	9b01      	ldr	r3, [sp, #4]
 8011266:	2b00      	cmp	r3, #0
 8011268:	d1fc      	bne.n	8011264 <RCC_APB2PeriphClockCmd+0x20>

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 801126a:	4a07      	ldr	r2, [pc, #28]	; (8011288 <RCC_APB2PeriphClockCmd+0x44>)
 801126c:	6c53      	ldr	r3, [r2, #68]	; 0x44
 801126e:	4318      	orrs	r0, r3
 8011270:	e005      	b.n	801127e <RCC_APB2PeriphClockCmd+0x3a>
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8011272:	2900      	cmp	r1, #0
 8011274:	d1f9      	bne.n	801126a <RCC_APB2PeriphClockCmd+0x26>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8011276:	4a04      	ldr	r2, [pc, #16]	; (8011288 <RCC_APB2PeriphClockCmd+0x44>)
 8011278:	6c53      	ldr	r3, [r2, #68]	; 0x44
 801127a:	ea23 0000 	bic.w	r0, r3, r0
 801127e:	6450      	str	r0, [r2, #68]	; 0x44
  }
}
 8011280:	b002      	add	sp, #8
 8011282:	4770      	bx	lr
 8011284:	fb8880cc 	.word	0xfb8880cc
 8011288:	40023800 	.word	0x40023800

0801128c <RCC_APB1PeriphResetCmd>:
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
 801128c:	4b0f      	ldr	r3, [pc, #60]	; (80112cc <RCC_APB1PeriphResetCmd+0x40>)
 801128e:	4003      	ands	r3, r0
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8011290:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
 8011292:	b92b      	cbnz	r3, 80112a0 <RCC_APB1PeriphResetCmd+0x14>
 8011294:	b120      	cbz	r0, 80112a0 <RCC_APB1PeriphResetCmd+0x14>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011296:	2901      	cmp	r1, #1
 8011298:	d90f      	bls.n	80112ba <RCC_APB1PeriphResetCmd+0x2e>
 801129a:	2301      	movs	r3, #1
 801129c:	9301      	str	r3, [sp, #4]
 801129e:	e005      	b.n	80112ac <RCC_APB1PeriphResetCmd+0x20>
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
 80112a0:	2301      	movs	r3, #1
 80112a2:	9300      	str	r3, [sp, #0]
 80112a4:	9b00      	ldr	r3, [sp, #0]
 80112a6:	2b00      	cmp	r3, #0
 80112a8:	d1fc      	bne.n	80112a4 <RCC_APB1PeriphResetCmd+0x18>
 80112aa:	e7f4      	b.n	8011296 <RCC_APB1PeriphResetCmd+0xa>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80112ac:	9b01      	ldr	r3, [sp, #4]
 80112ae:	2b00      	cmp	r3, #0
 80112b0:	d1fc      	bne.n	80112ac <RCC_APB1PeriphResetCmd+0x20>
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80112b2:	4a07      	ldr	r2, [pc, #28]	; (80112d0 <RCC_APB1PeriphResetCmd+0x44>)
 80112b4:	6a13      	ldr	r3, [r2, #32]
 80112b6:	4318      	orrs	r0, r3
 80112b8:	e005      	b.n	80112c6 <RCC_APB1PeriphResetCmd+0x3a>
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80112ba:	2900      	cmp	r1, #0
 80112bc:	d1f9      	bne.n	80112b2 <RCC_APB1PeriphResetCmd+0x26>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80112be:	4a04      	ldr	r2, [pc, #16]	; (80112d0 <RCC_APB1PeriphResetCmd+0x44>)
 80112c0:	6a13      	ldr	r3, [r2, #32]
 80112c2:	ea23 0000 	bic.w	r0, r3, r0
 80112c6:	6210      	str	r0, [r2, #32]
  }
}
 80112c8:	b002      	add	sp, #8
 80112ca:	4770      	bx	lr
 80112cc:	09013600 	.word	0x09013600
 80112d0:	40023800 	.word	0x40023800

080112d4 <RCC_APB2PeriphResetCmd>:
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
 80112d4:	4b0f      	ldr	r3, [pc, #60]	; (8011314 <RCC_APB2PeriphResetCmd+0x40>)
 80112d6:	4003      	ands	r3, r0
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80112d8:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
 80112da:	b92b      	cbnz	r3, 80112e8 <RCC_APB2PeriphResetCmd+0x14>
 80112dc:	b120      	cbz	r0, 80112e8 <RCC_APB2PeriphResetCmd+0x14>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80112de:	2901      	cmp	r1, #1
 80112e0:	d90f      	bls.n	8011302 <RCC_APB2PeriphResetCmd+0x2e>
 80112e2:	2301      	movs	r3, #1
 80112e4:	9301      	str	r3, [sp, #4]
 80112e6:	e005      	b.n	80112f4 <RCC_APB2PeriphResetCmd+0x20>
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
 80112e8:	2301      	movs	r3, #1
 80112ea:	9300      	str	r3, [sp, #0]
 80112ec:	9b00      	ldr	r3, [sp, #0]
 80112ee:	2b00      	cmp	r3, #0
 80112f0:	d1fc      	bne.n	80112ec <RCC_APB2PeriphResetCmd+0x18>
 80112f2:	e7f4      	b.n	80112de <RCC_APB2PeriphResetCmd+0xa>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80112f4:	9b01      	ldr	r3, [sp, #4]
 80112f6:	2b00      	cmp	r3, #0
 80112f8:	d1fc      	bne.n	80112f4 <RCC_APB2PeriphResetCmd+0x20>
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80112fa:	4a07      	ldr	r2, [pc, #28]	; (8011318 <RCC_APB2PeriphResetCmd+0x44>)
 80112fc:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80112fe:	4318      	orrs	r0, r3
 8011300:	e005      	b.n	801130e <RCC_APB2PeriphResetCmd+0x3a>
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8011302:	2900      	cmp	r1, #0
 8011304:	d1f9      	bne.n	80112fa <RCC_APB2PeriphResetCmd+0x26>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8011306:	4a04      	ldr	r2, [pc, #16]	; (8011318 <RCC_APB2PeriphResetCmd+0x44>)
 8011308:	6a53      	ldr	r3, [r2, #36]	; 0x24
 801130a:	ea23 0000 	bic.w	r0, r3, r0
 801130e:	6250      	str	r0, [r2, #36]	; 0x24
  }
}
 8011310:	b002      	add	sp, #8
 8011312:	4770      	bx	lr
 8011314:	fb8886cc 	.word	0xfb8886cc
 8011318:	40023800 	.word	0x40023800

0801131c <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 801131c:	b570      	push	{r4, r5, r6, lr}
  uint32_t integerdivider = 0x00;
  uint32_t fractionaldivider = 0x00;
  RCC_ClocksTypeDef RCC_ClocksStatus;

  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 801131e:	4e68      	ldr	r6, [pc, #416]	; (80114c0 <USART_Init+0x1a4>)
 8011320:	42b0      	cmp	r0, r6
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8011322:	b08c      	sub	sp, #48	; 0x30
 8011324:	4604      	mov	r4, r0
 8011326:	460d      	mov	r5, r1
  uint32_t integerdivider = 0x00;
  uint32_t fractionaldivider = 0x00;
  RCC_ClocksTypeDef RCC_ClocksStatus;

  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011328:	d105      	bne.n	8011336 <USART_Init+0x1a>
  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 801132a:	682b      	ldr	r3, [r5, #0]
 801132c:	4a65      	ldr	r2, [pc, #404]	; (80114c4 <USART_Init+0x1a8>)
 801132e:	3b01      	subs	r3, #1
 8011330:	4293      	cmp	r3, r2
 8011332:	d821      	bhi.n	8011378 <USART_Init+0x5c>
 8011334:	e025      	b.n	8011382 <USART_Init+0x66>
  uint32_t integerdivider = 0x00;
  uint32_t fractionaldivider = 0x00;
  RCC_ClocksTypeDef RCC_ClocksStatus;

  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011336:	4b64      	ldr	r3, [pc, #400]	; (80114c8 <USART_Init+0x1ac>)
 8011338:	4298      	cmp	r0, r3
 801133a:	d0f6      	beq.n	801132a <USART_Init+0xe>
 801133c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011340:	4298      	cmp	r0, r3
 8011342:	d0f2      	beq.n	801132a <USART_Init+0xe>
 8011344:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011348:	4298      	cmp	r0, r3
 801134a:	d0ee      	beq.n	801132a <USART_Init+0xe>
 801134c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011350:	4298      	cmp	r0, r3
 8011352:	d0ea      	beq.n	801132a <USART_Init+0xe>
 8011354:	f503 4344 	add.w	r3, r3, #50176	; 0xc400
 8011358:	4298      	cmp	r0, r3
 801135a:	d0e6      	beq.n	801132a <USART_Init+0xe>
 801135c:	f5a3 431c 	sub.w	r3, r3, #39936	; 0x9c00
 8011360:	4298      	cmp	r0, r3
 8011362:	d0e2      	beq.n	801132a <USART_Init+0xe>
 8011364:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011368:	4298      	cmp	r0, r3
 801136a:	d0de      	beq.n	801132a <USART_Init+0xe>
 801136c:	2301      	movs	r3, #1
 801136e:	9300      	str	r3, [sp, #0]
 8011370:	9b00      	ldr	r3, [sp, #0]
 8011372:	2b00      	cmp	r3, #0
 8011374:	d1fc      	bne.n	8011370 <USART_Init+0x54>
 8011376:	e7d8      	b.n	801132a <USART_Init+0xe>
  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 8011378:	2301      	movs	r3, #1
 801137a:	9301      	str	r3, [sp, #4]
 801137c:	9b01      	ldr	r3, [sp, #4]
 801137e:	2b00      	cmp	r3, #0
 8011380:	d1fc      	bne.n	801137c <USART_Init+0x60>
  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 8011382:	88ab      	ldrh	r3, [r5, #4]
 8011384:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8011388:	b29b      	uxth	r3, r3
 801138a:	b123      	cbz	r3, 8011396 <USART_Init+0x7a>
 801138c:	2301      	movs	r3, #1
 801138e:	9302      	str	r3, [sp, #8]
 8011390:	9b02      	ldr	r3, [sp, #8]
 8011392:	2b00      	cmp	r3, #0
 8011394:	d1fc      	bne.n	8011390 <USART_Init+0x74>
  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 8011396:	88e9      	ldrh	r1, [r5, #6]
 8011398:	f421 5340 	bic.w	r3, r1, #12288	; 0x3000
 801139c:	b123      	cbz	r3, 80113a8 <USART_Init+0x8c>
 801139e:	2301      	movs	r3, #1
 80113a0:	9303      	str	r3, [sp, #12]
 80113a2:	9b03      	ldr	r3, [sp, #12]
 80113a4:	2b00      	cmp	r3, #0
 80113a6:	d1fc      	bne.n	80113a2 <USART_Init+0x86>
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 80113a8:	892b      	ldrh	r3, [r5, #8]
 80113aa:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 80113ae:	b13a      	cbz	r2, 80113c0 <USART_Init+0xa4>
 80113b0:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80113b4:	d004      	beq.n	80113c0 <USART_Init+0xa4>
 80113b6:	2301      	movs	r3, #1
 80113b8:	9304      	str	r3, [sp, #16]
 80113ba:	9b04      	ldr	r3, [sp, #16]
 80113bc:	2b00      	cmp	r3, #0
 80113be:	d1fc      	bne.n	80113ba <USART_Init+0x9e>
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 80113c0:	896b      	ldrh	r3, [r5, #10]
 80113c2:	f023 020c 	bic.w	r2, r3, #12
 80113c6:	b91a      	cbnz	r2, 80113d0 <USART_Init+0xb4>
 80113c8:	b113      	cbz	r3, 80113d0 <USART_Init+0xb4>
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 80113ca:	89aa      	ldrh	r2, [r5, #12]
 80113cc:	b932      	cbnz	r2, 80113dc <USART_Init+0xc0>
 80113ce:	e00f      	b.n	80113f0 <USART_Init+0xd4>
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 80113d0:	2301      	movs	r3, #1
 80113d2:	9305      	str	r3, [sp, #20]
 80113d4:	9b05      	ldr	r3, [sp, #20]
 80113d6:	2b00      	cmp	r3, #0
 80113d8:	d1fc      	bne.n	80113d4 <USART_Init+0xb8>
 80113da:	e7f6      	b.n	80113ca <USART_Init+0xae>
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 80113dc:	f422 7300 	bic.w	r3, r2, #512	; 0x200
 80113e0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80113e4:	d125      	bne.n	8011432 <USART_Init+0x116>

  /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 80113e6:	42b4      	cmp	r4, r6
 80113e8:	d002      	beq.n	80113f0 <USART_Init+0xd4>
 80113ea:	4b37      	ldr	r3, [pc, #220]	; (80114c8 <USART_Init+0x1ac>)
 80113ec:	429c      	cmp	r4, r3
 80113ee:	d159      	bne.n	80114a4 <USART_Init+0x188>
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80113f0:	8a23      	ldrh	r3, [r4, #16]
 80113f2:	b29b      	uxth	r3, r3

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80113f4:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80113f8:	430b      	orrs	r3, r1
 80113fa:	8223      	strh	r3, [r4, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80113fc:	89a3      	ldrh	r3, [r4, #12]
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80113fe:	88a9      	ldrh	r1, [r5, #4]
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8011400:	b29b      	uxth	r3, r3

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8011402:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8011406:	f023 020c 	bic.w	r2, r3, #12
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 801140a:	892b      	ldrh	r3, [r5, #8]
 801140c:	430b      	orrs	r3, r1
 801140e:	8969      	ldrh	r1, [r5, #10]
 8011410:	430b      	orrs	r3, r1
 8011412:	b29b      	uxth	r3, r3
 8011414:	4313      	orrs	r3, r2
 8011416:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8011418:	8aa3      	ldrh	r3, [r4, #20]
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 801141a:	89aa      	ldrh	r2, [r5, #12]

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 801141c:	b29b      	uxth	r3, r3

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 801141e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8011422:	4313      	orrs	r3, r2
 8011424:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8011426:	a808      	add	r0, sp, #32
 8011428:	f7ff fe80 	bl	801112c <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 801142c:	42b4      	cmp	r4, r6
 801142e:	d109      	bne.n	8011444 <USART_Init+0x128>
 8011430:	e00b      	b.n	801144a <USART_Init+0x12e>
  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 8011432:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8011436:	d0d6      	beq.n	80113e6 <USART_Init+0xca>
 8011438:	2301      	movs	r3, #1
 801143a:	9306      	str	r3, [sp, #24]
 801143c:	9b06      	ldr	r3, [sp, #24]
 801143e:	2b00      	cmp	r3, #0
 8011440:	d1fc      	bne.n	801143c <USART_Init+0x120>
 8011442:	e7d0      	b.n	80113e6 <USART_Init+0xca>

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);

  if ((USARTx == USART1) || (USARTx == USART6))
 8011444:	4b21      	ldr	r3, [pc, #132]	; (80114cc <USART_Init+0x1b0>)
 8011446:	429c      	cmp	r4, r3
 8011448:	d101      	bne.n	801144e <USART_Init+0x132>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 801144a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801144c:	e000      	b.n	8011450 <USART_Init+0x134>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 801144e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8011450:	89a2      	ldrh	r2, [r4, #12]
 8011452:	6829      	ldr	r1, [r5, #0]
 8011454:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 8011458:	f04f 0219 	mov.w	r2, #25
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 801145c:	fb02 f203 	mul.w	r2, r2, r3
 8011460:	bf14      	ite	ne
 8011462:	004d      	lslne	r5, r1, #1
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8011464:	008d      	lsleq	r5, r1, #2
 8011466:	fbb2 f5f5 	udiv	r5, r2, r5

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 801146a:	89a2      	ldrh	r2, [r4, #12]
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;
 801146c:	2664      	movs	r6, #100	; 0x64
 801146e:	fbb5 f0f6 	udiv	r0, r5, r6
 8011472:	0100      	lsls	r0, r0, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8011474:	0901      	lsrs	r1, r0, #4

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8011476:	0412      	lsls	r2, r2, #16
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8011478:	fb06 5311 	mls	r3, r6, r1, r5

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 801147c:	d507      	bpl.n	801148e <USART_Init+0x172>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 801147e:	00d9      	lsls	r1, r3, #3
 8011480:	3132      	adds	r1, #50	; 0x32
 8011482:	fbb1 f2f6 	udiv	r2, r1, r6
 8011486:	f002 0207 	and.w	r2, r2, #7
 801148a:	4310      	orrs	r0, r2
 801148c:	e006      	b.n	801149c <USART_Init+0x180>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 801148e:	011a      	lsls	r2, r3, #4
 8011490:	3232      	adds	r2, #50	; 0x32
 8011492:	fbb2 f3f6 	udiv	r3, r2, r6
 8011496:	f003 030f 	and.w	r3, r3, #15
 801149a:	4318      	orrs	r0, r3
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 801149c:	b280      	uxth	r0, r0
 801149e:	8120      	strh	r0, [r4, #8]
}
 80114a0:	b00c      	add	sp, #48	; 0x30
 80114a2:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));

  /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 80114a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80114a8:	429c      	cmp	r4, r3
 80114aa:	d0a1      	beq.n	80113f0 <USART_Init+0xd4>
 80114ac:	f503 434c 	add.w	r3, r3, #52224	; 0xcc00
 80114b0:	429c      	cmp	r4, r3
 80114b2:	d09d      	beq.n	80113f0 <USART_Init+0xd4>
 80114b4:	2301      	movs	r3, #1
 80114b6:	9307      	str	r3, [sp, #28]
 80114b8:	9b07      	ldr	r3, [sp, #28]
 80114ba:	2b00      	cmp	r3, #0
 80114bc:	d1fc      	bne.n	80114b8 <USART_Init+0x19c>
 80114be:	e797      	b.n	80113f0 <USART_Init+0xd4>
 80114c0:	40011000 	.word	0x40011000
 80114c4:	007270df 	.word	0x007270df
 80114c8:	40004400 	.word	0x40004400
 80114cc:	40011400 	.word	0x40011400

080114d0 <USART_Cmd>:
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 80114d0:	4b1d      	ldr	r3, [pc, #116]	; (8011548 <USART_Cmd+0x78>)
 80114d2:	4298      	cmp	r0, r3
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80114d4:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 80114d6:	d104      	bne.n	80114e2 <USART_Cmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80114d8:	2901      	cmp	r1, #1
 80114da:	d92b      	bls.n	8011534 <USART_Cmd+0x64>
 80114dc:	2301      	movs	r3, #1
 80114de:	9301      	str	r3, [sp, #4]
 80114e0:	e020      	b.n	8011524 <USART_Cmd+0x54>
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 80114e2:	4b1a      	ldr	r3, [pc, #104]	; (801154c <USART_Cmd+0x7c>)
 80114e4:	4298      	cmp	r0, r3
 80114e6:	d0f7      	beq.n	80114d8 <USART_Cmd+0x8>
 80114e8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80114ec:	4298      	cmp	r0, r3
 80114ee:	d0f3      	beq.n	80114d8 <USART_Cmd+0x8>
 80114f0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80114f4:	4298      	cmp	r0, r3
 80114f6:	d0ef      	beq.n	80114d8 <USART_Cmd+0x8>
 80114f8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80114fc:	4298      	cmp	r0, r3
 80114fe:	d0eb      	beq.n	80114d8 <USART_Cmd+0x8>
 8011500:	f503 4344 	add.w	r3, r3, #50176	; 0xc400
 8011504:	4298      	cmp	r0, r3
 8011506:	d0e7      	beq.n	80114d8 <USART_Cmd+0x8>
 8011508:	f5a3 431c 	sub.w	r3, r3, #39936	; 0x9c00
 801150c:	4298      	cmp	r0, r3
 801150e:	d0e3      	beq.n	80114d8 <USART_Cmd+0x8>
 8011510:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011514:	4298      	cmp	r0, r3
 8011516:	d0df      	beq.n	80114d8 <USART_Cmd+0x8>
 8011518:	2301      	movs	r3, #1
 801151a:	9300      	str	r3, [sp, #0]
 801151c:	9b00      	ldr	r3, [sp, #0]
 801151e:	2b00      	cmp	r3, #0
 8011520:	d1fc      	bne.n	801151c <USART_Cmd+0x4c>
 8011522:	e7d9      	b.n	80114d8 <USART_Cmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011524:	9b01      	ldr	r3, [sp, #4]
 8011526:	2b00      	cmp	r3, #0
 8011528:	d1fc      	bne.n	8011524 <USART_Cmd+0x54>
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 801152a:	8983      	ldrh	r3, [r0, #12]
 801152c:	b29b      	uxth	r3, r3
 801152e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8011532:	e006      	b.n	8011542 <USART_Cmd+0x72>
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8011534:	2900      	cmp	r1, #0
 8011536:	d1f8      	bne.n	801152a <USART_Cmd+0x5a>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8011538:	8983      	ldrh	r3, [r0, #12]
 801153a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 801153e:	041b      	lsls	r3, r3, #16
 8011540:	0c1b      	lsrs	r3, r3, #16
 8011542:	8183      	strh	r3, [r0, #12]
  }
}
 8011544:	b002      	add	sp, #8
 8011546:	4770      	bx	lr
 8011548:	40011000 	.word	0x40011000
 801154c:	40004400 	.word	0x40004400

08011550 <USART_SendData>:
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011550:	4b19      	ldr	r3, [pc, #100]	; (80115b8 <USART_SendData+0x68>)
 8011552:	4298      	cmp	r0, r3
  *         UART peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8011554:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011556:	d103      	bne.n	8011560 <USART_SendData+0x10>
  assert_param(IS_USART_DATA(Data)); 
 8011558:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 801155c:	d221      	bcs.n	80115a2 <USART_SendData+0x52>
 801155e:	e025      	b.n	80115ac <USART_SendData+0x5c>
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011560:	4b16      	ldr	r3, [pc, #88]	; (80115bc <USART_SendData+0x6c>)
 8011562:	4298      	cmp	r0, r3
 8011564:	d0f8      	beq.n	8011558 <USART_SendData+0x8>
 8011566:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801156a:	4298      	cmp	r0, r3
 801156c:	d0f4      	beq.n	8011558 <USART_SendData+0x8>
 801156e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011572:	4298      	cmp	r0, r3
 8011574:	d0f0      	beq.n	8011558 <USART_SendData+0x8>
 8011576:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801157a:	4298      	cmp	r0, r3
 801157c:	d0ec      	beq.n	8011558 <USART_SendData+0x8>
 801157e:	f503 4344 	add.w	r3, r3, #50176	; 0xc400
 8011582:	4298      	cmp	r0, r3
 8011584:	d0e8      	beq.n	8011558 <USART_SendData+0x8>
 8011586:	f5a3 431c 	sub.w	r3, r3, #39936	; 0x9c00
 801158a:	4298      	cmp	r0, r3
 801158c:	d0e4      	beq.n	8011558 <USART_SendData+0x8>
 801158e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011592:	4298      	cmp	r0, r3
 8011594:	d0e0      	beq.n	8011558 <USART_SendData+0x8>
 8011596:	2301      	movs	r3, #1
 8011598:	9300      	str	r3, [sp, #0]
 801159a:	9b00      	ldr	r3, [sp, #0]
 801159c:	2b00      	cmp	r3, #0
 801159e:	d1fc      	bne.n	801159a <USART_SendData+0x4a>
 80115a0:	e7da      	b.n	8011558 <USART_SendData+0x8>
  assert_param(IS_USART_DATA(Data)); 
 80115a2:	2301      	movs	r3, #1
 80115a4:	9301      	str	r3, [sp, #4]
 80115a6:	9b01      	ldr	r3, [sp, #4]
 80115a8:	2b00      	cmp	r3, #0
 80115aa:	d1fc      	bne.n	80115a6 <USART_SendData+0x56>
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 80115ac:	f3c1 0108 	ubfx	r1, r1, #0, #9
 80115b0:	8081      	strh	r1, [r0, #4]
}
 80115b2:	b002      	add	sp, #8
 80115b4:	4770      	bx	lr
 80115b6:	bf00      	nop
 80115b8:	40011000 	.word	0x40011000
 80115bc:	40004400 	.word	0x40004400

080115c0 <USART_ReceiveData>:
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 80115c0:	4b14      	ldr	r3, [pc, #80]	; (8011614 <USART_ReceiveData+0x54>)
 80115c2:	4298      	cmp	r0, r3
  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
  *         UART peripheral.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
 80115c4:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 80115c6:	d020      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115c8:	f5a3 434c 	sub.w	r3, r3, #52224	; 0xcc00
 80115cc:	4298      	cmp	r0, r3
 80115ce:	d01c      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115d0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80115d4:	4298      	cmp	r0, r3
 80115d6:	d018      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115d8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80115dc:	4298      	cmp	r0, r3
 80115de:	d014      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115e0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80115e4:	4298      	cmp	r0, r3
 80115e6:	d010      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115e8:	f503 4344 	add.w	r3, r3, #50176	; 0xc400
 80115ec:	4298      	cmp	r0, r3
 80115ee:	d00c      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115f0:	f5a3 431c 	sub.w	r3, r3, #39936	; 0x9c00
 80115f4:	4298      	cmp	r0, r3
 80115f6:	d008      	beq.n	801160a <USART_ReceiveData+0x4a>
 80115f8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80115fc:	4298      	cmp	r0, r3
 80115fe:	d004      	beq.n	801160a <USART_ReceiveData+0x4a>
 8011600:	2301      	movs	r3, #1
 8011602:	9301      	str	r3, [sp, #4]
 8011604:	9b01      	ldr	r3, [sp, #4]
 8011606:	2b00      	cmp	r3, #0
 8011608:	d1fc      	bne.n	8011604 <USART_ReceiveData+0x44>
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 801160a:	8880      	ldrh	r0, [r0, #4]
 801160c:	f3c0 0008 	ubfx	r0, r0, #0, #9
}
 8011610:	b002      	add	sp, #8
 8011612:	4770      	bx	lr
 8011614:	40011000 	.word	0x40011000

08011618 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8011618:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  uint32_t usartxbase = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 801161a:	4b4b      	ldr	r3, [pc, #300]	; (8011748 <USART_ITConfig+0x130>)
 801161c:	4298      	cmp	r0, r3
 801161e:	461c      	mov	r4, r3
 8011620:	d102      	bne.n	8011628 <USART_ITConfig+0x10>
  assert_param(IS_USART_CONFIG_IT(USART_IT));
 8011622:	2928      	cmp	r1, #40	; 0x28
 8011624:	d121      	bne.n	801166a <USART_ITConfig+0x52>
 8011626:	e055      	b.n	80116d4 <USART_ITConfig+0xbc>
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  uint32_t usartxbase = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011628:	4b48      	ldr	r3, [pc, #288]	; (801174c <USART_ITConfig+0x134>)
 801162a:	4298      	cmp	r0, r3
 801162c:	d0f9      	beq.n	8011622 <USART_ITConfig+0xa>
 801162e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011632:	4298      	cmp	r0, r3
 8011634:	d0f5      	beq.n	8011622 <USART_ITConfig+0xa>
 8011636:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801163a:	4298      	cmp	r0, r3
 801163c:	d0f1      	beq.n	8011622 <USART_ITConfig+0xa>
 801163e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011642:	4298      	cmp	r0, r3
 8011644:	d0ed      	beq.n	8011622 <USART_ITConfig+0xa>
 8011646:	f503 4344 	add.w	r3, r3, #50176	; 0xc400
 801164a:	4298      	cmp	r0, r3
 801164c:	d0e9      	beq.n	8011622 <USART_ITConfig+0xa>
 801164e:	f5a3 431c 	sub.w	r3, r3, #39936	; 0x9c00
 8011652:	4298      	cmp	r0, r3
 8011654:	d0e5      	beq.n	8011622 <USART_ITConfig+0xa>
 8011656:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801165a:	4298      	cmp	r0, r3
 801165c:	d0e1      	beq.n	8011622 <USART_ITConfig+0xa>
 801165e:	2301      	movs	r3, #1
 8011660:	9300      	str	r3, [sp, #0]
 8011662:	9b00      	ldr	r3, [sp, #0]
 8011664:	2b00      	cmp	r3, #0
 8011666:	d1fc      	bne.n	8011662 <USART_ITConfig+0x4a>
 8011668:	e7db      	b.n	8011622 <USART_ITConfig+0xa>
  assert_param(IS_USART_CONFIG_IT(USART_IT));
 801166a:	f240 7327 	movw	r3, #1831	; 0x727
 801166e:	4299      	cmp	r1, r3
 8011670:	d030      	beq.n	80116d4 <USART_ITConfig+0xbc>
 8011672:	f240 6326 	movw	r3, #1574	; 0x626
 8011676:	4299      	cmp	r1, r3
 8011678:	d02c      	beq.n	80116d4 <USART_ITConfig+0xbc>
 801167a:	f240 5325 	movw	r3, #1317	; 0x525
 801167e:	4299      	cmp	r1, r3
 8011680:	d028      	beq.n	80116d4 <USART_ITConfig+0xbc>
 8011682:	f240 4324 	movw	r3, #1060	; 0x424
 8011686:	4299      	cmp	r1, r3
 8011688:	d024      	beq.n	80116d4 <USART_ITConfig+0xbc>
 801168a:	f640 0346 	movw	r3, #2118	; 0x846
 801168e:	4299      	cmp	r1, r3
 8011690:	d055      	beq.n	801173e <USART_ITConfig+0x126>
 8011692:	f640 136a 	movw	r3, #2410	; 0x96a
 8011696:	4299      	cmp	r1, r3
 8011698:	d029      	beq.n	80116ee <USART_ITConfig+0xd6>
 801169a:	2960      	cmp	r1, #96	; 0x60
 801169c:	f04f 0301 	mov.w	r3, #1
 80116a0:	d049      	beq.n	8011736 <USART_ITConfig+0x11e>
 80116a2:	9301      	str	r3, [sp, #4]
 80116a4:	9b01      	ldr	r3, [sp, #4]
 80116a6:	2b00      	cmp	r3, #0
 80116a8:	d1fc      	bne.n	80116a4 <USART_ITConfig+0x8c>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80116aa:	2a01      	cmp	r2, #1
 80116ac:	d908      	bls.n	80116c0 <USART_ITConfig+0xa8>
 80116ae:	2301      	movs	r3, #1
 80116b0:	9302      	str	r3, [sp, #8]
 80116b2:	9b02      	ldr	r3, [sp, #8]
 80116b4:	2b00      	cmp	r3, #0
 80116b6:	d1fc      	bne.n	80116b2 <USART_ITConfig+0x9a>

  /* The CTS interrupt is not available for UART4 and UART5 */
  if (USART_IT == USART_IT_CTS)
 80116b8:	f640 136a 	movw	r3, #2410	; 0x96a
 80116bc:	4299      	cmp	r1, r3
 80116be:	d018      	beq.n	80116f2 <USART_ITConfig+0xda>
  } 
    
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 80116c0:	f3c1 1442 	ubfx	r4, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80116c4:	2301      	movs	r3, #1
 80116c6:	f001 011f 	and.w	r1, r1, #31
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80116ca:	429c      	cmp	r4, r3
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80116cc:	fa03 f101 	lsl.w	r1, r3, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80116d0:	d109      	bne.n	80116e6 <USART_ITConfig+0xce>
 80116d2:	e006      	b.n	80116e2 <USART_ITConfig+0xca>
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  uint32_t usartxbase = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CONFIG_IT(USART_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80116d4:	2a01      	cmp	r2, #1
 80116d6:	d8ea      	bhi.n	80116ae <USART_ITConfig+0x96>
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80116d8:	f001 011f 	and.w	r1, r1, #31
 80116dc:	2301      	movs	r3, #1
 80116de:	fa03 f101 	lsl.w	r1, r3, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
  {
    usartxbase += 0x0C;
 80116e2:	300c      	adds	r0, #12
 80116e4:	e00d      	b.n	8011702 <USART_ITConfig+0xea>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 80116e6:	2c02      	cmp	r4, #2
 80116e8:	d10a      	bne.n	8011700 <USART_ITConfig+0xe8>
  {
    usartxbase += 0x10;
 80116ea:	3010      	adds	r0, #16
 80116ec:	e009      	b.n	8011702 <USART_ITConfig+0xea>
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  uint32_t usartxbase = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CONFIG_IT(USART_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80116ee:	2a01      	cmp	r2, #1
 80116f0:	d8dd      	bhi.n	80116ae <USART_ITConfig+0x96>

  /* The CTS interrupt is not available for UART4 and UART5 */
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 80116f2:	42a0      	cmp	r0, r4
 80116f4:	d10e      	bne.n	8011714 <USART_ITConfig+0xfc>
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80116f6:	f001 011f 	and.w	r1, r1, #31
 80116fa:	2301      	movs	r3, #1
 80116fc:	fa03 f101 	lsl.w	r1, r3, r1
  {
    usartxbase += 0x10;
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8011700:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8011702:	6803      	ldr	r3, [r0, #0]
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
 8011704:	b10a      	cbz	r2, 801170a <USART_ITConfig+0xf2>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8011706:	4319      	orrs	r1, r3
 8011708:	e001      	b.n	801170e <USART_ITConfig+0xf6>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 801170a:	ea23 0101 	bic.w	r1, r3, r1
 801170e:	6001      	str	r1, [r0, #0]
  }
}
 8011710:	b004      	add	sp, #16
 8011712:	bd10      	pop	{r4, pc}
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* The CTS interrupt is not available for UART4 and UART5 */
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 8011714:	4b0d      	ldr	r3, [pc, #52]	; (801174c <USART_ITConfig+0x134>)
 8011716:	4298      	cmp	r0, r3
 8011718:	d0d2      	beq.n	80116c0 <USART_ITConfig+0xa8>
 801171a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801171e:	4298      	cmp	r0, r3
 8011720:	d0ce      	beq.n	80116c0 <USART_ITConfig+0xa8>
 8011722:	f503 434c 	add.w	r3, r3, #52224	; 0xcc00
 8011726:	4298      	cmp	r0, r3
 8011728:	d0ca      	beq.n	80116c0 <USART_ITConfig+0xa8>
 801172a:	2301      	movs	r3, #1
 801172c:	9303      	str	r3, [sp, #12]
 801172e:	9b03      	ldr	r3, [sp, #12]
 8011730:	2b00      	cmp	r3, #0
 8011732:	d1fc      	bne.n	801172e <USART_ITConfig+0x116>
 8011734:	e7c4      	b.n	80116c0 <USART_ITConfig+0xa8>
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  uint32_t usartxbase = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CONFIG_IT(USART_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011736:	2a01      	cmp	r2, #1
 8011738:	d8b9      	bhi.n	80116ae <USART_ITConfig+0x96>
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 801173a:	4619      	mov	r1, r3
 801173c:	e7e0      	b.n	8011700 <USART_ITConfig+0xe8>
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
  uint32_t usartxbase = 0x00;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CONFIG_IT(USART_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 801173e:	2a01      	cmp	r2, #1
 8011740:	d8b5      	bhi.n	80116ae <USART_ITConfig+0x96>
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 8011742:	2140      	movs	r1, #64	; 0x40
 8011744:	e7d1      	b.n	80116ea <USART_ITConfig+0xd2>
 8011746:	bf00      	nop
 8011748:	40011000 	.word	0x40011000
 801174c:	40004400 	.word	0x40004400

08011750 <USART_GetFlagStatus>:
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011750:	4b2d      	ldr	r3, [pc, #180]	; (8011808 <USART_GetFlagStatus+0xb8>)
 8011752:	4298      	cmp	r0, r3
  *            @arg USART_FLAG_FE:   Framing Error flag
  *            @arg USART_FLAG_PE:   Parity Error flag
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 8011754:	b084      	sub	sp, #16
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011756:	d102      	bne.n	801175e <USART_GetFlagStatus+0xe>
  assert_param(IS_USART_FLAG(USART_FLAG));
 8011758:	2901      	cmp	r1, #1
 801175a:	d121      	bne.n	80117a0 <USART_GetFlagStatus+0x50>
 801175c:	e04d      	b.n	80117fa <USART_GetFlagStatus+0xaa>
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 801175e:	4a2b      	ldr	r2, [pc, #172]	; (801180c <USART_GetFlagStatus+0xbc>)
 8011760:	4290      	cmp	r0, r2
 8011762:	d0f9      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 8011764:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011768:	4290      	cmp	r0, r2
 801176a:	d0f5      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 801176c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011770:	4290      	cmp	r0, r2
 8011772:	d0f1      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 8011774:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011778:	4290      	cmp	r0, r2
 801177a:	d0ed      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 801177c:	f502 4244 	add.w	r2, r2, #50176	; 0xc400
 8011780:	4290      	cmp	r0, r2
 8011782:	d0e9      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 8011784:	f5a2 421c 	sub.w	r2, r2, #39936	; 0x9c00
 8011788:	4290      	cmp	r0, r2
 801178a:	d0e5      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 801178c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011790:	4290      	cmp	r0, r2
 8011792:	d0e1      	beq.n	8011758 <USART_GetFlagStatus+0x8>
 8011794:	2201      	movs	r2, #1
 8011796:	9201      	str	r2, [sp, #4]
 8011798:	9a01      	ldr	r2, [sp, #4]
 801179a:	2a00      	cmp	r2, #0
 801179c:	d1fc      	bne.n	8011798 <USART_GetFlagStatus+0x48>
 801179e:	e7db      	b.n	8011758 <USART_GetFlagStatus+0x8>
  assert_param(IS_USART_FLAG(USART_FLAG));
 80117a0:	2980      	cmp	r1, #128	; 0x80
 80117a2:	d02a      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117a4:	2940      	cmp	r1, #64	; 0x40
 80117a6:	d028      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117a8:	2920      	cmp	r1, #32
 80117aa:	d026      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117ac:	2910      	cmp	r1, #16
 80117ae:	d024      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117b0:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 80117b4:	d021      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117b6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80117ba:	d00c      	beq.n	80117d6 <USART_GetFlagStatus+0x86>
 80117bc:	2908      	cmp	r1, #8
 80117be:	d804      	bhi.n	80117ca <USART_GetFlagStatus+0x7a>
 80117c0:	f44f 738a 	mov.w	r3, #276	; 0x114
 80117c4:	40cb      	lsrs	r3, r1
 80117c6:	07db      	lsls	r3, r3, #31
 80117c8:	d417      	bmi.n	80117fa <USART_GetFlagStatus+0xaa>
 80117ca:	2301      	movs	r3, #1
 80117cc:	9302      	str	r3, [sp, #8]
 80117ce:	9b02      	ldr	r3, [sp, #8]
 80117d0:	2b00      	cmp	r3, #0
 80117d2:	d1fc      	bne.n	80117ce <USART_GetFlagStatus+0x7e>
 80117d4:	e011      	b.n	80117fa <USART_GetFlagStatus+0xaa>

  /* The CTS flag is not available for UART4 and UART5 */
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 80117d6:	4298      	cmp	r0, r3
 80117d8:	d00f      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117da:	4b0c      	ldr	r3, [pc, #48]	; (801180c <USART_GetFlagStatus+0xbc>)
 80117dc:	4298      	cmp	r0, r3
 80117de:	d00c      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117e0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80117e4:	4298      	cmp	r0, r3
 80117e6:	d008      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117e8:	f503 434c 	add.w	r3, r3, #52224	; 0xcc00
 80117ec:	4298      	cmp	r0, r3
 80117ee:	d004      	beq.n	80117fa <USART_GetFlagStatus+0xaa>
 80117f0:	2301      	movs	r3, #1
 80117f2:	9303      	str	r3, [sp, #12]
 80117f4:	9b03      	ldr	r3, [sp, #12]
 80117f6:	2b00      	cmp	r3, #0
 80117f8:	d1fc      	bne.n	80117f4 <USART_GetFlagStatus+0xa4>
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 80117fa:	8803      	ldrh	r3, [r0, #0]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 80117fc:	4219      	tst	r1, r3
 80117fe:	bf14      	ite	ne
 8011800:	2001      	movne	r0, #1
 8011802:	2000      	moveq	r0, #0
}
 8011804:	b004      	add	sp, #16
 8011806:	4770      	bx	lr
 8011808:	40011000 	.word	0x40011000
 801180c:	40004400 	.word	0x40004400

08011810 <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8011810:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 8011812:	4b47      	ldr	r3, [pc, #284]	; (8011930 <USART_GetITStatus+0x120>)
 8011814:	4298      	cmp	r0, r3
 8011816:	d102      	bne.n	801181e <USART_GetITStatus+0xe>
  assert_param(IS_USART_GET_IT(USART_IT)); 
 8011818:	2928      	cmp	r1, #40	; 0x28
 801181a:	d121      	bne.n	8011860 <USART_GetITStatus+0x50>
 801181c:	e064      	b.n	80118e8 <USART_GetITStatus+0xd8>
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
 801181e:	4a45      	ldr	r2, [pc, #276]	; (8011934 <USART_GetITStatus+0x124>)
 8011820:	4290      	cmp	r0, r2
 8011822:	d0f9      	beq.n	8011818 <USART_GetITStatus+0x8>
 8011824:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011828:	4290      	cmp	r0, r2
 801182a:	d0f5      	beq.n	8011818 <USART_GetITStatus+0x8>
 801182c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011830:	4290      	cmp	r0, r2
 8011832:	d0f1      	beq.n	8011818 <USART_GetITStatus+0x8>
 8011834:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011838:	4290      	cmp	r0, r2
 801183a:	d0ed      	beq.n	8011818 <USART_GetITStatus+0x8>
 801183c:	f502 4244 	add.w	r2, r2, #50176	; 0xc400
 8011840:	4290      	cmp	r0, r2
 8011842:	d0e9      	beq.n	8011818 <USART_GetITStatus+0x8>
 8011844:	f5a2 421c 	sub.w	r2, r2, #39936	; 0x9c00
 8011848:	4290      	cmp	r0, r2
 801184a:	d0e5      	beq.n	8011818 <USART_GetITStatus+0x8>
 801184c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8011850:	4290      	cmp	r0, r2
 8011852:	d0e1      	beq.n	8011818 <USART_GetITStatus+0x8>
 8011854:	2201      	movs	r2, #1
 8011856:	9201      	str	r2, [sp, #4]
 8011858:	9a01      	ldr	r2, [sp, #4]
 801185a:	2a00      	cmp	r2, #0
 801185c:	d1fc      	bne.n	8011858 <USART_GetITStatus+0x48>
 801185e:	e7db      	b.n	8011818 <USART_GetITStatus+0x8>
  assert_param(IS_USART_GET_IT(USART_IT)); 
 8011860:	f240 7227 	movw	r2, #1831	; 0x727
 8011864:	4291      	cmp	r1, r2
 8011866:	d05b      	beq.n	8011920 <USART_GetITStatus+0x110>
 8011868:	f240 6226 	movw	r2, #1574	; 0x626
 801186c:	4291      	cmp	r1, r2
 801186e:	d057      	beq.n	8011920 <USART_GetITStatus+0x110>
 8011870:	f240 5225 	movw	r2, #1317	; 0x525
 8011874:	4291      	cmp	r1, r2
 8011876:	d053      	beq.n	8011920 <USART_GetITStatus+0x110>
 8011878:	f240 4224 	movw	r2, #1060	; 0x424
 801187c:	4291      	cmp	r1, r2
 801187e:	d04f      	beq.n	8011920 <USART_GetITStatus+0x110>
 8011880:	f640 0246 	movw	r2, #2118	; 0x846
 8011884:	4291      	cmp	r1, r2
 8011886:	d015      	beq.n	80118b4 <USART_GetITStatus+0xa4>
 8011888:	f640 126a 	movw	r2, #2410	; 0x96a
 801188c:	4291      	cmp	r1, r2
 801188e:	d026      	beq.n	80118de <USART_GetITStatus+0xce>
 8011890:	f240 3325 	movw	r3, #805	; 0x325
 8011894:	4299      	cmp	r1, r3
 8011896:	d043      	beq.n	8011920 <USART_GetITStatus+0x110>
 8011898:	f5b1 7f18 	cmp.w	r1, #608	; 0x260
 801189c:	d00d      	beq.n	80118ba <USART_GetITStatus+0xaa>
 801189e:	f421 7300 	bic.w	r3, r1, #512	; 0x200
 80118a2:	f5b3 7fb0 	cmp.w	r3, #352	; 0x160
 80118a6:	d01f      	beq.n	80118e8 <USART_GetITStatus+0xd8>
 80118a8:	2301      	movs	r3, #1
 80118aa:	9302      	str	r3, [sp, #8]
 80118ac:	9b02      	ldr	r3, [sp, #8]
 80118ae:	2b00      	cmp	r3, #0
 80118b0:	d1fc      	bne.n	80118ac <USART_GetITStatus+0x9c>
 80118b2:	e019      	b.n	80118e8 <USART_GetITStatus+0xd8>
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80118b4:	2340      	movs	r3, #64	; 0x40
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
  {
    itmask &= USARTx->CR2;
 80118b6:	8a02      	ldrh	r2, [r0, #16]
 80118b8:	e001      	b.n	80118be <USART_GetITStatus+0xae>
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80118ba:	2301      	movs	r3, #1
  {
    itmask &= USARTx->CR2;
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 80118bc:	8a82      	ldrh	r2, [r0, #20]
 80118be:	b292      	uxth	r2, r2
 80118c0:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->SR;
 80118c2:	8802      	ldrh	r2, [r0, #0]
 80118c4:	b292      	uxth	r2, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 80118c6:	b143      	cbz	r3, 80118da <USART_GetITStatus+0xca>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
 80118c8:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
 80118ca:	0a09      	lsrs	r1, r1, #8
  bitpos = (uint32_t)0x01 << bitpos;
 80118cc:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->SR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
  {
    bitstatus = SET;
 80118d0:	420a      	tst	r2, r1
 80118d2:	bf14      	ite	ne
 80118d4:	4618      	movne	r0, r3
 80118d6:	2000      	moveq	r0, #0
 80118d8:	e027      	b.n	801192a <USART_GetITStatus+0x11a>
  }
  else
  {
    bitstatus = RESET;
 80118da:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
 80118dc:	e025      	b.n	801192a <USART_GetITStatus+0x11a>
  assert_param(IS_USART_GET_IT(USART_IT)); 

  /* The CTS interrupt is not available for UART4 and UART5 */ 
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 80118de:	4298      	cmp	r0, r3
 80118e0:	d002      	beq.n	80118e8 <USART_GetITStatus+0xd8>
 80118e2:	4b14      	ldr	r3, [pc, #80]	; (8011934 <USART_GetITStatus+0x124>)
 80118e4:	4298      	cmp	r0, r3
 80118e6:	d10d      	bne.n	8011904 <USART_GetITStatus+0xf4>
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 80118e8:	f3c1 1242 	ubfx	r2, r1, #5, #3
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 80118ec:	f001 041f 	and.w	r4, r1, #31
  itmask = (uint32_t)0x01 << itmask;
 80118f0:	2301      	movs	r3, #1
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 80118f2:	2a01      	cmp	r2, #1
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80118f4:	fa03 f304 	lsl.w	r3, r3, r4
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 80118f8:	d101      	bne.n	80118fe <USART_GetITStatus+0xee>
  {
    itmask &= USARTx->CR1;
 80118fa:	8982      	ldrh	r2, [r0, #12]
 80118fc:	e7df      	b.n	80118be <USART_GetITStatus+0xae>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 80118fe:	2a02      	cmp	r2, #2
 8011900:	d1dc      	bne.n	80118bc <USART_GetITStatus+0xac>
 8011902:	e7d8      	b.n	80118b6 <USART_GetITStatus+0xa6>
  assert_param(IS_USART_GET_IT(USART_IT)); 

  /* The CTS interrupt is not available for UART4 and UART5 */ 
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
 8011904:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011908:	4298      	cmp	r0, r3
 801190a:	d0ed      	beq.n	80118e8 <USART_GetITStatus+0xd8>
 801190c:	f503 434c 	add.w	r3, r3, #52224	; 0xcc00
 8011910:	4298      	cmp	r0, r3
 8011912:	d0e9      	beq.n	80118e8 <USART_GetITStatus+0xd8>
 8011914:	2301      	movs	r3, #1
 8011916:	9303      	str	r3, [sp, #12]
 8011918:	9b03      	ldr	r3, [sp, #12]
 801191a:	2b00      	cmp	r3, #0
 801191c:	d1fc      	bne.n	8011918 <USART_GetITStatus+0x108>
 801191e:	e7e3      	b.n	80118e8 <USART_GetITStatus+0xd8>
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8011920:	f001 021f 	and.w	r2, r1, #31
  itmask = (uint32_t)0x01 << itmask;
 8011924:	2301      	movs	r3, #1
 8011926:	4093      	lsls	r3, r2
 8011928:	e7e7      	b.n	80118fa <USART_GetITStatus+0xea>
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
 801192a:	b004      	add	sp, #16
 801192c:	bd10      	pop	{r4, pc}
 801192e:	bf00      	nop
 8011930:	40011000 	.word	0x40011000
 8011934:	40004400 	.word	0x40004400

08011938 <SPI_I2S_DeInit>:
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 8011938:	4b2c      	ldr	r3, [pc, #176]	; (80119ec <SPI_I2S_DeInit+0xb4>)
 801193a:	4298      	cmp	r0, r3
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 801193c:	b507      	push	{r0, r1, r2, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 801193e:	d019      	beq.n	8011974 <SPI_I2S_DeInit+0x3c>
 8011940:	f5a3 4378 	sub.w	r3, r3, #63488	; 0xf800
 8011944:	4298      	cmp	r0, r3
 8011946:	d039      	beq.n	80119bc <SPI_I2S_DeInit+0x84>
 8011948:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801194c:	4298      	cmp	r0, r3
 801194e:	d023      	beq.n	8011998 <SPI_I2S_DeInit+0x60>
 8011950:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011954:	4298      	cmp	r0, r3
 8011956:	d016      	beq.n	8011986 <SPI_I2S_DeInit+0x4e>
 8011958:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 801195c:	4298      	cmp	r0, r3
 801195e:	d024      	beq.n	80119aa <SPI_I2S_DeInit+0x72>
 8011960:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011964:	4298      	cmp	r0, r3
 8011966:	d034      	beq.n	80119d2 <SPI_I2S_DeInit+0x9a>
 8011968:	2301      	movs	r3, #1
 801196a:	9301      	str	r3, [sp, #4]
 801196c:	9b01      	ldr	r3, [sp, #4]
 801196e:	2b00      	cmp	r3, #0
 8011970:	d1fc      	bne.n	801196c <SPI_I2S_DeInit+0x34>
 8011972:	e038      	b.n	80119e6 <SPI_I2S_DeInit+0xae>

  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 8011974:	2101      	movs	r1, #1
 8011976:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 801197a:	f7ff fcab 	bl	80112d4 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 801197e:	2100      	movs	r1, #0
 8011980:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8011984:	e02d      	b.n	80119e2 <SPI_I2S_DeInit+0xaa>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
  }
  else if (SPIx == SPI4)
  {
    /* Enable SPI4 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
 8011986:	2101      	movs	r1, #1
 8011988:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 801198c:	f7ff fca2 	bl	80112d4 <RCC_APB2PeriphResetCmd>
    /* Release SPI4 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
 8011990:	2100      	movs	r1, #0
 8011992:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8011996:	e024      	b.n	80119e2 <SPI_I2S_DeInit+0xaa>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
  }
  else if (SPIx == SPI3)
  {
    /* Enable SPI3 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 8011998:	2101      	movs	r1, #1
 801199a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 801199e:	f7ff fc75 	bl	801128c <RCC_APB1PeriphResetCmd>
    /* Release SPI3 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 80119a2:	2100      	movs	r1, #0
 80119a4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80119a8:	e010      	b.n	80119cc <SPI_I2S_DeInit+0x94>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
  }
  else if (SPIx == SPI5)
  {
    /* Enable SPI5 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
 80119aa:	2101      	movs	r1, #1
 80119ac:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80119b0:	f7ff fc90 	bl	80112d4 <RCC_APB2PeriphResetCmd>
    /* Release SPI5 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
 80119b4:	2100      	movs	r1, #0
 80119b6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80119ba:	e012      	b.n	80119e2 <SPI_I2S_DeInit+0xaa>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
  }
  else if (SPIx == SPI2)
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 80119bc:	2101      	movs	r1, #1
 80119be:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80119c2:	f7ff fc63 	bl	801128c <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 80119c6:	2100      	movs	r1, #0
 80119c8:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80119cc:	f7ff fc5e 	bl	801128c <RCC_APB1PeriphResetCmd>
 80119d0:	e009      	b.n	80119e6 <SPI_I2S_DeInit+0xae>
  else 
  {
    if (SPIx == SPI6)
    {
      /* Enable SPI6 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
 80119d2:	2101      	movs	r1, #1
 80119d4:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80119d8:	f7ff fc7c 	bl	80112d4 <RCC_APB2PeriphResetCmd>
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
 80119dc:	2100      	movs	r1, #0
 80119de:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80119e2:	f7ff fc77 	bl	80112d4 <RCC_APB2PeriphResetCmd>
    }
  }
}
 80119e6:	b003      	add	sp, #12
 80119e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80119ec:	40013000 	.word	0x40013000

080119f0 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 80119f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t tmpreg = 0;
  
  /* check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 80119f4:	4b49      	ldr	r3, [pc, #292]	; (8011b1c <SPI_Init+0x12c>)
 80119f6:	4298      	cmp	r0, r3
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 80119f8:	b08a      	sub	sp, #40	; 0x28
  uint16_t tmpreg = 0;
  
  /* check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 80119fa:	d104      	bne.n	8011a06 <SPI_Init+0x16>
  
  /* Check the SPI parameters */
  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
 80119fc:	880d      	ldrh	r5, [r1, #0]
 80119fe:	f425 6380 	bic.w	r3, r5, #1024	; 0x400
 8011a02:	b9cb      	cbnz	r3, 8011a38 <SPI_Init+0x48>
 8011a04:	e022      	b.n	8011a4c <SPI_Init+0x5c>
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
  uint16_t tmpreg = 0;
  
  /* check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 8011a06:	4b46      	ldr	r3, [pc, #280]	; (8011b20 <SPI_Init+0x130>)
 8011a08:	4298      	cmp	r0, r3
 8011a0a:	d0f7      	beq.n	80119fc <SPI_Init+0xc>
 8011a0c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011a10:	4298      	cmp	r0, r3
 8011a12:	d0f3      	beq.n	80119fc <SPI_Init+0xc>
 8011a14:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011a18:	4298      	cmp	r0, r3
 8011a1a:	d0ef      	beq.n	80119fc <SPI_Init+0xc>
 8011a1c:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011a20:	4298      	cmp	r0, r3
 8011a22:	d0eb      	beq.n	80119fc <SPI_Init+0xc>
 8011a24:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011a28:	4298      	cmp	r0, r3
 8011a2a:	d0e7      	beq.n	80119fc <SPI_Init+0xc>
 8011a2c:	2301      	movs	r3, #1
 8011a2e:	9300      	str	r3, [sp, #0]
 8011a30:	9b00      	ldr	r3, [sp, #0]
 8011a32:	2b00      	cmp	r3, #0
 8011a34:	d1fc      	bne.n	8011a30 <SPI_Init+0x40>
 8011a36:	e7e1      	b.n	80119fc <SPI_Init+0xc>
  
  /* Check the SPI parameters */
  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
 8011a38:	f425 4380 	bic.w	r3, r5, #16384	; 0x4000
 8011a3c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8011a40:	d004      	beq.n	8011a4c <SPI_Init+0x5c>
 8011a42:	2301      	movs	r3, #1
 8011a44:	9301      	str	r3, [sp, #4]
 8011a46:	9b01      	ldr	r3, [sp, #4]
 8011a48:	2b00      	cmp	r3, #0
 8011a4a:	d1fc      	bne.n	8011a46 <SPI_Init+0x56>
  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
 8011a4c:	884b      	ldrh	r3, [r1, #2]
 8011a4e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8011a52:	d005      	beq.n	8011a60 <SPI_Init+0x70>
 8011a54:	b123      	cbz	r3, 8011a60 <SPI_Init+0x70>
 8011a56:	2201      	movs	r2, #1
 8011a58:	9202      	str	r2, [sp, #8]
 8011a5a:	9a02      	ldr	r2, [sp, #8]
 8011a5c:	2a00      	cmp	r2, #0
 8011a5e:	d1fc      	bne.n	8011a5a <SPI_Init+0x6a>
  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
 8011a60:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 8011a64:	f428 6200 	bic.w	r2, r8, #2048	; 0x800
 8011a68:	b122      	cbz	r2, 8011a74 <SPI_Init+0x84>
 8011a6a:	2201      	movs	r2, #1
 8011a6c:	9203      	str	r2, [sp, #12]
 8011a6e:	9a03      	ldr	r2, [sp, #12]
 8011a70:	2a00      	cmp	r2, #0
 8011a72:	d1fc      	bne.n	8011a6e <SPI_Init+0x7e>
  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
 8011a74:	88cc      	ldrh	r4, [r1, #6]
 8011a76:	f024 0202 	bic.w	r2, r4, #2
 8011a7a:	b122      	cbz	r2, 8011a86 <SPI_Init+0x96>
 8011a7c:	2201      	movs	r2, #1
 8011a7e:	9204      	str	r2, [sp, #16]
 8011a80:	9a04      	ldr	r2, [sp, #16]
 8011a82:	2a00      	cmp	r2, #0
 8011a84:	d1fc      	bne.n	8011a80 <SPI_Init+0x90>
  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
 8011a86:	890a      	ldrh	r2, [r1, #8]
 8011a88:	2a01      	cmp	r2, #1
 8011a8a:	d904      	bls.n	8011a96 <SPI_Init+0xa6>
 8011a8c:	2601      	movs	r6, #1
 8011a8e:	9605      	str	r6, [sp, #20]
 8011a90:	9e05      	ldr	r6, [sp, #20]
 8011a92:	2e00      	cmp	r6, #0
 8011a94:	d1fc      	bne.n	8011a90 <SPI_Init+0xa0>
  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
 8011a96:	894f      	ldrh	r7, [r1, #10]
 8011a98:	f427 7600 	bic.w	r6, r7, #512	; 0x200
 8011a9c:	b126      	cbz	r6, 8011aa8 <SPI_Init+0xb8>
 8011a9e:	2601      	movs	r6, #1
 8011aa0:	9606      	str	r6, [sp, #24]
 8011aa2:	9e06      	ldr	r6, [sp, #24]
 8011aa4:	2e00      	cmp	r6, #0
 8011aa6:	d1fc      	bne.n	8011aa2 <SPI_Init+0xb2>
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
 8011aa8:	f8b1 e00c 	ldrh.w	lr, [r1, #12]
 8011aac:	f02e 0618 	bic.w	r6, lr, #24
 8011ab0:	b2b6      	uxth	r6, r6
 8011ab2:	b136      	cbz	r6, 8011ac2 <SPI_Init+0xd2>
 8011ab4:	2e20      	cmp	r6, #32
 8011ab6:	d004      	beq.n	8011ac2 <SPI_Init+0xd2>
 8011ab8:	2601      	movs	r6, #1
 8011aba:	9607      	str	r6, [sp, #28]
 8011abc:	9e07      	ldr	r6, [sp, #28]
 8011abe:	2e00      	cmp	r6, #0
 8011ac0:	d1fc      	bne.n	8011abc <SPI_Init+0xcc>
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
 8011ac2:	f8b1 c00e 	ldrh.w	ip, [r1, #14]
 8011ac6:	f02c 0680 	bic.w	r6, ip, #128	; 0x80
 8011aca:	b126      	cbz	r6, 8011ad6 <SPI_Init+0xe6>
 8011acc:	2601      	movs	r6, #1
 8011ace:	9608      	str	r6, [sp, #32]
 8011ad0:	9e08      	ldr	r6, [sp, #32]
 8011ad2:	2e00      	cmp	r6, #0
 8011ad4:	d1fc      	bne.n	8011ad0 <SPI_Init+0xe0>
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
 8011ad6:	8a0e      	ldrh	r6, [r1, #16]
 8011ad8:	b926      	cbnz	r6, 8011ae4 <SPI_Init+0xf4>
 8011ada:	2601      	movs	r6, #1
 8011adc:	9609      	str	r6, [sp, #36]	; 0x24
 8011ade:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8011ae0:	2e00      	cmp	r6, #0
 8011ae2:	d1fc      	bne.n	8011ade <SPI_Init+0xee>
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8011ae4:	431d      	orrs	r5, r3
 8011ae6:	ea48 0505 	orr.w	r5, r8, r5
 8011aea:	432c      	orrs	r4, r5
 8011aec:	4314      	orrs	r4, r2
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8011aee:	8806      	ldrh	r6, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8011af0:	ea47 0204 	orr.w	r2, r7, r4
 8011af4:	ea4e 0202 	orr.w	r2, lr, r2

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 8011af8:	f406 5641 	and.w	r6, r6, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8011afc:	ea4c 0302 	orr.w	r3, ip, r2
 8011b00:	4333      	orrs	r3, r6
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8011b02:	8003      	strh	r3, [r0, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8011b04:	8b83      	ldrh	r3, [r0, #28]
 8011b06:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8011b0a:	041b      	lsls	r3, r3, #16
 8011b0c:	0c1b      	lsrs	r3, r3, #16
 8011b0e:	8383      	strh	r3, [r0, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8011b10:	8a0b      	ldrh	r3, [r1, #16]
 8011b12:	8203      	strh	r3, [r0, #16]
}
 8011b14:	b00a      	add	sp, #40	; 0x28
 8011b16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011b1a:	bf00      	nop
 8011b1c:	40013000 	.word	0x40013000
 8011b20:	40003800 	.word	0x40003800

08011b24 <SPI_Cmd>:
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 8011b24:	4b19      	ldr	r3, [pc, #100]	; (8011b8c <SPI_Cmd+0x68>)
 8011b26:	4298      	cmp	r0, r3
  * @param  NewState: new state of the SPIx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8011b28:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 8011b2a:	d104      	bne.n	8011b36 <SPI_Cmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011b2c:	2901      	cmp	r1, #1
 8011b2e:	d923      	bls.n	8011b78 <SPI_Cmd+0x54>
 8011b30:	2301      	movs	r3, #1
 8011b32:	9301      	str	r3, [sp, #4]
 8011b34:	e018      	b.n	8011b68 <SPI_Cmd+0x44>
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
 8011b36:	4b16      	ldr	r3, [pc, #88]	; (8011b90 <SPI_Cmd+0x6c>)
 8011b38:	4298      	cmp	r0, r3
 8011b3a:	d0f7      	beq.n	8011b2c <SPI_Cmd+0x8>
 8011b3c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011b40:	4298      	cmp	r0, r3
 8011b42:	d0f3      	beq.n	8011b2c <SPI_Cmd+0x8>
 8011b44:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011b48:	4298      	cmp	r0, r3
 8011b4a:	d0ef      	beq.n	8011b2c <SPI_Cmd+0x8>
 8011b4c:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011b50:	4298      	cmp	r0, r3
 8011b52:	d0eb      	beq.n	8011b2c <SPI_Cmd+0x8>
 8011b54:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011b58:	4298      	cmp	r0, r3
 8011b5a:	d0e7      	beq.n	8011b2c <SPI_Cmd+0x8>
 8011b5c:	2301      	movs	r3, #1
 8011b5e:	9300      	str	r3, [sp, #0]
 8011b60:	9b00      	ldr	r3, [sp, #0]
 8011b62:	2b00      	cmp	r3, #0
 8011b64:	d1fc      	bne.n	8011b60 <SPI_Cmd+0x3c>
 8011b66:	e7e1      	b.n	8011b2c <SPI_Cmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011b68:	9b01      	ldr	r3, [sp, #4]
 8011b6a:	2b00      	cmp	r3, #0
 8011b6c:	d1fc      	bne.n	8011b68 <SPI_Cmd+0x44>
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8011b6e:	8803      	ldrh	r3, [r0, #0]
 8011b70:	b29b      	uxth	r3, r3
 8011b72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011b76:	e006      	b.n	8011b86 <SPI_Cmd+0x62>
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8011b78:	2900      	cmp	r1, #0
 8011b7a:	d1f8      	bne.n	8011b6e <SPI_Cmd+0x4a>
    SPIx->CR1 |= SPI_CR1_SPE;
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8011b7c:	8803      	ldrh	r3, [r0, #0]
 8011b7e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8011b82:	041b      	lsls	r3, r3, #16
 8011b84:	0c1b      	lsrs	r3, r3, #16
 8011b86:	8003      	strh	r3, [r0, #0]
  }
}
 8011b88:	b002      	add	sp, #8
 8011b8a:	4770      	bx	lr
 8011b8c:	40013000 	.word	0x40013000
 8011b90:	40003800 	.word	0x40003800

08011b94 <SPI_I2S_ReceiveData>:
  * @retval The value of the received data.
  */
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011b94:	4b13      	ldr	r3, [pc, #76]	; (8011be4 <SPI_I2S_ReceiveData+0x50>)
 8011b96:	4298      	cmp	r0, r3
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @retval The value of the received data.
  */
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
{
 8011b98:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011b9a:	d01f      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011b9c:	f5a3 4378 	sub.w	r3, r3, #63488	; 0xf800
 8011ba0:	4298      	cmp	r0, r3
 8011ba2:	d01b      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011ba4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011ba8:	4298      	cmp	r0, r3
 8011baa:	d017      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011bac:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011bb0:	4298      	cmp	r0, r3
 8011bb2:	d013      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011bb4:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011bb8:	4298      	cmp	r0, r3
 8011bba:	d00f      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011bbc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011bc0:	4298      	cmp	r0, r3
 8011bc2:	d00b      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011bc4:	f5a3 3390 	sub.w	r3, r3, #73728	; 0x12000
 8011bc8:	4298      	cmp	r0, r3
 8011bca:	d007      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011bcc:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
 8011bd0:	d004      	beq.n	8011bdc <SPI_I2S_ReceiveData+0x48>
 8011bd2:	2301      	movs	r3, #1
 8011bd4:	9301      	str	r3, [sp, #4]
 8011bd6:	9b01      	ldr	r3, [sp, #4]
 8011bd8:	2b00      	cmp	r3, #0
 8011bda:	d1fc      	bne.n	8011bd6 <SPI_I2S_ReceiveData+0x42>
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8011bdc:	8980      	ldrh	r0, [r0, #12]
 8011bde:	b280      	uxth	r0, r0
}
 8011be0:	b002      	add	sp, #8
 8011be2:	4770      	bx	lr
 8011be4:	40013000 	.word	0x40013000

08011be8 <SPI_I2S_SendData>:
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011be8:	4b13      	ldr	r3, [pc, #76]	; (8011c38 <SPI_I2S_SendData+0x50>)
 8011bea:	4298      	cmp	r0, r3
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
  * @param  Data: Data to be transmitted.
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
 8011bec:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011bee:	d102      	bne.n	8011bf6 <SPI_I2S_SendData+0xe>
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 8011bf0:	8181      	strh	r1, [r0, #12]
}
 8011bf2:	b002      	add	sp, #8
 8011bf4:	4770      	bx	lr
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011bf6:	4b11      	ldr	r3, [pc, #68]	; (8011c3c <SPI_I2S_SendData+0x54>)
 8011bf8:	4298      	cmp	r0, r3
 8011bfa:	d0f9      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011bfc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011c00:	4298      	cmp	r0, r3
 8011c02:	d0f5      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c04:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011c08:	4298      	cmp	r0, r3
 8011c0a:	d0f1      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c0c:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011c10:	4298      	cmp	r0, r3
 8011c12:	d0ed      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c14:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011c18:	4298      	cmp	r0, r3
 8011c1a:	d0e9      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c1c:	f5a3 3390 	sub.w	r3, r3, #73728	; 0x12000
 8011c20:	4298      	cmp	r0, r3
 8011c22:	d0e5      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c24:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
 8011c28:	d0e2      	beq.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c2a:	2301      	movs	r3, #1
 8011c2c:	9301      	str	r3, [sp, #4]
 8011c2e:	9b01      	ldr	r3, [sp, #4]
 8011c30:	2b00      	cmp	r3, #0
 8011c32:	d1fc      	bne.n	8011c2e <SPI_I2S_SendData+0x46>
 8011c34:	e7dc      	b.n	8011bf0 <SPI_I2S_SendData+0x8>
 8011c36:	bf00      	nop
 8011c38:	40013000 	.word	0x40013000
 8011c3c:	40003800 	.word	0x40003800

08011c40 <SPI_I2S_DMACmd>:
  * @retval None
  */
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011c40:	4b20      	ldr	r3, [pc, #128]	; (8011cc4 <SPI_I2S_DMACmd+0x84>)
 8011c42:	4298      	cmp	r0, r3
  * @param  NewState: new state of the selected SPI DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
 8011c44:	b084      	sub	sp, #16
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011c46:	d102      	bne.n	8011c4e <SPI_I2S_DMACmd+0xe>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011c48:	2a01      	cmp	r2, #1
 8011c4a:	d820      	bhi.n	8011c8e <SPI_I2S_DMACmd+0x4e>
 8011c4c:	e024      	b.n	8011c98 <SPI_I2S_DMACmd+0x58>
  * @retval None
  */
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011c4e:	4b1e      	ldr	r3, [pc, #120]	; (8011cc8 <SPI_I2S_DMACmd+0x88>)
 8011c50:	4298      	cmp	r0, r3
 8011c52:	d0f9      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c54:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011c58:	4298      	cmp	r0, r3
 8011c5a:	d0f5      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c5c:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011c60:	4298      	cmp	r0, r3
 8011c62:	d0f1      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c64:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011c68:	4298      	cmp	r0, r3
 8011c6a:	d0ed      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c6c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011c70:	4298      	cmp	r0, r3
 8011c72:	d0e9      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c74:	f5a3 3390 	sub.w	r3, r3, #73728	; 0x12000
 8011c78:	4298      	cmp	r0, r3
 8011c7a:	d0e5      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c7c:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
 8011c80:	d0e2      	beq.n	8011c48 <SPI_I2S_DMACmd+0x8>
 8011c82:	2301      	movs	r3, #1
 8011c84:	9301      	str	r3, [sp, #4]
 8011c86:	9b01      	ldr	r3, [sp, #4]
 8011c88:	2b00      	cmp	r3, #0
 8011c8a:	d1fc      	bne.n	8011c86 <SPI_I2S_DMACmd+0x46>
 8011c8c:	e7dc      	b.n	8011c48 <SPI_I2S_DMACmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011c8e:	2301      	movs	r3, #1
 8011c90:	9302      	str	r3, [sp, #8]
 8011c92:	9b02      	ldr	r3, [sp, #8]
 8011c94:	2b00      	cmp	r3, #0
 8011c96:	d1fc      	bne.n	8011c92 <SPI_I2S_DMACmd+0x52>
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
 8011c98:	f021 0303 	bic.w	r3, r1, #3
 8011c9c:	b92b      	cbnz	r3, 8011caa <SPI_I2S_DMACmd+0x6a>
 8011c9e:	b121      	cbz	r1, 8011caa <SPI_I2S_DMACmd+0x6a>

  if (NewState != DISABLE)
 8011ca0:	b14a      	cbz	r2, 8011cb6 <SPI_I2S_DMACmd+0x76>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8011ca2:	8883      	ldrh	r3, [r0, #4]
 8011ca4:	b29b      	uxth	r3, r3
 8011ca6:	4319      	orrs	r1, r3
 8011ca8:	e009      	b.n	8011cbe <SPI_I2S_DMACmd+0x7e>
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
 8011caa:	2301      	movs	r3, #1
 8011cac:	9303      	str	r3, [sp, #12]
 8011cae:	9b03      	ldr	r3, [sp, #12]
 8011cb0:	2b00      	cmp	r3, #0
 8011cb2:	d1fc      	bne.n	8011cae <SPI_I2S_DMACmd+0x6e>
 8011cb4:	e7f4      	b.n	8011ca0 <SPI_I2S_DMACmd+0x60>
    SPIx->CR2 |= SPI_I2S_DMAReq;
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8011cb6:	8883      	ldrh	r3, [r0, #4]
 8011cb8:	b29b      	uxth	r3, r3
 8011cba:	ea23 0101 	bic.w	r1, r3, r1
 8011cbe:	8081      	strh	r1, [r0, #4]
  }
}
 8011cc0:	b004      	add	sp, #16
 8011cc2:	4770      	bx	lr
 8011cc4:	40013000 	.word	0x40013000
 8011cc8:	40003800 	.word	0x40003800

08011ccc <SPI_I2S_ITConfig>:
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
{
  uint16_t itpos = 0, itmask = 0 ;
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011ccc:	4b24      	ldr	r3, [pc, #144]	; (8011d60 <SPI_I2S_ITConfig+0x94>)
 8011cce:	4298      	cmp	r0, r3
  * @param  NewState: new state of the specified SPI interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
{
 8011cd0:	b084      	sub	sp, #16
  uint16_t itpos = 0, itmask = 0 ;
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011cd2:	d102      	bne.n	8011cda <SPI_I2S_ITConfig+0xe>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011cd4:	2a01      	cmp	r2, #1
 8011cd6:	d820      	bhi.n	8011d1a <SPI_I2S_ITConfig+0x4e>
 8011cd8:	e024      	b.n	8011d24 <SPI_I2S_ITConfig+0x58>
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
{
  uint16_t itpos = 0, itmask = 0 ;
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011cda:	4b22      	ldr	r3, [pc, #136]	; (8011d64 <SPI_I2S_ITConfig+0x98>)
 8011cdc:	4298      	cmp	r0, r3
 8011cde:	d0f9      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011ce0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011ce4:	4298      	cmp	r0, r3
 8011ce6:	d0f5      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011ce8:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011cec:	4298      	cmp	r0, r3
 8011cee:	d0f1      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011cf0:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011cf4:	4298      	cmp	r0, r3
 8011cf6:	d0ed      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011cf8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011cfc:	4298      	cmp	r0, r3
 8011cfe:	d0e9      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011d00:	f5a3 3390 	sub.w	r3, r3, #73728	; 0x12000
 8011d04:	4298      	cmp	r0, r3
 8011d06:	d0e5      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011d08:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
 8011d0c:	d0e2      	beq.n	8011cd4 <SPI_I2S_ITConfig+0x8>
 8011d0e:	2301      	movs	r3, #1
 8011d10:	9301      	str	r3, [sp, #4]
 8011d12:	9b01      	ldr	r3, [sp, #4]
 8011d14:	2b00      	cmp	r3, #0
 8011d16:	d1fc      	bne.n	8011d12 <SPI_I2S_ITConfig+0x46>
 8011d18:	e7dc      	b.n	8011cd4 <SPI_I2S_ITConfig+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8011d1a:	2301      	movs	r3, #1
 8011d1c:	9302      	str	r3, [sp, #8]
 8011d1e:	9b02      	ldr	r3, [sp, #8]
 8011d20:	2b00      	cmp	r3, #0
 8011d22:	d1fc      	bne.n	8011d1e <SPI_I2S_ITConfig+0x52>
  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
 8011d24:	2971      	cmp	r1, #113	; 0x71
 8011d26:	d001      	beq.n	8011d2c <SPI_I2S_ITConfig+0x60>
 8011d28:	2960      	cmp	r1, #96	; 0x60
 8011d2a:	d109      	bne.n	8011d40 <SPI_I2S_ITConfig+0x74>

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8011d2c:	0909      	lsrs	r1, r1, #4
 8011d2e:	2301      	movs	r3, #1
 8011d30:	fa03 f101 	lsl.w	r1, r3, r1
 8011d34:	b289      	uxth	r1, r1

  if (NewState != DISABLE)
 8011d36:	b15a      	cbz	r2, 8011d50 <SPI_I2S_ITConfig+0x84>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 8011d38:	8883      	ldrh	r3, [r0, #4]
 8011d3a:	b29b      	uxth	r3, r3
 8011d3c:	4319      	orrs	r1, r3
 8011d3e:	e00b      	b.n	8011d58 <SPI_I2S_ITConfig+0x8c>
  uint16_t itpos = 0, itmask = 0 ;
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
 8011d40:	2950      	cmp	r1, #80	; 0x50
 8011d42:	d0f3      	beq.n	8011d2c <SPI_I2S_ITConfig+0x60>
 8011d44:	2301      	movs	r3, #1
 8011d46:	9303      	str	r3, [sp, #12]
 8011d48:	9b03      	ldr	r3, [sp, #12]
 8011d4a:	2b00      	cmp	r3, #0
 8011d4c:	d1fc      	bne.n	8011d48 <SPI_I2S_ITConfig+0x7c>
 8011d4e:	e7ed      	b.n	8011d2c <SPI_I2S_ITConfig+0x60>
    SPIx->CR2 |= itmask;
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8011d50:	8883      	ldrh	r3, [r0, #4]
 8011d52:	b29b      	uxth	r3, r3
 8011d54:	ea23 0101 	bic.w	r1, r3, r1
 8011d58:	8081      	strh	r1, [r0, #4]
  }
}
 8011d5a:	b004      	add	sp, #16
 8011d5c:	4770      	bx	lr
 8011d5e:	bf00      	nop
 8011d60:	40013000 	.word	0x40013000
 8011d64:	40003800 	.word	0x40003800

08011d68 <SPI_I2S_GetFlagStatus>:
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011d68:	4b20      	ldr	r3, [pc, #128]	; (8011dec <SPI_I2S_GetFlagStatus+0x84>)
 8011d6a:	4298      	cmp	r0, r3
  *            @arg I2S_FLAG_UDR: Underrun Error flag.
  *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 8011d6c:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011d6e:	d102      	bne.n	8011d76 <SPI_I2S_GetFlagStatus+0xe>
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
 8011d70:	2980      	cmp	r1, #128	; 0x80
 8011d72:	d120      	bne.n	8011db6 <SPI_I2S_GetFlagStatus+0x4e>
 8011d74:	e033      	b.n	8011dde <SPI_I2S_GetFlagStatus+0x76>
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011d76:	4b1e      	ldr	r3, [pc, #120]	; (8011df0 <SPI_I2S_GetFlagStatus+0x88>)
 8011d78:	4298      	cmp	r0, r3
 8011d7a:	d0f9      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011d7c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011d80:	4298      	cmp	r0, r3
 8011d82:	d0f5      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011d84:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011d88:	4298      	cmp	r0, r3
 8011d8a:	d0f1      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011d8c:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011d90:	4298      	cmp	r0, r3
 8011d92:	d0ed      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011d94:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011d98:	4298      	cmp	r0, r3
 8011d9a:	d0e9      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011d9c:	f5a3 3390 	sub.w	r3, r3, #73728	; 0x12000
 8011da0:	4298      	cmp	r0, r3
 8011da2:	d0e5      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011da4:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
 8011da8:	d0e2      	beq.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
 8011daa:	2301      	movs	r3, #1
 8011dac:	9300      	str	r3, [sp, #0]
 8011dae:	9b00      	ldr	r3, [sp, #0]
 8011db0:	2b00      	cmp	r3, #0
 8011db2:	d1fc      	bne.n	8011dae <SPI_I2S_GetFlagStatus+0x46>
 8011db4:	e7dc      	b.n	8011d70 <SPI_I2S_GetFlagStatus+0x8>
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
 8011db6:	2940      	cmp	r1, #64	; 0x40
 8011db8:	d011      	beq.n	8011dde <SPI_I2S_GetFlagStatus+0x76>
 8011dba:	1e4b      	subs	r3, r1, #1
 8011dbc:	b29b      	uxth	r3, r3
 8011dbe:	2b1f      	cmp	r3, #31
 8011dc0:	d80a      	bhi.n	8011dd8 <SPI_I2S_GetFlagStatus+0x70>
 8011dc2:	4a0c      	ldr	r2, [pc, #48]	; (8011df4 <SPI_I2S_GetFlagStatus+0x8c>)
 8011dc4:	fa22 f303 	lsr.w	r3, r2, r3
 8011dc8:	07db      	lsls	r3, r3, #31
 8011dca:	d408      	bmi.n	8011dde <SPI_I2S_GetFlagStatus+0x76>
 8011dcc:	2301      	movs	r3, #1
 8011dce:	9301      	str	r3, [sp, #4]
 8011dd0:	9b01      	ldr	r3, [sp, #4]
 8011dd2:	2b00      	cmp	r3, #0
 8011dd4:	d1fc      	bne.n	8011dd0 <SPI_I2S_GetFlagStatus+0x68>
 8011dd6:	e002      	b.n	8011dde <SPI_I2S_GetFlagStatus+0x76>
 8011dd8:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8011ddc:	d1f6      	bne.n	8011dcc <SPI_I2S_GetFlagStatus+0x64>
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8011dde:	8903      	ldrh	r3, [r0, #8]
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
 8011de0:	4219      	tst	r1, r3
 8011de2:	bf14      	ite	ne
 8011de4:	2001      	movne	r0, #1
 8011de6:	2000      	moveq	r0, #0
}
 8011de8:	b002      	add	sp, #8
 8011dea:	4770      	bx	lr
 8011dec:	40013000 	.word	0x40013000
 8011df0:	40003800 	.word	0x40003800
 8011df4:	8000808b 	.word	0x8000808b

08011df8 <SPI_I2S_GetITStatus>:
{
  ITStatus bitstatus = RESET;
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011df8:	4b24      	ldr	r3, [pc, #144]	; (8011e8c <SPI_I2S_GetITStatus+0x94>)
 8011dfa:	4298      	cmp	r0, r3
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8011dfc:	b513      	push	{r0, r1, r4, lr}
  ITStatus bitstatus = RESET;
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011dfe:	d105      	bne.n	8011e0c <SPI_I2S_GetITStatus+0x14>
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
 8011e00:	f1a1 0353 	sub.w	r3, r1, #83	; 0x53
 8011e04:	b2db      	uxtb	r3, r3
 8011e06:	2b1e      	cmp	r3, #30
 8011e08:	d838      	bhi.n	8011e7c <SPI_I2S_GetITStatus+0x84>
 8011e0a:	e01f      	b.n	8011e4c <SPI_I2S_GetITStatus+0x54>
{
  ITStatus bitstatus = RESET;
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
 8011e0c:	4b20      	ldr	r3, [pc, #128]	; (8011e90 <SPI_I2S_GetITStatus+0x98>)
 8011e0e:	4298      	cmp	r0, r3
 8011e10:	d0f6      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e12:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011e16:	4298      	cmp	r0, r3
 8011e18:	d0f2      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e1a:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
 8011e1e:	4298      	cmp	r0, r3
 8011e20:	d0ee      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e22:	f503 53e0 	add.w	r3, r3, #7168	; 0x1c00
 8011e26:	4298      	cmp	r0, r3
 8011e28:	d0ea      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e2a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8011e2e:	4298      	cmp	r0, r3
 8011e30:	d0e6      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e32:	f5a3 3390 	sub.w	r3, r3, #73728	; 0x12000
 8011e36:	4298      	cmp	r0, r3
 8011e38:	d0e2      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e3a:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
 8011e3e:	d0df      	beq.n	8011e00 <SPI_I2S_GetITStatus+0x8>
 8011e40:	2301      	movs	r3, #1
 8011e42:	9300      	str	r3, [sp, #0]
 8011e44:	9b00      	ldr	r3, [sp, #0]
 8011e46:	2b00      	cmp	r3, #0
 8011e48:	d1fc      	bne.n	8011e44 <SPI_I2S_GetITStatus+0x4c>
 8011e4a:	e7d9      	b.n	8011e00 <SPI_I2S_GetITStatus+0x8>
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
 8011e4c:	4a11      	ldr	r2, [pc, #68]	; (8011e94 <SPI_I2S_GetITStatus+0x9c>)
 8011e4e:	fa22 f303 	lsr.w	r3, r2, r3
 8011e52:	07db      	lsls	r3, r3, #31
 8011e54:	d512      	bpl.n	8011e7c <SPI_I2S_GetITStatus+0x84>

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8011e56:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8011e58:	8903      	ldrh	r3, [r0, #8]
 8011e5a:	2201      	movs	r2, #1
 8011e5c:	f001 000f 	and.w	r0, r1, #15
 8011e60:	b29b      	uxth	r3, r3
 8011e62:	fa02 f000 	lsl.w	r0, r2, r0
 8011e66:	4018      	ands	r0, r3

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8011e68:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8011e6a:	d00d      	beq.n	8011e88 <SPI_I2S_GetITStatus+0x90>
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 8011e6c:	0909      	lsrs	r1, r1, #4
 8011e6e:	fa02 f101 	lsl.w	r1, r2, r1
 8011e72:	420c      	tst	r4, r1
 8011e74:	bf14      	ite	ne
 8011e76:	2001      	movne	r0, #1
 8011e78:	2000      	moveq	r0, #0
 8011e7a:	e005      	b.n	8011e88 <SPI_I2S_GetITStatus+0x90>
  ITStatus bitstatus = RESET;
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
 8011e7c:	2301      	movs	r3, #1
 8011e7e:	9301      	str	r3, [sp, #4]
 8011e80:	9b01      	ldr	r3, [sp, #4]
 8011e82:	2b00      	cmp	r3, #0
 8011e84:	d1fc      	bne.n	8011e80 <SPI_I2S_GetITStatus+0x88>
 8011e86:	e7e6      	b.n	8011e56 <SPI_I2S_GetITStatus+0x5e>
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 8011e88:	b002      	add	sp, #8
 8011e8a:	bd10      	pop	{r4, pc}
 8011e8c:	40013000 	.word	0x40013000
 8011e90:	40003800 	.word	0x40003800
 8011e94:	4000202f 	.word	0x4000202f

08011e98 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8011e98:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
 8011e9a:	7903      	ldrb	r3, [r0, #4]
 8011e9c:	f013 0ffb 	tst.w	r3, #251	; 0xfb
 8011ea0:	d105      	bne.n	8011eae <EXTI_Init+0x16>
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
 8011ea2:	7942      	ldrb	r2, [r0, #5]
 8011ea4:	f002 01fb 	and.w	r1, r2, #251	; 0xfb
 8011ea8:	2908      	cmp	r1, #8
 8011eaa:	d106      	bne.n	8011eba <EXTI_Init+0x22>
 8011eac:	e00c      	b.n	8011ec8 <EXTI_Init+0x30>
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
 8011eae:	2201      	movs	r2, #1
 8011eb0:	9200      	str	r2, [sp, #0]
 8011eb2:	9a00      	ldr	r2, [sp, #0]
 8011eb4:	2a00      	cmp	r2, #0
 8011eb6:	d1fc      	bne.n	8011eb2 <EXTI_Init+0x1a>
 8011eb8:	e7f3      	b.n	8011ea2 <EXTI_Init+0xa>
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
 8011eba:	2a10      	cmp	r2, #16
 8011ebc:	d004      	beq.n	8011ec8 <EXTI_Init+0x30>
 8011ebe:	2201      	movs	r2, #1
 8011ec0:	9201      	str	r2, [sp, #4]
 8011ec2:	9a01      	ldr	r2, [sp, #4]
 8011ec4:	2a00      	cmp	r2, #0
 8011ec6:	d1fc      	bne.n	8011ec2 <EXTI_Init+0x2a>
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
 8011ec8:	6802      	ldr	r2, [r0, #0]
 8011eca:	0dd1      	lsrs	r1, r2, #23
 8011ecc:	05c9      	lsls	r1, r1, #23
 8011ece:	b931      	cbnz	r1, 8011ede <EXTI_Init+0x46>
 8011ed0:	b12a      	cbz	r2, 8011ede <EXTI_Init+0x46>
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));
 8011ed2:	7981      	ldrb	r1, [r0, #6]
 8011ed4:	2901      	cmp	r1, #1
 8011ed6:	d934      	bls.n	8011f42 <EXTI_Init+0xaa>
 8011ed8:	2301      	movs	r3, #1
 8011eda:	9303      	str	r3, [sp, #12]
 8011edc:	e005      	b.n	8011eea <EXTI_Init+0x52>
  uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
 8011ede:	2101      	movs	r1, #1
 8011ee0:	9102      	str	r1, [sp, #8]
 8011ee2:	9902      	ldr	r1, [sp, #8]
 8011ee4:	2900      	cmp	r1, #0
 8011ee6:	d1fc      	bne.n	8011ee2 <EXTI_Init+0x4a>
 8011ee8:	e7f3      	b.n	8011ed2 <EXTI_Init+0x3a>
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));
 8011eea:	9b03      	ldr	r3, [sp, #12]
 8011eec:	2b00      	cmp	r3, #0
 8011eee:	d1fc      	bne.n	8011eea <EXTI_Init+0x52>
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8011ef0:	4b1e      	ldr	r3, [pc, #120]	; (8011f6c <EXTI_Init+0xd4>)
 8011ef2:	6819      	ldr	r1, [r3, #0]
 8011ef4:	ea21 0202 	bic.w	r2, r1, r2
 8011ef8:	601a      	str	r2, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8011efa:	685a      	ldr	r2, [r3, #4]
 8011efc:	6801      	ldr	r1, [r0, #0]
 8011efe:	ea22 0201 	bic.w	r2, r2, r1
 8011f02:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8011f04:	7902      	ldrb	r2, [r0, #4]
 8011f06:	6801      	ldr	r1, [r0, #0]
 8011f08:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8011f0c:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 8011f10:	6814      	ldr	r4, [r2, #0]
 8011f12:	4321      	orrs	r1, r4
 8011f14:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8011f16:	689a      	ldr	r2, [r3, #8]
 8011f18:	6801      	ldr	r1, [r0, #0]
 8011f1a:	ea22 0201 	bic.w	r2, r2, r1
 8011f1e:	609a      	str	r2, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8011f20:	6801      	ldr	r1, [r0, #0]
 8011f22:	68da      	ldr	r2, [r3, #12]
 8011f24:	ea22 0201 	bic.w	r2, r2, r1
 8011f28:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8011f2a:	7942      	ldrb	r2, [r0, #5]
 8011f2c:	6801      	ldr	r1, [r0, #0]
 8011f2e:	2a10      	cmp	r2, #16
 8011f30:	d112      	bne.n	8011f58 <EXTI_Init+0xc0>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8011f32:	689a      	ldr	r2, [r3, #8]
 8011f34:	4311      	orrs	r1, r2
 8011f36:	6099      	str	r1, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8011f38:	68d9      	ldr	r1, [r3, #12]
 8011f3a:	6802      	ldr	r2, [r0, #0]
 8011f3c:	430a      	orrs	r2, r1
 8011f3e:	60da      	str	r2, [r3, #12]
 8011f40:	e011      	b.n	8011f66 <EXTI_Init+0xce>
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8011f42:	2900      	cmp	r1, #0
 8011f44:	d1d4      	bne.n	8011ef0 <EXTI_Init+0x58>
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8011f46:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8011f4a:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 8011f4e:	6819      	ldr	r1, [r3, #0]
 8011f50:	ea21 0202 	bic.w	r2, r1, r2
 8011f54:	601a      	str	r2, [r3, #0]
  }
}
 8011f56:	e006      	b.n	8011f66 <EXTI_Init+0xce>
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8011f58:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
 8011f5c:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 8011f60:	681a      	ldr	r2, [r3, #0]
 8011f62:	4311      	orrs	r1, r2
 8011f64:	6019      	str	r1, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8011f66:	b004      	add	sp, #16
 8011f68:	bd10      	pop	{r4, pc}
 8011f6a:	bf00      	nop
 8011f6c:	40013c00 	.word	0x40013c00

08011f70 <EXTI_GetITStatus>:
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
 8011f70:	1e42      	subs	r2, r0, #1
 8011f72:	2a1f      	cmp	r2, #31
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be(0..22)
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 8011f74:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
 8011f76:	d838      	bhi.n	8011fea <EXTI_GetITStatus+0x7a>
 8011f78:	4b21      	ldr	r3, [pc, #132]	; (8012000 <EXTI_GetITStatus+0x90>)
 8011f7a:	40d3      	lsrs	r3, r2
 8011f7c:	07db      	lsls	r3, r3, #31
 8011f7e:	d436      	bmi.n	8011fee <EXTI_GetITStatus+0x7e>
 8011f80:	2880      	cmp	r0, #128	; 0x80
 8011f82:	d034      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011f84:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8011f88:	d031      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011f8a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8011f8e:	d02e      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011f90:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8011f94:	d02b      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011f96:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8011f9a:	d028      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011f9c:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8011fa0:	d025      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fa2:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8011fa6:	d022      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fa8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 8011fac:	d01f      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fae:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8011fb2:	d01c      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fb4:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8011fb8:	d019      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fba:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 8011fbe:	d016      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fc0:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8011fc4:	d013      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fc6:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8011fca:	d010      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fcc:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 8011fd0:	d00d      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fd2:	f5b0 1f00 	cmp.w	r0, #2097152	; 0x200000
 8011fd6:	d00a      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fd8:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
 8011fdc:	d007      	beq.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fde:	2301      	movs	r3, #1
 8011fe0:	9301      	str	r3, [sp, #4]
 8011fe2:	9b01      	ldr	r3, [sp, #4]
 8011fe4:	2b00      	cmp	r3, #0
 8011fe6:	d1fc      	bne.n	8011fe2 <EXTI_GetITStatus+0x72>
 8011fe8:	e001      	b.n	8011fee <EXTI_GetITStatus+0x7e>
 8011fea:	2840      	cmp	r0, #64	; 0x40
 8011fec:	d1c8      	bne.n	8011f80 <EXTI_GetITStatus+0x10>
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8011fee:	4b05      	ldr	r3, [pc, #20]	; (8012004 <EXTI_GetITStatus+0x94>)
 8011ff0:	695b      	ldr	r3, [r3, #20]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8011ff2:	4218      	tst	r0, r3
 8011ff4:	bf14      	ite	ne
 8011ff6:	2001      	movne	r0, #1
 8011ff8:	2000      	moveq	r0, #0
  
}
 8011ffa:	b002      	add	sp, #8
 8011ffc:	4770      	bx	lr
 8011ffe:	bf00      	nop
 8012000:	8000808b 	.word	0x8000808b
 8012004:	40013c00 	.word	0x40013c00

08012008 <EXTI_ClearITPendingBit>:
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
 8012008:	0dc3      	lsrs	r3, r0, #23
 801200a:	05db      	lsls	r3, r3, #23
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 801200c:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
 801200e:	b923      	cbnz	r3, 801201a <EXTI_ClearITPendingBit+0x12>
 8012010:	b118      	cbz	r0, 801201a <EXTI_ClearITPendingBit+0x12>
  
  EXTI->PR = EXTI_Line;
 8012012:	4b05      	ldr	r3, [pc, #20]	; (8012028 <EXTI_ClearITPendingBit+0x20>)
 8012014:	6158      	str	r0, [r3, #20]
}
 8012016:	b002      	add	sp, #8
 8012018:	4770      	bx	lr
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
 801201a:	2301      	movs	r3, #1
 801201c:	9301      	str	r3, [sp, #4]
 801201e:	9b01      	ldr	r3, [sp, #4]
 8012020:	2b00      	cmp	r3, #0
 8012022:	d1fc      	bne.n	801201e <EXTI_ClearITPendingBit+0x16>
 8012024:	e7f5      	b.n	8012012 <EXTI_ClearITPendingBit+0xa>
 8012026:	bf00      	nop
 8012028:	40013c00 	.word	0x40013c00

0801202c <SYSCFG_EXTILineConfig>:
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
  uint32_t tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
 801202c:	280a      	cmp	r0, #10
  *           be (0..7) for STM32F42xxx/43xxx devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 801202e:	b513      	push	{r0, r1, r4, lr}
  uint32_t tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
 8012030:	d802      	bhi.n	8012038 <SYSCFG_EXTILineConfig+0xc>
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
 8012032:	290f      	cmp	r1, #15
 8012034:	d806      	bhi.n	8012044 <SYSCFG_EXTILineConfig+0x18>
 8012036:	e00a      	b.n	801204e <SYSCFG_EXTILineConfig+0x22>
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
  uint32_t tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
 8012038:	2301      	movs	r3, #1
 801203a:	9300      	str	r3, [sp, #0]
 801203c:	9b00      	ldr	r3, [sp, #0]
 801203e:	2b00      	cmp	r3, #0
 8012040:	d1fc      	bne.n	801203c <SYSCFG_EXTILineConfig+0x10>
 8012042:	e7f6      	b.n	8012032 <SYSCFG_EXTILineConfig+0x6>
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
 8012044:	2301      	movs	r3, #1
 8012046:	9301      	str	r3, [sp, #4]
 8012048:	9b01      	ldr	r3, [sp, #4]
 801204a:	2b00      	cmp	r3, #0
 801204c:	d1fc      	bne.n	8012048 <SYSCFG_EXTILineConfig+0x1c>

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 801204e:	f001 0203 	and.w	r2, r1, #3
 8012052:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
 8012056:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 801205a:	f501 319c 	add.w	r1, r1, #79872	; 0x13800
 801205e:	0093      	lsls	r3, r2, #2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8012060:	688c      	ldr	r4, [r1, #8]
 8012062:	220f      	movs	r2, #15
 8012064:	409a      	lsls	r2, r3
 8012066:	ea24 0202 	bic.w	r2, r4, r2
 801206a:	608a      	str	r2, [r1, #8]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 801206c:	688a      	ldr	r2, [r1, #8]
 801206e:	fa00 f303 	lsl.w	r3, r0, r3
 8012072:	4313      	orrs	r3, r2
 8012074:	608b      	str	r3, [r1, #8]
}
 8012076:	b002      	add	sp, #8
 8012078:	bd10      	pop	{r4, pc}
	...

0801207c <I2C_DeInit>:
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801207c:	4b18      	ldr	r3, [pc, #96]	; (80120e0 <I2C_DeInit+0x64>)
 801207e:	4298      	cmp	r0, r3
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 8012080:	b507      	push	{r0, r1, r2, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012082:	d00d      	beq.n	80120a0 <I2C_DeInit+0x24>
 8012084:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012088:	4298      	cmp	r0, r3
 801208a:	d012      	beq.n	80120b2 <I2C_DeInit+0x36>
 801208c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012090:	4298      	cmp	r0, r3
 8012092:	d017      	beq.n	80120c4 <I2C_DeInit+0x48>
 8012094:	2301      	movs	r3, #1
 8012096:	9301      	str	r3, [sp, #4]
 8012098:	9b01      	ldr	r3, [sp, #4]
 801209a:	2b00      	cmp	r3, #0
 801209c:	d1fc      	bne.n	8012098 <I2C_DeInit+0x1c>
 801209e:	e01b      	b.n	80120d8 <I2C_DeInit+0x5c>

  if (I2Cx == I2C1)
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 80120a0:	2101      	movs	r1, #1
 80120a2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80120a6:	f7ff f8f1 	bl	801128c <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 80120aa:	2100      	movs	r1, #0
 80120ac:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80120b0:	e010      	b.n	80120d4 <I2C_DeInit+0x58>
  }
  else if (I2Cx == I2C2)
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 80120b2:	2101      	movs	r1, #1
 80120b4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80120b8:	f7ff f8e8 	bl	801128c <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 80120bc:	2100      	movs	r1, #0
 80120be:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80120c2:	e007      	b.n	80120d4 <I2C_DeInit+0x58>
  else 
  {
    if (I2Cx == I2C3)
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 80120c4:	2101      	movs	r1, #1
 80120c6:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80120ca:	f7ff f8df 	bl	801128c <RCC_APB1PeriphResetCmd>
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 80120ce:	2100      	movs	r1, #0
 80120d0:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80120d4:	f7ff f8da 	bl	801128c <RCC_APB1PeriphResetCmd>
    }
  }
}
 80120d8:	b003      	add	sp, #12
 80120da:	f85d fb04 	ldr.w	pc, [sp], #4
 80120de:	bf00      	nop
 80120e0:	40005400 	.word	0x40005400

080120e4 <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 80120e4:	b570      	push	{r4, r5, r6, lr}
  uint16_t tmpreg = 0, freqrange = 0;
  uint16_t result = 0x04;
  uint32_t pclk1 = 8000000;
  RCC_ClocksTypeDef  rcc_clocks;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80120e6:	4b5b      	ldr	r3, [pc, #364]	; (8012254 <I2C_Init+0x170>)
 80120e8:	4298      	cmp	r0, r3
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 80120ea:	b08c      	sub	sp, #48	; 0x30
 80120ec:	4604      	mov	r4, r0
 80120ee:	460d      	mov	r5, r1
  uint16_t tmpreg = 0, freqrange = 0;
  uint16_t result = 0x04;
  uint32_t pclk1 = 8000000;
  RCC_ClocksTypeDef  rcc_clocks;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80120f0:	d105      	bne.n	80120fe <I2C_Init+0x1a>
  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
 80120f2:	682b      	ldr	r3, [r5, #0]
 80120f4:	4a58      	ldr	r2, [pc, #352]	; (8012258 <I2C_Init+0x174>)
 80120f6:	3b01      	subs	r3, #1
 80120f8:	4293      	cmp	r3, r2
 80120fa:	d80d      	bhi.n	8012118 <I2C_Init+0x34>
 80120fc:	e011      	b.n	8012122 <I2C_Init+0x3e>
  uint16_t tmpreg = 0, freqrange = 0;
  uint16_t result = 0x04;
  uint32_t pclk1 = 8000000;
  RCC_ClocksTypeDef  rcc_clocks;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80120fe:	4b57      	ldr	r3, [pc, #348]	; (801225c <I2C_Init+0x178>)
 8012100:	4298      	cmp	r0, r3
 8012102:	d0f6      	beq.n	80120f2 <I2C_Init+0xe>
 8012104:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012108:	4298      	cmp	r0, r3
 801210a:	d0f2      	beq.n	80120f2 <I2C_Init+0xe>
 801210c:	2301      	movs	r3, #1
 801210e:	9301      	str	r3, [sp, #4]
 8012110:	9b01      	ldr	r3, [sp, #4]
 8012112:	2b00      	cmp	r3, #0
 8012114:	d1fc      	bne.n	8012110 <I2C_Init+0x2c>
 8012116:	e7ec      	b.n	80120f2 <I2C_Init+0xe>
  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
 8012118:	2301      	movs	r3, #1
 801211a:	9302      	str	r3, [sp, #8]
 801211c:	9b02      	ldr	r3, [sp, #8]
 801211e:	2b00      	cmp	r3, #0
 8012120:	d1fc      	bne.n	801211c <I2C_Init+0x38>
  assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
 8012122:	88ab      	ldrh	r3, [r5, #4]
 8012124:	f023 0202 	bic.w	r2, r3, #2
 8012128:	b132      	cbz	r2, 8012138 <I2C_Init+0x54>
 801212a:	2b0a      	cmp	r3, #10
 801212c:	d004      	beq.n	8012138 <I2C_Init+0x54>
 801212e:	2301      	movs	r3, #1
 8012130:	9303      	str	r3, [sp, #12]
 8012132:	9b03      	ldr	r3, [sp, #12]
 8012134:	2b00      	cmp	r3, #0
 8012136:	d1fc      	bne.n	8012132 <I2C_Init+0x4e>
  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
 8012138:	88eb      	ldrh	r3, [r5, #6]
 801213a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801213e:	d008      	beq.n	8012152 <I2C_Init+0x6e>
 8012140:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 8012144:	4293      	cmp	r3, r2
 8012146:	d004      	beq.n	8012152 <I2C_Init+0x6e>
 8012148:	2301      	movs	r3, #1
 801214a:	9304      	str	r3, [sp, #16]
 801214c:	9b04      	ldr	r3, [sp, #16]
 801214e:	2b00      	cmp	r3, #0
 8012150:	d1fc      	bne.n	801214c <I2C_Init+0x68>
  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
 8012152:	892b      	ldrh	r3, [r5, #8]
 8012154:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8012158:	d304      	bcc.n	8012164 <I2C_Init+0x80>
 801215a:	2301      	movs	r3, #1
 801215c:	9305      	str	r3, [sp, #20]
 801215e:	9b05      	ldr	r3, [sp, #20]
 8012160:	2b00      	cmp	r3, #0
 8012162:	d1fc      	bne.n	801215e <I2C_Init+0x7a>
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
 8012164:	896b      	ldrh	r3, [r5, #10]
 8012166:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801216a:	b29b      	uxth	r3, r3
 801216c:	b123      	cbz	r3, 8012178 <I2C_Init+0x94>
 801216e:	2301      	movs	r3, #1
 8012170:	9306      	str	r3, [sp, #24]
 8012172:	9b06      	ldr	r3, [sp, #24]
 8012174:	2b00      	cmp	r3, #0
 8012176:	d1fc      	bne.n	8012172 <I2C_Init+0x8e>
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
 8012178:	89ab      	ldrh	r3, [r5, #12]
 801217a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 801217e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8012182:	d004      	beq.n	801218e <I2C_Init+0xaa>
 8012184:	2301      	movs	r3, #1
 8012186:	9307      	str	r3, [sp, #28]
 8012188:	9b07      	ldr	r3, [sp, #28]
 801218a:	2b00      	cmp	r3, #0
 801218c:	d1fc      	bne.n	8012188 <I2C_Init+0xa4>

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 801218e:	88a6      	ldrh	r6, [r4, #4]
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8012190:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8012194:	a808      	add	r0, sp, #32

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8012196:	0436      	lsls	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8012198:	f7fe ffc8 	bl	801112c <RCC_GetClocksFreq>

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 801219c:	0c36      	lsrs	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
 801219e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 80121a0:	482f      	ldr	r0, [pc, #188]	; (8012260 <I2C_Init+0x17c>)
 80121a2:	fbb2 f0f0 	udiv	r0, r2, r0
 80121a6:	b281      	uxth	r1, r0
  tmpreg |= freqrange;
 80121a8:	430e      	orrs	r6, r1
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 80121aa:	80a6      	strh	r6, [r4, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 80121ac:	8823      	ldrh	r3, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 80121ae:	4e2d      	ldr	r6, [pc, #180]	; (8012264 <I2C_Init+0x180>)
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 80121b0:	f023 0301 	bic.w	r3, r3, #1
 80121b4:	041b      	lsls	r3, r3, #16
 80121b6:	0c1b      	lsrs	r3, r3, #16
 80121b8:	8023      	strh	r3, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 80121ba:	682b      	ldr	r3, [r5, #0]
 80121bc:	42b3      	cmp	r3, r6
 80121be:	d80a      	bhi.n	80121d6 <I2C_Init+0xf2>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 80121c0:	005b      	lsls	r3, r3, #1
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 80121c2:	3101      	adds	r1, #1

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 80121c4:	fbb2 f3f3 	udiv	r3, r2, r3
 80121c8:	b29b      	uxth	r3, r3
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
    {
      /* Set minimum allowed value */
      result = 0x04;  
 80121ca:	2b03      	cmp	r3, #3
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 80121cc:	b289      	uxth	r1, r1
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
    {
      /* Set minimum allowed value */
      result = 0x04;  
 80121ce:	bf98      	it	ls
 80121d0:	2304      	movls	r3, #4
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 80121d2:	8421      	strh	r1, [r4, #32]
 80121d4:	e023      	b.n	801221e <I2C_Init+0x13a>
  /* Configure speed in fast mode */
  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
     input clock) must be a multiple of 10 MHz */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 80121d6:	88ee      	ldrh	r6, [r5, #6]
 80121d8:	f64b 71ff 	movw	r1, #49151	; 0xbfff
 80121dc:	428e      	cmp	r6, r1
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 80121de:	bf1b      	ittet	ne
 80121e0:	2119      	movne	r1, #25
 80121e2:	434b      	mulne	r3, r1
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 80121e4:	eb03 0343 	addeq.w	r3, r3, r3, lsl #1
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 80121e8:	fbb2 f3f3 	udivne	r3, r2, r3
 80121ec:	bf15      	itete	ne
 80121ee:	b29b      	uxthne	r3, r3
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 80121f0:	fbb2 f3f3 	udiveq	r3, r2, r3
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 80121f4:	f443 4380 	orrne.w	r3, r3, #16384	; 0x4000
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 80121f8:	b29b      	uxtheq	r3, r3
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
    }

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
 80121fa:	f3c3 020b 	ubfx	r2, r3, #0, #12
 80121fe:	b90a      	cbnz	r2, 8012204 <I2C_Init+0x120>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 8012200:	f043 0301 	orr.w	r3, r3, #1
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8012204:	f44f 7196 	mov.w	r1, #300	; 0x12c
 8012208:	fb01 f200 	mul.w	r2, r1, r0
 801220c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8012210:	fb92 f2f1 	sdiv	r2, r2, r1
 8012214:	3201      	adds	r2, #1
 8012216:	b292      	uxth	r2, r2
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 8012218:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 801221c:	8422      	strh	r2, [r4, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 801221e:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8012220:	8823      	ldrh	r3, [r4, #0]
 8012222:	b29b      	uxth	r3, r3
 8012224:	f043 0301 	orr.w	r3, r3, #1
 8012228:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 801222a:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 801222c:	88a9      	ldrh	r1, [r5, #4]
 801222e:	896a      	ldrh	r2, [r5, #10]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 8012230:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8012234:	f023 0302 	bic.w	r3, r3, #2
 8012238:	041b      	lsls	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 801223a:	430a      	orrs	r2, r1

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 801223c:	0c1b      	lsrs	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 801223e:	4313      	orrs	r3, r2
 8012240:	b29b      	uxth	r3, r3
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8012242:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8012244:	89aa      	ldrh	r2, [r5, #12]
 8012246:	892b      	ldrh	r3, [r5, #8]
 8012248:	4313      	orrs	r3, r2
 801224a:	b29b      	uxth	r3, r3
 801224c:	8123      	strh	r3, [r4, #8]
}
 801224e:	b00c      	add	sp, #48	; 0x30
 8012250:	bd70      	pop	{r4, r5, r6, pc}
 8012252:	bf00      	nop
 8012254:	40005400 	.word	0x40005400
 8012258:	00061a7f 	.word	0x00061a7f
 801225c:	40005800 	.word	0x40005800
 8012260:	000f4240 	.word	0x000f4240
 8012264:	000186a0 	.word	0x000186a0

08012268 <I2C_Cmd>:
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012268:	4b13      	ldr	r3, [pc, #76]	; (80122b8 <I2C_Cmd+0x50>)
 801226a:	4298      	cmp	r0, r3
  * @param  NewState: new state of the I2Cx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 801226c:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801226e:	d104      	bne.n	801227a <I2C_Cmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012270:	2901      	cmp	r1, #1
 8012272:	d917      	bls.n	80122a4 <I2C_Cmd+0x3c>
 8012274:	2301      	movs	r3, #1
 8012276:	9301      	str	r3, [sp, #4]
 8012278:	e00c      	b.n	8012294 <I2C_Cmd+0x2c>
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801227a:	4b10      	ldr	r3, [pc, #64]	; (80122bc <I2C_Cmd+0x54>)
 801227c:	4298      	cmp	r0, r3
 801227e:	d0f7      	beq.n	8012270 <I2C_Cmd+0x8>
 8012280:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012284:	4298      	cmp	r0, r3
 8012286:	d0f3      	beq.n	8012270 <I2C_Cmd+0x8>
 8012288:	2301      	movs	r3, #1
 801228a:	9300      	str	r3, [sp, #0]
 801228c:	9b00      	ldr	r3, [sp, #0]
 801228e:	2b00      	cmp	r3, #0
 8012290:	d1fc      	bne.n	801228c <I2C_Cmd+0x24>
 8012292:	e7ed      	b.n	8012270 <I2C_Cmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012294:	9b01      	ldr	r3, [sp, #4]
 8012296:	2b00      	cmp	r3, #0
 8012298:	d1fc      	bne.n	8012294 <I2C_Cmd+0x2c>
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 801229a:	8803      	ldrh	r3, [r0, #0]
 801229c:	b29b      	uxth	r3, r3
 801229e:	f043 0301 	orr.w	r3, r3, #1
 80122a2:	e006      	b.n	80122b2 <I2C_Cmd+0x4a>
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80122a4:	2900      	cmp	r1, #0
 80122a6:	d1f8      	bne.n	801229a <I2C_Cmd+0x32>
    I2Cx->CR1 |= I2C_CR1_PE;
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 80122a8:	8803      	ldrh	r3, [r0, #0]
 80122aa:	f023 0301 	bic.w	r3, r3, #1
 80122ae:	041b      	lsls	r3, r3, #16
 80122b0:	0c1b      	lsrs	r3, r3, #16
 80122b2:	8003      	strh	r3, [r0, #0]
  }
}
 80122b4:	b002      	add	sp, #8
 80122b6:	4770      	bx	lr
 80122b8:	40005400 	.word	0x40005400
 80122bc:	40005800 	.word	0x40005800

080122c0 <I2C_GenerateSTART>:
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80122c0:	4b13      	ldr	r3, [pc, #76]	; (8012310 <I2C_GenerateSTART+0x50>)
 80122c2:	4298      	cmp	r0, r3
  * @param  NewState: new state of the I2C START condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 80122c4:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80122c6:	d104      	bne.n	80122d2 <I2C_GenerateSTART+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80122c8:	2901      	cmp	r1, #1
 80122ca:	d917      	bls.n	80122fc <I2C_GenerateSTART+0x3c>
 80122cc:	2301      	movs	r3, #1
 80122ce:	9301      	str	r3, [sp, #4]
 80122d0:	e00c      	b.n	80122ec <I2C_GenerateSTART+0x2c>
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80122d2:	4b10      	ldr	r3, [pc, #64]	; (8012314 <I2C_GenerateSTART+0x54>)
 80122d4:	4298      	cmp	r0, r3
 80122d6:	d0f7      	beq.n	80122c8 <I2C_GenerateSTART+0x8>
 80122d8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80122dc:	4298      	cmp	r0, r3
 80122de:	d0f3      	beq.n	80122c8 <I2C_GenerateSTART+0x8>
 80122e0:	2301      	movs	r3, #1
 80122e2:	9300      	str	r3, [sp, #0]
 80122e4:	9b00      	ldr	r3, [sp, #0]
 80122e6:	2b00      	cmp	r3, #0
 80122e8:	d1fc      	bne.n	80122e4 <I2C_GenerateSTART+0x24>
 80122ea:	e7ed      	b.n	80122c8 <I2C_GenerateSTART+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80122ec:	9b01      	ldr	r3, [sp, #4]
 80122ee:	2b00      	cmp	r3, #0
 80122f0:	d1fc      	bne.n	80122ec <I2C_GenerateSTART+0x2c>
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 80122f2:	8803      	ldrh	r3, [r0, #0]
 80122f4:	b29b      	uxth	r3, r3
 80122f6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80122fa:	e006      	b.n	801230a <I2C_GenerateSTART+0x4a>
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80122fc:	2900      	cmp	r1, #0
 80122fe:	d1f8      	bne.n	80122f2 <I2C_GenerateSTART+0x32>
    I2Cx->CR1 |= I2C_CR1_START;
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 8012300:	8803      	ldrh	r3, [r0, #0]
 8012302:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8012306:	041b      	lsls	r3, r3, #16
 8012308:	0c1b      	lsrs	r3, r3, #16
 801230a:	8003      	strh	r3, [r0, #0]
  }
}
 801230c:	b002      	add	sp, #8
 801230e:	4770      	bx	lr
 8012310:	40005400 	.word	0x40005400
 8012314:	40005800 	.word	0x40005800

08012318 <I2C_GenerateSTOP>:
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012318:	4b13      	ldr	r3, [pc, #76]	; (8012368 <I2C_GenerateSTOP+0x50>)
 801231a:	4298      	cmp	r0, r3
  * @param  NewState: new state of the I2C STOP condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 801231c:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801231e:	d104      	bne.n	801232a <I2C_GenerateSTOP+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012320:	2901      	cmp	r1, #1
 8012322:	d917      	bls.n	8012354 <I2C_GenerateSTOP+0x3c>
 8012324:	2301      	movs	r3, #1
 8012326:	9301      	str	r3, [sp, #4]
 8012328:	e00c      	b.n	8012344 <I2C_GenerateSTOP+0x2c>
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801232a:	4b10      	ldr	r3, [pc, #64]	; (801236c <I2C_GenerateSTOP+0x54>)
 801232c:	4298      	cmp	r0, r3
 801232e:	d0f7      	beq.n	8012320 <I2C_GenerateSTOP+0x8>
 8012330:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012334:	4298      	cmp	r0, r3
 8012336:	d0f3      	beq.n	8012320 <I2C_GenerateSTOP+0x8>
 8012338:	2301      	movs	r3, #1
 801233a:	9300      	str	r3, [sp, #0]
 801233c:	9b00      	ldr	r3, [sp, #0]
 801233e:	2b00      	cmp	r3, #0
 8012340:	d1fc      	bne.n	801233c <I2C_GenerateSTOP+0x24>
 8012342:	e7ed      	b.n	8012320 <I2C_GenerateSTOP+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012344:	9b01      	ldr	r3, [sp, #4]
 8012346:	2b00      	cmp	r3, #0
 8012348:	d1fc      	bne.n	8012344 <I2C_GenerateSTOP+0x2c>
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 801234a:	8803      	ldrh	r3, [r0, #0]
 801234c:	b29b      	uxth	r3, r3
 801234e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8012352:	e006      	b.n	8012362 <I2C_GenerateSTOP+0x4a>
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8012354:	2900      	cmp	r1, #0
 8012356:	d1f8      	bne.n	801234a <I2C_GenerateSTOP+0x32>
    I2Cx->CR1 |= I2C_CR1_STOP;
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 8012358:	8803      	ldrh	r3, [r0, #0]
 801235a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 801235e:	041b      	lsls	r3, r3, #16
 8012360:	0c1b      	lsrs	r3, r3, #16
 8012362:	8003      	strh	r3, [r0, #0]
  }
}
 8012364:	b002      	add	sp, #8
 8012366:	4770      	bx	lr
 8012368:	40005400 	.word	0x40005400
 801236c:	40005800 	.word	0x40005800

08012370 <I2C_Send7bitAddress>:
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012370:	4b11      	ldr	r3, [pc, #68]	; (80123b8 <I2C_Send7bitAddress+0x48>)
 8012372:	4298      	cmp	r0, r3
  *            @arg I2C_Direction_Transmitter: Transmitter mode
  *            @arg I2C_Direction_Receiver: Receiver mode
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
 8012374:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012376:	d104      	bne.n	8012382 <I2C_Send7bitAddress+0x12>
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
 8012378:	2a01      	cmp	r2, #1
 801237a:	d915      	bls.n	80123a8 <I2C_Send7bitAddress+0x38>
 801237c:	2301      	movs	r3, #1
 801237e:	9301      	str	r3, [sp, #4]
 8012380:	e00c      	b.n	801239c <I2C_Send7bitAddress+0x2c>
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012382:	4b0e      	ldr	r3, [pc, #56]	; (80123bc <I2C_Send7bitAddress+0x4c>)
 8012384:	4298      	cmp	r0, r3
 8012386:	d0f7      	beq.n	8012378 <I2C_Send7bitAddress+0x8>
 8012388:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801238c:	4298      	cmp	r0, r3
 801238e:	d0f3      	beq.n	8012378 <I2C_Send7bitAddress+0x8>
 8012390:	2301      	movs	r3, #1
 8012392:	9300      	str	r3, [sp, #0]
 8012394:	9b00      	ldr	r3, [sp, #0]
 8012396:	2b00      	cmp	r3, #0
 8012398:	d1fc      	bne.n	8012394 <I2C_Send7bitAddress+0x24>
 801239a:	e7ed      	b.n	8012378 <I2C_Send7bitAddress+0x8>
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
 801239c:	9b01      	ldr	r3, [sp, #4]
 801239e:	2b00      	cmp	r3, #0
 80123a0:	d1fc      	bne.n	801239c <I2C_Send7bitAddress+0x2c>
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
  {
    /* Set the address bit0 for read */
    Address |= I2C_OAR1_ADD0;
 80123a2:	f041 0101 	orr.w	r1, r1, #1
 80123a6:	e003      	b.n	80123b0 <I2C_Send7bitAddress+0x40>
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 80123a8:	2a00      	cmp	r2, #0
 80123aa:	d1fa      	bne.n	80123a2 <I2C_Send7bitAddress+0x32>
    Address |= I2C_OAR1_ADD0;
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 80123ac:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 80123b0:	b289      	uxth	r1, r1
 80123b2:	8201      	strh	r1, [r0, #16]
}
 80123b4:	b002      	add	sp, #8
 80123b6:	4770      	bx	lr
 80123b8:	40005400 	.word	0x40005400
 80123bc:	40005800 	.word	0x40005800

080123c0 <I2C_AcknowledgeConfig>:
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80123c0:	4b13      	ldr	r3, [pc, #76]	; (8012410 <I2C_AcknowledgeConfig+0x50>)
 80123c2:	4298      	cmp	r0, r3
  * @param  NewState: new state of the I2C Acknowledgement.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 80123c4:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80123c6:	d104      	bne.n	80123d2 <I2C_AcknowledgeConfig+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80123c8:	2901      	cmp	r1, #1
 80123ca:	d917      	bls.n	80123fc <I2C_AcknowledgeConfig+0x3c>
 80123cc:	2301      	movs	r3, #1
 80123ce:	9301      	str	r3, [sp, #4]
 80123d0:	e00c      	b.n	80123ec <I2C_AcknowledgeConfig+0x2c>
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 80123d2:	4b10      	ldr	r3, [pc, #64]	; (8012414 <I2C_AcknowledgeConfig+0x54>)
 80123d4:	4298      	cmp	r0, r3
 80123d6:	d0f7      	beq.n	80123c8 <I2C_AcknowledgeConfig+0x8>
 80123d8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80123dc:	4298      	cmp	r0, r3
 80123de:	d0f3      	beq.n	80123c8 <I2C_AcknowledgeConfig+0x8>
 80123e0:	2301      	movs	r3, #1
 80123e2:	9300      	str	r3, [sp, #0]
 80123e4:	9b00      	ldr	r3, [sp, #0]
 80123e6:	2b00      	cmp	r3, #0
 80123e8:	d1fc      	bne.n	80123e4 <I2C_AcknowledgeConfig+0x24>
 80123ea:	e7ed      	b.n	80123c8 <I2C_AcknowledgeConfig+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80123ec:	9b01      	ldr	r3, [sp, #4]
 80123ee:	2b00      	cmp	r3, #0
 80123f0:	d1fc      	bne.n	80123ec <I2C_AcknowledgeConfig+0x2c>
  if (NewState != DISABLE)
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 80123f2:	8803      	ldrh	r3, [r0, #0]
 80123f4:	b29b      	uxth	r3, r3
 80123f6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80123fa:	e006      	b.n	801240a <I2C_AcknowledgeConfig+0x4a>
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80123fc:	2900      	cmp	r1, #0
 80123fe:	d1f8      	bne.n	80123f2 <I2C_AcknowledgeConfig+0x32>
    I2Cx->CR1 |= I2C_CR1_ACK;
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 8012400:	8803      	ldrh	r3, [r0, #0]
 8012402:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8012406:	041b      	lsls	r3, r3, #16
 8012408:	0c1b      	lsrs	r3, r3, #16
 801240a:	8003      	strh	r3, [r0, #0]
  }
}
 801240c:	b002      	add	sp, #8
 801240e:	4770      	bx	lr
 8012410:	40005400 	.word	0x40005400
 8012414:	40005800 	.word	0x40005800

08012418 <I2C_SendData>:
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012418:	4b0a      	ldr	r3, [pc, #40]	; (8012444 <I2C_SendData+0x2c>)
 801241a:	4298      	cmp	r0, r3
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Data: Byte to be transmitted..
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
 801241c:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801241e:	d103      	bne.n	8012428 <I2C_SendData+0x10>
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8012420:	b289      	uxth	r1, r1
 8012422:	8201      	strh	r1, [r0, #16]
}
 8012424:	b002      	add	sp, #8
 8012426:	4770      	bx	lr
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012428:	4b07      	ldr	r3, [pc, #28]	; (8012448 <I2C_SendData+0x30>)
 801242a:	4298      	cmp	r0, r3
 801242c:	d0f8      	beq.n	8012420 <I2C_SendData+0x8>
 801242e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012432:	4298      	cmp	r0, r3
 8012434:	d0f4      	beq.n	8012420 <I2C_SendData+0x8>
 8012436:	2301      	movs	r3, #1
 8012438:	9301      	str	r3, [sp, #4]
 801243a:	9b01      	ldr	r3, [sp, #4]
 801243c:	2b00      	cmp	r3, #0
 801243e:	d1fc      	bne.n	801243a <I2C_SendData+0x22>
 8012440:	e7ee      	b.n	8012420 <I2C_SendData+0x8>
 8012442:	bf00      	nop
 8012444:	40005400 	.word	0x40005400
 8012448:	40005800 	.word	0x40005800

0801244c <I2C_ReceiveData>:
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801244c:	4b0a      	ldr	r3, [pc, #40]	; (8012478 <I2C_ReceiveData+0x2c>)
 801244e:	4298      	cmp	r0, r3
  * @brief  Returns the most recent received data by the I2Cx peripheral.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
 8012450:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012452:	d00c      	beq.n	801246e <I2C_ReceiveData+0x22>
 8012454:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012458:	4298      	cmp	r0, r3
 801245a:	d008      	beq.n	801246e <I2C_ReceiveData+0x22>
 801245c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012460:	4298      	cmp	r0, r3
 8012462:	d004      	beq.n	801246e <I2C_ReceiveData+0x22>
 8012464:	2301      	movs	r3, #1
 8012466:	9301      	str	r3, [sp, #4]
 8012468:	9b01      	ldr	r3, [sp, #4]
 801246a:	2b00      	cmp	r3, #0
 801246c:	d1fc      	bne.n	8012468 <I2C_ReceiveData+0x1c>
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 801246e:	8a00      	ldrh	r0, [r0, #16]
 8012470:	b2c0      	uxtb	r0, r0
}
 8012472:	b002      	add	sp, #8
 8012474:	4770      	bx	lr
 8012476:	bf00      	nop
 8012478:	40005400 	.word	0x40005400

0801247c <I2C_CheckEvent>:
  uint32_t lastevent = 0;
  uint32_t flag1 = 0, flag2 = 0;
  ErrorStatus status = ERROR;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801247c:	4b28      	ldr	r3, [pc, #160]	; (8012520 <I2C_CheckEvent+0xa4>)
 801247e:	4298      	cmp	r0, r3
  * @retval An ErrorStatus enumeration value:
  *           - SUCCESS: Last event is equal to the I2C_EVENT
  *           - ERROR: Last event is different from the I2C_EVENT
  */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
 8012480:	b513      	push	{r0, r1, r4, lr}
  uint32_t lastevent = 0;
  uint32_t flag1 = 0, flag2 = 0;
  ErrorStatus status = ERROR;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012482:	d105      	bne.n	8012490 <I2C_CheckEvent+0x14>
  assert_param(IS_I2C_EVENT(I2C_EVENT));
 8012484:	4a27      	ldr	r2, [pc, #156]	; (8012524 <I2C_CheckEvent+0xa8>)
 8012486:	f421 3380 	bic.w	r3, r1, #65536	; 0x10000
 801248a:	4293      	cmp	r3, r2
 801248c:	d10d      	bne.n	80124aa <I2C_CheckEvent+0x2e>
 801248e:	e03a      	b.n	8012506 <I2C_CheckEvent+0x8a>
  uint32_t lastevent = 0;
  uint32_t flag1 = 0, flag2 = 0;
  ErrorStatus status = ERROR;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012490:	4b25      	ldr	r3, [pc, #148]	; (8012528 <I2C_CheckEvent+0xac>)
 8012492:	4298      	cmp	r0, r3
 8012494:	d0f6      	beq.n	8012484 <I2C_CheckEvent+0x8>
 8012496:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801249a:	4298      	cmp	r0, r3
 801249c:	d0f2      	beq.n	8012484 <I2C_CheckEvent+0x8>
 801249e:	2301      	movs	r3, #1
 80124a0:	9300      	str	r3, [sp, #0]
 80124a2:	9b00      	ldr	r3, [sp, #0]
 80124a4:	2b00      	cmp	r3, #0
 80124a6:	d1fc      	bne.n	80124a2 <I2C_CheckEvent+0x26>
 80124a8:	e7ec      	b.n	8012484 <I2C_CheckEvent+0x8>
  assert_param(IS_I2C_EVENT(I2C_EVENT));
 80124aa:	f1b1 1f02 	cmp.w	r1, #131074	; 0x20002
 80124ae:	d02a      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124b0:	4a1e      	ldr	r2, [pc, #120]	; (801252c <I2C_CheckEvent+0xb0>)
 80124b2:	f021 0404 	bic.w	r4, r1, #4
 80124b6:	4294      	cmp	r4, r2
 80124b8:	d025      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124ba:	f021 0240 	bic.w	r2, r1, #64	; 0x40
 80124be:	f5b2 0f02 	cmp.w	r2, #8519680	; 0x820000
 80124c2:	d020      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124c4:	f5b2 1f90 	cmp.w	r2, #1179648	; 0x120000
 80124c8:	d01d      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124ca:	4a19      	ldr	r2, [pc, #100]	; (8012530 <I2C_CheckEvent+0xb4>)
 80124cc:	4293      	cmp	r3, r2
 80124ce:	d01a      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124d0:	4a18      	ldr	r2, [pc, #96]	; (8012534 <I2C_CheckEvent+0xb8>)
 80124d2:	4293      	cmp	r3, r2
 80124d4:	d017      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124d6:	4b18      	ldr	r3, [pc, #96]	; (8012538 <I2C_CheckEvent+0xbc>)
 80124d8:	4299      	cmp	r1, r3
 80124da:	d014      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124dc:	2910      	cmp	r1, #16
 80124de:	d012      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124e0:	f5a1 3340 	sub.w	r3, r1, #196608	; 0x30000
 80124e4:	3b01      	subs	r3, #1
 80124e6:	2b01      	cmp	r3, #1
 80124e8:	d90d      	bls.n	8012506 <I2C_CheckEvent+0x8a>
 80124ea:	4b14      	ldr	r3, [pc, #80]	; (801253c <I2C_CheckEvent+0xc0>)
 80124ec:	4299      	cmp	r1, r3
 80124ee:	d00a      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124f0:	4b13      	ldr	r3, [pc, #76]	; (8012540 <I2C_CheckEvent+0xc4>)
 80124f2:	4299      	cmp	r1, r3
 80124f4:	d007      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124f6:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 80124fa:	d004      	beq.n	8012506 <I2C_CheckEvent+0x8a>
 80124fc:	2301      	movs	r3, #1
 80124fe:	9301      	str	r3, [sp, #4]
 8012500:	9b01      	ldr	r3, [sp, #4]
 8012502:	2b00      	cmp	r3, #0
 8012504:	d1fc      	bne.n	8012500 <I2C_CheckEvent+0x84>

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8012506:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 8012508:	8b00      	ldrh	r0, [r0, #24]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 801250a:	b29b      	uxth	r3, r3
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
  }
  /* Return status */
  return status;
 801250c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8012510:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000
 8012514:	4018      	ands	r0, r3
 8012516:	1a43      	subs	r3, r0, r1
 8012518:	4258      	negs	r0, r3
 801251a:	4158      	adcs	r0, r3
}
 801251c:	b002      	add	sp, #8
 801251e:	bd10      	pop	{r4, pc}
 8012520:	40005400 	.word	0x40005400
 8012524:	00060082 	.word	0x00060082
 8012528:	40005800 	.word	0x40005800
 801252c:	00860080 	.word	0x00860080
 8012530:	00020040 	.word	0x00020040
 8012534:	00060084 	.word	0x00060084
 8012538:	00160084 	.word	0x00160084
 801253c:	00070080 	.word	0x00070080
 8012540:	00030008 	.word	0x00030008

08012544 <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 8012544:	b084      	sub	sp, #16
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 8012546:	2300      	movs	r3, #0
 8012548:	9300      	str	r3, [sp, #0]
 801254a:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801254c:	4b36      	ldr	r3, [pc, #216]	; (8012628 <I2C_GetFlagStatus+0xe4>)
 801254e:	4298      	cmp	r0, r3
 8012550:	d103      	bne.n	801255a <I2C_GetFlagStatus+0x16>
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
 8012552:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8012556:	d10d      	bne.n	8012574 <I2C_GetFlagStatus+0x30>
 8012558:	e00f      	b.n	801257a <I2C_GetFlagStatus+0x36>
{
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801255a:	4b34      	ldr	r3, [pc, #208]	; (801262c <I2C_GetFlagStatus+0xe8>)
 801255c:	4298      	cmp	r0, r3
 801255e:	d0f8      	beq.n	8012552 <I2C_GetFlagStatus+0xe>
 8012560:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012564:	4298      	cmp	r0, r3
 8012566:	d0f4      	beq.n	8012552 <I2C_GetFlagStatus+0xe>
 8012568:	2301      	movs	r3, #1
 801256a:	9302      	str	r3, [sp, #8]
 801256c:	9b02      	ldr	r3, [sp, #8]
 801256e:	2b00      	cmp	r3, #0
 8012570:	d1fc      	bne.n	801256c <I2C_GetFlagStatus+0x28>
 8012572:	e7ee      	b.n	8012552 <I2C_GetFlagStatus+0xe>
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
 8012574:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 8012578:	d10a      	bne.n	8012590 <I2C_GetFlagStatus+0x4c>

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 801257a:	0f0b      	lsrs	r3, r1, #28
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 801257c:	9001      	str	r0, [sp, #4]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 801257e:	9300      	str	r3, [sp, #0]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
  
  if(i2creg != 0)
 8012580:	9b00      	ldr	r3, [sp, #0]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
 8012582:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  
  if(i2creg != 0)
 8012586:	2b00      	cmp	r3, #0
 8012588:	d042      	beq.n	8012610 <I2C_GetFlagStatus+0xcc>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 801258a:	9b01      	ldr	r3, [sp, #4]
 801258c:	3314      	adds	r3, #20
 801258e:	e042      	b.n	8012616 <I2C_GetFlagStatus+0xd2>
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
 8012590:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8012594:	d0f1      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 8012596:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 801259a:	d0ee      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 801259c:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 80125a0:	d0eb      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125a2:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 80125a6:	d0e8      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125a8:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 80125ac:	d0e5      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125ae:	4b20      	ldr	r3, [pc, #128]	; (8012630 <I2C_GetFlagStatus+0xec>)
 80125b0:	4299      	cmp	r1, r3
 80125b2:	d0e2      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125b4:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 80125b8:	4299      	cmp	r1, r3
 80125ba:	d0de      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125bc:	f1b1 2f10 	cmp.w	r1, #268439552	; 0x10001000
 80125c0:	d0db      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125c2:	f5a3 5360 	sub.w	r3, r3, #14336	; 0x3800
 80125c6:	4299      	cmp	r1, r3
 80125c8:	d0d7      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125ca:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 80125ce:	4299      	cmp	r1, r3
 80125d0:	d0d3      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125d2:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
 80125d6:	4299      	cmp	r1, r3
 80125d8:	d0cf      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125da:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 80125de:	4299      	cmp	r1, r3
 80125e0:	d0cb      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125e2:	3b80      	subs	r3, #128	; 0x80
 80125e4:	4299      	cmp	r1, r3
 80125e6:	d0c8      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125e8:	3b40      	subs	r3, #64	; 0x40
 80125ea:	4299      	cmp	r1, r3
 80125ec:	d0c5      	beq.n	801257a <I2C_GetFlagStatus+0x36>
 80125ee:	f101 4370 	add.w	r3, r1, #4026531840	; 0xf0000000
 80125f2:	3b01      	subs	r3, #1
 80125f4:	2b0f      	cmp	r3, #15
 80125f6:	d805      	bhi.n	8012604 <I2C_GetFlagStatus+0xc0>
 80125f8:	f248 028b 	movw	r2, #32907	; 0x808b
 80125fc:	fa22 f303 	lsr.w	r3, r2, r3
 8012600:	07db      	lsls	r3, r3, #31
 8012602:	d4ba      	bmi.n	801257a <I2C_GetFlagStatus+0x36>
 8012604:	2301      	movs	r3, #1
 8012606:	9303      	str	r3, [sp, #12]
 8012608:	9b03      	ldr	r3, [sp, #12]
 801260a:	2b00      	cmp	r3, #0
 801260c:	d1fc      	bne.n	8012608 <I2C_GetFlagStatus+0xc4>
 801260e:	e7b4      	b.n	801257a <I2C_GetFlagStatus+0x36>
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 8012610:	9b01      	ldr	r3, [sp, #4]
    i2cxbase += 0x14;
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 8012612:	0c09      	lsrs	r1, r1, #16
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 8012614:	3318      	adds	r3, #24
 8012616:	9301      	str	r3, [sp, #4]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 8012618:	9b01      	ldr	r3, [sp, #4]
 801261a:	681b      	ldr	r3, [r3, #0]
    /* I2C_FLAG is reset */
    bitstatus = RESET;
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
 801261c:	4219      	tst	r1, r3
}
 801261e:	bf14      	ite	ne
 8012620:	2001      	movne	r0, #1
 8012622:	2000      	moveq	r0, #0
 8012624:	b004      	add	sp, #16
 8012626:	4770      	bx	lr
 8012628:	40005400 	.word	0x40005400
 801262c:	40005800 	.word	0x40005800
 8012630:	10008000 	.word	0x10008000

08012634 <I2C_ClearITPendingBit>:
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
  uint32_t flagpos = 0;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012634:	4b10      	ldr	r3, [pc, #64]	; (8012678 <I2C_ClearITPendingBit+0x44>)
 8012636:	4298      	cmp	r0, r3
  *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
  *          I2C_DR register (I2C_SendData()).
  * @retval None
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
 8012638:	b082      	sub	sp, #8
  uint32_t flagpos = 0;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 801263a:	d104      	bne.n	8012646 <I2C_ClearITPendingBit+0x12>
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
 801263c:	f242 03ff 	movw	r3, #8447	; 0x20ff
 8012640:	400b      	ands	r3, r1
 8012642:	b99b      	cbnz	r3, 801266c <I2C_ClearITPendingBit+0x38>
 8012644:	e00c      	b.n	8012660 <I2C_ClearITPendingBit+0x2c>
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
  uint32_t flagpos = 0;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 8012646:	4b0d      	ldr	r3, [pc, #52]	; (801267c <I2C_ClearITPendingBit+0x48>)
 8012648:	4298      	cmp	r0, r3
 801264a:	d0f7      	beq.n	801263c <I2C_ClearITPendingBit+0x8>
 801264c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8012650:	4298      	cmp	r0, r3
 8012652:	d0f3      	beq.n	801263c <I2C_ClearITPendingBit+0x8>
 8012654:	2301      	movs	r3, #1
 8012656:	9300      	str	r3, [sp, #0]
 8012658:	9b00      	ldr	r3, [sp, #0]
 801265a:	2b00      	cmp	r3, #0
 801265c:	d1fc      	bne.n	8012658 <I2C_ClearITPendingBit+0x24>
 801265e:	e7ed      	b.n	801263c <I2C_ClearITPendingBit+0x8>
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
 8012660:	b121      	cbz	r1, 801266c <I2C_ClearITPendingBit+0x38>

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8012662:	43c9      	mvns	r1, r1
 8012664:	b289      	uxth	r1, r1
 8012666:	8281      	strh	r1, [r0, #20]
}
 8012668:	b002      	add	sp, #8
 801266a:	4770      	bx	lr
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
  uint32_t flagpos = 0;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
 801266c:	2301      	movs	r3, #1
 801266e:	9301      	str	r3, [sp, #4]
 8012670:	9b01      	ldr	r3, [sp, #4]
 8012672:	2b00      	cmp	r3, #0
 8012674:	d1fc      	bne.n	8012670 <I2C_ClearITPendingBit+0x3c>
 8012676:	e7f4      	b.n	8012662 <I2C_ClearITPendingBit+0x2e>
 8012678:	40005400 	.word	0x40005400
 801267c:	40005800 	.word	0x40005800

08012680 <I2C_ClearFlag>:
 8012680:	f7ff bfd8 	b.w	8012634 <I2C_ClearITPendingBit>

08012684 <DMA_DeInit>:
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012684:	4b4e      	ldr	r3, [pc, #312]	; (80127c0 <DMA_DeInit+0x13c>)
 8012686:	4298      	cmp	r0, r3
  * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
  *         to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
 8012688:	b082      	sub	sp, #8
 801268a:	461a      	mov	r2, r3
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 801268c:	d112      	bne.n	80126b4 <DMA_DeInit+0x30>

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 801268e:	6803      	ldr	r3, [r0, #0]
 8012690:	f023 0301 	bic.w	r3, r3, #1
 8012694:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 8012696:	2300      	movs	r3, #0
 8012698:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 801269a:	4290      	cmp	r0, r2

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 801269c:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 801269e:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 80126a0:	60c3      	str	r3, [r0, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 80126a2:	6103      	str	r3, [r0, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 80126a4:	f04f 0321 	mov.w	r3, #33	; 0x21
 80126a8:	6143      	str	r3, [r0, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80126aa:	d137      	bne.n	801271c <DMA_DeInit+0x98>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 80126ac:	4b45      	ldr	r3, [pc, #276]	; (80127c4 <DMA_DeInit+0x140>)
 80126ae:	223d      	movs	r2, #61	; 0x3d
 80126b0:	609a      	str	r2, [r3, #8]
 80126b2:	e083      	b.n	80127bc <DMA_DeInit+0x138>
  * @retval None
  */
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 80126b4:	4b44      	ldr	r3, [pc, #272]	; (80127c8 <DMA_DeInit+0x144>)
 80126b6:	4298      	cmp	r0, r3
 80126b8:	d0e9      	beq.n	801268e <DMA_DeInit+0xa>
 80126ba:	3318      	adds	r3, #24
 80126bc:	4298      	cmp	r0, r3
 80126be:	d0e6      	beq.n	801268e <DMA_DeInit+0xa>
 80126c0:	3318      	adds	r3, #24
 80126c2:	4298      	cmp	r0, r3
 80126c4:	d0e3      	beq.n	801268e <DMA_DeInit+0xa>
 80126c6:	3318      	adds	r3, #24
 80126c8:	4298      	cmp	r0, r3
 80126ca:	d0e0      	beq.n	801268e <DMA_DeInit+0xa>
 80126cc:	3318      	adds	r3, #24
 80126ce:	4298      	cmp	r0, r3
 80126d0:	d0dd      	beq.n	801268e <DMA_DeInit+0xa>
 80126d2:	3318      	adds	r3, #24
 80126d4:	4298      	cmp	r0, r3
 80126d6:	d0da      	beq.n	801268e <DMA_DeInit+0xa>
 80126d8:	3318      	adds	r3, #24
 80126da:	4298      	cmp	r0, r3
 80126dc:	d0d7      	beq.n	801268e <DMA_DeInit+0xa>
 80126de:	f503 7356 	add.w	r3, r3, #856	; 0x358
 80126e2:	4298      	cmp	r0, r3
 80126e4:	d0d3      	beq.n	801268e <DMA_DeInit+0xa>
 80126e6:	3318      	adds	r3, #24
 80126e8:	4298      	cmp	r0, r3
 80126ea:	d0d0      	beq.n	801268e <DMA_DeInit+0xa>
 80126ec:	3318      	adds	r3, #24
 80126ee:	4298      	cmp	r0, r3
 80126f0:	d0cd      	beq.n	801268e <DMA_DeInit+0xa>
 80126f2:	3318      	adds	r3, #24
 80126f4:	4298      	cmp	r0, r3
 80126f6:	d0ca      	beq.n	801268e <DMA_DeInit+0xa>
 80126f8:	3318      	adds	r3, #24
 80126fa:	4298      	cmp	r0, r3
 80126fc:	d0c7      	beq.n	801268e <DMA_DeInit+0xa>
 80126fe:	3318      	adds	r3, #24
 8012700:	4298      	cmp	r0, r3
 8012702:	d0c4      	beq.n	801268e <DMA_DeInit+0xa>
 8012704:	3318      	adds	r3, #24
 8012706:	4298      	cmp	r0, r3
 8012708:	d0c1      	beq.n	801268e <DMA_DeInit+0xa>
 801270a:	3318      	adds	r3, #24
 801270c:	4298      	cmp	r0, r3
 801270e:	d0be      	beq.n	801268e <DMA_DeInit+0xa>
 8012710:	2301      	movs	r3, #1
 8012712:	9301      	str	r3, [sp, #4]
 8012714:	9b01      	ldr	r3, [sp, #4]
 8012716:	2b00      	cmp	r3, #0
 8012718:	d1fc      	bne.n	8012714 <DMA_DeInit+0x90>
 801271a:	e7b8      	b.n	801268e <DMA_DeInit+0xa>
  if (DMAy_Streamx == DMA1_Stream0)
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 801271c:	4b2a      	ldr	r3, [pc, #168]	; (80127c8 <DMA_DeInit+0x144>)
 801271e:	4298      	cmp	r0, r3
 8012720:	d01b      	beq.n	801275a <DMA_DeInit+0xd6>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 8012722:	4b2a      	ldr	r3, [pc, #168]	; (80127cc <DMA_DeInit+0x148>)
 8012724:	4298      	cmp	r0, r3
 8012726:	d020      	beq.n	801276a <DMA_DeInit+0xe6>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 8012728:	4b29      	ldr	r3, [pc, #164]	; (80127d0 <DMA_DeInit+0x14c>)
 801272a:	4298      	cmp	r0, r3
 801272c:	d025      	beq.n	801277a <DMA_DeInit+0xf6>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 801272e:	4b29      	ldr	r3, [pc, #164]	; (80127d4 <DMA_DeInit+0x150>)
 8012730:	4298      	cmp	r0, r3
 8012732:	d02a      	beq.n	801278a <DMA_DeInit+0x106>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 8012734:	4b28      	ldr	r3, [pc, #160]	; (80127d8 <DMA_DeInit+0x154>)
 8012736:	4298      	cmp	r0, r3
 8012738:	d02e      	beq.n	8012798 <DMA_DeInit+0x114>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 801273a:	4b28      	ldr	r3, [pc, #160]	; (80127dc <DMA_DeInit+0x158>)
 801273c:	4298      	cmp	r0, r3
 801273e:	d032      	beq.n	80127a6 <DMA_DeInit+0x122>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 8012740:	4b27      	ldr	r3, [pc, #156]	; (80127e0 <DMA_DeInit+0x15c>)
 8012742:	4298      	cmp	r0, r3
 8012744:	d036      	beq.n	80127b4 <DMA_DeInit+0x130>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 8012746:	4b27      	ldr	r3, [pc, #156]	; (80127e4 <DMA_DeInit+0x160>)
 8012748:	4298      	cmp	r0, r3
 801274a:	d103      	bne.n	8012754 <DMA_DeInit+0xd0>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 801274c:	223d      	movs	r2, #61	; 0x3d
 801274e:	f843 2c08 	str.w	r2, [r3, #-8]
 8012752:	e033      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 8012754:	4b24      	ldr	r3, [pc, #144]	; (80127e8 <DMA_DeInit+0x164>)
 8012756:	4298      	cmp	r0, r3
 8012758:	d104      	bne.n	8012764 <DMA_DeInit+0xe0>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 801275a:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 801275e:	f843 2c20 	str.w	r2, [r3, #-32]
 8012762:	e02b      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 8012764:	4b21      	ldr	r3, [pc, #132]	; (80127ec <DMA_DeInit+0x168>)
 8012766:	4298      	cmp	r0, r3
 8012768:	d104      	bne.n	8012774 <DMA_DeInit+0xf0>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 801276a:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 801276e:	f843 2c38 	str.w	r2, [r3, #-56]
 8012772:	e023      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 8012774:	4b1e      	ldr	r3, [pc, #120]	; (80127f0 <DMA_DeInit+0x16c>)
 8012776:	4298      	cmp	r0, r3
 8012778:	d104      	bne.n	8012784 <DMA_DeInit+0x100>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 801277a:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 801277e:	f843 2c50 	str.w	r2, [r3, #-80]
 8012782:	e01b      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 8012784:	4b1b      	ldr	r3, [pc, #108]	; (80127f4 <DMA_DeInit+0x170>)
 8012786:	4298      	cmp	r0, r3
 8012788:	d103      	bne.n	8012792 <DMA_DeInit+0x10e>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 801278a:	4a1b      	ldr	r2, [pc, #108]	; (80127f8 <DMA_DeInit+0x174>)
 801278c:	f843 2c64 	str.w	r2, [r3, #-100]
 8012790:	e014      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 8012792:	4b1a      	ldr	r3, [pc, #104]	; (80127fc <DMA_DeInit+0x178>)
 8012794:	4298      	cmp	r0, r3
 8012796:	d103      	bne.n	80127a0 <DMA_DeInit+0x11c>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 8012798:	4a19      	ldr	r2, [pc, #100]	; (8012800 <DMA_DeInit+0x17c>)
 801279a:	f843 2c7c 	str.w	r2, [r3, #-124]
 801279e:	e00d      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 80127a0:	4b18      	ldr	r3, [pc, #96]	; (8012804 <DMA_DeInit+0x180>)
 80127a2:	4298      	cmp	r0, r3
 80127a4:	d103      	bne.n	80127ae <DMA_DeInit+0x12a>
  {
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 80127a6:	4a18      	ldr	r2, [pc, #96]	; (8012808 <DMA_DeInit+0x184>)
 80127a8:	f843 2c94 	str.w	r2, [r3, #-148]
 80127ac:	e006      	b.n	80127bc <DMA_DeInit+0x138>
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 80127ae:	4b17      	ldr	r3, [pc, #92]	; (801280c <DMA_DeInit+0x188>)
 80127b0:	4298      	cmp	r0, r3
 80127b2:	d103      	bne.n	80127bc <DMA_DeInit+0x138>
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 80127b4:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 80127b8:	f843 2cac 	str.w	r2, [r3, #-172]
    }
  }
}
 80127bc:	b002      	add	sp, #8
 80127be:	4770      	bx	lr
 80127c0:	40026010 	.word	0x40026010
 80127c4:	40026000 	.word	0x40026000
 80127c8:	40026028 	.word	0x40026028
 80127cc:	40026040 	.word	0x40026040
 80127d0:	40026058 	.word	0x40026058
 80127d4:	40026070 	.word	0x40026070
 80127d8:	40026088 	.word	0x40026088
 80127dc:	400260a0 	.word	0x400260a0
 80127e0:	400260b8 	.word	0x400260b8
 80127e4:	40026410 	.word	0x40026410
 80127e8:	40026428 	.word	0x40026428
 80127ec:	40026440 	.word	0x40026440
 80127f0:	40026458 	.word	0x40026458
 80127f4:	40026470 	.word	0x40026470
 80127f8:	2000003d 	.word	0x2000003d
 80127fc:	40026488 	.word	0x40026488
 8012800:	20000f40 	.word	0x20000f40
 8012804:	400264a0 	.word	0x400264a0
 8012808:	203d0000 	.word	0x203d0000
 801280c:	400264b8 	.word	0x400264b8

08012810 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 8012810:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012814:	4b72      	ldr	r3, [pc, #456]	; (80129e0 <DMA_Init+0x1d0>)
 8012816:	4298      	cmp	r0, r3
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 8012818:	b08f      	sub	sp, #60	; 0x3c
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 801281a:	d104      	bne.n	8012826 <DMA_Init+0x16>
  assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
 801281c:	680d      	ldr	r5, [r1, #0]
 801281e:	f035 63c0 	bics.w	r3, r5, #100663296	; 0x6000000
 8012822:	d134      	bne.n	801288e <DMA_Init+0x7e>
 8012824:	e03b      	b.n	801289e <DMA_Init+0x8e>
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012826:	4b6f      	ldr	r3, [pc, #444]	; (80129e4 <DMA_Init+0x1d4>)
 8012828:	4298      	cmp	r0, r3
 801282a:	d0f7      	beq.n	801281c <DMA_Init+0xc>
 801282c:	3318      	adds	r3, #24
 801282e:	4298      	cmp	r0, r3
 8012830:	d0f4      	beq.n	801281c <DMA_Init+0xc>
 8012832:	3318      	adds	r3, #24
 8012834:	4298      	cmp	r0, r3
 8012836:	d0f1      	beq.n	801281c <DMA_Init+0xc>
 8012838:	3318      	adds	r3, #24
 801283a:	4298      	cmp	r0, r3
 801283c:	d0ee      	beq.n	801281c <DMA_Init+0xc>
 801283e:	3318      	adds	r3, #24
 8012840:	4298      	cmp	r0, r3
 8012842:	d0eb      	beq.n	801281c <DMA_Init+0xc>
 8012844:	3318      	adds	r3, #24
 8012846:	4298      	cmp	r0, r3
 8012848:	d0e8      	beq.n	801281c <DMA_Init+0xc>
 801284a:	3318      	adds	r3, #24
 801284c:	4298      	cmp	r0, r3
 801284e:	d0e5      	beq.n	801281c <DMA_Init+0xc>
 8012850:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8012854:	4298      	cmp	r0, r3
 8012856:	d0e1      	beq.n	801281c <DMA_Init+0xc>
 8012858:	3318      	adds	r3, #24
 801285a:	4298      	cmp	r0, r3
 801285c:	d0de      	beq.n	801281c <DMA_Init+0xc>
 801285e:	3318      	adds	r3, #24
 8012860:	4298      	cmp	r0, r3
 8012862:	d0db      	beq.n	801281c <DMA_Init+0xc>
 8012864:	3318      	adds	r3, #24
 8012866:	4298      	cmp	r0, r3
 8012868:	d0d8      	beq.n	801281c <DMA_Init+0xc>
 801286a:	3318      	adds	r3, #24
 801286c:	4298      	cmp	r0, r3
 801286e:	d0d5      	beq.n	801281c <DMA_Init+0xc>
 8012870:	3318      	adds	r3, #24
 8012872:	4298      	cmp	r0, r3
 8012874:	d0d2      	beq.n	801281c <DMA_Init+0xc>
 8012876:	3318      	adds	r3, #24
 8012878:	4298      	cmp	r0, r3
 801287a:	d0cf      	beq.n	801281c <DMA_Init+0xc>
 801287c:	3318      	adds	r3, #24
 801287e:	4298      	cmp	r0, r3
 8012880:	d0cc      	beq.n	801281c <DMA_Init+0xc>
 8012882:	2301      	movs	r3, #1
 8012884:	9300      	str	r3, [sp, #0]
 8012886:	9b00      	ldr	r3, [sp, #0]
 8012888:	2b00      	cmp	r3, #0
 801288a:	d1fc      	bne.n	8012886 <DMA_Init+0x76>
 801288c:	e7c6      	b.n	801281c <DMA_Init+0xc>
  assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
 801288e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8012892:	d004      	beq.n	801289e <DMA_Init+0x8e>
 8012894:	2301      	movs	r3, #1
 8012896:	9301      	str	r3, [sp, #4]
 8012898:	9b01      	ldr	r3, [sp, #4]
 801289a:	2b00      	cmp	r3, #0
 801289c:	d1fc      	bne.n	8012898 <DMA_Init+0x88>
  assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
 801289e:	68cb      	ldr	r3, [r1, #12]
 80128a0:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 80128a4:	d006      	beq.n	80128b4 <DMA_Init+0xa4>
 80128a6:	2b80      	cmp	r3, #128	; 0x80
 80128a8:	d004      	beq.n	80128b4 <DMA_Init+0xa4>
 80128aa:	2201      	movs	r2, #1
 80128ac:	9202      	str	r2, [sp, #8]
 80128ae:	9a02      	ldr	r2, [sp, #8]
 80128b0:	2a00      	cmp	r2, #0
 80128b2:	d1fc      	bne.n	80128ae <DMA_Init+0x9e>
  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
 80128b4:	690a      	ldr	r2, [r1, #16]
 80128b6:	f64f 74fe 	movw	r4, #65534	; 0xfffe
 80128ba:	3a01      	subs	r2, #1
 80128bc:	42a2      	cmp	r2, r4
 80128be:	d904      	bls.n	80128ca <DMA_Init+0xba>
 80128c0:	2201      	movs	r2, #1
 80128c2:	9203      	str	r2, [sp, #12]
 80128c4:	9a03      	ldr	r2, [sp, #12]
 80128c6:	2a00      	cmp	r2, #0
 80128c8:	d1fc      	bne.n	80128c4 <DMA_Init+0xb4>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
 80128ca:	694a      	ldr	r2, [r1, #20]
 80128cc:	f432 7400 	bics.w	r4, r2, #512	; 0x200
 80128d0:	d004      	beq.n	80128dc <DMA_Init+0xcc>
 80128d2:	2401      	movs	r4, #1
 80128d4:	9404      	str	r4, [sp, #16]
 80128d6:	9c04      	ldr	r4, [sp, #16]
 80128d8:	2c00      	cmp	r4, #0
 80128da:	d1fc      	bne.n	80128d6 <DMA_Init+0xc6>
  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
 80128dc:	f8d1 e018 	ldr.w	lr, [r1, #24]
 80128e0:	f43e 6480 	bics.w	r4, lr, #1024	; 0x400
 80128e4:	d004      	beq.n	80128f0 <DMA_Init+0xe0>
 80128e6:	2401      	movs	r4, #1
 80128e8:	9405      	str	r4, [sp, #20]
 80128ea:	9c05      	ldr	r4, [sp, #20]
 80128ec:	2c00      	cmp	r4, #0
 80128ee:	d1fc      	bne.n	80128ea <DMA_Init+0xda>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
 80128f0:	69ce      	ldr	r6, [r1, #28]
 80128f2:	f436 6400 	bics.w	r4, r6, #2048	; 0x800
 80128f6:	d007      	beq.n	8012908 <DMA_Init+0xf8>
 80128f8:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
 80128fc:	d004      	beq.n	8012908 <DMA_Init+0xf8>
 80128fe:	2401      	movs	r4, #1
 8012900:	9406      	str	r4, [sp, #24]
 8012902:	9c06      	ldr	r4, [sp, #24]
 8012904:	2c00      	cmp	r4, #0
 8012906:	d1fc      	bne.n	8012902 <DMA_Init+0xf2>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
 8012908:	6a0f      	ldr	r7, [r1, #32]
 801290a:	f437 5400 	bics.w	r4, r7, #8192	; 0x2000
 801290e:	d007      	beq.n	8012920 <DMA_Init+0x110>
 8012910:	f5b7 4f80 	cmp.w	r7, #16384	; 0x4000
 8012914:	d004      	beq.n	8012920 <DMA_Init+0x110>
 8012916:	2401      	movs	r4, #1
 8012918:	9407      	str	r4, [sp, #28]
 801291a:	9c07      	ldr	r4, [sp, #28]
 801291c:	2c00      	cmp	r4, #0
 801291e:	d1fc      	bne.n	801291a <DMA_Init+0x10a>
  assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
 8012920:	f8d1 c024 	ldr.w	ip, [r1, #36]	; 0x24
 8012924:	f43c 7480 	bics.w	r4, ip, #256	; 0x100
 8012928:	d004      	beq.n	8012934 <DMA_Init+0x124>
 801292a:	2401      	movs	r4, #1
 801292c:	9408      	str	r4, [sp, #32]
 801292e:	9c08      	ldr	r4, [sp, #32]
 8012930:	2c00      	cmp	r4, #0
 8012932:	d1fc      	bne.n	801292e <DMA_Init+0x11e>
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
 8012934:	f8d1 8028 	ldr.w	r8, [r1, #40]	; 0x28
 8012938:	f438 3440 	bics.w	r4, r8, #196608	; 0x30000
 801293c:	d004      	beq.n	8012948 <DMA_Init+0x138>
 801293e:	2401      	movs	r4, #1
 8012940:	9409      	str	r4, [sp, #36]	; 0x24
 8012942:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8012944:	2c00      	cmp	r4, #0
 8012946:	d1fc      	bne.n	8012942 <DMA_Init+0x132>
  assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
 8012948:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 801294a:	f034 0404 	bics.w	r4, r4, #4
 801294e:	d004      	beq.n	801295a <DMA_Init+0x14a>
 8012950:	2401      	movs	r4, #1
 8012952:	940a      	str	r4, [sp, #40]	; 0x28
 8012954:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8012956:	2c00      	cmp	r4, #0
 8012958:	d1fc      	bne.n	8012954 <DMA_Init+0x144>
  assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
 801295a:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 801295c:	2c03      	cmp	r4, #3
 801295e:	d904      	bls.n	801296a <DMA_Init+0x15a>
 8012960:	2401      	movs	r4, #1
 8012962:	940b      	str	r4, [sp, #44]	; 0x2c
 8012964:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8012966:	2c00      	cmp	r4, #0
 8012968:	d1fc      	bne.n	8012964 <DMA_Init+0x154>
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
 801296a:	f8d1 a034 	ldr.w	sl, [r1, #52]	; 0x34
 801296e:	f03a 74c0 	bics.w	r4, sl, #25165824	; 0x1800000
 8012972:	d004      	beq.n	801297e <DMA_Init+0x16e>
 8012974:	2401      	movs	r4, #1
 8012976:	940c      	str	r4, [sp, #48]	; 0x30
 8012978:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 801297a:	2c00      	cmp	r4, #0
 801297c:	d1fc      	bne.n	8012978 <DMA_Init+0x168>
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
 801297e:	f8d1 9038 	ldr.w	r9, [r1, #56]	; 0x38
 8012982:	f439 04c0 	bics.w	r4, r9, #6291456	; 0x600000
 8012986:	d004      	beq.n	8012992 <DMA_Init+0x182>
 8012988:	2401      	movs	r4, #1
 801298a:	940d      	str	r4, [sp, #52]	; 0x34
 801298c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 801298e:	2c00      	cmp	r4, #0
 8012990:	d1fc      	bne.n	801298c <DMA_Init+0x17c>
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8012992:	432b      	orrs	r3, r5
 8012994:	431a      	orrs	r2, r3
 8012996:	ea42 020e 	orr.w	r2, r2, lr
 801299a:	4332      	orrs	r2, r6
 801299c:	433a      	orrs	r2, r7
 801299e:	ea42 020c 	orr.w	r2, r2, ip
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 80129a2:	f8d0 b000 	ldr.w	fp, [r0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80129a6:	4c10      	ldr	r4, [pc, #64]	; (80129e8 <DMA_Init+0x1d8>)
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 80129a8:	ea42 0208 	orr.w	r2, r2, r8
 80129ac:	ea42 020a 	orr.w	r2, r2, sl
  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80129b0:	ea0b 0404 	and.w	r4, fp, r4
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 80129b4:	ea42 0309 	orr.w	r3, r2, r9
 80129b8:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 80129ba:	6003      	str	r3, [r0, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 80129bc:	6943      	ldr	r3, [r0, #20]
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 80129be:	6acc      	ldr	r4, [r1, #44]	; 0x2c
  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80129c0:	f023 0207 	bic.w	r2, r3, #7

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 80129c4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80129c6:	4323      	orrs	r3, r4
 80129c8:	4313      	orrs	r3, r2

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 80129ca:	6143      	str	r3, [r0, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 80129cc:	690b      	ldr	r3, [r1, #16]
 80129ce:	6043      	str	r3, [r0, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 80129d0:	684b      	ldr	r3, [r1, #4]
 80129d2:	6083      	str	r3, [r0, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 80129d4:	688b      	ldr	r3, [r1, #8]
 80129d6:	60c3      	str	r3, [r0, #12]
}
 80129d8:	b00f      	add	sp, #60	; 0x3c
 80129da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80129de:	bf00      	nop
 80129e0:	40026010 	.word	0x40026010
 80129e4:	40026028 	.word	0x40026028
 80129e8:	f01c803f 	.word	0xf01c803f

080129ec <DMA_Cmd>:
  * @retval None
  */
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 80129ec:	4b25      	ldr	r3, [pc, #148]	; (8012a84 <DMA_Cmd+0x98>)
 80129ee:	4298      	cmp	r0, r3
  *        this single data is finished.            
  *    
  * @retval None
  */
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{
 80129f0:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 80129f2:	d104      	bne.n	80129fe <DMA_Cmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80129f4:	2901      	cmp	r1, #1
 80129f6:	d93d      	bls.n	8012a74 <DMA_Cmd+0x88>
 80129f8:	2301      	movs	r3, #1
 80129fa:	9301      	str	r3, [sp, #4]
 80129fc:	e033      	b.n	8012a66 <DMA_Cmd+0x7a>
  * @retval None
  */
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 80129fe:	4b22      	ldr	r3, [pc, #136]	; (8012a88 <DMA_Cmd+0x9c>)
 8012a00:	4298      	cmp	r0, r3
 8012a02:	d0f7      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a04:	3318      	adds	r3, #24
 8012a06:	4298      	cmp	r0, r3
 8012a08:	d0f4      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a0a:	3318      	adds	r3, #24
 8012a0c:	4298      	cmp	r0, r3
 8012a0e:	d0f1      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a10:	3318      	adds	r3, #24
 8012a12:	4298      	cmp	r0, r3
 8012a14:	d0ee      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a16:	3318      	adds	r3, #24
 8012a18:	4298      	cmp	r0, r3
 8012a1a:	d0eb      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a1c:	3318      	adds	r3, #24
 8012a1e:	4298      	cmp	r0, r3
 8012a20:	d0e8      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a22:	3318      	adds	r3, #24
 8012a24:	4298      	cmp	r0, r3
 8012a26:	d0e5      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a28:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8012a2c:	4298      	cmp	r0, r3
 8012a2e:	d0e1      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a30:	3318      	adds	r3, #24
 8012a32:	4298      	cmp	r0, r3
 8012a34:	d0de      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a36:	3318      	adds	r3, #24
 8012a38:	4298      	cmp	r0, r3
 8012a3a:	d0db      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a3c:	3318      	adds	r3, #24
 8012a3e:	4298      	cmp	r0, r3
 8012a40:	d0d8      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a42:	3318      	adds	r3, #24
 8012a44:	4298      	cmp	r0, r3
 8012a46:	d0d5      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a48:	3318      	adds	r3, #24
 8012a4a:	4298      	cmp	r0, r3
 8012a4c:	d0d2      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a4e:	3318      	adds	r3, #24
 8012a50:	4298      	cmp	r0, r3
 8012a52:	d0cf      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a54:	3318      	adds	r3, #24
 8012a56:	4298      	cmp	r0, r3
 8012a58:	d0cc      	beq.n	80129f4 <DMA_Cmd+0x8>
 8012a5a:	2301      	movs	r3, #1
 8012a5c:	9300      	str	r3, [sp, #0]
 8012a5e:	9b00      	ldr	r3, [sp, #0]
 8012a60:	2b00      	cmp	r3, #0
 8012a62:	d1fc      	bne.n	8012a5e <DMA_Cmd+0x72>
 8012a64:	e7c6      	b.n	80129f4 <DMA_Cmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012a66:	9b01      	ldr	r3, [sp, #4]
 8012a68:	2b00      	cmp	r3, #0
 8012a6a:	d1fc      	bne.n	8012a66 <DMA_Cmd+0x7a>

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8012a6c:	6803      	ldr	r3, [r0, #0]
 8012a6e:	f043 0301 	orr.w	r3, r3, #1
 8012a72:	e004      	b.n	8012a7e <DMA_Cmd+0x92>
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8012a74:	2900      	cmp	r1, #0
 8012a76:	d1f9      	bne.n	8012a6c <DMA_Cmd+0x80>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8012a78:	6803      	ldr	r3, [r0, #0]
 8012a7a:	f023 0301 	bic.w	r3, r3, #1
 8012a7e:	6003      	str	r3, [r0, #0]
  }
}
 8012a80:	b002      	add	sp, #8
 8012a82:	4770      	bx	lr
 8012a84:	40026010 	.word	0x40026010
 8012a88:	40026028 	.word	0x40026028

08012a8c <DMA_ITConfig>:
  * @retval None
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012a8c:	4b35      	ldr	r3, [pc, #212]	; (8012b64 <DMA_ITConfig+0xd8>)
 8012a8e:	4298      	cmp	r0, r3
  * @param  NewState: new state of the specified DMA interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
 8012a90:	b084      	sub	sp, #16
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012a92:	d103      	bne.n	8012a9c <DMA_ITConfig+0x10>
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
 8012a94:	f031 039e 	bics.w	r3, r1, #158	; 0x9e
 8012a98:	d138      	bne.n	8012b0c <DMA_ITConfig+0x80>
 8012a9a:	e033      	b.n	8012b04 <DMA_ITConfig+0x78>
  * @retval None
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012a9c:	4b32      	ldr	r3, [pc, #200]	; (8012b68 <DMA_ITConfig+0xdc>)
 8012a9e:	4298      	cmp	r0, r3
 8012aa0:	d0f8      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012aa2:	3318      	adds	r3, #24
 8012aa4:	4298      	cmp	r0, r3
 8012aa6:	d0f5      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012aa8:	3318      	adds	r3, #24
 8012aaa:	4298      	cmp	r0, r3
 8012aac:	d0f2      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012aae:	3318      	adds	r3, #24
 8012ab0:	4298      	cmp	r0, r3
 8012ab2:	d0ef      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ab4:	3318      	adds	r3, #24
 8012ab6:	4298      	cmp	r0, r3
 8012ab8:	d0ec      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012aba:	3318      	adds	r3, #24
 8012abc:	4298      	cmp	r0, r3
 8012abe:	d0e9      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ac0:	3318      	adds	r3, #24
 8012ac2:	4298      	cmp	r0, r3
 8012ac4:	d0e6      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ac6:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8012aca:	4298      	cmp	r0, r3
 8012acc:	d0e2      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ace:	3318      	adds	r3, #24
 8012ad0:	4298      	cmp	r0, r3
 8012ad2:	d0df      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ad4:	3318      	adds	r3, #24
 8012ad6:	4298      	cmp	r0, r3
 8012ad8:	d0dc      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ada:	3318      	adds	r3, #24
 8012adc:	4298      	cmp	r0, r3
 8012ade:	d0d9      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ae0:	3318      	adds	r3, #24
 8012ae2:	4298      	cmp	r0, r3
 8012ae4:	d0d6      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012ae6:	3318      	adds	r3, #24
 8012ae8:	4298      	cmp	r0, r3
 8012aea:	d0d3      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012aec:	3318      	adds	r3, #24
 8012aee:	4298      	cmp	r0, r3
 8012af0:	d0d0      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012af2:	3318      	adds	r3, #24
 8012af4:	4298      	cmp	r0, r3
 8012af6:	d0cd      	beq.n	8012a94 <DMA_ITConfig+0x8>
 8012af8:	2301      	movs	r3, #1
 8012afa:	9301      	str	r3, [sp, #4]
 8012afc:	9b01      	ldr	r3, [sp, #4]
 8012afe:	2b00      	cmp	r3, #0
 8012b00:	d1fc      	bne.n	8012afc <DMA_ITConfig+0x70>
 8012b02:	e7c7      	b.n	8012a94 <DMA_ITConfig+0x8>
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
 8012b04:	b111      	cbz	r1, 8012b0c <DMA_ITConfig+0x80>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012b06:	2a01      	cmp	r2, #1
 8012b08:	d806      	bhi.n	8012b18 <DMA_ITConfig+0x8c>
 8012b0a:	e00a      	b.n	8012b22 <DMA_ITConfig+0x96>
  */
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
 8012b0c:	2301      	movs	r3, #1
 8012b0e:	9302      	str	r3, [sp, #8]
 8012b10:	9b02      	ldr	r3, [sp, #8]
 8012b12:	2b00      	cmp	r3, #0
 8012b14:	d1fc      	bne.n	8012b10 <DMA_ITConfig+0x84>
 8012b16:	e7f6      	b.n	8012b06 <DMA_ITConfig+0x7a>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8012b18:	2301      	movs	r3, #1
 8012b1a:	9303      	str	r3, [sp, #12]
 8012b1c:	9b03      	ldr	r3, [sp, #12]
 8012b1e:	2b00      	cmp	r3, #0
 8012b20:	d1fc      	bne.n	8012b1c <DMA_ITConfig+0x90>

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 8012b22:	060b      	lsls	r3, r1, #24
 8012b24:	d511      	bpl.n	8012b4a <DMA_ITConfig+0xbe>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8012b26:	6943      	ldr	r3, [r0, #20]
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
  {
    if (NewState != DISABLE)
 8012b28:	b14a      	cbz	r2, 8012b3e <DMA_ITConfig+0xb2>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8012b2a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8012b2e:	2980      	cmp	r1, #128	; 0x80
  if ((DMA_IT & DMA_IT_FE) != 0)
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8012b30:	6143      	str	r3, [r0, #20]
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8012b32:	d014      	beq.n	8012b5e <DMA_ITConfig+0xd2>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 8012b34:	6803      	ldr	r3, [r0, #0]
 8012b36:	f001 011e 	and.w	r1, r1, #30
 8012b3a:	4319      	orrs	r1, r3
 8012b3c:	e00e      	b.n	8012b5c <DMA_ITConfig+0xd0>
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8012b3e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8012b42:	2980      	cmp	r1, #128	; 0x80
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8012b44:	6143      	str	r3, [r0, #20]
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8012b46:	d104      	bne.n	8012b52 <DMA_ITConfig+0xc6>
 8012b48:	e009      	b.n	8012b5e <DMA_ITConfig+0xd2>
 8012b4a:	2980      	cmp	r1, #128	; 0x80
 8012b4c:	d007      	beq.n	8012b5e <DMA_ITConfig+0xd2>
  {
    if (NewState != DISABLE)
 8012b4e:	2a00      	cmp	r2, #0
 8012b50:	d1f0      	bne.n	8012b34 <DMA_ITConfig+0xa8>
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 8012b52:	6803      	ldr	r3, [r0, #0]
 8012b54:	f001 011e 	and.w	r1, r1, #30
 8012b58:	ea23 0101 	bic.w	r1, r3, r1
 8012b5c:	6001      	str	r1, [r0, #0]
    }    
  }
}
 8012b5e:	b004      	add	sp, #16
 8012b60:	4770      	bx	lr
 8012b62:	bf00      	nop
 8012b64:	40026010 	.word	0x40026010
 8012b68:	40026028 	.word	0x40026028

08012b6c <DMA_GetITStatus>:
  ITStatus bitstatus = RESET;
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012b6c:	4b85      	ldr	r3, [pc, #532]	; (8012d84 <DMA_GetITStatus+0x218>)
 8012b6e:	4298      	cmp	r0, r3
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8012b70:	b082      	sub	sp, #8
  ITStatus bitstatus = RESET;
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012b72:	f000 8100 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012b76:	4b84      	ldr	r3, [pc, #528]	; (8012d88 <DMA_GetITStatus+0x21c>)
 8012b78:	4298      	cmp	r0, r3
 8012b7a:	f000 80fc 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012b7e:	3318      	adds	r3, #24
 8012b80:	4298      	cmp	r0, r3
 8012b82:	f000 80f8 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012b86:	3318      	adds	r3, #24
 8012b88:	4298      	cmp	r0, r3
 8012b8a:	f000 80f4 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012b8e:	3318      	adds	r3, #24
 8012b90:	4298      	cmp	r0, r3
 8012b92:	f000 80f0 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012b96:	3318      	adds	r3, #24
 8012b98:	4298      	cmp	r0, r3
 8012b9a:	f000 80ec 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012b9e:	3318      	adds	r3, #24
 8012ba0:	4298      	cmp	r0, r3
 8012ba2:	f000 80e8 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012ba6:	3318      	adds	r3, #24
 8012ba8:	4298      	cmp	r0, r3
 8012baa:	f000 80e4 	beq.w	8012d76 <DMA_GetITStatus+0x20a>
 8012bae:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8012bb2:	4298      	cmp	r0, r3
 8012bb4:	d01d      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bb6:	3318      	adds	r3, #24
 8012bb8:	4298      	cmp	r0, r3
 8012bba:	d01a      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bbc:	3318      	adds	r3, #24
 8012bbe:	4298      	cmp	r0, r3
 8012bc0:	d017      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bc2:	3318      	adds	r3, #24
 8012bc4:	4298      	cmp	r0, r3
 8012bc6:	d014      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bc8:	3318      	adds	r3, #24
 8012bca:	4298      	cmp	r0, r3
 8012bcc:	d011      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bce:	3318      	adds	r3, #24
 8012bd0:	4298      	cmp	r0, r3
 8012bd2:	d00e      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bd4:	3318      	adds	r3, #24
 8012bd6:	4298      	cmp	r0, r3
 8012bd8:	d00b      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012bda:	3318      	adds	r3, #24
 8012bdc:	4298      	cmp	r0, r3
 8012bde:	d008      	beq.n	8012bf2 <DMA_GetITStatus+0x86>
 8012be0:	2301      	movs	r3, #1
 8012be2:	9300      	str	r3, [sp, #0]
 8012be4:	9b00      	ldr	r3, [sp, #0]
 8012be6:	2b00      	cmp	r3, #0
 8012be8:	d1fc      	bne.n	8012be4 <DMA_GetITStatus+0x78>
  assert_param(IS_DMA_GET_IT(DMA_IT));
 8012bea:	4b68      	ldr	r3, [pc, #416]	; (8012d8c <DMA_GetITStatus+0x220>)
 8012bec:	4299      	cmp	r1, r3
 8012bee:	d104      	bne.n	8012bfa <DMA_GetITStatus+0x8e>
 8012bf0:	e0a2      	b.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012bf2:	4b66      	ldr	r3, [pc, #408]	; (8012d8c <DMA_GetITStatus+0x220>)
 8012bf4:	4299      	cmp	r1, r3
 8012bf6:	f000 8096 	beq.w	8012d26 <DMA_GetITStatus+0x1ba>
 8012bfa:	4b65      	ldr	r3, [pc, #404]	; (8012d90 <DMA_GetITStatus+0x224>)
 8012bfc:	4299      	cmp	r1, r3
 8012bfe:	f000 809b 	beq.w	8012d38 <DMA_GetITStatus+0x1cc>
 8012c02:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
 8012c06:	3b08      	subs	r3, #8
 8012c08:	4299      	cmp	r1, r3
 8012c0a:	f000 8095 	beq.w	8012d38 <DMA_GetITStatus+0x1cc>
 8012c0e:	4b61      	ldr	r3, [pc, #388]	; (8012d94 <DMA_GetITStatus+0x228>)
 8012c10:	4299      	cmp	r1, r3
 8012c12:	f000 8091 	beq.w	8012d38 <DMA_GetITStatus+0x1cc>
 8012c16:	4b60      	ldr	r3, [pc, #384]	; (8012d98 <DMA_GetITStatus+0x22c>)
 8012c18:	4299      	cmp	r1, r3
 8012c1a:	f000 8097 	beq.w	8012d4c <DMA_GetITStatus+0x1e0>
 8012c1e:	4b5f      	ldr	r3, [pc, #380]	; (8012d9c <DMA_GetITStatus+0x230>)
 8012c20:	4299      	cmp	r1, r3
 8012c22:	f000 8089 	beq.w	8012d38 <DMA_GetITStatus+0x1cc>
 8012c26:	f5a3 4388 	sub.w	r3, r3, #17408	; 0x4400
 8012c2a:	4299      	cmp	r1, r3
 8012c2c:	f000 8084 	beq.w	8012d38 <DMA_GetITStatus+0x1cc>
 8012c30:	f5a3 5308 	sub.w	r3, r3, #8704	; 0x2200
 8012c34:	4299      	cmp	r1, r3
 8012c36:	d07f      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c38:	f5a3 5388 	sub.w	r3, r3, #4352	; 0x1100
 8012c3c:	4299      	cmp	r1, r3
 8012c3e:	d07b      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c40:	4b57      	ldr	r3, [pc, #348]	; (8012da0 <DMA_GetITStatus+0x234>)
 8012c42:	4299      	cmp	r1, r3
 8012c44:	f000 8082 	beq.w	8012d4c <DMA_GetITStatus+0x1e0>
 8012c48:	4b56      	ldr	r3, [pc, #344]	; (8012da4 <DMA_GetITStatus+0x238>)
 8012c4a:	4299      	cmp	r1, r3
 8012c4c:	d074      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c4e:	f5a3 1382 	sub.w	r3, r3, #1064960	; 0x104000
 8012c52:	4299      	cmp	r1, r3
 8012c54:	d070      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c56:	f5a3 2302 	sub.w	r3, r3, #532480	; 0x82000
 8012c5a:	4299      	cmp	r1, r3
 8012c5c:	d06c      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c5e:	f5a3 2382 	sub.w	r3, r3, #266240	; 0x41000
 8012c62:	4299      	cmp	r1, r3
 8012c64:	d068      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c66:	4b50      	ldr	r3, [pc, #320]	; (8012da8 <DMA_GetITStatus+0x23c>)
 8012c68:	4299      	cmp	r1, r3
 8012c6a:	d06f      	beq.n	8012d4c <DMA_GetITStatus+0x1e0>
 8012c6c:	4b4f      	ldr	r3, [pc, #316]	; (8012dac <DMA_GetITStatus+0x240>)
 8012c6e:	4299      	cmp	r1, r3
 8012c70:	d062      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c72:	4b4f      	ldr	r3, [pc, #316]	; (8012db0 <DMA_GetITStatus+0x244>)
 8012c74:	4299      	cmp	r1, r3
 8012c76:	d05f      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c78:	4b4e      	ldr	r3, [pc, #312]	; (8012db4 <DMA_GetITStatus+0x248>)
 8012c7a:	4299      	cmp	r1, r3
 8012c7c:	d05c      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c7e:	4b4e      	ldr	r3, [pc, #312]	; (8012db8 <DMA_GetITStatus+0x24c>)
 8012c80:	4299      	cmp	r1, r3
 8012c82:	d059      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c84:	4b4d      	ldr	r3, [pc, #308]	; (8012dbc <DMA_GetITStatus+0x250>)
 8012c86:	4299      	cmp	r1, r3
 8012c88:	d060      	beq.n	8012d4c <DMA_GetITStatus+0x1e0>
 8012c8a:	4b4d      	ldr	r3, [pc, #308]	; (8012dc0 <DMA_GetITStatus+0x254>)
 8012c8c:	4299      	cmp	r1, r3
 8012c8e:	d053      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c90:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8012c94:	3b10      	subs	r3, #16
 8012c96:	4299      	cmp	r1, r3
 8012c98:	d04e      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012c9a:	4b4a      	ldr	r3, [pc, #296]	; (8012dc4 <DMA_GetITStatus+0x258>)
 8012c9c:	4299      	cmp	r1, r3
 8012c9e:	d04b      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012ca0:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 8012ca4:	3b04      	subs	r3, #4
 8012ca6:	4299      	cmp	r1, r3
 8012ca8:	d046      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012caa:	4b47      	ldr	r3, [pc, #284]	; (8012dc8 <DMA_GetITStatus+0x25c>)
 8012cac:	4299      	cmp	r1, r3
 8012cae:	d04d      	beq.n	8012d4c <DMA_GetITStatus+0x1e0>
 8012cb0:	4b46      	ldr	r3, [pc, #280]	; (8012dcc <DMA_GetITStatus+0x260>)
 8012cb2:	4299      	cmp	r1, r3
 8012cb4:	d040      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cb6:	f5a3 4388 	sub.w	r3, r3, #17408	; 0x4400
 8012cba:	4299      	cmp	r1, r3
 8012cbc:	d03c      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cbe:	f5a3 5308 	sub.w	r3, r3, #8704	; 0x2200
 8012cc2:	4299      	cmp	r1, r3
 8012cc4:	d038      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cc6:	f5a3 5388 	sub.w	r3, r3, #4352	; 0x1100
 8012cca:	4299      	cmp	r1, r3
 8012ccc:	d034      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cce:	4b40      	ldr	r3, [pc, #256]	; (8012dd0 <DMA_GetITStatus+0x264>)
 8012cd0:	4299      	cmp	r1, r3
 8012cd2:	d03b      	beq.n	8012d4c <DMA_GetITStatus+0x1e0>
 8012cd4:	4b3f      	ldr	r3, [pc, #252]	; (8012dd4 <DMA_GetITStatus+0x268>)
 8012cd6:	4299      	cmp	r1, r3
 8012cd8:	d02e      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cda:	f5a3 1382 	sub.w	r3, r3, #1064960	; 0x104000
 8012cde:	4299      	cmp	r1, r3
 8012ce0:	d02a      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012ce2:	f5a3 2302 	sub.w	r3, r3, #532480	; 0x82000
 8012ce6:	4299      	cmp	r1, r3
 8012ce8:	d026      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cea:	f5a3 2382 	sub.w	r3, r3, #266240	; 0x41000
 8012cee:	4299      	cmp	r1, r3
 8012cf0:	d022      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cf2:	4b39      	ldr	r3, [pc, #228]	; (8012dd8 <DMA_GetITStatus+0x26c>)
 8012cf4:	4299      	cmp	r1, r3
 8012cf6:	d029      	beq.n	8012d4c <DMA_GetITStatus+0x1e0>
 8012cf8:	4b38      	ldr	r3, [pc, #224]	; (8012ddc <DMA_GetITStatus+0x270>)
 8012cfa:	4299      	cmp	r1, r3
 8012cfc:	d01c      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012cfe:	4b38      	ldr	r3, [pc, #224]	; (8012de0 <DMA_GetITStatus+0x274>)
 8012d00:	4299      	cmp	r1, r3
 8012d02:	d019      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012d04:	4b37      	ldr	r3, [pc, #220]	; (8012de4 <DMA_GetITStatus+0x278>)
 8012d06:	4299      	cmp	r1, r3
 8012d08:	d016      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012d0a:	4b37      	ldr	r3, [pc, #220]	; (8012de8 <DMA_GetITStatus+0x27c>)
 8012d0c:	4299      	cmp	r1, r3
 8012d0e:	d013      	beq.n	8012d38 <DMA_GetITStatus+0x1cc>
 8012d10:	4b36      	ldr	r3, [pc, #216]	; (8012dec <DMA_GetITStatus+0x280>)
 8012d12:	4299      	cmp	r1, r3
 8012d14:	d01a      	beq.n	8012d4c <DMA_GetITStatus+0x1e0>
 8012d16:	2301      	movs	r3, #1
 8012d18:	9301      	str	r3, [sp, #4]
 8012d1a:	9b01      	ldr	r3, [sp, #4]
 8012d1c:	2b00      	cmp	r3, #0
 8012d1e:	d1fc      	bne.n	8012d1a <DMA_GetITStatus+0x1ae>
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8012d20:	4b33      	ldr	r3, [pc, #204]	; (8012df0 <DMA_GetITStatus+0x284>)
 8012d22:	4298      	cmp	r0, r3
 8012d24:	d901      	bls.n	8012d2a <DMA_GetITStatus+0x1be>
    DMAy = DMA1; 
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8012d26:	4a33      	ldr	r2, [pc, #204]	; (8012df4 <DMA_GetITStatus+0x288>)
 8012d28:	e000      	b.n	8012d2c <DMA_GetITStatus+0x1c0>
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8012d2a:	4a33      	ldr	r2, [pc, #204]	; (8012df8 <DMA_GetITStatus+0x28c>)
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 8012d2c:	f021 23f0 	bic.w	r3, r1, #4026593280	; 0xf000f000
 8012d30:	f023 13c3 	bic.w	r3, r3, #12779715	; 0xc300c3
 8012d34:	b173      	cbz	r3, 8012d54 <DMA_GetITStatus+0x1e8>
 8012d36:	e003      	b.n	8012d40 <DMA_GetITStatus+0x1d4>
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8012d38:	4b2d      	ldr	r3, [pc, #180]	; (8012df0 <DMA_GetITStatus+0x284>)
 8012d3a:	4298      	cmp	r0, r3
 8012d3c:	d8f3      	bhi.n	8012d26 <DMA_GetITStatus+0x1ba>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8012d3e:	4a2e      	ldr	r2, [pc, #184]	; (8012df8 <DMA_GetITStatus+0x28c>)
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 8012d40:	6800      	ldr	r0, [r0, #0]
 8012d42:	f000 001e 	and.w	r0, r0, #30
 8012d46:	ea00 23d1 	and.w	r3, r0, r1, lsr #11
 8012d4a:	e006      	b.n	8012d5a <DMA_GetITStatus+0x1ee>
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8012d4c:	4b28      	ldr	r3, [pc, #160]	; (8012df0 <DMA_GetITStatus+0x284>)
 8012d4e:	4298      	cmp	r0, r3
 8012d50:	d8e9      	bhi.n	8012d26 <DMA_GetITStatus+0x1ba>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8012d52:	4a29      	ldr	r2, [pc, #164]	; (8012df8 <DMA_GetITStatus+0x28c>)
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
  }
  else 
  {
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 8012d54:	6940      	ldr	r0, [r0, #20]
 8012d56:	f000 0380 	and.w	r3, r0, #128	; 0x80
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8012d5a:	0088      	lsls	r0, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 8012d5c:	bf4c      	ite	mi
 8012d5e:	6850      	ldrmi	r0, [r2, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 8012d60:	6810      	ldrpl	r0, [r2, #0]

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8012d62:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8012d66:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8012d6a:	4008      	ands	r0, r1
 8012d6c:	d008      	beq.n	8012d80 <DMA_GetITStatus+0x214>
  {
    /* DMA_IT is set */
    bitstatus = SET;
 8012d6e:	1c18      	adds	r0, r3, #0
 8012d70:	bf18      	it	ne
 8012d72:	2001      	movne	r0, #1
 8012d74:	e004      	b.n	8012d80 <DMA_GetITStatus+0x214>
  DMA_TypeDef* DMAy;
  uint32_t tmpreg = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 8012d76:	4b05      	ldr	r3, [pc, #20]	; (8012d8c <DMA_GetITStatus+0x220>)
 8012d78:	4299      	cmp	r1, r3
 8012d7a:	f47f af3e 	bne.w	8012bfa <DMA_GetITStatus+0x8e>
 8012d7e:	e7de      	b.n	8012d3e <DMA_GetITStatus+0x1d2>
    bitstatus = RESET;
  }

  /* Return the DMA_IT status */
  return  bitstatus;
}
 8012d80:	b002      	add	sp, #8
 8012d82:	4770      	bx	lr
 8012d84:	40026010 	.word	0x40026010
 8012d88:	40026028 	.word	0x40026028
 8012d8c:	10008020 	.word	0x10008020
 8012d90:	10004010 	.word	0x10004010
 8012d94:	10001004 	.word	0x10001004
 8012d98:	90000001 	.word	0x90000001
 8012d9c:	10008800 	.word	0x10008800
 8012da0:	90000040 	.word	0x90000040
 8012da4:	10208000 	.word	0x10208000
 8012da8:	90010000 	.word	0x90010000
 8012dac:	18008000 	.word	0x18008000
 8012db0:	14004000 	.word	0x14004000
 8012db4:	12002000 	.word	0x12002000
 8012db8:	11001000 	.word	0x11001000
 8012dbc:	90400000 	.word	0x90400000
 8012dc0:	20008020 	.word	0x20008020
 8012dc4:	20002008 	.word	0x20002008
 8012dc8:	a0000001 	.word	0xa0000001
 8012dcc:	20008800 	.word	0x20008800
 8012dd0:	a0000040 	.word	0xa0000040
 8012dd4:	20208000 	.word	0x20208000
 8012dd8:	a0010000 	.word	0xa0010000
 8012ddc:	28008000 	.word	0x28008000
 8012de0:	24004000 	.word	0x24004000
 8012de4:	22002000 	.word	0x22002000
 8012de8:	21001000 	.word	0x21001000
 8012dec:	a0400000 	.word	0xa0400000
 8012df0:	4002640f 	.word	0x4002640f
 8012df4:	40026400 	.word	0x40026400
 8012df8:	40026000 	.word	0x40026000

08012dfc <DMA_ClearITPendingBit>:
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
  DMA_TypeDef* DMAy;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012dfc:	4b2e      	ldr	r3, [pc, #184]	; (8012eb8 <DMA_ClearITPendingBit+0xbc>)
 8012dfe:	4298      	cmp	r0, r3
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8012e00:	b513      	push	{r0, r1, r4, lr}
  DMA_TypeDef* DMAy;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012e02:	d105      	bne.n	8012e10 <DMA_ClearITPendingBit+0x14>
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
 8012e04:	f001 5340 	and.w	r3, r1, #805306368	; 0x30000000
 8012e08:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8012e0c:	d134      	bne.n	8012e78 <DMA_ClearITPendingBit+0x7c>
 8012e0e:	e047      	b.n	8012ea0 <DMA_ClearITPendingBit+0xa4>
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
  DMA_TypeDef* DMAy;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
 8012e10:	4b2a      	ldr	r3, [pc, #168]	; (8012ebc <DMA_ClearITPendingBit+0xc0>)
 8012e12:	4298      	cmp	r0, r3
 8012e14:	d0f6      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e16:	3318      	adds	r3, #24
 8012e18:	4298      	cmp	r0, r3
 8012e1a:	d0f3      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e1c:	3318      	adds	r3, #24
 8012e1e:	4298      	cmp	r0, r3
 8012e20:	d0f0      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e22:	3318      	adds	r3, #24
 8012e24:	4298      	cmp	r0, r3
 8012e26:	d0ed      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e28:	3318      	adds	r3, #24
 8012e2a:	4298      	cmp	r0, r3
 8012e2c:	d0ea      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e2e:	3318      	adds	r3, #24
 8012e30:	4298      	cmp	r0, r3
 8012e32:	d0e7      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e34:	3318      	adds	r3, #24
 8012e36:	4298      	cmp	r0, r3
 8012e38:	d0e4      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e3a:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8012e3e:	4298      	cmp	r0, r3
 8012e40:	d0e0      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e42:	3318      	adds	r3, #24
 8012e44:	4298      	cmp	r0, r3
 8012e46:	d0dd      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e48:	3318      	adds	r3, #24
 8012e4a:	4298      	cmp	r0, r3
 8012e4c:	d0da      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e4e:	3318      	adds	r3, #24
 8012e50:	4298      	cmp	r0, r3
 8012e52:	d0d7      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e54:	3318      	adds	r3, #24
 8012e56:	4298      	cmp	r0, r3
 8012e58:	d0d4      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e5a:	3318      	adds	r3, #24
 8012e5c:	4298      	cmp	r0, r3
 8012e5e:	d0d1      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e60:	3318      	adds	r3, #24
 8012e62:	4298      	cmp	r0, r3
 8012e64:	d0ce      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e66:	3318      	adds	r3, #24
 8012e68:	4298      	cmp	r0, r3
 8012e6a:	d0cb      	beq.n	8012e04 <DMA_ClearITPendingBit+0x8>
 8012e6c:	2301      	movs	r3, #1
 8012e6e:	9300      	str	r3, [sp, #0]
 8012e70:	9b00      	ldr	r3, [sp, #0]
 8012e72:	2b00      	cmp	r3, #0
 8012e74:	d1fc      	bne.n	8012e70 <DMA_ClearITPendingBit+0x74>
 8012e76:	e7c5      	b.n	8012e04 <DMA_ClearITPendingBit+0x8>
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
 8012e78:	b193      	cbz	r3, 8012ea0 <DMA_ClearITPendingBit+0xa4>
 8012e7a:	4b11      	ldr	r3, [pc, #68]	; (8012ec0 <DMA_ClearITPendingBit+0xc4>)
 8012e7c:	400b      	ands	r3, r1
 8012e7e:	b97b      	cbnz	r3, 8012ea0 <DMA_ClearITPendingBit+0xa4>
    DMAy = DMA1; 
  } 
  else 
  {
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
 8012e80:	4a10      	ldr	r2, [pc, #64]	; (8012ec4 <DMA_ClearITPendingBit+0xc8>)
 8012e82:	4b11      	ldr	r3, [pc, #68]	; (8012ec8 <DMA_ClearITPendingBit+0xcc>)
 8012e84:	4c11      	ldr	r4, [pc, #68]	; (8012ecc <DMA_ClearITPendingBit+0xd0>)
 8012e86:	42a0      	cmp	r0, r4
 8012e88:	bf94      	ite	ls
 8012e8a:	4618      	movls	r0, r3
 8012e8c:	4610      	movhi	r0, r2
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8012e8e:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8012e92:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8012e96:	d009      	beq.n	8012eac <DMA_ClearITPendingBit+0xb0>
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8012e98:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8012e9c:	60c1      	str	r1, [r0, #12]
 8012e9e:	e008      	b.n	8012eb2 <DMA_ClearITPendingBit+0xb6>
{
  DMA_TypeDef* DMAy;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
 8012ea0:	2301      	movs	r3, #1
 8012ea2:	9301      	str	r3, [sp, #4]
 8012ea4:	9b01      	ldr	r3, [sp, #4]
 8012ea6:	2b00      	cmp	r3, #0
 8012ea8:	d1fc      	bne.n	8012ea4 <DMA_ClearITPendingBit+0xa8>
 8012eaa:	e7e9      	b.n	8012e80 <DMA_ClearITPendingBit+0x84>
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8012eac:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8012eb0:	6081      	str	r1, [r0, #8]
  }   
}
 8012eb2:	b002      	add	sp, #8
 8012eb4:	bd10      	pop	{r4, pc}
 8012eb6:	bf00      	nop
 8012eb8:	40026010 	.word	0x40026010
 8012ebc:	40026028 	.word	0x40026028
 8012ec0:	40820082 	.word	0x40820082
 8012ec4:	40026400 	.word	0x40026400
 8012ec8:	40026000 	.word	0x40026000
 8012ecc:	4002640f 	.word	0x4002640f

08012ed0 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8012ed0:	b530      	push	{r4, r5, lr}
  uint32_t tmpreg1 = 0;
  uint8_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8012ed2:	4b3d      	ldr	r3, [pc, #244]	; (8012fc8 <ADC_Init+0xf8>)
 8012ed4:	4298      	cmp	r0, r3
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8012ed6:	b089      	sub	sp, #36	; 0x24
  uint32_t tmpreg1 = 0;
  uint8_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8012ed8:	d104      	bne.n	8012ee4 <ADC_Init+0x14>
  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
 8012eda:	680c      	ldr	r4, [r1, #0]
 8012edc:	f034 7340 	bics.w	r3, r4, #50331648	; 0x3000000
 8012ee0:	d10d      	bne.n	8012efe <ADC_Init+0x2e>
 8012ee2:	e011      	b.n	8012f08 <ADC_Init+0x38>
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
  uint32_t tmpreg1 = 0;
  uint8_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8012ee4:	4b39      	ldr	r3, [pc, #228]	; (8012fcc <ADC_Init+0xfc>)
 8012ee6:	4298      	cmp	r0, r3
 8012ee8:	d0f7      	beq.n	8012eda <ADC_Init+0xa>
 8012eea:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8012eee:	4298      	cmp	r0, r3
 8012ef0:	d0f3      	beq.n	8012eda <ADC_Init+0xa>
 8012ef2:	2301      	movs	r3, #1
 8012ef4:	9300      	str	r3, [sp, #0]
 8012ef6:	9b00      	ldr	r3, [sp, #0]
 8012ef8:	2b00      	cmp	r3, #0
 8012efa:	d1fc      	bne.n	8012ef6 <ADC_Init+0x26>
 8012efc:	e7ed      	b.n	8012eda <ADC_Init+0xa>
  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
 8012efe:	2301      	movs	r3, #1
 8012f00:	9301      	str	r3, [sp, #4]
 8012f02:	9b01      	ldr	r3, [sp, #4]
 8012f04:	2b00      	cmp	r3, #0
 8012f06:	d1fc      	bne.n	8012f02 <ADC_Init+0x32>
  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
 8012f08:	790d      	ldrb	r5, [r1, #4]
 8012f0a:	2d01      	cmp	r5, #1
 8012f0c:	d904      	bls.n	8012f18 <ADC_Init+0x48>
 8012f0e:	2301      	movs	r3, #1
 8012f10:	9302      	str	r3, [sp, #8]
 8012f12:	9b02      	ldr	r3, [sp, #8]
 8012f14:	2b00      	cmp	r3, #0
 8012f16:	d1fc      	bne.n	8012f12 <ADC_Init+0x42>
  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
 8012f18:	794b      	ldrb	r3, [r1, #5]
 8012f1a:	2b01      	cmp	r3, #1
 8012f1c:	d904      	bls.n	8012f28 <ADC_Init+0x58>
 8012f1e:	2301      	movs	r3, #1
 8012f20:	9303      	str	r3, [sp, #12]
 8012f22:	9b03      	ldr	r3, [sp, #12]
 8012f24:	2b00      	cmp	r3, #0
 8012f26:	d1fc      	bne.n	8012f22 <ADC_Init+0x52>
  assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
 8012f28:	688b      	ldr	r3, [r1, #8]
 8012f2a:	f033 5340 	bics.w	r3, r3, #805306368	; 0x30000000
 8012f2e:	d004      	beq.n	8012f3a <ADC_Init+0x6a>
 8012f30:	2301      	movs	r3, #1
 8012f32:	9304      	str	r3, [sp, #16]
 8012f34:	9b04      	ldr	r3, [sp, #16]
 8012f36:	2b00      	cmp	r3, #0
 8012f38:	d1fc      	bne.n	8012f34 <ADC_Init+0x64>
  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
 8012f3a:	68ca      	ldr	r2, [r1, #12]
 8012f3c:	f032 7240 	bics.w	r2, r2, #50331648	; 0x3000000
 8012f40:	d002      	beq.n	8012f48 <ADC_Init+0x78>
 8012f42:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 8012f46:	d104      	bne.n	8012f52 <ADC_Init+0x82>
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
 8012f48:	690b      	ldr	r3, [r1, #16]
 8012f4a:	f433 6300 	bics.w	r3, r3, #2048	; 0x800
 8012f4e:	d10c      	bne.n	8012f6a <ADC_Init+0x9a>
 8012f50:	e010      	b.n	8012f74 <ADC_Init+0xa4>
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
  assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
 8012f52:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 8012f56:	d0f7      	beq.n	8012f48 <ADC_Init+0x78>
 8012f58:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 8012f5c:	d0f4      	beq.n	8012f48 <ADC_Init+0x78>
 8012f5e:	2301      	movs	r3, #1
 8012f60:	9305      	str	r3, [sp, #20]
 8012f62:	9b05      	ldr	r3, [sp, #20]
 8012f64:	2b00      	cmp	r3, #0
 8012f66:	d1fc      	bne.n	8012f62 <ADC_Init+0x92>
 8012f68:	e7ee      	b.n	8012f48 <ADC_Init+0x78>
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
 8012f6a:	2301      	movs	r3, #1
 8012f6c:	9306      	str	r3, [sp, #24]
 8012f6e:	9b06      	ldr	r3, [sp, #24]
 8012f70:	2b00      	cmp	r3, #0
 8012f72:	d1fc      	bne.n	8012f6e <ADC_Init+0x9e>
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
 8012f74:	7d0a      	ldrb	r2, [r1, #20]
 8012f76:	3a01      	subs	r2, #1
 8012f78:	2a0f      	cmp	r2, #15
 8012f7a:	d904      	bls.n	8012f86 <ADC_Init+0xb6>
 8012f7c:	2301      	movs	r3, #1
 8012f7e:	9307      	str	r3, [sp, #28]
 8012f80:	9b07      	ldr	r3, [sp, #28]
 8012f82:	2b00      	cmp	r3, #0
 8012f84:	d1fc      	bne.n	8012f80 <ADC_Init+0xb0>
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8012f86:	6842      	ldr	r2, [r0, #4]
 8012f88:	f022 7340 	bic.w	r3, r2, #50331648	; 0x3000000
 8012f8c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8012f90:	4323      	orrs	r3, r4
  tmpreg1 &= CR1_CLEAR_MASK;
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8012f92:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8012f96:	6043      	str	r3, [r0, #4]
 8012f98:	68cb      	ldr	r3, [r1, #12]
 8012f9a:	690a      	ldr	r2, [r1, #16]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8012f9c:	6884      	ldr	r4, [r0, #8]
 8012f9e:	431a      	orrs	r2, r3
 8012fa0:	688b      	ldr	r3, [r1, #8]
 8012fa2:	431a      	orrs	r2, r3
 8012fa4:	4b0a      	ldr	r3, [pc, #40]	; (8012fd0 <ADC_Init+0x100>)
 8012fa6:	4023      	ands	r3, r4
 8012fa8:	4313      	orrs	r3, r2
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8012faa:	794a      	ldrb	r2, [r1, #5]
 8012fac:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8012fb0:	6083      	str	r3, [r0, #8]
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8012fb2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 8012fb4:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8012fb8:	7d0b      	ldrb	r3, [r1, #20]
 8012fba:	3b01      	subs	r3, #1
 8012fbc:	b2db      	uxtb	r3, r3
 8012fbe:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8012fc2:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8012fc4:	b009      	add	sp, #36	; 0x24
 8012fc6:	bd30      	pop	{r4, r5, pc}
 8012fc8:	40012000 	.word	0x40012000
 8012fcc:	40012100 	.word	0x40012100
 8012fd0:	c0fff7fd 	.word	0xc0fff7fd

08012fd4 <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8012fd4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint32_t tmpreg1 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
 8012fd6:	6805      	ldr	r5, [r0, #0]
 8012fd8:	2d19      	cmp	r5, #25
 8012fda:	d808      	bhi.n	8012fee <ADC_CommonInit+0x1a>
 8012fdc:	4a1d      	ldr	r2, [pc, #116]	; (8013054 <ADC_CommonInit+0x80>)
 8012fde:	40ea      	lsrs	r2, r5
 8012fe0:	07d3      	lsls	r3, r2, #31
 8012fe2:	d504      	bpl.n	8012fee <ADC_CommonInit+0x1a>
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
 8012fe4:	6841      	ldr	r1, [r0, #4]
 8012fe6:	f431 3340 	bics.w	r3, r1, #196608	; 0x30000
 8012fea:	d106      	bne.n	8012ffa <ADC_CommonInit+0x26>
 8012fec:	e00a      	b.n	8013004 <ADC_CommonInit+0x30>
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  uint32_t tmpreg1 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
 8012fee:	2301      	movs	r3, #1
 8012ff0:	9300      	str	r3, [sp, #0]
 8012ff2:	9b00      	ldr	r3, [sp, #0]
 8012ff4:	2b00      	cmp	r3, #0
 8012ff6:	d1fc      	bne.n	8012ff2 <ADC_CommonInit+0x1e>
 8012ff8:	e7f4      	b.n	8012fe4 <ADC_CommonInit+0x10>
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
 8012ffa:	2301      	movs	r3, #1
 8012ffc:	9301      	str	r3, [sp, #4]
 8012ffe:	9b01      	ldr	r3, [sp, #4]
 8013000:	2b00      	cmp	r3, #0
 8013002:	d1fc      	bne.n	8012ffe <ADC_CommonInit+0x2a>
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
 8013004:	6884      	ldr	r4, [r0, #8]
 8013006:	f434 4340 	bics.w	r3, r4, #49152	; 0xc000
 801300a:	d004      	beq.n	8013016 <ADC_CommonInit+0x42>
 801300c:	2301      	movs	r3, #1
 801300e:	9302      	str	r3, [sp, #8]
 8013010:	9b02      	ldr	r3, [sp, #8]
 8013012:	2b00      	cmp	r3, #0
 8013014:	d1fc      	bne.n	8013010 <ADC_CommonInit+0x3c>
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
 8013016:	68c3      	ldr	r3, [r0, #12]
 8013018:	f433 7240 	bics.w	r2, r3, #768	; 0x300
 801301c:	d002      	beq.n	8013024 <ADC_CommonInit+0x50>
 801301e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8013022:	d10a      	bne.n	801303a <ADC_CommonInit+0x66>
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 8013024:	480c      	ldr	r0, [pc, #48]	; (8013058 <ADC_CommonInit+0x84>)
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 8013026:	4a0d      	ldr	r2, [pc, #52]	; (801305c <ADC_CommonInit+0x88>)
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 8013028:	6846      	ldr	r6, [r0, #4]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 801302a:	4329      	orrs	r1, r5
 801302c:	430c      	orrs	r4, r1
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 801302e:	4032      	ands	r2, r6
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8013030:	4323      	orrs	r3, r4
 8013032:	4313      	orrs	r3, r2
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 8013034:	6043      	str	r3, [r0, #4]
}
 8013036:	b004      	add	sp, #16
 8013038:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t tmpreg1 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
 801303a:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 801303e:	d0f1      	beq.n	8013024 <ADC_CommonInit+0x50>
 8013040:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8013044:	d0ee      	beq.n	8013024 <ADC_CommonInit+0x50>
 8013046:	2201      	movs	r2, #1
 8013048:	9203      	str	r2, [sp, #12]
 801304a:	9a03      	ldr	r2, [sp, #12]
 801304c:	2a00      	cmp	r2, #0
 801304e:	d1fc      	bne.n	801304a <ADC_CommonInit+0x76>
 8013050:	e7e8      	b.n	8013024 <ADC_CommonInit+0x50>
 8013052:	bf00      	nop
 8013054:	02e602e7 	.word	0x02e602e7
 8013058:	40012300 	.word	0x40012300
 801305c:	fffc30e0 	.word	0xfffc30e0

08013060 <ADC_Cmd>:
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8013060:	4b12      	ldr	r3, [pc, #72]	; (80130ac <ADC_Cmd+0x4c>)
 8013062:	4298      	cmp	r0, r3
  * @param  NewState: new state of the ADCx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8013064:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8013066:	d104      	bne.n	8013072 <ADC_Cmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8013068:	2901      	cmp	r1, #1
 801306a:	d916      	bls.n	801309a <ADC_Cmd+0x3a>
 801306c:	2301      	movs	r3, #1
 801306e:	9301      	str	r3, [sp, #4]
 8013070:	e00c      	b.n	801308c <ADC_Cmd+0x2c>
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8013072:	4b0f      	ldr	r3, [pc, #60]	; (80130b0 <ADC_Cmd+0x50>)
 8013074:	4298      	cmp	r0, r3
 8013076:	d0f7      	beq.n	8013068 <ADC_Cmd+0x8>
 8013078:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801307c:	4298      	cmp	r0, r3
 801307e:	d0f3      	beq.n	8013068 <ADC_Cmd+0x8>
 8013080:	2301      	movs	r3, #1
 8013082:	9300      	str	r3, [sp, #0]
 8013084:	9b00      	ldr	r3, [sp, #0]
 8013086:	2b00      	cmp	r3, #0
 8013088:	d1fc      	bne.n	8013084 <ADC_Cmd+0x24>
 801308a:	e7ed      	b.n	8013068 <ADC_Cmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 801308c:	9b01      	ldr	r3, [sp, #4]
 801308e:	2b00      	cmp	r3, #0
 8013090:	d1fc      	bne.n	801308c <ADC_Cmd+0x2c>
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8013092:	6883      	ldr	r3, [r0, #8]
 8013094:	f043 0301 	orr.w	r3, r3, #1
 8013098:	e004      	b.n	80130a4 <ADC_Cmd+0x44>
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 801309a:	2900      	cmp	r1, #0
 801309c:	d1f9      	bne.n	8013092 <ADC_Cmd+0x32>
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 801309e:	6883      	ldr	r3, [r0, #8]
 80130a0:	f023 0301 	bic.w	r3, r3, #1
 80130a4:	6083      	str	r3, [r0, #8]
  }
}
 80130a6:	b002      	add	sp, #8
 80130a8:	4770      	bx	lr
 80130aa:	bf00      	nop
 80130ac:	40012000 	.word	0x40012000
 80130b0:	40012100 	.word	0x40012100

080130b4 <ADC_RegularChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80130b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80130b6:	4c37      	ldr	r4, [pc, #220]	; (8013194 <ADC_RegularChannelConfig+0xe0>)
 80130b8:	42a0      	cmp	r0, r4
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80130ba:	b085      	sub	sp, #20
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80130bc:	d102      	bne.n	80130c4 <ADC_RegularChannelConfig+0x10>
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
 80130be:	2912      	cmp	r1, #18
 80130c0:	d80d      	bhi.n	80130de <ADC_RegularChannelConfig+0x2a>
 80130c2:	e011      	b.n	80130e8 <ADC_RegularChannelConfig+0x34>
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80130c4:	4c34      	ldr	r4, [pc, #208]	; (8013198 <ADC_RegularChannelConfig+0xe4>)
 80130c6:	42a0      	cmp	r0, r4
 80130c8:	d0f9      	beq.n	80130be <ADC_RegularChannelConfig+0xa>
 80130ca:	f504 7480 	add.w	r4, r4, #256	; 0x100
 80130ce:	42a0      	cmp	r0, r4
 80130d0:	d0f5      	beq.n	80130be <ADC_RegularChannelConfig+0xa>
 80130d2:	2401      	movs	r4, #1
 80130d4:	9400      	str	r4, [sp, #0]
 80130d6:	9c00      	ldr	r4, [sp, #0]
 80130d8:	2c00      	cmp	r4, #0
 80130da:	d1fc      	bne.n	80130d6 <ADC_RegularChannelConfig+0x22>
 80130dc:	e7ef      	b.n	80130be <ADC_RegularChannelConfig+0xa>
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
 80130de:	2401      	movs	r4, #1
 80130e0:	9401      	str	r4, [sp, #4]
 80130e2:	9c01      	ldr	r4, [sp, #4]
 80130e4:	2c00      	cmp	r4, #0
 80130e6:	d1fc      	bne.n	80130e2 <ADC_RegularChannelConfig+0x2e>
  assert_param(IS_ADC_REGULAR_RANK(Rank));
 80130e8:	1e54      	subs	r4, r2, #1
 80130ea:	b2e5      	uxtb	r5, r4
 80130ec:	2d0f      	cmp	r5, #15
 80130ee:	d904      	bls.n	80130fa <ADC_RegularChannelConfig+0x46>
 80130f0:	2501      	movs	r5, #1
 80130f2:	9502      	str	r5, [sp, #8]
 80130f4:	9d02      	ldr	r5, [sp, #8]
 80130f6:	2d00      	cmp	r5, #0
 80130f8:	d1fc      	bne.n	80130f4 <ADC_RegularChannelConfig+0x40>
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
 80130fa:	2b07      	cmp	r3, #7
 80130fc:	d904      	bls.n	8013108 <ADC_RegularChannelConfig+0x54>
 80130fe:	2501      	movs	r5, #1
 8013100:	9503      	str	r5, [sp, #12]
 8013102:	9d03      	ldr	r5, [sp, #12]
 8013104:	2d00      	cmp	r5, #0
 8013106:	d1fc      	bne.n	8013102 <ADC_RegularChannelConfig+0x4e>
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8013108:	2909      	cmp	r1, #9
 801310a:	d90d      	bls.n	8013128 <ADC_RegularChannelConfig+0x74>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 801310c:	f1a1 050a 	sub.w	r5, r1, #10
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8013110:	68c7      	ldr	r7, [r0, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8013112:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8013116:	2607      	movs	r6, #7
 8013118:	40ae      	lsls	r6, r5
 801311a:	ea27 0606 	bic.w	r6, r7, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 801311e:	fa03 f505 	lsl.w	r5, r3, r5
 8013122:	4335      	orrs	r5, r6
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8013124:	60c5      	str	r5, [r0, #12]
 8013126:	e00a      	b.n	801313e <ADC_RegularChannelConfig+0x8a>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8013128:	6907      	ldr	r7, [r0, #16]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 801312a:	eb01 0541 	add.w	r5, r1, r1, lsl #1
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 801312e:	2607      	movs	r6, #7
 8013130:	40ae      	lsls	r6, r5
 8013132:	ea27 0606 	bic.w	r6, r7, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8013136:	fa03 f505 	lsl.w	r5, r3, r5
 801313a:	4335      	orrs	r5, r6
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 801313c:	6105      	str	r5, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 801313e:	2a06      	cmp	r2, #6
 8013140:	d80b      	bhi.n	801315a <ADC_RegularChannelConfig+0xa6>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8013142:	6b43      	ldr	r3, [r0, #52]	; 0x34
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8013144:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8013148:	221f      	movs	r2, #31
 801314a:	40a2      	lsls	r2, r4
 801314c:	ea23 0202 	bic.w	r2, r3, r2
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8013150:	fa01 f404 	lsl.w	r4, r1, r4
 8013154:	4314      	orrs	r4, r2
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8013156:	6344      	str	r4, [r0, #52]	; 0x34
 8013158:	e01a      	b.n	8013190 <ADC_RegularChannelConfig+0xdc>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 801315a:	2a0c      	cmp	r2, #12
 801315c:	d80c      	bhi.n	8013178 <ADC_RegularChannelConfig+0xc4>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 801315e:	3a07      	subs	r2, #7
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8013160:	6b03      	ldr	r3, [r0, #48]	; 0x30
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8013162:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8013166:	241f      	movs	r4, #31
 8013168:	4094      	lsls	r4, r2
 801316a:	ea23 0404 	bic.w	r4, r3, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 801316e:	fa01 f202 	lsl.w	r2, r1, r2
 8013172:	4322      	orrs	r2, r4
    
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8013174:	6302      	str	r2, [r0, #48]	; 0x30
 8013176:	e00b      	b.n	8013190 <ADC_RegularChannelConfig+0xdc>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8013178:	3a0d      	subs	r2, #13
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 801317a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 801317c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8013180:	231f      	movs	r3, #31
 8013182:	4093      	lsls	r3, r2
 8013184:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8013188:	fa01 f202 	lsl.w	r2, r1, r2
 801318c:	431a      	orrs	r2, r3
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 801318e:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 8013190:	b005      	add	sp, #20
 8013192:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013194:	40012000 	.word	0x40012000
 8013198:	40012100 	.word	0x40012100

0801319c <ADC_SoftwareStartConv>:
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 801319c:	4b0b      	ldr	r3, [pc, #44]	; (80131cc <ADC_SoftwareStartConv+0x30>)
 801319e:	4298      	cmp	r0, r3
  * @brief  Enables the selected ADC software start conversion of the regular channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
 80131a0:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80131a2:	d105      	bne.n	80131b0 <ADC_SoftwareStartConv+0x14>
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80131a4:	6883      	ldr	r3, [r0, #8]
 80131a6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80131aa:	6083      	str	r3, [r0, #8]
}
 80131ac:	b002      	add	sp, #8
 80131ae:	4770      	bx	lr
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80131b0:	4b07      	ldr	r3, [pc, #28]	; (80131d0 <ADC_SoftwareStartConv+0x34>)
 80131b2:	4298      	cmp	r0, r3
 80131b4:	d0f6      	beq.n	80131a4 <ADC_SoftwareStartConv+0x8>
 80131b6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131ba:	4298      	cmp	r0, r3
 80131bc:	d0f2      	beq.n	80131a4 <ADC_SoftwareStartConv+0x8>
 80131be:	2301      	movs	r3, #1
 80131c0:	9301      	str	r3, [sp, #4]
 80131c2:	9b01      	ldr	r3, [sp, #4]
 80131c4:	2b00      	cmp	r3, #0
 80131c6:	d1fc      	bne.n	80131c2 <ADC_SoftwareStartConv+0x26>
 80131c8:	e7ec      	b.n	80131a4 <ADC_SoftwareStartConv+0x8>
 80131ca:	bf00      	nop
 80131cc:	40012000 	.word	0x40012000
 80131d0:	40012100 	.word	0x40012100

080131d4 <ADC_DMACmd>:
  * @retval None
  */
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80131d4:	4b12      	ldr	r3, [pc, #72]	; (8013220 <ADC_DMACmd+0x4c>)
 80131d6:	4298      	cmp	r0, r3
  * @param  NewState: new state of the selected ADC DMA transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80131d8:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80131da:	d104      	bne.n	80131e6 <ADC_DMACmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 80131dc:	2901      	cmp	r1, #1
 80131de:	d916      	bls.n	801320e <ADC_DMACmd+0x3a>
 80131e0:	2301      	movs	r3, #1
 80131e2:	9301      	str	r3, [sp, #4]
 80131e4:	e00c      	b.n	8013200 <ADC_DMACmd+0x2c>
  * @retval None
  */
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 80131e6:	4b0f      	ldr	r3, [pc, #60]	; (8013224 <ADC_DMACmd+0x50>)
 80131e8:	4298      	cmp	r0, r3
 80131ea:	d0f7      	beq.n	80131dc <ADC_DMACmd+0x8>
 80131ec:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80131f0:	4298      	cmp	r0, r3
 80131f2:	d0f3      	beq.n	80131dc <ADC_DMACmd+0x8>
 80131f4:	2301      	movs	r3, #1
 80131f6:	9300      	str	r3, [sp, #0]
 80131f8:	9b00      	ldr	r3, [sp, #0]
 80131fa:	2b00      	cmp	r3, #0
 80131fc:	d1fc      	bne.n	80131f8 <ADC_DMACmd+0x24>
 80131fe:	e7ed      	b.n	80131dc <ADC_DMACmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8013200:	9b01      	ldr	r3, [sp, #4]
 8013202:	2b00      	cmp	r3, #0
 8013204:	d1fc      	bne.n	8013200 <ADC_DMACmd+0x2c>
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8013206:	6883      	ldr	r3, [r0, #8]
 8013208:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 801320c:	e004      	b.n	8013218 <ADC_DMACmd+0x44>
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 801320e:	2900      	cmp	r1, #0
 8013210:	d1f9      	bne.n	8013206 <ADC_DMACmd+0x32>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 8013212:	6883      	ldr	r3, [r0, #8]
 8013214:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8013218:	6083      	str	r3, [r0, #8]
  }
}
 801321a:	b002      	add	sp, #8
 801321c:	4770      	bx	lr
 801321e:	bf00      	nop
 8013220:	40012000 	.word	0x40012000
 8013224:	40012100 	.word	0x40012100

08013228 <ADC_DMARequestAfterLastTransferCmd>:
  * @retval None
  */
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 8013228:	4b12      	ldr	r3, [pc, #72]	; (8013274 <ADC_DMARequestAfterLastTransferCmd+0x4c>)
 801322a:	4298      	cmp	r0, r3
  * @param  NewState: new state of the selected ADC DMA request after last transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 801322c:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 801322e:	d104      	bne.n	801323a <ADC_DMARequestAfterLastTransferCmd+0x12>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8013230:	2901      	cmp	r1, #1
 8013232:	d916      	bls.n	8013262 <ADC_DMARequestAfterLastTransferCmd+0x3a>
 8013234:	2301      	movs	r3, #1
 8013236:	9301      	str	r3, [sp, #4]
 8013238:	e00c      	b.n	8013254 <ADC_DMARequestAfterLastTransferCmd+0x2c>
  * @retval None
  */
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
 801323a:	4b0f      	ldr	r3, [pc, #60]	; (8013278 <ADC_DMARequestAfterLastTransferCmd+0x50>)
 801323c:	4298      	cmp	r0, r3
 801323e:	d0f7      	beq.n	8013230 <ADC_DMARequestAfterLastTransferCmd+0x8>
 8013240:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013244:	4298      	cmp	r0, r3
 8013246:	d0f3      	beq.n	8013230 <ADC_DMARequestAfterLastTransferCmd+0x8>
 8013248:	2301      	movs	r3, #1
 801324a:	9300      	str	r3, [sp, #0]
 801324c:	9b00      	ldr	r3, [sp, #0]
 801324e:	2b00      	cmp	r3, #0
 8013250:	d1fc      	bne.n	801324c <ADC_DMARequestAfterLastTransferCmd+0x24>
 8013252:	e7ed      	b.n	8013230 <ADC_DMARequestAfterLastTransferCmd+0x8>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 8013254:	9b01      	ldr	r3, [sp, #4]
 8013256:	2b00      	cmp	r3, #0
 8013258:	d1fc      	bne.n	8013254 <ADC_DMARequestAfterLastTransferCmd+0x2c>
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 801325a:	6883      	ldr	r3, [r0, #8]
 801325c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8013260:	e004      	b.n	801326c <ADC_DMARequestAfterLastTransferCmd+0x44>
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8013262:	2900      	cmp	r1, #0
 8013264:	d1f9      	bne.n	801325a <ADC_DMARequestAfterLastTransferCmd+0x32>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
 8013266:	6883      	ldr	r3, [r0, #8]
 8013268:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 801326c:	6083      	str	r3, [r0, #8]
  }
}
 801326e:	b002      	add	sp, #8
 8013270:	4770      	bx	lr
 8013272:	bf00      	nop
 8013274:	40012000 	.word	0x40012000
 8013278:	40012100 	.word	0x40012100

0801327c <IWDG_WriteAccessCmd>:
  * @retval None
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
 801327c:	f245 5355 	movw	r3, #21845	; 0x5555
 8013280:	4298      	cmp	r0, r3
  *            @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
  *            @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
  * @retval None
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
 8013282:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
 8013284:	d103      	bne.n	801328e <IWDG_WriteAccessCmd+0x12>
  IWDG->KR = IWDG_WriteAccess;
 8013286:	4b06      	ldr	r3, [pc, #24]	; (80132a0 <IWDG_WriteAccessCmd+0x24>)
 8013288:	6018      	str	r0, [r3, #0]
}
 801328a:	b002      	add	sp, #8
 801328c:	4770      	bx	lr
  * @retval None
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
 801328e:	2800      	cmp	r0, #0
 8013290:	d0f9      	beq.n	8013286 <IWDG_WriteAccessCmd+0xa>
 8013292:	2301      	movs	r3, #1
 8013294:	9301      	str	r3, [sp, #4]
 8013296:	9b01      	ldr	r3, [sp, #4]
 8013298:	2b00      	cmp	r3, #0
 801329a:	d1fc      	bne.n	8013296 <IWDG_WriteAccessCmd+0x1a>
 801329c:	e7f3      	b.n	8013286 <IWDG_WriteAccessCmd+0xa>
 801329e:	bf00      	nop
 80132a0:	40003000 	.word	0x40003000

080132a4 <IWDG_SetPrescaler>:
  * @retval None
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
 80132a4:	2806      	cmp	r0, #6
  *            @arg IWDG_Prescaler_128: IWDG prescaler set to 128
  *            @arg IWDG_Prescaler_256: IWDG prescaler set to 256
  * @retval None
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
 80132a6:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
 80132a8:	d803      	bhi.n	80132b2 <IWDG_SetPrescaler+0xe>
  IWDG->PR = IWDG_Prescaler;
 80132aa:	4b05      	ldr	r3, [pc, #20]	; (80132c0 <IWDG_SetPrescaler+0x1c>)
 80132ac:	6058      	str	r0, [r3, #4]
}
 80132ae:	b002      	add	sp, #8
 80132b0:	4770      	bx	lr
  * @retval None
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
 80132b2:	2301      	movs	r3, #1
 80132b4:	9301      	str	r3, [sp, #4]
 80132b6:	9b01      	ldr	r3, [sp, #4]
 80132b8:	2b00      	cmp	r3, #0
 80132ba:	d1fc      	bne.n	80132b6 <IWDG_SetPrescaler+0x12>
 80132bc:	e7f5      	b.n	80132aa <IWDG_SetPrescaler+0x6>
 80132be:	bf00      	nop
 80132c0:	40003000 	.word	0x40003000

080132c4 <IWDG_SetReload>:
  * @retval None
  */
void IWDG_SetReload(uint16_t Reload)
{
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
 80132c4:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
  * @param  Reload: specifies the IWDG Reload value.
  *          This parameter must be a number between 0 and 0x0FFF.
  * @retval None
  */
void IWDG_SetReload(uint16_t Reload)
{
 80132c8:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
 80132ca:	d203      	bcs.n	80132d4 <IWDG_SetReload+0x10>
  IWDG->RLR = Reload;
 80132cc:	4b04      	ldr	r3, [pc, #16]	; (80132e0 <IWDG_SetReload+0x1c>)
 80132ce:	6098      	str	r0, [r3, #8]
}
 80132d0:	b002      	add	sp, #8
 80132d2:	4770      	bx	lr
  * @retval None
  */
void IWDG_SetReload(uint16_t Reload)
{
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
 80132d4:	2301      	movs	r3, #1
 80132d6:	9301      	str	r3, [sp, #4]
 80132d8:	9b01      	ldr	r3, [sp, #4]
 80132da:	2b00      	cmp	r3, #0
 80132dc:	d1fc      	bne.n	80132d8 <IWDG_SetReload+0x14>
 80132de:	e7f5      	b.n	80132cc <IWDG_SetReload+0x8>
 80132e0:	40003000 	.word	0x40003000

080132e4 <IWDG_ReloadCounter>:
  * @param  None
  * @retval None
  */
void IWDG_ReloadCounter(void)
{
  IWDG->KR = KR_KEY_RELOAD;
 80132e4:	4b02      	ldr	r3, [pc, #8]	; (80132f0 <IWDG_ReloadCounter+0xc>)
 80132e6:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 80132ea:	601a      	str	r2, [r3, #0]
 80132ec:	4770      	bx	lr
 80132ee:	bf00      	nop
 80132f0:	40003000 	.word	0x40003000

080132f4 <IWDG_Enable>:
  * @param  None
  * @retval None
  */
void IWDG_Enable(void)
{
  IWDG->KR = KR_KEY_ENABLE;
 80132f4:	4b02      	ldr	r3, [pc, #8]	; (8013300 <IWDG_Enable+0xc>)
 80132f6:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 80132fa:	601a      	str	r2, [r3, #0]
 80132fc:	4770      	bx	lr
 80132fe:	bf00      	nop
 8013300:	40003000 	.word	0x40003000

08013304 <initParam>:

EHIF_CMD_DI_GET_CHIP_INFO_DATA_T    ehifNwmGetChipIdData;

static void initParam(void)
{
  memset(&ehifCmdParam, 0x00, sizeof(ehifCmdParam));
 8013304:	2212      	movs	r2, #18
 8013306:	2100      	movs	r1, #0
 8013308:	4801      	ldr	r0, [pc, #4]	; (8013310 <initParam+0xc>)
 801330a:	f001 b93b 	b.w	8014584 <memset>
 801330e:	bf00      	nop
 8013310:	2001aef9 	.word	0x2001aef9

08013314 <getDeviceInfo>:
} // initParam



EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T getDeviceInfo(void)
{
 8013314:	b570      	push	{r4, r5, r6, lr}
 8013316:	b086      	sub	sp, #24
  uint16_t readbcLength;

  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
  memset(&devInfo, 0x00, sizeof(devInfo) );
 8013318:	2600      	movs	r6, #0
} // initParam



EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T getDeviceInfo(void)
{
 801331a:	4605      	mov	r5, r0
  uint16_t readbcLength;

  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T devInfo;
  memset(&devInfo, 0x00, sizeof(devInfo) );
 801331c:	ac03      	add	r4, sp, #12
 801331e:	9603      	str	r6, [sp, #12]
 8013320:	9604      	str	r6, [sp, #16]
 8013322:	9605      	str	r6, [sp, #20]
  initParam();
 8013324:	f7ff ffee 	bl	8013304 <initParam>
  readbcLength = 12;

  ehifCmdExecWithRead(EHIF_EXEC_ALL, EHIF_CMD_DI_GET_DEVICE_INFO,
 8013328:	230c      	movs	r3, #12
 801332a:	9300      	str	r3, [sp, #0]
 801332c:	9401      	str	r4, [sp, #4]
 801332e:	4b07      	ldr	r3, [pc, #28]	; (801334c <getDeviceInfo+0x38>)
 8013330:	4632      	mov	r2, r6
 8013332:	211e      	movs	r1, #30
 8013334:	2006      	movs	r0, #6
 8013336:	f000 fa49 	bl	80137cc <ehifCmdExecWithRead>
                      0, &ehifCmdParam,
                      readbcLength, &devInfo);

  return devInfo;
 801333a:	4623      	mov	r3, r4
 801333c:	cb03      	ldmia	r3!, {r0, r1}
 801333e:	6028      	str	r0, [r5, #0]
 8013340:	6818      	ldr	r0, [r3, #0]
 8013342:	60a8      	str	r0, [r5, #8]
}
 8013344:	4628      	mov	r0, r5

  ehifCmdExecWithRead(EHIF_EXEC_ALL, EHIF_CMD_DI_GET_DEVICE_INFO,
                      0, &ehifCmdParam,
                      readbcLength, &devInfo);

  return devInfo;
 8013346:	6069      	str	r1, [r5, #4]
}
 8013348:	b006      	add	sp, #24
 801334a:	bd70      	pop	{r4, r5, r6, pc}
 801334c:	2001aef9 	.word	0x2001aef9

08013350 <clearFlags>:
      return 0;
    }
}

void clearFlags( uint8_t mask )
{
 8013350:	b510      	push	{r4, lr}
 8013352:	4604      	mov	r4, r0
  mask &= 0x3F;
  initParam();
 8013354:	f7ff ffd6 	bl	8013304 <initParam>
  ehifCmdParam.ehcEvtClr.clearedEvents = mask;
 8013358:	4a04      	ldr	r2, [pc, #16]	; (801336c <clearFlags+0x1c>)
 801335a:	f004 043f 	and.w	r4, r4, #63	; 0x3f
 801335e:	7014      	strb	r4, [r2, #0]
  ehifCmdExec(EHIF_CMD_EHC_EVT_CLR, sizeof(EHIF_CMD_EHC_EVT_CLR_PARAM_T), &ehifCmdParam);
 8013360:	2101      	movs	r1, #1
 8013362:	2019      	movs	r0, #25
}
 8013364:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void clearFlags( uint8_t mask )
{
  mask &= 0x3F;
  initParam();
  ehifCmdParam.ehcEvtClr.clearedEvents = mask;
  ehifCmdExec(EHIF_CMD_EHC_EVT_CLR, sizeof(EHIF_CMD_EHC_EVT_CLR_PARAM_T), &ehifCmdParam);
 8013368:	f000 b9c4 	b.w	80136f4 <ehifCmdExec>
 801336c:	2001aef9 	.word	0x2001aef9

08013370 <setIntEvents>:
}

void setIntEvents( uint8_t mask )
{
 8013370:	b510      	push	{r4, lr}
 8013372:	4604      	mov	r4, r0
  initParam();
 8013374:	f7ff ffc6 	bl	8013304 <initParam>
  ehifCmdParam.ehcEvtMask.irqGioLevel = ACTIVE_LOW;
 8013378:	4a05      	ldr	r2, [pc, #20]	; (8013390 <setIntEvents+0x20>)
 801337a:	7813      	ldrb	r3, [r2, #0]
  ehifCmdParam.ehcEvtMask.eventFilter = mask;
 801337c:	7054      	strb	r4, [r2, #1]
}

void setIntEvents( uint8_t mask )
{
  initParam();
  ehifCmdParam.ehcEvtMask.irqGioLevel = ACTIVE_LOW;
 801337e:	f36f 0300 	bfc	r3, #0, #1
 8013382:	7013      	strb	r3, [r2, #0]
  ehifCmdParam.ehcEvtMask.eventFilter = mask;
  ehifCmdExec(EHIF_CMD_EHC_EVT_MASK, sizeof(EHIF_CMD_EHC_EVT_MASK_PARAM_T), &ehifCmdParam);
 8013384:	2102      	movs	r1, #2
 8013386:	201a      	movs	r0, #26
}
 8013388:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void setIntEvents( uint8_t mask )
{
  initParam();
  ehifCmdParam.ehcEvtMask.irqGioLevel = ACTIVE_LOW;
  ehifCmdParam.ehcEvtMask.eventFilter = mask;
  ehifCmdExec(EHIF_CMD_EHC_EVT_MASK, sizeof(EHIF_CMD_EHC_EVT_MASK_PARAM_T), &ehifCmdParam);
 801338c:	f000 b9b2 	b.w	80136f4 <ehifCmdExec>
 8013390:	2001aef9 	.word	0x2001aef9

08013394 <queueRX>:



// returns RX data length and address
int queueRX(uint32_t *address, uint8_t *ret_data, uint8_t *reset)
{
 8013394:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013396:	b08f      	sub	sp, #60	; 0x3c
 8013398:	4607      	mov	r7, r0
 801339a:	460e      	mov	r6, r1
 801339c:	4615      	mov	r5, r2
  uint16_t readbcLength;
  unsigned char data[PAYLOAD_PLUS_ADR];
#define RX_FRAME_HEADER_SIZE 5

  // check Data avalibility
  if (ehifGetStatus() &  BV_EHIF_EVT_DSC_RX_AVAIL )
 801339e:	f000 fb9c 	bl	8013ada <ehifGetStatus>
 80133a2:	f000 0080 	and.w	r0, r0, #128	; 0x80
 80133a6:	b284      	uxth	r4, r0
 80133a8:	b324      	cbz	r4, 80133f4 <queueRX+0x60>
    {
      initParam();
 80133aa:	f7ff ffab 	bl	8013304 <initParam>
      readbcLength = PAYLOAD_PLUS_ADR;
 80133ae:	2325      	movs	r3, #37	; 0x25
 80133b0:	f8ad 300e 	strh.w	r3, [sp, #14]
      ehifCmdExecWithReadbc(EHIF_EXEC_ALL,  EHIF_CMD_DSC_RX_DATAGRAM,
 80133b4:	ab04      	add	r3, sp, #16
 80133b6:	9301      	str	r3, [sp, #4]
 80133b8:	f10d 030e 	add.w	r3, sp, #14
 80133bc:	9300      	str	r3, [sp, #0]
 80133be:	2200      	movs	r2, #0
 80133c0:	4b0e      	ldr	r3, [pc, #56]	; (80133fc <queueRX+0x68>)
 80133c2:	2105      	movs	r1, #5
 80133c4:	2006      	movs	r0, #6
 80133c6:	f000 fab1 	bl	801392c <ehifCmdExecWithReadbc>
                            0, &ehifCmdParam,
                            &readbcLength, &data);
      if (readbcLength)
 80133ca:	f8bd 400e 	ldrh.w	r4, [sp, #14]
 80133ce:	b14c      	cbz	r4, 80133e4 <queueRX+0x50>
        {
          ret = readbcLength-RX_FRAME_HEADER_SIZE;
 80133d0:	3c05      	subs	r4, #5
          *address = *(uint32_t *)(data + 1);
 80133d2:	f8dd 3011 	ldr.w	r3, [sp, #17]
 80133d6:	603b      	str	r3, [r7, #0]
          memcpy(ret_data, data + RX_FRAME_HEADER_SIZE, readbcLength - RX_FRAME_HEADER_SIZE);     // 5 = 4bytes of address and one additional reserved byte
 80133d8:	4622      	mov	r2, r4
 80133da:	f10d 0115 	add.w	r1, sp, #21
 80133de:	4630      	mov	r0, r6
 80133e0:	f001 f836 	bl	8014450 <memcpy>
      else
        {
          ret = 0;
        }

      if(reset)
 80133e4:	b135      	cbz	r5, 80133f4 <queueRX+0x60>
        {
          if (data[0] & 0x01) // check reset conection flag in received datagram
 80133e6:	f89d 3010 	ldrb.w	r3, [sp, #16]
 80133ea:	f013 0301 	ands.w	r3, r3, #1
            *reset = 1;
 80133ee:	bf18      	it	ne
 80133f0:	2301      	movne	r3, #1
          else
            *reset = 0;
 80133f2:	702b      	strb	r3, [r5, #0]
        }
    }
  return ret;
}
 80133f4:	4620      	mov	r0, r4
 80133f6:	b00f      	add	sp, #60	; 0x3c
 80133f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80133fa:	bf00      	nop
 80133fc:	2001aef9 	.word	0x2001aef9

08013400 <queueTX>:

int queueTX(remoteDev_t *dev, uint16_t dataLength, uint8_t *data, uint8_t reset)
{
 8013400:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  //#warning "Check for data-side connection availability and remote device compatibility"
  int ret = 0;

  massert(dataLength <= MAX_PAYLOAD);
 8013404:	2920      	cmp	r1, #32
    }
  return ret;
}

int queueTX(remoteDev_t *dev, uint16_t dataLength, uint8_t *data, uint8_t reset)
{
 8013406:	b085      	sub	sp, #20
 8013408:	4607      	mov	r7, r0
 801340a:	460e      	mov	r6, r1
 801340c:	4690      	mov	r8, r2
 801340e:	4699      	mov	r9, r3
  //#warning "Check for data-side connection availability and remote device compatibility"
  int ret = 0;

  massert(dataLength <= MAX_PAYLOAD);
 8013410:	d807      	bhi.n	8013422 <queueTX+0x22>
  uint16_t status = ehifGetStatus();
 8013412:	f000 fb62 	bl	8013ada <ehifGetStatus>

  if (  status &  BV_EHIF_STAT_CONNECTED )
 8013416:	05c5      	lsls	r5, r0, #23
{
  //#warning "Check for data-side connection availability and remote device compatibility"
  int ret = 0;

  massert(dataLength <= MAX_PAYLOAD);
  uint16_t status = ehifGetStatus();
 8013418:	4604      	mov	r4, r0

  if (  status &  BV_EHIF_STAT_CONNECTED )
 801341a:	d40e      	bmi.n	801343a <queueTX+0x3a>
        }

    }
  else
    {
      return -2;
 801341c:	f06f 0001 	mvn.w	r0, #1
 8013420:	e046      	b.n	80134b0 <queueTX+0xb0>
int queueTX(remoteDev_t *dev, uint16_t dataLength, uint8_t *data, uint8_t reset)
{
  //#warning "Check for data-side connection availability and remote device compatibility"
  int ret = 0;

  massert(dataLength <= MAX_PAYLOAD);
 8013422:	4b25      	ldr	r3, [pc, #148]	; (80134b8 <queueTX+0xb8>)
 8013424:	4925      	ldr	r1, [pc, #148]	; (80134bc <queueTX+0xbc>)
 8013426:	4826      	ldr	r0, [pc, #152]	; (80134c0 <queueTX+0xc0>)
 8013428:	22a1      	movs	r2, #161	; 0xa1
 801342a:	f7f5 f99b 	bl	8008764 <xprintf>
 801342e:	2301      	movs	r3, #1
 8013430:	9302      	str	r3, [sp, #8]
 8013432:	9b02      	ldr	r3, [sp, #8]
 8013434:	2b00      	cmp	r3, #0
 8013436:	d1fc      	bne.n	8013432 <queueTX+0x32>
 8013438:	e7eb      	b.n	8013412 <queueTX+0x12>
  uint16_t status = ehifGetStatus();

  if (  status &  BV_EHIF_STAT_CONNECTED )
    {
      if ( status & BV_EHIF_EVT_SPI_ERROR)
 801343a:	06c0      	lsls	r0, r0, #27
 801343c:	d515      	bpl.n	801346a <queueTX+0x6a>
        {
          // clear SPI_ERROR_FLAG:
          clearFlags( BV_EHIF_EVT_SPI_ERROR );
 801343e:	2010      	movs	r0, #16
 8013440:	f7ff ff86 	bl	8013350 <clearFlags>
 8013444:	2564      	movs	r5, #100	; 0x64
          int timeout = 100;
          do
            {
              status = ehifGetStatus();
 8013446:	f000 fb48 	bl	8013ada <ehifGetStatus>
            }
          while ( status & BV_EHIF_EVT_SPI_ERROR && --timeout );
 801344a:	06c1      	lsls	r1, r0, #27
          // clear SPI_ERROR_FLAG:
          clearFlags( BV_EHIF_EVT_SPI_ERROR );
          int timeout = 100;
          do
            {
              status = ehifGetStatus();
 801344c:	4604      	mov	r4, r0
            }
          while ( status & BV_EHIF_EVT_SPI_ERROR && --timeout );
 801344e:	d50c      	bpl.n	801346a <queueTX+0x6a>
 8013450:	3d01      	subs	r5, #1
 8013452:	d1f8      	bne.n	8013446 <queueTX+0x46>
          massert(timeout);
 8013454:	4b1b      	ldr	r3, [pc, #108]	; (80134c4 <queueTX+0xc4>)
 8013456:	4919      	ldr	r1, [pc, #100]	; (80134bc <queueTX+0xbc>)
 8013458:	4819      	ldr	r0, [pc, #100]	; (80134c0 <queueTX+0xc0>)
 801345a:	22b0      	movs	r2, #176	; 0xb0
 801345c:	f7f5 f982 	bl	8008764 <xprintf>
 8013460:	2301      	movs	r3, #1
 8013462:	9303      	str	r3, [sp, #12]
 8013464:	9b03      	ldr	r3, [sp, #12]
 8013466:	2b00      	cmp	r3, #0
 8013468:	d1fc      	bne.n	8013464 <queueTX+0x64>
        }
      if ( status & BV_EHIF_EVT_DSC_TX_AVAIL )
 801346a:	0662      	lsls	r2, r4, #25
 801346c:	d51e      	bpl.n	80134ac <queueTX+0xac>
        {
          initParam();
 801346e:	f7ff ff49 	bl	8013304 <initParam>
 8013472:	4b15      	ldr	r3, [pc, #84]	; (80134c8 <queueTX+0xc8>)
          // check wheather datagram connection needs to be reestablished
          if (reset)
 8013474:	f1b9 0f00 	cmp.w	r9, #0
 8013478:	d003      	beq.n	8013482 <queueTX+0x82>
            ehifCmdParam.dscTxDatagram.connReset = 1;
 801347a:	781a      	ldrb	r2, [r3, #0]
 801347c:	f042 0201 	orr.w	r2, r2, #1
 8013480:	701a      	strb	r2, [r3, #0]

          ehifCmdParam.dscTxDatagram.addr = dev->devID;
 8013482:	683a      	ldr	r2, [r7, #0]
 8013484:	f8c3 2001 	str.w	r2, [r3, #1]

          WAIT_BUSY;
 8013488:	f000 fb27 	bl	8013ada <ehifGetStatus>
 801348c:	0403      	lsls	r3, r0, #16
 801348e:	d403      	bmi.n	8013498 <queueTX+0x98>
 8013490:	2001      	movs	r0, #1
 8013492:	f7f7 f9fd 	bl	800a890 <vTaskDelay>
 8013496:	e7f7      	b.n	8013488 <queueTX+0x88>
          ehifCmdExecWithWrite(EHIF_EXEC_ALL, EHIF_CMD_DSC_TX_DATAGRAM,
 8013498:	2006      	movs	r0, #6
 801349a:	e88d 0140 	stmia.w	sp, {r6, r8}
 801349e:	4b0a      	ldr	r3, [pc, #40]	; (80134c8 <queueTX+0xc8>)
 80134a0:	2205      	movs	r2, #5
 80134a2:	2104      	movs	r1, #4
 80134a4:	f000 fa8c 	bl	80139c0 <ehifCmdExecWithWrite>
  else
    {
      return -2;
    }

  return ret;
 80134a8:	2000      	movs	r0, #0
 80134aa:	e001      	b.n	80134b0 <queueTX+0xb0>
                               sizeof(EHIF_CMD_DSC_TX_DATAGRAM_PARAM_T) , &ehifCmdParam,
                               dataLength, (void *) data);
        }
      else
        {
          return -1;//TxFull
 80134ac:	f04f 30ff 	mov.w	r0, #4294967295
    {
      return -2;
    }

  return ret;
}
 80134b0:	b005      	add	sp, #20
 80134b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80134b6:	bf00      	nop
 80134b8:	0801e4d6 	.word	0x0801e4d6
 80134bc:	0801e4b5 	.word	0x0801e4b5
 80134c0:	080148f4 	.word	0x080148f4
 80134c4:	0801e2ab 	.word	0x0801e2ab
 80134c8:	2001aef9 	.word	0x2001aef9

080134cc <reset_powerActive>:
  ehifCmdExec(EHIF_CMD_PM_SET_STATE, sizeof(EHIF_CMD_PM_SET_STATE_PARAM_T), &ehifCmdParam);
}


int reset_powerActive(void)
{
 80134cc:	b508      	push	{r3, lr}
  // HANDLE POWER ON
  // Ensure known state (power state 5)
  ehifSysResetSpi(1); // with wait rready flag
 80134ce:	2001      	movs	r0, #1
 80134d0:	f000 fbf4 	bl	8013cbc <ehifSysResetSpi>
  ehifWaitReadyMs(300);
 80134d4:	f44f 7096 	mov.w	r0, #300	; 0x12c
 80134d8:	f000 fbd8 	bl	8013c8c <ehifWaitReadyMs>
  return ehifGetWaitReadyError();
 80134dc:	f000 fc3e 	bl	8013d5c <ehifGetWaitReadyError>
}
 80134e0:	bd08      	pop	{r3, pc}
	...

080134e4 <initParam>:
EHIF_CMD_RC_SET_DATA_PARAM_T ehifRcSetDataParam;


static void initParam(void)
{
  memset(&ehifCmdParam, 0x00, sizeof(ehifCmdParam));
 80134e4:	2212      	movs	r2, #18
 80134e6:	2100      	movs	r1, #0
 80134e8:	4801      	ldr	r0, [pc, #4]	; (80134f0 <initParam+0xc>)
 80134ea:	f001 b84b 	b.w	8014584 <memset>
 80134ee:	bf00      	nop
 80134f0:	2001aef9 	.word	0x2001aef9

080134f4 <getStatus>:
  return 0;
}


EHIF_CMD_NWM_GET_STATUS_SLAVE_DATA_T getStatus(void)
{
 80134f4:	b570      	push	{r4, r5, r6, lr}
 80134f6:	4605      	mov	r5, r0
 80134f8:	b08c      	sub	sp, #48	; 0x30

  uint16_t readbcLength;

  WAIT_BUSY;
 80134fa:	f000 faee 	bl	8013ada <ehifGetStatus>
 80134fe:	0403      	lsls	r3, r0, #16
 8013500:	d403      	bmi.n	801350a <getStatus+0x16>
 8013502:	2001      	movs	r0, #1
 8013504:	f7f7 f9c4 	bl	800a890 <vTaskDelay>
 8013508:	e7f7      	b.n	80134fa <getStatus+0x6>
  EHIF_CMD_NWM_GET_STATUS_SLAVE_DATA_T statusSlave;
  memset(&statusSlave, 0x00, sizeof(statusSlave) );
 801350a:	ac04      	add	r4, sp, #16
 801350c:	261e      	movs	r6, #30
 801350e:	4632      	mov	r2, r6
 8013510:	2100      	movs	r1, #0
 8013512:	4620      	mov	r0, r4
 8013514:	f001 f836 	bl	8014584 <memset>
  initParam();
 8013518:	f7ff ffe4 	bl	80134e4 <initParam>

  *((unsigned short *) &ehifCmdParam) = 0x00B0;
 801351c:	4b15      	ldr	r3, [pc, #84]	; (8013574 <getStatus+0x80>)
 801351e:	f06f 014f 	mvn.w	r1, #79	; 0x4f
 8013522:	7019      	strb	r1, [r3, #0]
  readbcLength = 30;
 8013524:	a90c      	add	r1, sp, #48	; 0x30
  WAIT_BUSY;
  EHIF_CMD_NWM_GET_STATUS_SLAVE_DATA_T statusSlave;
  memset(&statusSlave, 0x00, sizeof(statusSlave) );
  initParam();

  *((unsigned short *) &ehifCmdParam) = 0x00B0;
 8013526:	2200      	movs	r2, #0
  readbcLength = 30;
 8013528:	f821 6d22 	strh.w	r6, [r1, #-34]!
  WAIT_BUSY;
  EHIF_CMD_NWM_GET_STATUS_SLAVE_DATA_T statusSlave;
  memset(&statusSlave, 0x00, sizeof(statusSlave) );
  initParam();

  *((unsigned short *) &ehifCmdParam) = 0x00B0;
 801352c:	705a      	strb	r2, [r3, #1]
  readbcLength = 30;

  ehifCmdExecWithReadbc(EHIF_EXEC_ALL, EHIF_CMD_NWM_GET_STATUS_S,
 801352e:	2006      	movs	r0, #6
 8013530:	e88d 0012 	stmia.w	sp, {r1, r4}
 8013534:	218a      	movs	r1, #138	; 0x8a
 8013536:	f000 f9f9 	bl	801392c <ehifCmdExecWithReadbc>
                        0, &ehifCmdParam,   // command lenth and params
                        &readbcLength, &statusSlave);

  if (readbcLength == 0 || statusSlave.nwkId == 0)
 801353a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 801353e:	b10b      	cbz	r3, 8013544 <getStatus+0x50>
 8013540:	9b04      	ldr	r3, [sp, #16]
 8013542:	b923      	cbnz	r3, 801354e <getStatus+0x5a>
    {
      memset(&statusSlave, 0x00, sizeof(statusSlave) );
 8013544:	221e      	movs	r2, #30
 8013546:	2100      	movs	r1, #0
 8013548:	4620      	mov	r0, r4
 801354a:	f001 f81b 	bl	8014584 <memset>
    }

  return statusSlave;
 801354e:	4623      	mov	r3, r4
 8013550:	462a      	mov	r2, r5
 8013552:	ae0a      	add	r6, sp, #40	; 0x28
 8013554:	461c      	mov	r4, r3
 8013556:	cc03      	ldmia	r4!, {r0, r1}
 8013558:	42b4      	cmp	r4, r6
 801355a:	6010      	str	r0, [r2, #0]
 801355c:	6051      	str	r1, [r2, #4]
 801355e:	4623      	mov	r3, r4
 8013560:	f102 0208 	add.w	r2, r2, #8
 8013564:	d1f6      	bne.n	8013554 <getStatus+0x60>
 8013566:	6820      	ldr	r0, [r4, #0]
 8013568:	6010      	str	r0, [r2, #0]
 801356a:	88a3      	ldrh	r3, [r4, #4]
 801356c:	8093      	strh	r3, [r2, #4]
}
 801356e:	4628      	mov	r0, r5
 8013570:	b00c      	add	sp, #48	; 0x30
 8013572:	bd70      	pop	{r4, r5, r6, pc}
 8013574:	2001aef9 	.word	0x2001aef9

08013578 <getNetworkID>:

  return getVolumeStruct;
}

EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T getNetworkID(uint32_t masterID, uint32_t timeout_ms)
{
 8013578:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801357c:	b092      	sub	sp, #72	; 0x48
  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T retInfo;
  memset(&retInfo, 0x00, sizeof(retInfo));
 801357e:	2400      	movs	r4, #0

  return getVolumeStruct;
}

EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T getNetworkID(uint32_t masterID, uint32_t timeout_ms)
{
 8013580:	4605      	mov	r5, r0
  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T retInfo;
  memset(&retInfo, 0x00, sizeof(retInfo));
  //  massert(timeout_ms > 4000);
#define MAX_NETWORKS_NUM 1
  ehifWaitReadyMs(1000);
 8013582:	f44f 707a 	mov.w	r0, #1000	; 0x3e8

  return getVolumeStruct;
}

EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T getNetworkID(uint32_t masterID, uint32_t timeout_ms)
{
 8013586:	4616      	mov	r6, r2
 8013588:	460f      	mov	r7, r1
  EHIF_CMD_DI_GET_DEVICE_INFO_DATA_T retInfo;
  memset(&retInfo, 0x00, sizeof(retInfo));
 801358a:	9404      	str	r4, [sp, #16]
 801358c:	9405      	str	r4, [sp, #20]
 801358e:	9406      	str	r4, [sp, #24]
  //  massert(timeout_ms > 4000);
#define MAX_NETWORKS_NUM 1
  ehifWaitReadyMs(1000);
 8013590:	f000 fb7c 	bl	8013c8c <ehifWaitReadyMs>

  uint16_t readbcLength;
  // TODO: check device state

  // Search for one protocol master with pairing signal enabled for 10 seconds
  initParam();
 8013594:	f7ff ffa6 	bl	80134e4 <initParam>
  EHIF_CMD_NWM_DO_SCAN_PARAM_T params;
  memset(&params, 0x00, sizeof(params));
 8013598:	2210      	movs	r2, #16
 801359a:	4621      	mov	r1, r4
 801359c:	a807      	add	r0, sp, #28
 801359e:	f000 fff1 	bl	8014584 <memset>

  ehifCmdParam.nwmDoScan.scanTo           = timeout_ms / 10; //timeout in 10ms
 80135a2:	4b28      	ldr	r3, [pc, #160]	; (8013644 <getNetworkID+0xcc>)
 80135a4:	7859      	ldrb	r1, [r3, #1]
  ehifCmdParam.nwmDoScan.scanMax          = MAX_NETWORKS_NUM;
  ehifCmdParam.nwmDoScan.reqPairingSignal = 0;
  ehifCmdParam.nwmDoScan.reqRssi          = -128;
  ehifCmdParam.nwmDoScan.mfctId           = masterID;
 80135a6:	f8c3 7002 	str.w	r7, [r3, #2]
  // Search for one protocol master with pairing signal enabled for 10 seconds
  initParam();
  EHIF_CMD_NWM_DO_SCAN_PARAM_T params;
  memset(&params, 0x00, sizeof(params));

  ehifCmdParam.nwmDoScan.scanTo           = timeout_ms / 10; //timeout in 10ms
 80135aa:	f021 010f 	bic.w	r1, r1, #15
 80135ae:	220a      	movs	r2, #10
 80135b0:	fbb6 f2f2 	udiv	r2, r6, r2
 80135b4:	701a      	strb	r2, [r3, #0]
 80135b6:	f3c2 2203 	ubfx	r2, r2, #8, #4
  ehifCmdParam.nwmDoScan.scanMax          = MAX_NETWORKS_NUM;
 80135ba:	430a      	orrs	r2, r1
 80135bc:	2101      	movs	r1, #1
 80135be:	f361 1207 	bfi	r2, r1, #4, #4
 80135c2:	705a      	strb	r2, [r3, #1]
  ehifCmdParam.nwmDoScan.reqPairingSignal = 0;
 80135c4:	7b9a      	ldrb	r2, [r3, #14]
 80135c6:	f364 0200 	bfi	r2, r4, #0, #1
 80135ca:	739a      	strb	r2, [r3, #14]
  ehifCmdParam.nwmDoScan.reqRssi          = -128;
 80135cc:	2280      	movs	r2, #128	; 0x80
 80135ce:	73da      	strb	r2, [r3, #15]
  ehifCmdParam.nwmDoScan.mfctId           = masterID;
  ehifCmdExecWithReadbc(EHIF_EXEC_CMD, EHIF_CMD_NWM_DO_SCAN,
 80135d0:	2108      	movs	r1, #8
 80135d2:	2210      	movs	r2, #16
 80135d4:	2002      	movs	r0, #2
 80135d6:	9401      	str	r4, [sp, #4]
 80135d8:	9400      	str	r4, [sp, #0]
 80135da:	f000 f9a7 	bl	801392c <ehifCmdExecWithReadbc>
                        sizeof(EHIF_CMD_NWM_DO_SCAN_PARAM_T), &ehifCmdParam,
                        NULL, NULL);

  // Fetch network information once ready
  ehifWaitReadyMs(timeout_ms + 1000);
 80135de:	f506 707a 	add.w	r0, r6, #1000	; 0x3e8
 80135e2:	b280      	uxth	r0, r0
  readbcLength = sizeof(ehifNwmDoScanData);
 80135e4:	f04f 081c 	mov.w	r8, #28


  memset(&ehifNwmDoScanData, 0x00, sizeof(ehifNwmDoScanData));
 80135e8:	ae0b      	add	r6, sp, #44	; 0x2c
  ehifCmdExecWithReadbc(EHIF_EXEC_CMD, EHIF_CMD_NWM_DO_SCAN,
                        sizeof(EHIF_CMD_NWM_DO_SCAN_PARAM_T), &ehifCmdParam,
                        NULL, NULL);

  // Fetch network information once ready
  ehifWaitReadyMs(timeout_ms + 1000);
 80135ea:	f000 fb4f 	bl	8013c8c <ehifWaitReadyMs>
  readbcLength = sizeof(ehifNwmDoScanData);


  memset(&ehifNwmDoScanData, 0x00, sizeof(ehifNwmDoScanData));
 80135ee:	4642      	mov	r2, r8
 80135f0:	4621      	mov	r1, r4
 80135f2:	4630      	mov	r0, r6
                        sizeof(EHIF_CMD_NWM_DO_SCAN_PARAM_T), &ehifCmdParam,
                        NULL, NULL);

  // Fetch network information once ready
  ehifWaitReadyMs(timeout_ms + 1000);
  readbcLength = sizeof(ehifNwmDoScanData);
 80135f4:	f8ad 800e 	strh.w	r8, [sp, #14]


  memset(&ehifNwmDoScanData, 0x00, sizeof(ehifNwmDoScanData));
 80135f8:	f000 ffc4 	bl	8014584 <memset>
  ehifCmdExecWithReadbc(EHIF_EXEC_DATA, EHIF_CMD_NWM_DO_SCAN,
 80135fc:	f10d 030e 	add.w	r3, sp, #14
 8013600:	9300      	str	r3, [sp, #0]
 8013602:	2108      	movs	r1, #8
 8013604:	9601      	str	r6, [sp, #4]
 8013606:	4623      	mov	r3, r4
 8013608:	4622      	mov	r2, r4
 801360a:	2004      	movs	r0, #4
 801360c:	f000 f98e 	bl	801392c <ehifCmdExecWithReadbc>
                        0, NULL,
                        &readbcLength, &ehifNwmDoScanData);

  if (readbcLength == 0)
 8013610:	f8bd 100e 	ldrh.w	r1, [sp, #14]
 8013614:	b919      	cbnz	r1, 801361e <getNetworkID+0xa6>
    {
      // return empty result
      memset(&ehifNwmDoScanData, 0x00, sizeof(ehifNwmDoScanData));
 8013616:	4642      	mov	r2, r8
 8013618:	4630      	mov	r0, r6
 801361a:	f000 ffb3 	bl	8014584 <memset>
    }

  uint16_t i = 0;
  for ( i = 0; i < MAX_NETWORKS_NUM; i++)
    if (ehifNwmDoScanData[i].mfctId == masterID)
 801361e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013620:	429f      	cmp	r7, r3
 8013622:	d104      	bne.n	801362e <getNetworkID+0xb6>
      {
        retInfo.deviceId = ehifNwmDoScanData[i].deviceId;
 8013624:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013626:	9304      	str	r3, [sp, #16]
        retInfo.mfctId = ehifNwmDoScanData[i].mfctId;
        retInfo.prodId = ehifNwmDoScanData[i].prodId;
 8013628:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  uint16_t i = 0;
  for ( i = 0; i < MAX_NETWORKS_NUM; i++)
    if (ehifNwmDoScanData[i].mfctId == masterID)
      {
        retInfo.deviceId = ehifNwmDoScanData[i].deviceId;
        retInfo.mfctId = ehifNwmDoScanData[i].mfctId;
 801362a:	9705      	str	r7, [sp, #20]
        retInfo.prodId = ehifNwmDoScanData[i].prodId;
 801362c:	9306      	str	r3, [sp, #24]
        /*         ehifNwmDoScanData[i].rssi); */

        return  retInfo;
      }

  return retInfo;
 801362e:	ab04      	add	r3, sp, #16
 8013630:	cb03      	ldmia	r3!, {r0, r1}
 8013632:	6028      	str	r0, [r5, #0]
 8013634:	6818      	ldr	r0, [r3, #0]
 8013636:	60a8      	str	r0, [r5, #8]
}
 8013638:	4628      	mov	r0, r5
        /*         ehifNwmDoScanData[i].rssi); */

        return  retInfo;
      }

  return retInfo;
 801363a:	6069      	str	r1, [r5, #4]
}
 801363c:	b012      	add	sp, #72	; 0x48
 801363e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013642:	bf00      	nop
 8013644:	2001aef9 	.word	0x2001aef9

08013648 <disconnectFromMaster>:
  return ehifNwmDoScanData;

}

void disconnectFromMaster(void)
{
 8013648:	b508      	push	{r3, lr}
  // Let the last executed EHIF command complete, with 1 second timeout
  ehifWaitReadyMs(1000);
 801364a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801364e:	f000 fb1d 	bl	8013c8c <ehifWaitReadyMs>

  // Disconnect if currently connected
  int stat = ehifGetStatus();
 8013652:	f000 fa42 	bl	8013ada <ehifGetStatus>
  if (stat & BV_EHIF_STAT_CONNECTED)
 8013656:	05c3      	lsls	r3, r0, #23
 8013658:	d50c      	bpl.n	8013674 <disconnectFromMaster+0x2c>
    {
      initParam();
 801365a:	f7ff ff43 	bl	80134e4 <initParam>
      // All parameters should be zero
      ehifCmdExec(EHIF_CMD_NWM_DO_JOIN, sizeof(EHIF_CMD_NWM_DO_JOIN_PARAM_T), &ehifCmdParam);
 801365e:	2009      	movs	r0, #9
 8013660:	4a05      	ldr	r2, [pc, #20]	; (8013678 <disconnectFromMaster+0x30>)
 8013662:	2112      	movs	r1, #18
 8013664:	f000 f846 	bl	80136f4 <ehifCmdExec>
      ehifWaitReadyMs(5000);
 8013668:	f241 3088 	movw	r0, #5000	; 0x1388
    }
}
 801366c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (stat & BV_EHIF_STAT_CONNECTED)
    {
      initParam();
      // All parameters should be zero
      ehifCmdExec(EHIF_CMD_NWM_DO_JOIN, sizeof(EHIF_CMD_NWM_DO_JOIN_PARAM_T), &ehifCmdParam);
      ehifWaitReadyMs(5000);
 8013670:	f000 bb0c 	b.w	8013c8c <ehifWaitReadyMs>
 8013674:	bd08      	pop	{r3, pc}
 8013676:	bf00      	nop
 8013678:	2001aef9 	.word	0x2001aef9

0801367c <doJoin>:
    }
}

uint8_t doJoin(uint32_t masterAddress, uint32_t masterManID)
{
 801367c:	b538      	push	{r3, r4, r5, lr}
 801367e:	4605      	mov	r5, r0
  uint8_t ret = 0 ;

  // Let the last executed EHIF command complete, with 1 second timeout
  ehifWaitReadyMs(1000);
 8013680:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
      ehifWaitReadyMs(5000);
    }
}

uint8_t doJoin(uint32_t masterAddress, uint32_t masterManID)
{
 8013684:	460c      	mov	r4, r1
  uint8_t ret = 0 ;

  // Let the last executed EHIF command complete, with 1 second timeout
  ehifWaitReadyMs(1000);
 8013686:	f000 fb01 	bl	8013c8c <ehifWaitReadyMs>

  disconnectFromMaster();
 801368a:	f7ff ffdd 	bl	8013648 <disconnectFromMaster>

  initParam();
 801368e:	f7ff ff29 	bl	80134e4 <initParam>
  ehifCmdParam.nwmDoJoin.joinTo = 100;//1s
 8013692:	4a0c      	ldr	r2, [pc, #48]	; (80136c4 <doJoin+0x48>)
 8013694:	2364      	movs	r3, #100	; 0x64
 8013696:	7013      	strb	r3, [r2, #0]
 8013698:	7853      	ldrb	r3, [r2, #1]
  ehifCmdParam.nwmDoJoin.deviceId = masterAddress;
 801369a:	f8c2 5002 	str.w	r5, [r2, #2]
  ehifWaitReadyMs(1000);

  disconnectFromMaster();

  initParam();
  ehifCmdParam.nwmDoJoin.joinTo = 100;//1s
 801369e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  ehifCmdParam.nwmDoJoin.deviceId = masterAddress;
  ehifCmdParam.nwmDoJoin.mfctId = masterManID;
  ehifCmdExec(EHIF_CMD_NWM_DO_JOIN, sizeof(EHIF_CMD_NWM_DO_JOIN_PARAM_T), &ehifCmdParam);
 80136a2:	2112      	movs	r1, #18
 80136a4:	2009      	movs	r0, #9
  ehifWaitReadyMs(1000);

  disconnectFromMaster();

  initParam();
  ehifCmdParam.nwmDoJoin.joinTo = 100;//1s
 80136a6:	7053      	strb	r3, [r2, #1]
  ehifCmdParam.nwmDoJoin.deviceId = masterAddress;
  ehifCmdParam.nwmDoJoin.mfctId = masterManID;
 80136a8:	f8c2 4006 	str.w	r4, [r2, #6]
  ehifCmdExec(EHIF_CMD_NWM_DO_JOIN, sizeof(EHIF_CMD_NWM_DO_JOIN_PARAM_T), &ehifCmdParam);
 80136ac:	f000 f822 	bl	80136f4 <ehifCmdExec>
  // }

  ehifWaitReadyMs(5000);
 80136b0:	f241 3088 	movw	r0, #5000	; 0x1388
 80136b4:	f000 faea 	bl	8013c8c <ehifWaitReadyMs>
  uint16_t status = ehifGetStatus();
 80136b8:	f000 fa0f 	bl	8013ada <ehifGetStatus>
  else
    {
      ret = 0;
    }
  return ret;
}
 80136bc:	f3c0 2000 	ubfx	r0, r0, #8, #1
 80136c0:	bd38      	pop	{r3, r4, r5, pc}
 80136c2:	bf00      	nop
 80136c4:	2001aef9 	.word	0x2001aef9

080136c8 <activateChannels>:




void activateChannels(uint8_t *ch)
{
 80136c8:	b510      	push	{r4, lr}
  // Connected: Subscribe to audio channels (0xFF = unused)
  memset(&ehifCmdParam, 0xFF, sizeof(EHIF_CMD_NWM_ACH_SET_USAGE_PARAM_T));
 80136ca:	21ff      	movs	r1, #255	; 0xff




void activateChannels(uint8_t *ch)
{
 80136cc:	4604      	mov	r4, r0
  // Connected: Subscribe to audio channels (0xFF = unused)
  memset(&ehifCmdParam, 0xFF, sizeof(EHIF_CMD_NWM_ACH_SET_USAGE_PARAM_T));
 80136ce:	2210      	movs	r2, #16
 80136d0:	4807      	ldr	r0, [pc, #28]	; (80136f0 <activateChannels+0x28>)
 80136d2:	f000 ff57 	bl	8014584 <memset>
  int i = 0;
  for (i = 0; i < MAX_SLOT_NUM; i++)
    {
      ehifCmdParam.nwmAchSetUsage.pAchUsage[i] = ch[i];
 80136d6:	4b06      	ldr	r3, [pc, #24]	; (80136f0 <activateChannels+0x28>)
void activateChannels(uint8_t *ch)
{
  // Connected: Subscribe to audio channels (0xFF = unused)
  memset(&ehifCmdParam, 0xFF, sizeof(EHIF_CMD_NWM_ACH_SET_USAGE_PARAM_T));
  int i = 0;
  for (i = 0; i < MAX_SLOT_NUM; i++)
 80136d8:	2100      	movs	r1, #0
    {
      ehifCmdParam.nwmAchSetUsage.pAchUsage[i] = ch[i];
 80136da:	5c62      	ldrb	r2, [r4, r1]
 80136dc:	54ca      	strb	r2, [r1, r3]
void activateChannels(uint8_t *ch)
{
  // Connected: Subscribe to audio channels (0xFF = unused)
  memset(&ehifCmdParam, 0xFF, sizeof(EHIF_CMD_NWM_ACH_SET_USAGE_PARAM_T));
  int i = 0;
  for (i = 0; i < MAX_SLOT_NUM; i++)
 80136de:	3101      	adds	r1, #1
 80136e0:	2910      	cmp	r1, #16
 80136e2:	d1fa      	bne.n	80136da <activateChannels+0x12>
    {
      ehifCmdParam.nwmAchSetUsage.pAchUsage[i] = ch[i];
    }
  ehifCmdExec(EHIF_CMD_NWM_ACH_SET_USAGE, sizeof(EHIF_CMD_NWM_ACH_SET_USAGE_PARAM_T), &ehifCmdParam);
 80136e4:	4a02      	ldr	r2, [pc, #8]	; (80136f0 <activateChannels+0x28>)
 80136e6:	200b      	movs	r0, #11
}
 80136e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  int i = 0;
  for (i = 0; i < MAX_SLOT_NUM; i++)
    {
      ehifCmdParam.nwmAchSetUsage.pAchUsage[i] = ch[i];
    }
  ehifCmdExec(EHIF_CMD_NWM_ACH_SET_USAGE, sizeof(EHIF_CMD_NWM_ACH_SET_USAGE_PARAM_T), &ehifCmdParam);
 80136ec:	f000 b802 	b.w	80136f4 <ehifCmdExec>
 80136f0:	2001aef9 	.word	0x2001aef9

080136f4 <ehifCmdExec>:
 */
void ehifCmdExec(uint8_t cmd, uint8_t cmdLength, const void* pCmdParam) {

    // Locate endianess conversion specification for CMD_REQ
    const int8_t* pFieldSpec = NULL;
    switch (cmd) {
 80136f4:	f1a0 0309 	sub.w	r3, r0, #9
 * \param[in]       cmdLength
 *     Command parameter length, in most cases sizeof(EHIF_CMD_XXXXX_PARAM_T)
 * \param[in]       *pCmdParam
 *     Pointer to the command parameter structure, EHIF_CMD_XXXXX_PARAM_T
 */
void ehifCmdExec(uint8_t cmd, uint8_t cmdLength, const void* pCmdParam) {
 80136f8:	b500      	push	{lr}

    // Locate endianess conversion specification for CMD_REQ
    const int8_t* pFieldSpec = NULL;
    switch (cmd) {
 80136fa:	2b24      	cmp	r3, #36	; 0x24
 80136fc:	d83d      	bhi.n	801377a <ehifCmdExec+0x86>
 80136fe:	e8df f003 	tbb	[pc, r3]
 8013702:	3c15      	.short	0x3c15
 8013704:	1d1b1917 	.word	0x1d1b1917
 8013708:	3c3c3c3c 	.word	0x3c3c3c3c
 801370c:	3c2d2b29 	.word	0x3c2d2b29
 8013710:	13373c23 	.word	0x13373c23
 8013714:	3c3c213c 	.word	0x3c3c213c
 8013718:	3c3c333c 	.word	0x3c3c333c
 801371c:	3c2f3c35 	.word	0x3c2f3c35
 8013720:	3c3c2531 	.word	0x3c3c2531
 8013724:	273c      	.short	0x273c
 8013726:	1f          	.byte	0x1f
 8013727:	00          	.byte	0x00
    case EHIF_CMD_EHC_EVT_CLR:        { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
    case EHIF_CMD_EHC_EVT_MASK:       { static const int8_t pF[] = { F8(2), 0 };                 pFieldSpec = pF; } break;
 8013728:	4b15      	ldr	r3, [pc, #84]	; (8013780 <ehifCmdExec+0x8c>)
 801372a:	e022      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_NWM_DO_JOIN:        { static const int8_t pF[] = { F16(1), F32(4), 0 };        pFieldSpec = pF; } break;
 801372c:	4b15      	ldr	r3, [pc, #84]	; (8013784 <ehifCmdExec+0x90>)
 801372e:	e020      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_NWM_ACH_SET_USAGE:  { static const int8_t pF[] = { F8(16), 0 };                pFieldSpec = pF; } break;
 8013730:	4b15      	ldr	r3, [pc, #84]	; (8013788 <ehifCmdExec+0x94>)
 8013732:	e01e      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_NWM_CONTROL_ENABLE: { static const int8_t pF[] = { F8(2), 0 };                 pFieldSpec = pF; } break;
 8013734:	4b15      	ldr	r3, [pc, #84]	; (801378c <ehifCmdExec+0x98>)
 8013736:	e01c      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_NWM_CONTROL_SIGNAL: { static const int8_t pF[] = { F8(2), 0 };                 pFieldSpec = pF; } break;
 8013738:	4b15      	ldr	r3, [pc, #84]	; (8013790 <ehifCmdExec+0x9c>)
 801373a:	e01a      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_NWM_SET_RF_CH_MASK: { static const int8_t pF[] = { F32(1), 0 };                pFieldSpec = pF; } break;
 801373c:	4b15      	ldr	r3, [pc, #84]	; (8013794 <ehifCmdExec+0xa0>)
 801373e:	e018      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_RC_SET_DATA:        { static const int8_t pF[] = { F8(9), F16(2), 0 };         pFieldSpec = pF; } break;
 8013740:	4b15      	ldr	r3, [pc, #84]	; (8013798 <ehifCmdExec+0xa4>)
 8013742:	e016      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_PM_SET_STATE:       { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 8013744:	4b15      	ldr	r3, [pc, #84]	; (801379c <ehifCmdExec+0xa8>)
 8013746:	e014      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_VC_SET_VOLUME:      { static const int8_t pF[] = { F32(1), 0 };                pFieldSpec = pF; } break;
 8013748:	4b15      	ldr	r3, [pc, #84]	; (80137a0 <ehifCmdExec+0xac>)
 801374a:	e012      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_CAL_SET_DATA:       { static const int8_t pF[] = { F8(1), F32(1), 0 };         pFieldSpec = pF; } break;
 801374c:	4b15      	ldr	r3, [pc, #84]	; (80137a4 <ehifCmdExec+0xb0>)
 801374e:	e010      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_NVS_SET_DATA:       { static const int8_t pF[] = { F8(1), F32(1), 0 };         pFieldSpec = pF; } break;
 8013750:	4b15      	ldr	r3, [pc, #84]	; (80137a8 <ehifCmdExec+0xb4>)
 8013752:	e00e      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_RFT_TXPER:          { static const int8_t pF[] = { F16(1), F32(1), F8(2), 0 }; pFieldSpec = pF; } break;
 8013754:	4b15      	ldr	r3, [pc, #84]	; (80137ac <ehifCmdExec+0xb8>)
 8013756:	e00c      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_RFT_TXTST_PN:       { static const int8_t pF[] = { F8(3), 0 };                 pFieldSpec = pF; } break;
 8013758:	4b15      	ldr	r3, [pc, #84]	; (80137b0 <ehifCmdExec+0xbc>)
 801375a:	e00a      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_RFT_TXTST_CW:       { static const int8_t pF[] = { F8(3), 0 };                 pFieldSpec = pF; } break;
 801375c:	4b15      	ldr	r3, [pc, #84]	; (80137b4 <ehifCmdExec+0xc0>)
 801375e:	e008      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_RFT_RXTST_CONT:     { static const int8_t pF[] = { F8(2), 0 };                 pFieldSpec = pF; } break;
 8013760:	4b15      	ldr	r3, [pc, #84]	; (80137b8 <ehifCmdExec+0xc4>)
 8013762:	e006      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_RFT_NWKSIM:         { static const int8_t pF[] = { F16(4), F8(6), 0 };         pFieldSpec = pF; } break;
 8013764:	4b15      	ldr	r3, [pc, #84]	; (80137bc <ehifCmdExec+0xc8>)
 8013766:	e004      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_AT_GEN_TONE:        { static const int8_t pF[] = { F8(3), F16(1), 0 };         pFieldSpec = pF; } break;
 8013768:	4b15      	ldr	r3, [pc, #84]	; (80137c0 <ehifCmdExec+0xcc>)
 801376a:	e002      	b.n	8013772 <ehifCmdExec+0x7e>
    case EHIF_CMD_IOTST_OUTPUT:       { static const int8_t pF[] = { F32(2), 0 };                pFieldSpec = pF; } break;
 801376c:	4b15      	ldr	r3, [pc, #84]	; (80137c4 <ehifCmdExec+0xd0>)
 801376e:	e000      	b.n	8013772 <ehifCmdExec+0x7e>
void ehifCmdExec(uint8_t cmd, uint8_t cmdLength, const void* pCmdParam) {

    // Locate endianess conversion specification for CMD_REQ
    const int8_t* pFieldSpec = NULL;
    switch (cmd) {
    case EHIF_CMD_EHC_EVT_CLR:        { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 8013770:	4b15      	ldr	r3, [pc, #84]	; (80137c8 <ehifCmdExec+0xd4>)
    }

    // Send CMD_REQ
    ehifFieldCmdReq(cmd, cmdLength, (const uint8_t*) pCmdParam, pFieldSpec);

} // ehifCmdExec
 8013772:	f85d eb04 	ldr.w	lr, [sp], #4
    case EHIF_CMD_IOTST_OUTPUT:       { static const int8_t pF[] = { F32(2), 0 };                pFieldSpec = pF; } break;
    default: return;
    }

    // Send CMD_REQ
    ehifFieldCmdReq(cmd, cmdLength, (const uint8_t*) pCmdParam, pFieldSpec);
 8013776:	f000 bc36 	b.w	8013fe6 <ehifFieldCmdReq>
 801377a:	f85d fb04 	ldr.w	pc, [sp], #4
 801377e:	bf00      	nop
 8013780:	0801e4f2 	.word	0x0801e4f2
 8013784:	0801e4f4 	.word	0x0801e4f4
 8013788:	0801e4f7 	.word	0x0801e4f7
 801378c:	0801e4f9 	.word	0x0801e4f9
 8013790:	0801e4fb 	.word	0x0801e4fb
 8013794:	0801e4fd 	.word	0x0801e4fd
 8013798:	0801e4ff 	.word	0x0801e4ff
 801379c:	0801e502 	.word	0x0801e502
 80137a0:	0801e504 	.word	0x0801e504
 80137a4:	0801e506 	.word	0x0801e506
 80137a8:	0801e509 	.word	0x0801e509
 80137ac:	0801e50c 	.word	0x0801e50c
 80137b0:	0801e510 	.word	0x0801e510
 80137b4:	0801e512 	.word	0x0801e512
 80137b8:	0801e514 	.word	0x0801e514
 80137bc:	0801e516 	.word	0x0801e516
 80137c0:	0801e519 	.word	0x0801e519
 80137c4:	0801e51c 	.word	0x0801e51c
 80137c8:	0801e4f0 	.word	0x0801e4f0

080137cc <ehifCmdExecWithRead>:
 * \param[in]       dataLength
 *     Read data length, in most cases sizeof(EHIF_CMD_XXXXX_DATA_T)
 * \param[out]      *pReadData
 *     Pointer to the read data structure, EHIF_CMD_XXXXX_DATA_T
 */
void ehifCmdExecWithRead(uint8_t execSel, uint8_t cmd, uint8_t cmdLength, const void* pCmdParam, uint16_t dataLength, void* pReadData) {
 80137cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80137ce:	4605      	mov	r5, r0

    // Execute command phase?
    if (execSel & EHIF_EXEC_CMD) {
 80137d0:	07a8      	lsls	r0, r5, #30
 * \param[in]       dataLength
 *     Read data length, in most cases sizeof(EHIF_CMD_XXXXX_DATA_T)
 * \param[out]      *pReadData
 *     Pointer to the read data structure, EHIF_CMD_XXXXX_DATA_T
 */
void ehifCmdExecWithRead(uint8_t execSel, uint8_t cmd, uint8_t cmdLength, const void* pCmdParam, uint16_t dataLength, void* pReadData) {
 80137d2:	460c      	mov	r4, r1
 80137d4:	f8bd 6018 	ldrh.w	r6, [sp, #24]
 80137d8:	9f07      	ldr	r7, [sp, #28]
 80137da:	4611      	mov	r1, r2
 80137dc:	461a      	mov	r2, r3

    // Execute command phase?
    if (execSel & EHIF_EXEC_CMD) {
 80137de:	d533      	bpl.n	8013848 <ehifCmdExecWithRead+0x7c>
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for CMD_REQ
        switch (cmd) {
 80137e0:	f1a4 0310 	sub.w	r3, r4, #16
 80137e4:	2b1e      	cmp	r3, #30
 80137e6:	d867      	bhi.n	80138b8 <ehifCmdExecWithRead+0xec>
 80137e8:	e8df f003 	tbb	[pc, r3]
 80137ec:	66221614 	.word	0x66221614
 80137f0:	66126666 	.word	0x66126666
 80137f4:	66666666 	.word	0x66666666
 80137f8:	102a1a66 	.word	0x102a1a66
 80137fc:	66282666 	.word	0x66282666
 8013800:	66246666 	.word	0x66246666
 8013804:	201e1c66 	.word	0x201e1c66
 8013808:	6666      	.short	0x6666
 801380a:	18          	.byte	0x18
 801380b:	00          	.byte	0x00
        case EHIF_CMD_DI_GET_DEVICE_INFO: { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
        case EHIF_CMD_DI_GET_CHIP_INFO:   { static const int8_t pF[] = { F16(1), 0 };                pFieldSpec = pF; } break;
 801380c:	4b2b      	ldr	r3, [pc, #172]	; (80138bc <ehifCmdExecWithRead+0xf0>)
 801380e:	e018      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_VC_GET_VOLUME:      { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 8013810:	4b2b      	ldr	r3, [pc, #172]	; (80138c0 <ehifCmdExecWithRead+0xf4>)
 8013812:	e016      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_PS_RF_STATS:        { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013814:	4b2b      	ldr	r3, [pc, #172]	; (80138c4 <ehifCmdExecWithRead+0xf8>)
 8013816:	e014      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_PS_AUDIO_STATS:     { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013818:	4b2b      	ldr	r3, [pc, #172]	; (80138c8 <ehifCmdExecWithRead+0xfc>)
 801381a:	e012      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_RC_GET_DATA:        { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 801381c:	4b2b      	ldr	r3, [pc, #172]	; (80138cc <ehifCmdExecWithRead+0x100>)
 801381e:	e010      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_PM_GET_DATA:        { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013820:	4b2b      	ldr	r3, [pc, #172]	; (80138d0 <ehifCmdExecWithRead+0x104>)
 8013822:	e00e      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_CAL_GET_DATA:       { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013824:	4b2b      	ldr	r3, [pc, #172]	; (80138d4 <ehifCmdExecWithRead+0x108>)
 8013826:	e00c      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_IO_GET_PIN_VAL:     { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013828:	4b2b      	ldr	r3, [pc, #172]	; (80138d8 <ehifCmdExecWithRead+0x10c>)
 801382a:	e00a      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_NVS_GET_DATA:       { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 801382c:	4b2b      	ldr	r3, [pc, #172]	; (80138dc <ehifCmdExecWithRead+0x110>)
 801382e:	e008      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_RFT_RXPER:          { static const int8_t pF[] = { F16(1), F32(2), F8(1), 0 }; pFieldSpec = pF; } break;
 8013830:	4b2b      	ldr	r3, [pc, #172]	; (80138e0 <ehifCmdExecWithRead+0x114>)
 8013832:	e006      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_RFT_RXTST_RSSI:     { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 8013834:	4b2b      	ldr	r3, [pc, #172]	; (80138e4 <ehifCmdExecWithRead+0x118>)
 8013836:	e004      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_AT_DET_TONE:        { static const int8_t pF[] = { F8(1), 0 };                 pFieldSpec = pF; } break;
 8013838:	4b2b      	ldr	r3, [pc, #172]	; (80138e8 <ehifCmdExecWithRead+0x11c>)
 801383a:	e002      	b.n	8013842 <ehifCmdExecWithRead+0x76>
        case EHIF_CMD_IOTST_INPUT:        { static const int8_t pF[] = { F32(1), 0 };                pFieldSpec = pF; } break;
 801383c:	4b2b      	ldr	r3, [pc, #172]	; (80138ec <ehifCmdExecWithRead+0x120>)
 801383e:	e000      	b.n	8013842 <ehifCmdExecWithRead+0x76>
    if (execSel & EHIF_EXEC_CMD) {
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for CMD_REQ
        switch (cmd) {
        case EHIF_CMD_DI_GET_DEVICE_INFO: { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013840:	4b2b      	ldr	r3, [pc, #172]	; (80138f0 <ehifCmdExecWithRead+0x124>)
        case EHIF_CMD_IOTST_INPUT:        { static const int8_t pF[] = { F32(1), 0 };                pFieldSpec = pF; } break;
        default: return;
        }

        // Send CMD_REQ
        ehifFieldCmdReq(cmd, cmdLength, (const uint8_t*) pCmdParam, pFieldSpec);
 8013842:	4620      	mov	r0, r4
 8013844:	f000 fbcf 	bl	8013fe6 <ehifFieldCmdReq>
    }

    // Execute data phase?
    if (execSel & EHIF_EXEC_DATA) {
 8013848:	076b      	lsls	r3, r5, #29
 801384a:	d535      	bpl.n	80138b8 <ehifCmdExecWithRead+0xec>
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for READ
        switch (cmd) {
 801384c:	3c10      	subs	r4, #16
 801384e:	2c1e      	cmp	r4, #30
 8013850:	d832      	bhi.n	80138b8 <ehifCmdExecWithRead+0xec>
 8013852:	e8df f004 	tbb	[pc, r4]
 8013856:	1614      	.short	0x1614
 8013858:	31313122 	.word	0x31313122
 801385c:	31313112 	.word	0x31313112
 8013860:	1a313131 	.word	0x1a313131
 8013864:	2631102a 	.word	0x2631102a
 8013868:	31313128 	.word	0x31313128
 801386c:	1c313124 	.word	0x1c313124
 8013870:	3131201e 	.word	0x3131201e
 8013874:	18          	.byte	0x18
 8013875:	00          	.byte	0x00
        case EHIF_CMD_DI_GET_DEVICE_INFO: { static const int8_t pF[] = { F32(3), 0 };                         pFieldSpec = pF; } break;
        case EHIF_CMD_DI_GET_CHIP_INFO:   { static const int8_t pF[] = { F16(2), F32(4), F16(2), 0 };         pFieldSpec = pF; } break;
 8013876:	4a1f      	ldr	r2, [pc, #124]	; (80138f4 <ehifCmdExecWithRead+0x128>)
 8013878:	e018      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_VC_GET_VOLUME:      { static const int8_t pF[] = { F16(1), 0 };                         pFieldSpec = pF; } break;
 801387a:	4a1f      	ldr	r2, [pc, #124]	; (80138f8 <ehifCmdExecWithRead+0x12c>)
 801387c:	e016      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_PS_RF_STATS:        { static const int8_t pF[] = { F32(5), F8(2), F16(21), 0 };         pFieldSpec = pF; } break;
 801387e:	4a1f      	ldr	r2, [pc, #124]	; (80138fc <ehifCmdExecWithRead+0x130>)
 8013880:	e014      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_PS_AUDIO_STATS:     { static const int8_t pF[] = { F32(3), F16(1), F8(2), F16(2), -1 }; pFieldSpec = pF; } break;
 8013882:	4a1f      	ldr	r2, [pc, #124]	; (8013900 <ehifCmdExecWithRead+0x134>)
 8013884:	e012      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_RC_GET_DATA:        { static const int8_t pF[] = { F8(9), F16(2), 0 };                  pFieldSpec = pF; } break;
 8013886:	4a1f      	ldr	r2, [pc, #124]	; (8013904 <ehifCmdExecWithRead+0x138>)
 8013888:	e010      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_PM_GET_DATA:        { static const int8_t pF[] = { F32(3), F16(1), 0 };                 pFieldSpec = pF; } break;
 801388a:	4a1f      	ldr	r2, [pc, #124]	; (8013908 <ehifCmdExecWithRead+0x13c>)
 801388c:	e00e      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_CAL_GET_DATA:       { static const int8_t pF[] = { F32(1), 0 };                         pFieldSpec = pF; } break;
 801388e:	4a1f      	ldr	r2, [pc, #124]	; (801390c <ehifCmdExecWithRead+0x140>)
 8013890:	e00c      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_IO_GET_PIN_VAL:     { static const int8_t pF[] = { F32(1), 0 };                         pFieldSpec = pF; } break;
 8013892:	4a1f      	ldr	r2, [pc, #124]	; (8013910 <ehifCmdExecWithRead+0x144>)
 8013894:	e00a      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_NVS_GET_DATA:       { static const int8_t pF[] = { F32(1), 0 };                         pFieldSpec = pF; } break;
 8013896:	4a1f      	ldr	r2, [pc, #124]	; (8013914 <ehifCmdExecWithRead+0x148>)
 8013898:	e008      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_RFT_RXPER:          { static const int8_t pF[] = { F32(6), F16(3), F32(1), F8(1), -3 }; pFieldSpec = pF; } break;
 801389a:	4a1f      	ldr	r2, [pc, #124]	; (8013918 <ehifCmdExecWithRead+0x14c>)
 801389c:	e006      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_RFT_RXTST_RSSI:     { static const int8_t pF[] = { F8(1), 0 };                          pFieldSpec = pF; } break;
 801389e:	4a1f      	ldr	r2, [pc, #124]	; (801391c <ehifCmdExecWithRead+0x150>)
 80138a0:	e004      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_AT_DET_TONE:        { static const int8_t pF[] = { F16(2), 0 };                         pFieldSpec = pF; } break;
 80138a2:	4a1f      	ldr	r2, [pc, #124]	; (8013920 <ehifCmdExecWithRead+0x154>)
 80138a4:	e002      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
        case EHIF_CMD_IOTST_INPUT:        { static const int8_t pF[] = { F32(1), 0 };                         pFieldSpec = pF; } break;
 80138a6:	4a1f      	ldr	r2, [pc, #124]	; (8013924 <ehifCmdExecWithRead+0x158>)
 80138a8:	e000      	b.n	80138ac <ehifCmdExecWithRead+0xe0>
    if (execSel & EHIF_EXEC_DATA) {
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for READ
        switch (cmd) {
        case EHIF_CMD_DI_GET_DEVICE_INFO: { static const int8_t pF[] = { F32(3), 0 };                         pFieldSpec = pF; } break;
 80138aa:	4a1f      	ldr	r2, [pc, #124]	; (8013928 <ehifCmdExecWithRead+0x15c>)
        case EHIF_CMD_IOTST_INPUT:        { static const int8_t pF[] = { F32(1), 0 };                         pFieldSpec = pF; } break;
        default: return;
        }

        // Send READ
        ehifFieldRead(dataLength, (uint8_t*) pReadData, pFieldSpec);
 80138ac:	4639      	mov	r1, r7
 80138ae:	4630      	mov	r0, r6
    }

} // ehifCmdExecWithRead
 80138b0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        case EHIF_CMD_IOTST_INPUT:        { static const int8_t pF[] = { F32(1), 0 };                         pFieldSpec = pF; } break;
        default: return;
        }

        // Send READ
        ehifFieldRead(dataLength, (uint8_t*) pReadData, pFieldSpec);
 80138b4:	f000 bb36 	b.w	8013f24 <ehifFieldRead>
 80138b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80138ba:	bf00      	nop
 80138bc:	0801e51f 	.word	0x0801e51f
 80138c0:	0801e521 	.word	0x0801e521
 80138c4:	0801e523 	.word	0x0801e523
 80138c8:	0801e524 	.word	0x0801e524
 80138cc:	0801e525 	.word	0x0801e525
 80138d0:	0801e527 	.word	0x0801e527
 80138d4:	0801e528 	.word	0x0801e528
 80138d8:	0801e529 	.word	0x0801e529
 80138dc:	0801e52a 	.word	0x0801e52a
 80138e0:	0801e52c 	.word	0x0801e52c
 80138e4:	0801e530 	.word	0x0801e530
 80138e8:	0801e532 	.word	0x0801e532
 80138ec:	0801e534 	.word	0x0801e534
 80138f0:	0801e51e 	.word	0x0801e51e
 80138f4:	0801e538 	.word	0x0801e538
 80138f8:	0801e53c 	.word	0x0801e53c
 80138fc:	0801e53e 	.word	0x0801e53e
 8013900:	0801e542 	.word	0x0801e542
 8013904:	0801e547 	.word	0x0801e547
 8013908:	0801e54a 	.word	0x0801e54a
 801390c:	0801e54d 	.word	0x0801e54d
 8013910:	0801e54f 	.word	0x0801e54f
 8013914:	0801e551 	.word	0x0801e551
 8013918:	0801e553 	.word	0x0801e553
 801391c:	0801e558 	.word	0x0801e558
 8013920:	0801e55a 	.word	0x0801e55a
 8013924:	0801e55c 	.word	0x0801e55c
 8013928:	0801e536 	.word	0x0801e536

0801392c <ehifCmdExecWithReadbc>:
 *     Upon function entry \a *pDataVarLength should indicate the size of \a pReadData[]. Upon function
 *     exit the value is changed to indicate the actual number of bytes read (0 to 4095)
 * \param[out]      *pReadbcData
 *     Pointer to the read data structure, EHIF_CMD_XXXXX_DATA_T
 */
void ehifCmdExecWithReadbc(uint8_t execSel, uint8_t cmd, uint8_t cmdLength, const void* pCmdParam, uint16_t* pDataVarLength, void* pReadbcData) {
 801392c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801392e:	4605      	mov	r5, r0

    // Execute command phase?
    if (execSel & EHIF_EXEC_CMD) {
 8013930:	07a8      	lsls	r0, r5, #30
 *     Upon function entry \a *pDataVarLength should indicate the size of \a pReadData[]. Upon function
 *     exit the value is changed to indicate the actual number of bytes read (0 to 4095)
 * \param[out]      *pReadbcData
 *     Pointer to the read data structure, EHIF_CMD_XXXXX_DATA_T
 */
void ehifCmdExecWithReadbc(uint8_t execSel, uint8_t cmd, uint8_t cmdLength, const void* pCmdParam, uint16_t* pDataVarLength, void* pReadbcData) {
 8013932:	460c      	mov	r4, r1
 8013934:	9e06      	ldr	r6, [sp, #24]
 8013936:	9f07      	ldr	r7, [sp, #28]
 8013938:	4611      	mov	r1, r2
 801393a:	461a      	mov	r2, r3

    // Execute command phase?
    if (execSel & EHIF_EXEC_CMD) {
 801393c:	d515      	bpl.n	801396a <ehifCmdExecWithReadbc+0x3e>
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for CMD_REQ
        switch (cmd) {
 801393e:	2c08      	cmp	r4, #8
 8013940:	d00e      	beq.n	8013960 <ehifCmdExecWithReadbc+0x34>
 8013942:	d802      	bhi.n	801394a <ehifCmdExecWithReadbc+0x1e>
 8013944:	2c05      	cmp	r4, #5
 8013946:	d009      	beq.n	801395c <ehifCmdExecWithReadbc+0x30>
 8013948:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801394a:	2c0a      	cmp	r4, #10
 801394c:	d002      	beq.n	8013954 <ehifCmdExecWithReadbc+0x28>
 801394e:	2c8a      	cmp	r4, #138	; 0x8a
 8013950:	d002      	beq.n	8013958 <ehifCmdExecWithReadbc+0x2c>
 8013952:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case EHIF_CMD_NWM_DO_SCAN:        { static const int8_t pF[] = { F16(1), F32(3), F8(2), 0 }; pFieldSpec = pF; } break;
        case EHIF_CMD_NWM_GET_STATUS_M:   { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013954:	4b12      	ldr	r3, [pc, #72]	; (80139a0 <ehifCmdExecWithReadbc+0x74>)
 8013956:	e004      	b.n	8013962 <ehifCmdExecWithReadbc+0x36>
        case EHIF_CMD_NWM_GET_STATUS_S:   { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 8013958:	4b12      	ldr	r3, [pc, #72]	; (80139a4 <ehifCmdExecWithReadbc+0x78>)
 801395a:	e002      	b.n	8013962 <ehifCmdExecWithReadbc+0x36>
        case EHIF_CMD_DSC_RX_DATAGRAM:    { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
 801395c:	4b12      	ldr	r3, [pc, #72]	; (80139a8 <ehifCmdExecWithReadbc+0x7c>)
 801395e:	e000      	b.n	8013962 <ehifCmdExecWithReadbc+0x36>
    if (execSel & EHIF_EXEC_CMD) {
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for CMD_REQ
        switch (cmd) {
        case EHIF_CMD_NWM_DO_SCAN:        { static const int8_t pF[] = { F16(1), F32(3), F8(2), 0 }; pFieldSpec = pF; } break;
 8013960:	4b12      	ldr	r3, [pc, #72]	; (80139ac <ehifCmdExecWithReadbc+0x80>)
        case EHIF_CMD_DSC_RX_DATAGRAM:    { static const int8_t pF[] = { 0 };                        pFieldSpec = pF; } break;
        default: return;
        }

        // Send CMD_REQ
        ehifFieldCmdReq(cmd & 0x3F, cmdLength, (const uint8_t*) pCmdParam, pFieldSpec);
 8013962:	f004 003f 	and.w	r0, r4, #63	; 0x3f
 8013966:	f000 fb3e 	bl	8013fe6 <ehifFieldCmdReq>
    }

    // Execute data phase?
    if (execSel & EHIF_EXEC_DATA) {
 801396a:	076b      	lsls	r3, r5, #29
 801396c:	d517      	bpl.n	801399e <ehifCmdExecWithReadbc+0x72>
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for READBC
        switch (cmd) {
 801396e:	2c08      	cmp	r4, #8
 8013970:	d00e      	beq.n	8013990 <ehifCmdExecWithReadbc+0x64>
 8013972:	d802      	bhi.n	801397a <ehifCmdExecWithReadbc+0x4e>
 8013974:	2c05      	cmp	r4, #5
 8013976:	d009      	beq.n	801398c <ehifCmdExecWithReadbc+0x60>
 8013978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801397a:	2c0a      	cmp	r4, #10
 801397c:	d002      	beq.n	8013984 <ehifCmdExecWithReadbc+0x58>
 801397e:	2c8a      	cmp	r4, #138	; 0x8a
 8013980:	d002      	beq.n	8013988 <ehifCmdExecWithReadbc+0x5c>
 8013982:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case EHIF_CMD_NWM_DO_SCAN:        { static const int8_t pF[] = { F32(3), F8(1), F16(1), F8(9), F16(2), -5 }; pFieldSpec = pF; } break;
        case EHIF_CMD_NWM_GET_STATUS_M:   { static const int8_t pF[] = { F8(1), F16(2), F32(3), F16(1), F8(2), -3 }; pFieldSpec = pF; } break;
 8013984:	4a0a      	ldr	r2, [pc, #40]	; (80139b0 <ehifCmdExecWithReadbc+0x84>)
 8013986:	e004      	b.n	8013992 <ehifCmdExecWithReadbc+0x66>
        case EHIF_CMD_NWM_GET_STATUS_S:   { static const int8_t pF[] = { F32(3), F8(1), F16(1), F8(9), F16(3), -5 }; pFieldSpec = pF; } break;
 8013988:	4a0a      	ldr	r2, [pc, #40]	; (80139b4 <ehifCmdExecWithReadbc+0x88>)
 801398a:	e002      	b.n	8013992 <ehifCmdExecWithReadbc+0x66>
        case EHIF_CMD_DSC_RX_DATAGRAM:    { static const int8_t pF[] = { F8(1), F32(1), F8(1), -1 };                 pFieldSpec = pF; } break;
 801398c:	4a0a      	ldr	r2, [pc, #40]	; (80139b8 <ehifCmdExecWithReadbc+0x8c>)
 801398e:	e000      	b.n	8013992 <ehifCmdExecWithReadbc+0x66>
    if (execSel & EHIF_EXEC_DATA) {
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for READBC
        switch (cmd) {
        case EHIF_CMD_NWM_DO_SCAN:        { static const int8_t pF[] = { F32(3), F8(1), F16(1), F8(9), F16(2), -5 }; pFieldSpec = pF; } break;
 8013990:	4a0a      	ldr	r2, [pc, #40]	; (80139bc <ehifCmdExecWithReadbc+0x90>)
        case EHIF_CMD_DSC_RX_DATAGRAM:    { static const int8_t pF[] = { F8(1), F32(1), F8(1), -1 };                 pFieldSpec = pF; } break;
        default: return;
        }

        // Send READBC
        ehifFieldReadbc(pDataVarLength, (uint8_t*) pReadbcData, pFieldSpec);
 8013992:	4639      	mov	r1, r7
 8013994:	4630      	mov	r0, r6
    }

} // ehifCmdExecWithReadbc
 8013996:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        case EHIF_CMD_DSC_RX_DATAGRAM:    { static const int8_t pF[] = { F8(1), F32(1), F8(1), -1 };                 pFieldSpec = pF; } break;
        default: return;
        }

        // Send READBC
        ehifFieldReadbc(pDataVarLength, (uint8_t*) pReadbcData, pFieldSpec);
 801399a:	f000 bae9 	b.w	8013f70 <ehifFieldReadbc>
 801399e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80139a0:	0801e562 	.word	0x0801e562
 80139a4:	0801e563 	.word	0x0801e563
 80139a8:	0801e564 	.word	0x0801e564
 80139ac:	0801e55e 	.word	0x0801e55e
 80139b0:	0801e56b 	.word	0x0801e56b
 80139b4:	0801e571 	.word	0x0801e571
 80139b8:	0801e577 	.word	0x0801e577
 80139bc:	0801e565 	.word	0x0801e565

080139c0 <ehifCmdExecWithWrite>:
 * \param[in]       dataLength
 *     Write data length, in most cases sizeof(EHIF_CMD_XXXXX_DATA_T)
 * \param[in]       *pWriteData
 *     Pointer to the write data structure, EHIF_CMD_XXXXX_DATA_T
 */
void ehifCmdExecWithWrite(uint8_t execSel, uint8_t cmd, uint8_t cmdLength, const void* pCmdParam, uint16_t dataLength, const void* pWriteData) {
 80139c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80139c2:	4605      	mov	r5, r0

    // Execute command phase?
    if (execSel & EHIF_EXEC_CMD) {
 80139c4:	07a8      	lsls	r0, r5, #30
 * \param[in]       dataLength
 *     Write data length, in most cases sizeof(EHIF_CMD_XXXXX_DATA_T)
 * \param[in]       *pWriteData
 *     Pointer to the write data structure, EHIF_CMD_XXXXX_DATA_T
 */
void ehifCmdExecWithWrite(uint8_t execSel, uint8_t cmd, uint8_t cmdLength, const void* pCmdParam, uint16_t dataLength, const void* pWriteData) {
 80139c6:	460c      	mov	r4, r1
 80139c8:	f8bd 6018 	ldrh.w	r6, [sp, #24]
 80139cc:	9f07      	ldr	r7, [sp, #28]
 80139ce:	4611      	mov	r1, r2
 80139d0:	461a      	mov	r2, r3

    // Execute command phase?
    if (execSel & EHIF_EXEC_CMD) {
 80139d2:	d505      	bpl.n	80139e0 <ehifCmdExecWithWrite+0x20>
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for CMD_REQ
        switch (cmd) {
 80139d4:	2c04      	cmp	r4, #4
 80139d6:	d10e      	bne.n	80139f6 <ehifCmdExecWithWrite+0x36>
        case EHIF_CMD_DSC_TX_DATAGRAM:    { static const int8_t pF[] = { F8(1), F32(1), 0 }; pFieldSpec = pF; } break;
        default: return;
        }

        // Send CMD_REQ
        ehifFieldCmdReq(cmd, cmdLength, (const uint8_t*) pCmdParam, pFieldSpec);
 80139d8:	4b07      	ldr	r3, [pc, #28]	; (80139f8 <ehifCmdExecWithWrite+0x38>)
 80139da:	4620      	mov	r0, r4
 80139dc:	f000 fb03 	bl	8013fe6 <ehifFieldCmdReq>
    }

    // Execute data phase?
    if (execSel & EHIF_EXEC_DATA) {
 80139e0:	076b      	lsls	r3, r5, #29
 80139e2:	d508      	bpl.n	80139f6 <ehifCmdExecWithWrite+0x36>
        const int8_t* pFieldSpec;

        // Locate endianess conversion specification for WRITE
        switch (cmd) {
 80139e4:	2c04      	cmp	r4, #4
 80139e6:	d106      	bne.n	80139f6 <ehifCmdExecWithWrite+0x36>
        case EHIF_CMD_DSC_TX_DATAGRAM:    { static const int8_t pF[] = { F8(1), -1 }; pFieldSpec = pF; } break;
        default: return;
        }

        // Send WRITE
        ehifFieldWrite(dataLength, (const uint8_t*) pWriteData, pFieldSpec);
 80139e8:	4639      	mov	r1, r7
 80139ea:	4630      	mov	r0, r6
 80139ec:	4a03      	ldr	r2, [pc, #12]	; (80139fc <ehifCmdExecWithWrite+0x3c>)
    }

} // ehifCmdExecWithWrite
 80139ee:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        case EHIF_CMD_DSC_TX_DATAGRAM:    { static const int8_t pF[] = { F8(1), -1 }; pFieldSpec = pF; } break;
        default: return;
        }

        // Send WRITE
        ehifFieldWrite(dataLength, (const uint8_t*) pWriteData, pFieldSpec);
 80139f2:	f000 ba6f 	b.w	8013ed4 <ehifFieldWrite>
 80139f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80139f8:	0801e57b 	.word	0x0801e57b
 80139fc:	0801e57e 	.word	0x0801e57e

08013a00 <ehifBlUnlockSpi>:
 *     - \ref EHIF_BL_SPI_LOADER_READY - Bootloader unlocking succeeded
 *     - \ref EHIF_BL_SPI_LOADER_LOCKED - Bootloader unlocking failed. Make sure that
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode, incorrect MCU clock speed,
 *       CC85XX crystal problems etc.)
 */
uint16_t ehifBlUnlockSpi(void) {
 8013a00:	b508      	push	{r3, lr}
    static const uint8_t pParams[4] = {
        0x25, 0x05, 0xB0, 0x07 // KEY
    };

    // Send BL_UNLOCK_SPI
    ehifCmdReq(0x00, sizeof(pParams), pParams);
 8013a02:	4a06      	ldr	r2, [pc, #24]	; (8013a1c <ehifBlUnlockSpi+0x1c>)
 8013a04:	2104      	movs	r1, #4
 8013a06:	2000      	movs	r0, #0
 8013a08:	f000 f8f8 	bl	8013bfc <ehifCmdReq>

    // Wait for completion and return status
    ehifWaitReadyMs(1);
 8013a0c:	2001      	movs	r0, #1
 8013a0e:	f000 f93d 	bl	8013c8c <ehifWaitReadyMs>
    return ehifGetStatus();

} // ehifBlUnlockSpi
 8013a12:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // Send BL_UNLOCK_SPI
    ehifCmdReq(0x00, sizeof(pParams), pParams);

    // Wait for completion and return status
    ehifWaitReadyMs(1);
    return ehifGetStatus();
 8013a16:	f000 b860 	b.w	8013ada <ehifGetStatus>
 8013a1a:	bf00      	nop
 8013a1c:	0801e580 	.word	0x0801e580

08013a20 <ehifBlFlashMassErase>:
 *     - \ref EHIF_BL_ERASE_DONE - Flash mass erase succeeded
 *     - \ref EHIF_BL_ERASE_FAILED - Flash mass erase failed (electrical error)
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode, incorrect MCU clock speed,
 *       CC85XX crystal problems etc.)
 */
uint16_t ehifBlFlashMassErase(void) {
 8013a20:	b508      	push	{r3, lr}
    static const uint8_t pParams[4] = {
        0x25, 0x05, 0x13, 0x37 // KEY
    };

    // Send BL_FLASH_MASS_ERASE
    ehifCmdReq(0x03, sizeof(pParams), pParams);
 8013a22:	4a06      	ldr	r2, [pc, #24]	; (8013a3c <ehifBlFlashMassErase+0x1c>)
 8013a24:	2104      	movs	r1, #4
 8013a26:	2003      	movs	r0, #3
 8013a28:	f000 f8e8 	bl	8013bfc <ehifCmdReq>

    // Wait for completion and return status
    ehifWaitReadyMs(25);
 8013a2c:	2019      	movs	r0, #25
 8013a2e:	f000 f92d 	bl	8013c8c <ehifWaitReadyMs>
    return ehifGetStatus();

} // ehifBlFlashMassErase
 8013a32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // Send BL_FLASH_MASS_ERASE
    ehifCmdReq(0x03, sizeof(pParams), pParams);

    // Wait for completion and return status
    ehifWaitReadyMs(25);
    return ehifGetStatus();
 8013a36:	f000 b850 	b.w	8013ada <ehifGetStatus>
 8013a3a:	bf00      	nop
 8013a3c:	0801e584 	.word	0x0801e584

08013a40 <ehifBlFlashPageProg>:
 *     - \ref EHIF_BL_PROG_DONE - Flash page programming succeeded
 *     - \ref EHIF_BL_PROG_FAILED - Flash page programming failed (electrical error)
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode, incorrect MCU clock speed,
 *       CC85XX crystal problems etc.)
 */
uint16_t ehifBlFlashPageProg(uint16_t ramAddr, uint16_t flashAddr) {
 8013a40:	b51f      	push	{r0, r1, r2, r3, r4, lr}

    // Prepare CMD_REQ parameters
    uint8_t pParams[10] = {
 8013a42:	0a03      	lsrs	r3, r0, #8
 8013a44:	f88d 3004 	strb.w	r3, [sp, #4]
 8013a48:	0a0b      	lsrs	r3, r1, #8
 8013a4a:	f88d 3006 	strb.w	r3, [sp, #6]
 8013a4e:	2301      	movs	r3, #1
 8013a50:	f88d 3008 	strb.w	r3, [sp, #8]
 8013a54:	2300      	movs	r3, #0
 8013a56:	f88d 3009 	strb.w	r3, [sp, #9]
 8013a5a:	2325      	movs	r3, #37	; 0x25
 8013a5c:	f88d 300a 	strb.w	r3, [sp, #10]
 8013a60:	2305      	movs	r3, #5
 8013a62:	f88d 300b 	strb.w	r3, [sp, #11]
 8013a66:	2313      	movs	r3, #19
        0x01, 0x00,                     // DWORD_COUNT
        0x25, 0x05, 0x13, 0x37          // KEY
    };

    // Send BL_FLASH_PAGE_PROG
    ehifCmdReq(0x07, sizeof(pParams), pParams);
 8013a68:	aa01      	add	r2, sp, #4
 *       CC85XX crystal problems etc.)
 */
uint16_t ehifBlFlashPageProg(uint16_t ramAddr, uint16_t flashAddr) {

    // Prepare CMD_REQ parameters
    uint8_t pParams[10] = {
 8013a6a:	f88d 0005 	strb.w	r0, [sp, #5]
 8013a6e:	f88d 1007 	strb.w	r1, [sp, #7]
 8013a72:	f88d 300c 	strb.w	r3, [sp, #12]
        0x01, 0x00,                     // DWORD_COUNT
        0x25, 0x05, 0x13, 0x37          // KEY
    };

    // Send BL_FLASH_PAGE_PROG
    ehifCmdReq(0x07, sizeof(pParams), pParams);
 8013a76:	210a      	movs	r1, #10
 *       CC85XX crystal problems etc.)
 */
uint16_t ehifBlFlashPageProg(uint16_t ramAddr, uint16_t flashAddr) {

    // Prepare CMD_REQ parameters
    uint8_t pParams[10] = {
 8013a78:	2337      	movs	r3, #55	; 0x37
        0x01, 0x00,                     // DWORD_COUNT
        0x25, 0x05, 0x13, 0x37          // KEY
    };

    // Send BL_FLASH_PAGE_PROG
    ehifCmdReq(0x07, sizeof(pParams), pParams);
 8013a7a:	2007      	movs	r0, #7
 *       CC85XX crystal problems etc.)
 */
uint16_t ehifBlFlashPageProg(uint16_t ramAddr, uint16_t flashAddr) {

    // Prepare CMD_REQ parameters
    uint8_t pParams[10] = {
 8013a7c:	f88d 300d 	strb.w	r3, [sp, #13]
        0x01, 0x00,                     // DWORD_COUNT
        0x25, 0x05, 0x13, 0x37          // KEY
    };

    // Send BL_FLASH_PAGE_PROG
    ehifCmdReq(0x07, sizeof(pParams), pParams);
 8013a80:	f000 f8bc 	bl	8013bfc <ehifCmdReq>

    // Wait for completion and return status
    ehifWaitReadyMs(10);
 8013a84:	200a      	movs	r0, #10
 8013a86:	f000 f901 	bl	8013c8c <ehifWaitReadyMs>
    return ehifGetStatus();
 8013a8a:	f000 f826 	bl	8013ada <ehifGetStatus>

} // ehifBlFlashPageProg
 8013a8e:	b005      	add	sp, #20
 8013a90:	f85d fb04 	ldr.w	pc, [sp], #4

08013a94 <ehifBlFlashVerify>:
 *     One of the following:
 *     - \ref EHIF_BL_VERIFY_OK - Flash verification succeeded (CC85XX contains image with valid CRC)
 *     - \ref EHIF_BL_VERIFY_FAILED - Flash verification failed (CC85XX contains image with invalid CRC)
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode etc.)
 */
uint16_t ehifBlFlashVerify(uint16_t byteCount, uint8_t* pCrcVal) {
 8013a94:	b513      	push	{r0, r1, r4, lr}

    // Prepare CMD_REQ parameters
    uint8_t pParams[8] = {
 8013a96:	2300      	movs	r3, #0
 8013a98:	2280      	movs	r2, #128	; 0x80
 *     One of the following:
 *     - \ref EHIF_BL_VERIFY_OK - Flash verification succeeded (CC85XX contains image with valid CRC)
 *     - \ref EHIF_BL_VERIFY_FAILED - Flash verification failed (CC85XX contains image with invalid CRC)
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode etc.)
 */
uint16_t ehifBlFlashVerify(uint16_t byteCount, uint8_t* pCrcVal) {
 8013a9a:	460c      	mov	r4, r1

    // Prepare CMD_REQ parameters
    uint8_t pParams[8] = {
 8013a9c:	f88d 3000 	strb.w	r3, [sp]
 8013aa0:	f88d 3001 	strb.w	r3, [sp, #1]
 8013aa4:	f88d 2002 	strb.w	r2, [sp, #2]
 8013aa8:	f88d 3003 	strb.w	r3, [sp, #3]
        0x00, 0x00, 0x80, 0x00,                    // DATA_ADDR
        0x00, 0x00, HI8(byteCount), LO8(byteCount) // BYTE_COUNT
    };

    // Send BL_FLASH_VERIFY
    ehifCmdReq(0x0F, sizeof(pParams), pParams);
 8013aac:	466a      	mov	r2, sp
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode etc.)
 */
uint16_t ehifBlFlashVerify(uint16_t byteCount, uint8_t* pCrcVal) {

    // Prepare CMD_REQ parameters
    uint8_t pParams[8] = {
 8013aae:	f88d 3004 	strb.w	r3, [sp, #4]
 8013ab2:	f88d 3005 	strb.w	r3, [sp, #5]
 8013ab6:	f88d 0007 	strb.w	r0, [sp, #7]
 8013aba:	0a03      	lsrs	r3, r0, #8
        0x00, 0x00, 0x80, 0x00,                    // DATA_ADDR
        0x00, 0x00, HI8(byteCount), LO8(byteCount) // BYTE_COUNT
    };

    // Send BL_FLASH_VERIFY
    ehifCmdReq(0x0F, sizeof(pParams), pParams);
 8013abc:	2108      	movs	r1, #8
 8013abe:	200f      	movs	r0, #15
 *     - Other: EHIF operation failed (CC85XX is not in bootloader mode etc.)
 */
uint16_t ehifBlFlashVerify(uint16_t byteCount, uint8_t* pCrcVal) {

    // Prepare CMD_REQ parameters
    uint8_t pParams[8] = {
 8013ac0:	f88d 3006 	strb.w	r3, [sp, #6]
        0x00, 0x00, 0x80, 0x00,                    // DATA_ADDR
        0x00, 0x00, HI8(byteCount), LO8(byteCount) // BYTE_COUNT
    };

    // Send BL_FLASH_VERIFY
    ehifCmdReq(0x0F, sizeof(pParams), pParams);
 8013ac4:	f000 f89a 	bl	8013bfc <ehifCmdReq>

    // Get CRC and return status
    ehifWaitReadyMs(15);
 8013ac8:	200f      	movs	r0, #15
 8013aca:	f000 f8df 	bl	8013c8c <ehifWaitReadyMs>
    return ehifRead(4, pCrcVal);
 8013ace:	4621      	mov	r1, r4
 8013ad0:	2004      	movs	r0, #4
 8013ad2:	f000 f85b 	bl	8013b8c <ehifRead>

} // ehifBlFlashVerify
 8013ad6:	b002      	add	sp, #8
 8013ad8:	bd10      	pop	{r4, pc}

08013ada <ehifGetStatus>:
 *
 * \return
 *     EHIF status word (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifGetStatus(void)
{
 8013ada:	b510      	push	{r4, lr}

  // Begin operation
  EHIF_SPI_BEGIN();
 8013adc:	f7f8 ff78 	bl	800c9d0 <EHIF_SPI_BEGIN>

  // Send type/length, receive status word
  uint16_t statusWord;
  EHIF_SPI_TX(0x80);
 8013ae0:	2080      	movs	r0, #128	; 0x80
 8013ae2:	f7f8 ff8b 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013ae6:	f7f8 ff93 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord = EHIF_SPI_RX() << 8;
 8013aea:	f7f8 ff93 	bl	800ca14 <EHIF_SPI_RX>
 8013aee:	0200      	lsls	r0, r0, #8
 8013af0:	b284      	uxth	r4, r0
  EHIF_SPI_TX(0x00);
 8013af2:	2000      	movs	r0, #0
 8013af4:	f7f8 ff82 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013af8:	f7f8 ff8a 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord |= EHIF_SPI_RX();
 8013afc:	f7f8 ff8a 	bl	800ca14 <EHIF_SPI_RX>
 8013b00:	4320      	orrs	r0, r4
 8013b02:	b284      	uxth	r4, r0

  // End operation
  EHIF_SPI_END();
 8013b04:	f7f8 ff90 	bl	800ca28 <EHIF_SPI_END>
  return statusWord;

} // ehifGetStatus
 8013b08:	4620      	mov	r0, r4
 8013b0a:	bd10      	pop	{r4, pc}

08013b0c <ehifWaitReady>:
 * The timeout mechanism ensures that code execution does not hang if the CC85XX does not respond.
 *
 * The function assumes that CSn is active.
 */
void ehifWaitReady(void)
{
 8013b0c:	b510      	push	{r4, lr}
  uint16_t maxDelay = 5000;
  while (!EHIF_SPI_IS_CMDREQ_READY() && --maxDelay)
 8013b0e:	f241 3488 	movw	r4, #5000	; 0x1388
 8013b12:	f7f8 ff69 	bl	800c9e8 <EHIF_SPI_IS_CMDREQ_READY>
 8013b16:	b948      	cbnz	r0, 8013b2c <ehifWaitReady+0x20>
 8013b18:	3c01      	subs	r4, #1
 8013b1a:	b2a4      	uxth	r4, r4
 8013b1c:	b11c      	cbz	r4, 8013b26 <ehifWaitReady+0x1a>
    {
      EHIF_DELAY_US(2);
 8013b1e:	2002      	movs	r0, #2
 8013b20:	f7f9 f944 	bl	800cdac <EHIF_DELAY_US>
 8013b24:	e7f5      	b.n	8013b12 <ehifWaitReady+0x6>
    }
  if (!maxDelay) waitReadyError = 1;
 8013b26:	4b02      	ldr	r3, [pc, #8]	; (8013b30 <ehifWaitReady+0x24>)
 8013b28:	2201      	movs	r2, #1
 8013b2a:	701a      	strb	r2, [r3, #0]
 8013b2c:	bd10      	pop	{r4, pc}
 8013b2e:	bf00      	nop
 8013b30:	2001adc0 	.word	0x2001adc0

08013b34 <ehifWrite>:
 *
 * \return
 *     EHIF status word at start of WRITE operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifWrite(uint16_t length, const uint8_t* pData)
{
 8013b34:	b570      	push	{r4, r5, r6, lr}
 8013b36:	4605      	mov	r5, r0
 8013b38:	460e      	mov	r6, r1

  // Begin operation
  EHIF_SPI_BEGIN();
 8013b3a:	f7f8 ff49 	bl	800c9d0 <EHIF_SPI_BEGIN>
  ehifWaitReady();
 8013b3e:	f7ff ffe5 	bl	8013b0c <ehifWaitReady>

  // Send type/length, receive status word
  uint16_t statusWord;
  EHIF_SPI_TX(0x80 | ((length >> 8) & 0x0F));
 8013b42:	f3c5 2003 	ubfx	r0, r5, #8, #4
 8013b46:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8013b4a:	f7f8 ff57 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013b4e:	f7f8 ff5f 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord = EHIF_SPI_RX() << 8;
 8013b52:	f7f8 ff5f 	bl	800ca14 <EHIF_SPI_RX>
 8013b56:	0200      	lsls	r0, r0, #8
 8013b58:	b284      	uxth	r4, r0
  EHIF_SPI_TX(length & 0xFF);
 8013b5a:	b2e8      	uxtb	r0, r5
 8013b5c:	f7f8 ff4e 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013b60:	f7f8 ff56 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord |= EHIF_SPI_RX();
 8013b64:	f7f8 ff56 	bl	800ca14 <EHIF_SPI_RX>
 8013b68:	4320      	orrs	r0, r4
 8013b6a:	b284      	uxth	r4, r0
 8013b6c:	4435      	add	r5, r6

  // Send data
  while (length--)
 8013b6e:	42ae      	cmp	r6, r5
 8013b70:	d006      	beq.n	8013b80 <ehifWrite+0x4c>
    {
      EHIF_SPI_WAIT_TXRX();
 8013b72:	f7f8 ff4d 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
      EHIF_SPI_TX(*(pData++));
 8013b76:	f816 0b01 	ldrb.w	r0, [r6], #1
 8013b7a:	f7f8 ff3f 	bl	800c9fc <EHIF_SPI_TX>
 8013b7e:	e7f6      	b.n	8013b6e <ehifWrite+0x3a>
    }
  EHIF_SPI_WAIT_TXRX();
 8013b80:	f7f8 ff46 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>

  // End operation
  EHIF_SPI_END();
 8013b84:	f7f8 ff50 	bl	800ca28 <EHIF_SPI_END>
  return statusWord;

} // ehifWrite
 8013b88:	4620      	mov	r0, r4
 8013b8a:	bd70      	pop	{r4, r5, r6, pc}

08013b8c <ehifRead>:
 *
 * \return
 *     EHIF status word at start of READ operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifRead(uint16_t length, uint8_t* pData)
{
 8013b8c:	b570      	push	{r4, r5, r6, lr}
 8013b8e:	4604      	mov	r4, r0
 8013b90:	460e      	mov	r6, r1

  // Begin operation
  EHIF_SPI_BEGIN();
 8013b92:	f7f8 ff1d 	bl	800c9d0 <EHIF_SPI_BEGIN>
  ehifWaitReady();
 8013b96:	f7ff ffb9 	bl	8013b0c <ehifWaitReady>

  // Send type/length, receive status word
  uint16_t statusWord;
  EHIF_SPI_TX(0x90 | ((length >> 8) & 0x0F));
 8013b9a:	f3c4 2003 	ubfx	r0, r4, #8, #4
 8013b9e:	f040 0090 	orr.w	r0, r0, #144	; 0x90
 8013ba2:	f7f8 ff2b 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013ba6:	f7f8 ff33 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord = EHIF_SPI_RX() << 8;
 8013baa:	f7f8 ff33 	bl	800ca14 <EHIF_SPI_RX>
 8013bae:	0200      	lsls	r0, r0, #8
 8013bb0:	b285      	uxth	r5, r0
  EHIF_SPI_TX(length & 0xFF);
 8013bb2:	b2e0      	uxtb	r0, r4
 8013bb4:	f7f8 ff22 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013bb8:	f7f8 ff2a 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord |= EHIF_SPI_RX();
 8013bbc:	f7f8 ff2a 	bl	800ca14 <EHIF_SPI_RX>
 8013bc0:	4328      	orrs	r0, r5
 8013bc2:	b285      	uxth	r5, r0

  // Receive data
  if (length--)
 8013bc4:	b1b4      	cbz	r4, 8013bf4 <ehifRead+0x68>
    {
      EHIF_SPI_TX(0x00);
 8013bc6:	2000      	movs	r0, #0
 8013bc8:	f7f8 ff18 	bl	800c9fc <EHIF_SPI_TX>
 8013bcc:	3c01      	subs	r4, #1
 8013bce:	fa16 f484 	uxtah	r4, r6, r4
      while (length--)
 8013bd2:	42a6      	cmp	r6, r4
 8013bd4:	d009      	beq.n	8013bea <ehifRead+0x5e>
        {
          EHIF_SPI_WAIT_TXRX();
 8013bd6:	f7f8 ff1b 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
          *(pData++) = EHIF_SPI_RX();
 8013bda:	f7f8 ff1b 	bl	800ca14 <EHIF_SPI_RX>
 8013bde:	f806 0b01 	strb.w	r0, [r6], #1
          EHIF_SPI_TX(0x00);
 8013be2:	2000      	movs	r0, #0
 8013be4:	f7f8 ff0a 	bl	800c9fc <EHIF_SPI_TX>
 8013be8:	e7f3      	b.n	8013bd2 <ehifRead+0x46>
        }
      EHIF_SPI_WAIT_TXRX();
 8013bea:	f7f8 ff11 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
      *(pData++) = EHIF_SPI_RX();
 8013bee:	f7f8 ff11 	bl	800ca14 <EHIF_SPI_RX>
 8013bf2:	7030      	strb	r0, [r6, #0]
    }

  // End operation
  EHIF_SPI_END();
 8013bf4:	f7f8 ff18 	bl	800ca28 <EHIF_SPI_END>
  return statusWord;

} // ehifRead
 8013bf8:	4628      	mov	r0, r5
 8013bfa:	bd70      	pop	{r4, r5, r6, pc}

08013bfc <ehifCmdReq>:
 *
 * \return
 *     EHIF status word at start of CMD_REQ operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifCmdReq(uint8_t cmd, uint8_t length, const uint8_t* pParam)
{
 8013bfc:	b570      	push	{r4, r5, r6, lr}
 8013bfe:	4604      	mov	r4, r0
 8013c00:	460d      	mov	r5, r1
 8013c02:	4616      	mov	r6, r2

  // Begin operation
  EHIF_SPI_BEGIN();
 8013c04:	f7f8 fee4 	bl	800c9d0 <EHIF_SPI_BEGIN>
  ehifWaitReady();
 8013c08:	f7ff ff80 	bl	8013b0c <ehifWaitReady>

  // Send type/command code/parameter length, receive status word
  uint16_t statusWord;
  EHIF_SPI_TX(0xC0 | cmd);
 8013c0c:	f044 00c0 	orr.w	r0, r4, #192	; 0xc0
 8013c10:	f7f8 fef4 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013c14:	f7f8 fefc 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord = EHIF_SPI_RX() << 8;
 8013c18:	f7f8 fefc 	bl	800ca14 <EHIF_SPI_RX>
 8013c1c:	0200      	lsls	r0, r0, #8
 8013c1e:	b284      	uxth	r4, r0
  EHIF_SPI_TX(length & 0xFF);
 8013c20:	4628      	mov	r0, r5
 8013c22:	f7f8 feeb 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013c26:	f7f8 fef3 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord |= EHIF_SPI_RX();
 8013c2a:	f7f8 fef3 	bl	800ca14 <EHIF_SPI_RX>
 8013c2e:	4320      	orrs	r0, r4
 8013c30:	b284      	uxth	r4, r0
 8013c32:	4435      	add	r5, r6

  // Send parameters
  while(length--)
 8013c34:	42ae      	cmp	r6, r5
 8013c36:	d006      	beq.n	8013c46 <ehifCmdReq+0x4a>
    {
      EHIF_SPI_WAIT_TXRX();
 8013c38:	f7f8 feea 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
      EHIF_SPI_TX(*(pParam++));
 8013c3c:	f816 0b01 	ldrb.w	r0, [r6], #1
 8013c40:	f7f8 fedc 	bl	800c9fc <EHIF_SPI_TX>
 8013c44:	e7f6      	b.n	8013c34 <ehifCmdReq+0x38>
    }
  EHIF_SPI_WAIT_TXRX();
 8013c46:	f7f8 fee3 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>

  // End operation
  EHIF_SPI_END();
 8013c4a:	f7f8 feed 	bl	800ca28 <EHIF_SPI_END>
  return statusWord;

} // ehifCmdReq
 8013c4e:	4620      	mov	r0, r4
 8013c50:	bd70      	pop	{r4, r5, r6, pc}

08013c52 <ehifSetAddr>:
 *
 * \return
 *     EHIF status word at start of SET_ADDR operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifSetAddr(uint16_t addr)
{
 8013c52:	b538      	push	{r3, r4, r5, lr}
 8013c54:	4605      	mov	r5, r0

  // Begin operation
  EHIF_SPI_BEGIN();
 8013c56:	f7f8 febb 	bl	800c9d0 <EHIF_SPI_BEGIN>
  ehifWaitReady();
 8013c5a:	f7ff ff57 	bl	8013b0c <ehifWaitReady>

  // Send type/address
  uint16_t statusWord;
  EHIF_SPI_TX(0x00 | (HI8(addr) & 0x7F));
 8013c5e:	f3c5 2006 	ubfx	r0, r5, #8, #7
 8013c62:	f7f8 fecb 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013c66:	f7f8 fed3 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord = EHIF_SPI_RX() << 8;
 8013c6a:	f7f8 fed3 	bl	800ca14 <EHIF_SPI_RX>
 8013c6e:	0200      	lsls	r0, r0, #8
 8013c70:	b284      	uxth	r4, r0
  EHIF_SPI_TX(LO8(addr) & 0xFF);
 8013c72:	b2e8      	uxtb	r0, r5
 8013c74:	f7f8 fec2 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013c78:	f7f8 feca 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  statusWord |= EHIF_SPI_RX();
 8013c7c:	f7f8 feca 	bl	800ca14 <EHIF_SPI_RX>
 8013c80:	4320      	orrs	r0, r4
 8013c82:	b284      	uxth	r4, r0

  // End operation
  EHIF_SPI_END();
 8013c84:	f7f8 fed0 	bl	800ca28 <EHIF_SPI_END>
  return statusWord;

} // ehifSetAddr
 8013c88:	4620      	mov	r0, r4
 8013c8a:	bd38      	pop	{r3, r4, r5, pc}

08013c8c <ehifWaitReadyMs>:
 *
 * \param[in]       timeout
 *     Timeout in milliseconds
 */
void ehifWaitReadyMs(uint16_t timeout)
{
 8013c8c:	b510      	push	{r4, lr}
 8013c8e:	4604      	mov	r4, r0
  EHIF_SPI_BEGIN();
 8013c90:	f7f8 fe9e 	bl	800c9d0 <EHIF_SPI_BEGIN>
  uint32_t maxDelay = ((uint32_t) timeout) * 1/* 00 */;
  while (!EHIF_SPI_IS_CMDREQ_READY() && --maxDelay)
 8013c94:	f7f8 fea8 	bl	800c9e8 <EHIF_SPI_IS_CMDREQ_READY>
 8013c98:	b928      	cbnz	r0, 8013ca6 <ehifWaitReadyMs+0x1a>
 8013c9a:	3c01      	subs	r4, #1
 8013c9c:	d004      	beq.n	8013ca8 <ehifWaitReadyMs+0x1c>
    {
      EHIF_DELAY_MS(1);
 8013c9e:	2001      	movs	r0, #1
 8013ca0:	f7f6 fdf6 	bl	800a890 <vTaskDelay>
 8013ca4:	e7f6      	b.n	8013c94 <ehifWaitReadyMs+0x8>
    }
  if (!maxDelay) waitReadyError = 1;
 8013ca6:	b914      	cbnz	r4, 8013cae <ehifWaitReadyMs+0x22>
 8013ca8:	4b03      	ldr	r3, [pc, #12]	; (8013cb8 <ehifWaitReadyMs+0x2c>)
 8013caa:	2201      	movs	r2, #1
 8013cac:	701a      	strb	r2, [r3, #0]
  EHIF_SPI_END();
} // ehifWaitReadyMs
 8013cae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  while (!EHIF_SPI_IS_CMDREQ_READY() && --maxDelay)
    {
      EHIF_DELAY_MS(1);
    }
  if (!maxDelay) waitReadyError = 1;
  EHIF_SPI_END();
 8013cb2:	f7f8 beb9 	b.w	800ca28 <EHIF_SPI_END>
 8013cb6:	bf00      	nop
 8013cb8:	2001adc0 	.word	0x2001adc0

08013cbc <ehifSysResetSpi>:
 *
 * Timing must be verified, using oscilloscope or logic analyzer, when porting to new microcontrollers
 * and/or compiler tools.
 */
void ehifSysResetSpi(uint8_t waitReady)
{
 8013cbc:	b510      	push	{r4, lr}
 8013cbe:	4604      	mov	r4, r0

  // Perform SYS_RESET sequence
  EHIF_SPI_BEGIN();
 8013cc0:	f7f8 fe86 	bl	800c9d0 <EHIF_SPI_BEGIN>
  EHIF_DELAY_MS(2);
 8013cc4:	2002      	movs	r0, #2
 8013cc6:	f7f6 fde3 	bl	800a890 <vTaskDelay>
  EHIF_SPI_TX(0xBF);
 8013cca:	20bf      	movs	r0, #191	; 0xbf
 8013ccc:	f7f8 fe96 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013cd0:	f7f8 fe9e 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  EHIF_SPI_TX(0xFF);
 8013cd4:	20ff      	movs	r0, #255	; 0xff
 8013cd6:	f7f8 fe91 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013cda:	f7f8 fe99 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  if (EHIF_DELAY_SPI_RESET_TO_CSN_HIGH)
    {
      EHIF_DELAY_US(EHIF_DELAY_SPI_RESET_TO_CSN_HIGH);
 8013cde:	2002      	movs	r0, #2
 8013ce0:	f7f9 f864 	bl	800cdac <EHIF_DELAY_US>
    }
  EHIF_SPI_END();
 8013ce4:	f7f8 fea0 	bl	800ca28 <EHIF_SPI_END>
  if (waitReady)
 8013ce8:	b15c      	cbz	r4, 8013d02 <ehifSysResetSpi+0x46>
    {
      EHIF_DELAY_US(1);
 8013cea:	2001      	movs	r0, #1
 8013cec:	f7f9 f85e 	bl	800cdac <EHIF_DELAY_US>
      EHIF_SPI_BEGIN();
 8013cf0:	f7f8 fe6e 	bl	800c9d0 <EHIF_SPI_BEGIN>
      ehifWaitReadyMs(100);
 8013cf4:	2064      	movs	r0, #100	; 0x64
 8013cf6:	f7ff ffc9 	bl	8013c8c <ehifWaitReadyMs>
      EHIF_SPI_END();
    }

} // ehifSysResetSpi
 8013cfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (waitReady)
    {
      EHIF_DELAY_US(1);
      EHIF_SPI_BEGIN();
      ehifWaitReadyMs(100);
      EHIF_SPI_END();
 8013cfe:	f7f8 be93 	b.w	800ca28 <EHIF_SPI_END>
 8013d02:	bd10      	pop	{r4, pc}

08013d04 <ehifBootResetSpi>:
 * Timing must be verified, using oscilloscope or logic analyzer, when porting to new microcontrollers
 * and/or compiler tools.
 */

void ehifBootResetSpi(void)
{
 8013d04:	b508      	push	{r3, lr}

// Perform SYS_RESET sequence
  EHIF_SPI_BEGIN();
 8013d06:	f7f8 fe63 	bl	800c9d0 <EHIF_SPI_BEGIN>
  EHIF_DELAY_MS(2);
 8013d0a:	2002      	movs	r0, #2
 8013d0c:	f7f6 fdc0 	bl	800a890 <vTaskDelay>
  EHIF_ENTER_CRITICAL_SECTION();
 8013d10:	f7f6 fa10 	bl	800a134 <vPortEnterCritical>
 8013d14:	2000      	movs	r0, #0
 8013d16:	f7fa f87f 	bl	800de18 <spiIRQEnable>
  //   int start = TIM14->CNT;
  EHIF_SPI_TX(0xB0);
 8013d1a:	20b0      	movs	r0, #176	; 0xb0
 8013d1c:	f7f8 fe6e 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013d20:	f7f8 fe76 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  EHIF_SPI_TX(0x00);
 8013d24:	2000      	movs	r0, #0
 8013d26:	f7f8 fe69 	bl	800c9fc <EHIF_SPI_TX>
  EHIF_SPI_WAIT_TXRX();
 8013d2a:	f7f8 fe71 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
  if (EHIF_DELAY_SPI_RESET_TO_CSN_HIGH)
    {
      EHIF_DELAY_US(EHIF_DELAY_SPI_RESET_TO_CSN_HIGH);
 8013d2e:	2002      	movs	r0, #2
 8013d30:	f7f9 f83c 	bl	800cdac <EHIF_DELAY_US>
    }
  EHIF_SPI_END();
 8013d34:	f7f8 fe78 	bl	800ca28 <EHIF_SPI_END>
  EHIF_DELAY_US(1);
 8013d38:	2001      	movs	r0, #1
 8013d3a:	f7f9 f837 	bl	800cdac <EHIF_DELAY_US>
  EHIF_SPI_BEGIN();
 8013d3e:	f7f8 fe47 	bl	800c9d0 <EHIF_SPI_BEGIN>
  //  int stop = TIM14->CNT;
  EHIF_LEAVE_CRITICAL_SECTION();
 8013d42:	2001      	movs	r0, #1
 8013d44:	f7fa f868 	bl	800de18 <spiIRQEnable>
 8013d48:	f7f6 fa06 	bl	800a158 <vPortExitCritical>
  ehifWaitReadyMs(100);
 8013d4c:	2064      	movs	r0, #100	; 0x64
 8013d4e:	f7ff ff9d 	bl	8013c8c <ehifWaitReadyMs>
  EHIF_SPI_END();

} // ehifBootResetSpi
 8013d52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  EHIF_DELAY_US(1);
  EHIF_SPI_BEGIN();
  //  int stop = TIM14->CNT;
  EHIF_LEAVE_CRITICAL_SECTION();
  ehifWaitReadyMs(100);
  EHIF_SPI_END();
 8013d56:	f7f8 be67 	b.w	800ca28 <EHIF_SPI_END>
	...

08013d5c <ehifGetWaitReadyError>:
 * \return
 *     Non-zero if CMD_REQ_READY violation has occurred, otherwise zero.
 */
uint8_t ehifGetWaitReadyError(void)
{
  if (waitReadyError)
 8013d5c:	4b03      	ldr	r3, [pc, #12]	; (8013d6c <ehifGetWaitReadyError+0x10>)
 8013d5e:	7818      	ldrb	r0, [r3, #0]
 8013d60:	b110      	cbz	r0, 8013d68 <ehifGetWaitReadyError+0xc>
    {
      waitReadyError = 0;
 8013d62:	2200      	movs	r2, #0
 8013d64:	701a      	strb	r2, [r3, #0]
      return 1;
 8013d66:	2001      	movs	r0, #1
    }
  else
    {
      return 0;
    }
} // ehifGetWaitReadyError
 8013d68:	4770      	bx	lr
 8013d6a:	bf00      	nop
 8013d6c:	2001adc0 	.word	0x2001adc0

08013d70 <ehifFieldTx>:
 *         - Bits 7:2 = Repeat count (number of times this field size is repeated)
 *     - Negative value (msb is 1):
 *         - Bits 7:0 = Negative offset applied to \a pFieldSpec, creating an infinite loop until the
 *           number of bytes specified by \a length is reached
 */
static void ehifFieldTx(int16_t length, const uint8_t* pData, const int8_t* pFieldSpec) {
 8013d70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8013d74:	4680      	mov	r8, r0
 8013d76:	4689      	mov	r9, r1
 8013d78:	4692      	mov	sl, r2
            // Bits 6:2 = repeat count (0 = one field, 1 = 2 fields and so on)
            uint16_t repeatCount = *pFieldSpec >> 2;
            do {

                // Bits 1:0 = field size shift (1 = 1 byte, 2 = 2 bytes, 3 = 4 bytes)
                uint8_t fieldSize = BV(((*pFieldSpec & 0x03) - 1) & 0x03);
 8013d7a:	2701      	movs	r7, #1
 *           number of bytes specified by \a length is reached
 */
static void ehifFieldTx(int16_t length, const uint8_t* pData, const int8_t* pFieldSpec) {

    // Until all the bytes have been consumed ...
    while (length > 0) {
 8013d7c:	f1b8 0f00 	cmp.w	r8, #0
 8013d80:	dd47      	ble.n	8013e12 <ehifFieldTx+0xa2>

        // Positive field spec value = Write field
        if (*pFieldSpec > 0) {
 8013d82:	f99a 6000 	ldrsb.w	r6, [sl]
 8013d86:	2e00      	cmp	r6, #0
 8013d88:	dd40      	ble.n	8013e0c <ehifFieldTx+0x9c>

            // Bits 6:2 = repeat count (0 = one field, 1 = 2 fields and so on)
            uint16_t repeatCount = *pFieldSpec >> 2;
 8013d8a:	f3c6 068f 	ubfx	r6, r6, #2, #16
            do {

                // Bits 1:0 = field size shift (1 = 1 byte, 2 = 2 bytes, 3 = 4 bytes)
                uint8_t fieldSize = BV(((*pFieldSpec & 0x03) - 1) & 0x03);
 8013d8e:	f89a 3000 	ldrb.w	r3, [sl]
 8013d92:	3b01      	subs	r3, #1
 8013d94:	f003 0303 	and.w	r3, r3, #3
 8013d98:	fa07 f403 	lsl.w	r4, r7, r3
                if (fieldSize > length) break;
 8013d9c:	4544      	cmp	r4, r8
 8013d9e:	dc32      	bgt.n	8013e06 <ehifFieldTx+0x96>
                pData += fieldSize;
                switch (fieldSize) {
 8013da0:	2c02      	cmp	r4, #2
            do {

                // Bits 1:0 = field size shift (1 = 1 byte, 2 = 2 bytes, 3 = 4 bytes)
                uint8_t fieldSize = BV(((*pFieldSpec & 0x03) - 1) & 0x03);
                if (fieldSize > length) break;
                pData += fieldSize;
 8013da2:	eb09 0504 	add.w	r5, r9, r4
                switch (fieldSize) {
 8013da6:	d013      	beq.n	8013dd0 <ehifFieldTx+0x60>
 8013da8:	2c04      	cmp	r4, #4
 8013daa:	d002      	beq.n	8013db2 <ehifFieldTx+0x42>
 8013dac:	2c01      	cmp	r4, #1
 8013dae:	d130      	bne.n	8013e12 <ehifFieldTx+0xa2>
 8013db0:	e017      	b.n	8013de2 <ehifFieldTx+0x72>
                case 4: // 32-bit
                    EHIF_SPI_TX(*(--pData));
 8013db2:	f815 0c01 	ldrb.w	r0, [r5, #-1]
 8013db6:	f7f8 fe21 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013dba:	f7f8 fe29 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    EHIF_SPI_TX(*(--pData));
 8013dbe:	f815 0c02 	ldrb.w	r0, [r5, #-2]
 8013dc2:	f7f8 fe1b 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013dc6:	f7f8 fe23 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                pData += fieldSize;
                switch (fieldSize) {
                case 4: // 32-bit
                    EHIF_SPI_TX(*(--pData));
                    EHIF_SPI_WAIT_TXRX();
                    EHIF_SPI_TX(*(--pData));
 8013dca:	f109 0902 	add.w	r9, r9, #2
 8013dce:	464d      	mov	r5, r9
                    EHIF_SPI_WAIT_TXRX();
                case 2: // 16-bit
                    EHIF_SPI_TX(*(--pData));
 8013dd0:	f815 0c01 	ldrb.w	r0, [r5, #-1]
 8013dd4:	f7f8 fe12 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013dd8:	f7f8 fe1a 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    EHIF_SPI_TX(*(--pData));
                    EHIF_SPI_WAIT_TXRX();
                    EHIF_SPI_TX(*(--pData));
                    EHIF_SPI_WAIT_TXRX();
                case 2: // 16-bit
                    EHIF_SPI_TX(*(--pData));
 8013ddc:	f105 39ff 	add.w	r9, r5, #4294967295
 8013de0:	464d      	mov	r5, r9
                    EHIF_SPI_WAIT_TXRX();
                case 1: // 8-bit
                    EHIF_SPI_TX(*(--pData));
 8013de2:	f815 0c01 	ldrb.w	r0, [r5, #-1]
 8013de6:	f7f8 fe09 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
                    break;
                default:
                    return;
                }
                pData += fieldSize;
 8013dea:	f104 39ff 	add.w	r9, r4, #4294967295
                case 2: // 16-bit
                    EHIF_SPI_TX(*(--pData));
                    EHIF_SPI_WAIT_TXRX();
                case 1: // 8-bit
                    EHIF_SPI_TX(*(--pData));
                    EHIF_SPI_WAIT_TXRX();
 8013dee:	f7f8 fe0f 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    break;
                default:
                    return;
                }
                pData += fieldSize;
                length -= fieldSize;
 8013df2:	ebc4 0408 	rsb	r4, r4, r8

            } while (repeatCount--);
 8013df6:	1e73      	subs	r3, r6, #1
                    EHIF_SPI_WAIT_TXRX();
                    break;
                default:
                    return;
                }
                pData += fieldSize;
 8013df8:	44a9      	add	r9, r5
                length -= fieldSize;
 8013dfa:	fa0f f884 	sxth.w	r8, r4

            } while (repeatCount--);
 8013dfe:	b29b      	uxth	r3, r3
 8013e00:	b10e      	cbz	r6, 8013e06 <ehifFieldTx+0x96>
 8013e02:	461e      	mov	r6, r3
 8013e04:	e7c3      	b.n	8013d8e <ehifFieldTx+0x1e>

            pFieldSpec++;
 8013e06:	f10a 0a01 	add.w	sl, sl, #1
 8013e0a:	e7b7      	b.n	8013d7c <ehifFieldTx+0xc>

        // Zero field spec value = bail out. This should only happen due to host processor software bugs
        } else if (*pFieldSpec == 0) {
 8013e0c:	d001      	beq.n	8013e12 <ehifFieldTx+0xa2>
            return;

        // Negative field spec value = Go back in field specification
        } else {
            pFieldSpec += *pFieldSpec;
 8013e0e:	44b2      	add	sl, r6
 8013e10:	e7b4      	b.n	8013d7c <ehifFieldTx+0xc>
 8013e12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08013e16 <ehifFieldRx>:
 *         - Bits 7:2 = Repeat count (number of times this field size is repeated)
 *     - Negative value (msb is 1):
 *         - Bits 7:0 = Negative offset applied to \a pFieldSpec, creating an infinite loop until the
 *           number of bytes specified by \a length is reached
 */
static void ehifFieldRx(uint16_t length, uint8_t* pData, const int8_t* pFieldSpec) {
 8013e16:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013e1a:	4606      	mov	r6, r0
 8013e1c:	4689      	mov	r9, r1
 8013e1e:	4690      	mov	r8, r2
            // Bits 6:2 = repeat count (0 = one field, 1 = 2 fields and so on)
            uint16_t repeatCount = *pFieldSpec >> 2;
            do {

                // Bits 1:0 = field size shift (1 = 1 byte, 2 = 2 bytes, 3 = 4 bytes)
                uint8_t fieldSize = BV(((*pFieldSpec & 0x03) - 1) & 0x03);
 8013e20:	2701      	movs	r7, #1
 *     - Negative value (msb is 1):
 *         - Bits 7:0 = Negative offset applied to \a pFieldSpec, creating an infinite loop until the
 *           number of bytes specified by \a length is reached
 */
static void ehifFieldRx(uint16_t length, uint8_t* pData, const int8_t* pFieldSpec) {
    while (length) {
 8013e22:	2e00      	cmp	r6, #0
 8013e24:	d054      	beq.n	8013ed0 <ehifFieldRx+0xba>

        // Positive field spec value = Write field
        if (*pFieldSpec > 0) {
 8013e26:	f998 5000 	ldrsb.w	r5, [r8]
 8013e2a:	2d00      	cmp	r5, #0
 8013e2c:	dd4d      	ble.n	8013eca <ehifFieldRx+0xb4>

            // Bits 6:2 = repeat count (0 = one field, 1 = 2 fields and so on)
            uint16_t repeatCount = *pFieldSpec >> 2;
 8013e2e:	f3c5 058f 	ubfx	r5, r5, #2, #16
            do {

                // Bits 1:0 = field size shift (1 = 1 byte, 2 = 2 bytes, 3 = 4 bytes)
                uint8_t fieldSize = BV(((*pFieldSpec & 0x03) - 1) & 0x03);
 8013e32:	f898 3000 	ldrb.w	r3, [r8]
 8013e36:	3b01      	subs	r3, #1
 8013e38:	f003 0303 	and.w	r3, r3, #3
 8013e3c:	fa07 f403 	lsl.w	r4, r7, r3
                if (fieldSize > length) break;
 8013e40:	fa1f fa84 	uxth.w	sl, r4
 8013e44:	4556      	cmp	r6, sl
 8013e46:	d33d      	bcc.n	8013ec4 <ehifFieldRx+0xae>
                pData += fieldSize;
                switch (fieldSize) {
 8013e48:	2c02      	cmp	r4, #2
            do {

                // Bits 1:0 = field size shift (1 = 1 byte, 2 = 2 bytes, 3 = 4 bytes)
                uint8_t fieldSize = BV(((*pFieldSpec & 0x03) - 1) & 0x03);
                if (fieldSize > length) break;
                pData += fieldSize;
 8013e4a:	eb09 0b04 	add.w	fp, r9, r4
                switch (fieldSize) {
 8013e4e:	d019      	beq.n	8013e84 <ehifFieldRx+0x6e>
 8013e50:	2c04      	cmp	r4, #4
 8013e52:	d002      	beq.n	8013e5a <ehifFieldRx+0x44>
 8013e54:	2c01      	cmp	r4, #1
 8013e56:	d13b      	bne.n	8013ed0 <ehifFieldRx+0xba>
 8013e58:	e020      	b.n	8013e9c <ehifFieldRx+0x86>
                case 4: // 32-bit
                    EHIF_SPI_TX(0x00);
 8013e5a:	2000      	movs	r0, #0
 8013e5c:	f7f8 fdce 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013e60:	f7f8 fdd6 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    *(--pData) = EHIF_SPI_RX();
 8013e64:	f7f8 fdd6 	bl	800ca14 <EHIF_SPI_RX>
 8013e68:	f80b 0c01 	strb.w	r0, [fp, #-1]
                    EHIF_SPI_TX(0x00);
 8013e6c:	2000      	movs	r0, #0
 8013e6e:	f7f8 fdc5 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013e72:	f7f8 fdcd 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    *(--pData) = EHIF_SPI_RX();
 8013e76:	f7f8 fdcd 	bl	800ca14 <EHIF_SPI_RX>
 8013e7a:	f109 0902 	add.w	r9, r9, #2
 8013e7e:	f80b 0c02 	strb.w	r0, [fp, #-2]
 8013e82:	46cb      	mov	fp, r9
                case 2: // 16-bit
                    EHIF_SPI_TX(*pData);
 8013e84:	46d9      	mov	r9, fp
 8013e86:	f819 0901 	ldrb.w	r0, [r9], #-1
 8013e8a:	f7f8 fdb7 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013e8e:	f7f8 fdbf 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    *(--pData) = EHIF_SPI_RX();
 8013e92:	f7f8 fdbf 	bl	800ca14 <EHIF_SPI_RX>
 8013e96:	f80b 0c01 	strb.w	r0, [fp, #-1]
 8013e9a:	46cb      	mov	fp, r9
                case 1: // 8-bit
                    EHIF_SPI_TX(0x00);
 8013e9c:	2000      	movs	r0, #0
 8013e9e:	f7f8 fdad 	bl	800c9fc <EHIF_SPI_TX>
                    EHIF_SPI_WAIT_TXRX();
 8013ea2:	f7f8 fdb5 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
                    *(--pData) = EHIF_SPI_RX();
 8013ea6:	f7f8 fdb5 	bl	800ca14 <EHIF_SPI_RX>
                    break;
                default:
                    return;
                }
                pData += fieldSize;
 8013eaa:	3c01      	subs	r4, #1
                length -= fieldSize;
 8013eac:	ebca 0606 	rsb	r6, sl, r6

            } while (repeatCount--);
 8013eb0:	1e6b      	subs	r3, r5, #1
                    EHIF_SPI_WAIT_TXRX();
                    *(--pData) = EHIF_SPI_RX();
                case 1: // 8-bit
                    EHIF_SPI_TX(0x00);
                    EHIF_SPI_WAIT_TXRX();
                    *(--pData) = EHIF_SPI_RX();
 8013eb2:	f80b 0c01 	strb.w	r0, [fp, #-1]
                    break;
                default:
                    return;
                }
                pData += fieldSize;
 8013eb6:	eb0b 0904 	add.w	r9, fp, r4
                length -= fieldSize;
 8013eba:	b2b6      	uxth	r6, r6

            } while (repeatCount--);
 8013ebc:	b29b      	uxth	r3, r3
 8013ebe:	b10d      	cbz	r5, 8013ec4 <ehifFieldRx+0xae>
 8013ec0:	461d      	mov	r5, r3
 8013ec2:	e7b6      	b.n	8013e32 <ehifFieldRx+0x1c>

            pFieldSpec++;
 8013ec4:	f108 0801 	add.w	r8, r8, #1
 8013ec8:	e7ab      	b.n	8013e22 <ehifFieldRx+0xc>

        // Zero field spec value = bail out. This should normally not happen, but can for instance happen
        // if an electrical error corrupts the length value returned by READBC
        } else if (*pFieldSpec == 0) {
 8013eca:	d001      	beq.n	8013ed0 <ehifFieldRx+0xba>
            return;

        // Negative field spec value = Go back in field specification
        } else {
            pFieldSpec += *pFieldSpec;
 8013ecc:	44a8      	add	r8, r5
 8013ece:	e7a8      	b.n	8013e22 <ehifFieldRx+0xc>
 8013ed0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08013ed4 <ehifFieldWrite>:
 *           number of bytes specified by \a length is reached
 *
 * \return
 *     EHIF status word at start of WRITE operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifFieldWrite(uint16_t length, const uint8_t* pData, const int8_t* pFieldSpec) {
 8013ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013ed6:	4605      	mov	r5, r0
 8013ed8:	460e      	mov	r6, r1
 8013eda:	4617      	mov	r7, r2

    // Begin operation
    EHIF_SPI_BEGIN();
 8013edc:	f7f8 fd78 	bl	800c9d0 <EHIF_SPI_BEGIN>
    ehifWaitReady();
 8013ee0:	f7ff fe14 	bl	8013b0c <ehifWaitReady>

    // Send type/length, receive status word
    uint16_t statusWord;
    EHIF_SPI_TX(0x80 | ((length >> 8) & 0x0F));
 8013ee4:	f3c5 2003 	ubfx	r0, r5, #8, #4
 8013ee8:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8013eec:	f7f8 fd86 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013ef0:	f7f8 fd8e 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord = EHIF_SPI_RX() << 8;
 8013ef4:	f7f8 fd8e 	bl	800ca14 <EHIF_SPI_RX>
 8013ef8:	0200      	lsls	r0, r0, #8
 8013efa:	b284      	uxth	r4, r0
    EHIF_SPI_TX(length & 0xFF);
 8013efc:	b2e8      	uxtb	r0, r5
 8013efe:	f7f8 fd7d 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013f02:	f7f8 fd85 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord |= EHIF_SPI_RX();
 8013f06:	f7f8 fd85 	bl	800ca14 <EHIF_SPI_RX>
 8013f0a:	4320      	orrs	r0, r4

    // Send data
    ehifFieldTx(length, pData, pFieldSpec);
 8013f0c:	463a      	mov	r2, r7
 8013f0e:	4631      	mov	r1, r6
    EHIF_SPI_TX(0x80 | ((length >> 8) & 0x0F));
    EHIF_SPI_WAIT_TXRX();
    statusWord = EHIF_SPI_RX() << 8;
    EHIF_SPI_TX(length & 0xFF);
    EHIF_SPI_WAIT_TXRX();
    statusWord |= EHIF_SPI_RX();
 8013f10:	b284      	uxth	r4, r0

    // Send data
    ehifFieldTx(length, pData, pFieldSpec);
 8013f12:	b228      	sxth	r0, r5
 8013f14:	f7ff ff2c 	bl	8013d70 <ehifFieldTx>
    EHIF_SPI_WAIT_TXRX();
 8013f18:	f7f8 fd7a 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>

    // End operation
    EHIF_SPI_END();
 8013f1c:	f7f8 fd84 	bl	800ca28 <EHIF_SPI_END>
    return statusWord;

} // ehifFieldWrite
 8013f20:	4620      	mov	r0, r4
 8013f22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013f24 <ehifFieldRead>:
 *           number of bytes specified by \a length is reached
 *
 * \return
 *     EHIF status word at start of READ operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifFieldRead(uint16_t length, uint8_t* pData, const int8_t* pFieldSpec) {
 8013f24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013f26:	4605      	mov	r5, r0
 8013f28:	460e      	mov	r6, r1
 8013f2a:	4617      	mov	r7, r2

    // Begin operation
    EHIF_SPI_BEGIN();
 8013f2c:	f7f8 fd50 	bl	800c9d0 <EHIF_SPI_BEGIN>
    ehifWaitReady();
 8013f30:	f7ff fdec 	bl	8013b0c <ehifWaitReady>

    // Send type/length, receive status word
    uint16_t statusWord;
    EHIF_SPI_TX(0x90 | ((length >> 8) & 0x0F));
 8013f34:	f3c5 2003 	ubfx	r0, r5, #8, #4
 8013f38:	f040 0090 	orr.w	r0, r0, #144	; 0x90
 8013f3c:	f7f8 fd5e 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013f40:	f7f8 fd66 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord = EHIF_SPI_RX() << 8;
 8013f44:	f7f8 fd66 	bl	800ca14 <EHIF_SPI_RX>
 8013f48:	0200      	lsls	r0, r0, #8
 8013f4a:	b284      	uxth	r4, r0
    EHIF_SPI_TX(length & 0xFF);
 8013f4c:	b2e8      	uxtb	r0, r5
 8013f4e:	f7f8 fd55 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013f52:	f7f8 fd5d 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord |= EHIF_SPI_RX();
 8013f56:	f7f8 fd5d 	bl	800ca14 <EHIF_SPI_RX>
 8013f5a:	4320      	orrs	r0, r4
 8013f5c:	b284      	uxth	r4, r0

    // Receive data
    ehifFieldRx(length, pData, pFieldSpec);
 8013f5e:	463a      	mov	r2, r7
 8013f60:	4628      	mov	r0, r5
 8013f62:	4631      	mov	r1, r6
 8013f64:	f7ff ff57 	bl	8013e16 <ehifFieldRx>

    // End operation
    EHIF_SPI_END();
 8013f68:	f7f8 fd5e 	bl	800ca28 <EHIF_SPI_END>
    return statusWord;

} // ehifFieldRead
 8013f6c:	4620      	mov	r0, r4
 8013f6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08013f70 <ehifFieldReadbc>:
 *           number of bytes specified by \a length is reached
 *
 * \return
 *     EHIF status word at start of READBC operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifFieldReadbc(uint16_t *pVarLength, uint8_t* pData, const int8_t* pFieldSpec) {
 8013f70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013f74:	460f      	mov	r7, r1
 8013f76:	4690      	mov	r8, r2
 8013f78:	4606      	mov	r6, r0

    // Begin operation
    EHIF_SPI_BEGIN();
 8013f7a:	f7f8 fd29 	bl	800c9d0 <EHIF_SPI_BEGIN>
    ehifWaitReady();
 8013f7e:	f7ff fdc5 	bl	8013b0c <ehifWaitReady>

    // Send type, receive status word
    uint16_t statusWord;
    EHIF_SPI_TX(0xA0);
 8013f82:	20a0      	movs	r0, #160	; 0xa0
 8013f84:	f7f8 fd3a 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013f88:	f7f8 fd42 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord = EHIF_SPI_RX() << 8;
 8013f8c:	f7f8 fd42 	bl	800ca14 <EHIF_SPI_RX>
 8013f90:	0200      	lsls	r0, r0, #8
 8013f92:	b284      	uxth	r4, r0
    EHIF_SPI_TX(0x00);
 8013f94:	2000      	movs	r0, #0
 8013f96:	f7f8 fd31 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013f9a:	f7f8 fd39 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord |= EHIF_SPI_RX();
 8013f9e:	f7f8 fd39 	bl	800ca14 <EHIF_SPI_RX>
 8013fa2:	4320      	orrs	r0, r4
 8013fa4:	b284      	uxth	r4, r0

    // Receive length
    uint16_t length;
    EHIF_SPI_TX(0xA0);
 8013fa6:	20a0      	movs	r0, #160	; 0xa0
 8013fa8:	f7f8 fd28 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013fac:	f7f8 fd30 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    length = EHIF_SPI_RX() << 8;
 8013fb0:	f7f8 fd30 	bl	800ca14 <EHIF_SPI_RX>
 8013fb4:	0200      	lsls	r0, r0, #8
 8013fb6:	b285      	uxth	r5, r0
    EHIF_SPI_TX(0x00);
 8013fb8:	2000      	movs	r0, #0
 8013fba:	f7f8 fd1f 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8013fbe:	f7f8 fd27 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    length |= EHIF_SPI_RX();
 8013fc2:	f7f8 fd27 	bl	800ca14 <EHIF_SPI_RX>
 8013fc6:	4328      	orrs	r0, r5

    // Constrain length
    if (length > *pVarLength) {
 8013fc8:	8835      	ldrh	r5, [r6, #0]
    EHIF_SPI_TX(0xA0);
    EHIF_SPI_WAIT_TXRX();
    length = EHIF_SPI_RX() << 8;
    EHIF_SPI_TX(0x00);
    EHIF_SPI_WAIT_TXRX();
    length |= EHIF_SPI_RX();
 8013fca:	b280      	uxth	r0, r0
 8013fcc:	42a8      	cmp	r0, r5
 8013fce:	bf28      	it	cs
 8013fd0:	4628      	movcs	r0, r5

    // Constrain length
    if (length > *pVarLength) {
        length = *pVarLength;
    }
    *pVarLength = length;
 8013fd2:	8030      	strh	r0, [r6, #0]

    // Receive data
    ehifFieldRx(length, pData, pFieldSpec);
 8013fd4:	4642      	mov	r2, r8
 8013fd6:	4639      	mov	r1, r7
 8013fd8:	f7ff ff1d 	bl	8013e16 <ehifFieldRx>

    // End operation
    EHIF_SPI_END();
 8013fdc:	f7f8 fd24 	bl	800ca28 <EHIF_SPI_END>
    return statusWord;

} // ehifFieldReadbc
 8013fe0:	4620      	mov	r0, r4
 8013fe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08013fe6 <ehifFieldCmdReq>:
 *           number of bytes specified by \a length is reached
 *
 * \return
 *     EHIF status word at start of CMD_REQ operation (see \c EHIF_EVT_XXXXX definitions)
 */
uint16_t ehifFieldCmdReq(uint8_t cmd, uint8_t length, const uint8_t* pParam, const int8_t* pFieldSpec) {
 8013fe6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013fe8:	4604      	mov	r4, r0
 8013fea:	461f      	mov	r7, r3
 8013fec:	460d      	mov	r5, r1
 8013fee:	4616      	mov	r6, r2

    // Begin operation
    EHIF_SPI_BEGIN();
 8013ff0:	f7f8 fcee 	bl	800c9d0 <EHIF_SPI_BEGIN>
    ehifWaitReady();
 8013ff4:	f7ff fd8a 	bl	8013b0c <ehifWaitReady>

    // Send type/command code/parameter length, receive status word
    uint16_t statusWord;
    EHIF_SPI_TX(0xC0 | cmd);
 8013ff8:	f044 00c0 	orr.w	r0, r4, #192	; 0xc0
 8013ffc:	f7f8 fcfe 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8014000:	f7f8 fd06 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord = EHIF_SPI_RX() << 8;
 8014004:	f7f8 fd06 	bl	800ca14 <EHIF_SPI_RX>
 8014008:	0200      	lsls	r0, r0, #8
 801400a:	b284      	uxth	r4, r0
    EHIF_SPI_TX(length & 0xFF);
 801400c:	4628      	mov	r0, r5
 801400e:	f7f8 fcf5 	bl	800c9fc <EHIF_SPI_TX>
    EHIF_SPI_WAIT_TXRX();
 8014012:	f7f8 fcfd 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>
    statusWord |= EHIF_SPI_RX();
 8014016:	f7f8 fcfd 	bl	800ca14 <EHIF_SPI_RX>
 801401a:	4320      	orrs	r0, r4

    // Send parameters
    ehifFieldTx(length, pParam, pFieldSpec);
 801401c:	463a      	mov	r2, r7
 801401e:	4631      	mov	r1, r6
    EHIF_SPI_TX(0xC0 | cmd);
    EHIF_SPI_WAIT_TXRX();
    statusWord = EHIF_SPI_RX() << 8;
    EHIF_SPI_TX(length & 0xFF);
    EHIF_SPI_WAIT_TXRX();
    statusWord |= EHIF_SPI_RX();
 8014020:	b284      	uxth	r4, r0

    // Send parameters
    ehifFieldTx(length, pParam, pFieldSpec);
 8014022:	4628      	mov	r0, r5
 8014024:	f7ff fea4 	bl	8013d70 <ehifFieldTx>
    EHIF_SPI_WAIT_TXRX();
 8014028:	f7f8 fcf2 	bl	800ca10 <EHIF_SPI_WAIT_TXRX>

    // End operation
    EHIF_SPI_END();
 801402c:	f7f8 fcfc 	bl	800ca28 <EHIF_SPI_END>
    return statusWord;

} // ehifFieldCmdReq
 8014030:	4620      	mov	r0, r4
 8014032:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08014034 <__aeabi_ldivmod>:
 8014034:	b97b      	cbnz	r3, 8014056 <__aeabi_ldivmod+0x22>
 8014036:	b972      	cbnz	r2, 8014056 <__aeabi_ldivmod+0x22>
 8014038:	2900      	cmp	r1, #0
 801403a:	bfbe      	ittt	lt
 801403c:	2000      	movlt	r0, #0
 801403e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8014042:	e006      	blt.n	8014052 <__aeabi_ldivmod+0x1e>
 8014044:	bf08      	it	eq
 8014046:	2800      	cmpeq	r0, #0
 8014048:	bf1c      	itt	ne
 801404a:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 801404e:	f04f 30ff 	movne.w	r0, #4294967295
 8014052:	f000 b9c9 	b.w	80143e8 <__aeabi_idiv0>
 8014056:	f1ad 0c08 	sub.w	ip, sp, #8
 801405a:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 801405e:	2900      	cmp	r1, #0
 8014060:	db09      	blt.n	8014076 <__aeabi_ldivmod+0x42>
 8014062:	2b00      	cmp	r3, #0
 8014064:	db1a      	blt.n	801409c <__aeabi_ldivmod+0x68>
 8014066:	f000 f84d 	bl	8014104 <__udivmoddi4>
 801406a:	f8dd e004 	ldr.w	lr, [sp, #4]
 801406e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8014072:	b004      	add	sp, #16
 8014074:	4770      	bx	lr
 8014076:	4240      	negs	r0, r0
 8014078:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801407c:	2b00      	cmp	r3, #0
 801407e:	db1b      	blt.n	80140b8 <__aeabi_ldivmod+0x84>
 8014080:	f000 f840 	bl	8014104 <__udivmoddi4>
 8014084:	f8dd e004 	ldr.w	lr, [sp, #4]
 8014088:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801408c:	b004      	add	sp, #16
 801408e:	4240      	negs	r0, r0
 8014090:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8014094:	4252      	negs	r2, r2
 8014096:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801409a:	4770      	bx	lr
 801409c:	4252      	negs	r2, r2
 801409e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80140a2:	f000 f82f 	bl	8014104 <__udivmoddi4>
 80140a6:	f8dd e004 	ldr.w	lr, [sp, #4]
 80140aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80140ae:	b004      	add	sp, #16
 80140b0:	4240      	negs	r0, r0
 80140b2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80140b6:	4770      	bx	lr
 80140b8:	4252      	negs	r2, r2
 80140ba:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80140be:	f000 f821 	bl	8014104 <__udivmoddi4>
 80140c2:	f8dd e004 	ldr.w	lr, [sp, #4]
 80140c6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80140ca:	b004      	add	sp, #16
 80140cc:	4252      	negs	r2, r2
 80140ce:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80140d2:	4770      	bx	lr

080140d4 <__aeabi_uldivmod>:
 80140d4:	b953      	cbnz	r3, 80140ec <__aeabi_uldivmod+0x18>
 80140d6:	b94a      	cbnz	r2, 80140ec <__aeabi_uldivmod+0x18>
 80140d8:	2900      	cmp	r1, #0
 80140da:	bf08      	it	eq
 80140dc:	2800      	cmpeq	r0, #0
 80140de:	bf1c      	itt	ne
 80140e0:	f04f 31ff 	movne.w	r1, #4294967295
 80140e4:	f04f 30ff 	movne.w	r0, #4294967295
 80140e8:	f000 b97e 	b.w	80143e8 <__aeabi_idiv0>
 80140ec:	f1ad 0c08 	sub.w	ip, sp, #8
 80140f0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80140f4:	f000 f806 	bl	8014104 <__udivmoddi4>
 80140f8:	f8dd e004 	ldr.w	lr, [sp, #4]
 80140fc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8014100:	b004      	add	sp, #16
 8014102:	4770      	bx	lr

08014104 <__udivmoddi4>:
 8014104:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014108:	468c      	mov	ip, r1
 801410a:	460e      	mov	r6, r1
 801410c:	4604      	mov	r4, r0
 801410e:	9d08      	ldr	r5, [sp, #32]
 8014110:	2b00      	cmp	r3, #0
 8014112:	d150      	bne.n	80141b6 <__udivmoddi4+0xb2>
 8014114:	428a      	cmp	r2, r1
 8014116:	4617      	mov	r7, r2
 8014118:	d96c      	bls.n	80141f4 <__udivmoddi4+0xf0>
 801411a:	fab2 fe82 	clz	lr, r2
 801411e:	f1be 0f00 	cmp.w	lr, #0
 8014122:	d00b      	beq.n	801413c <__udivmoddi4+0x38>
 8014124:	f1ce 0420 	rsb	r4, lr, #32
 8014128:	fa20 f404 	lsr.w	r4, r0, r4
 801412c:	fa01 f60e 	lsl.w	r6, r1, lr
 8014130:	ea44 0c06 	orr.w	ip, r4, r6
 8014134:	fa02 f70e 	lsl.w	r7, r2, lr
 8014138:	fa00 f40e 	lsl.w	r4, r0, lr
 801413c:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8014140:	0c22      	lsrs	r2, r4, #16
 8014142:	fbbc f0f9 	udiv	r0, ip, r9
 8014146:	fa1f f887 	uxth.w	r8, r7
 801414a:	fb09 c610 	mls	r6, r9, r0, ip
 801414e:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8014152:	fb00 f308 	mul.w	r3, r0, r8
 8014156:	42b3      	cmp	r3, r6
 8014158:	d909      	bls.n	801416e <__udivmoddi4+0x6a>
 801415a:	19f6      	adds	r6, r6, r7
 801415c:	f100 32ff 	add.w	r2, r0, #4294967295
 8014160:	f080 8122 	bcs.w	80143a8 <__udivmoddi4+0x2a4>
 8014164:	42b3      	cmp	r3, r6
 8014166:	f240 811f 	bls.w	80143a8 <__udivmoddi4+0x2a4>
 801416a:	3802      	subs	r0, #2
 801416c:	443e      	add	r6, r7
 801416e:	1af6      	subs	r6, r6, r3
 8014170:	b2a2      	uxth	r2, r4
 8014172:	fbb6 f3f9 	udiv	r3, r6, r9
 8014176:	fb09 6613 	mls	r6, r9, r3, r6
 801417a:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 801417e:	fb03 f808 	mul.w	r8, r3, r8
 8014182:	45a0      	cmp	r8, r4
 8014184:	d909      	bls.n	801419a <__udivmoddi4+0x96>
 8014186:	19e4      	adds	r4, r4, r7
 8014188:	f103 32ff 	add.w	r2, r3, #4294967295
 801418c:	f080 810a 	bcs.w	80143a4 <__udivmoddi4+0x2a0>
 8014190:	45a0      	cmp	r8, r4
 8014192:	f240 8107 	bls.w	80143a4 <__udivmoddi4+0x2a0>
 8014196:	3b02      	subs	r3, #2
 8014198:	443c      	add	r4, r7
 801419a:	ebc8 0404 	rsb	r4, r8, r4
 801419e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80141a2:	2100      	movs	r1, #0
 80141a4:	2d00      	cmp	r5, #0
 80141a6:	d062      	beq.n	801426e <__udivmoddi4+0x16a>
 80141a8:	fa24 f40e 	lsr.w	r4, r4, lr
 80141ac:	2300      	movs	r3, #0
 80141ae:	602c      	str	r4, [r5, #0]
 80141b0:	606b      	str	r3, [r5, #4]
 80141b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80141b6:	428b      	cmp	r3, r1
 80141b8:	d907      	bls.n	80141ca <__udivmoddi4+0xc6>
 80141ba:	2d00      	cmp	r5, #0
 80141bc:	d055      	beq.n	801426a <__udivmoddi4+0x166>
 80141be:	2100      	movs	r1, #0
 80141c0:	e885 0041 	stmia.w	r5, {r0, r6}
 80141c4:	4608      	mov	r0, r1
 80141c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80141ca:	fab3 f183 	clz	r1, r3
 80141ce:	2900      	cmp	r1, #0
 80141d0:	f040 8090 	bne.w	80142f4 <__udivmoddi4+0x1f0>
 80141d4:	42b3      	cmp	r3, r6
 80141d6:	d302      	bcc.n	80141de <__udivmoddi4+0xda>
 80141d8:	4282      	cmp	r2, r0
 80141da:	f200 80f8 	bhi.w	80143ce <__udivmoddi4+0x2ca>
 80141de:	1a84      	subs	r4, r0, r2
 80141e0:	eb66 0603 	sbc.w	r6, r6, r3
 80141e4:	2001      	movs	r0, #1
 80141e6:	46b4      	mov	ip, r6
 80141e8:	2d00      	cmp	r5, #0
 80141ea:	d040      	beq.n	801426e <__udivmoddi4+0x16a>
 80141ec:	e885 1010 	stmia.w	r5, {r4, ip}
 80141f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80141f4:	b912      	cbnz	r2, 80141fc <__udivmoddi4+0xf8>
 80141f6:	2701      	movs	r7, #1
 80141f8:	fbb7 f7f2 	udiv	r7, r7, r2
 80141fc:	fab7 fe87 	clz	lr, r7
 8014200:	f1be 0f00 	cmp.w	lr, #0
 8014204:	d135      	bne.n	8014272 <__udivmoddi4+0x16e>
 8014206:	1bf3      	subs	r3, r6, r7
 8014208:	ea4f 4817 	mov.w	r8, r7, lsr #16
 801420c:	fa1f fc87 	uxth.w	ip, r7
 8014210:	2101      	movs	r1, #1
 8014212:	fbb3 f0f8 	udiv	r0, r3, r8
 8014216:	0c22      	lsrs	r2, r4, #16
 8014218:	fb08 3610 	mls	r6, r8, r0, r3
 801421c:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8014220:	fb0c f300 	mul.w	r3, ip, r0
 8014224:	42b3      	cmp	r3, r6
 8014226:	d907      	bls.n	8014238 <__udivmoddi4+0x134>
 8014228:	19f6      	adds	r6, r6, r7
 801422a:	f100 32ff 	add.w	r2, r0, #4294967295
 801422e:	d202      	bcs.n	8014236 <__udivmoddi4+0x132>
 8014230:	42b3      	cmp	r3, r6
 8014232:	f200 80ce 	bhi.w	80143d2 <__udivmoddi4+0x2ce>
 8014236:	4610      	mov	r0, r2
 8014238:	1af6      	subs	r6, r6, r3
 801423a:	b2a2      	uxth	r2, r4
 801423c:	fbb6 f3f8 	udiv	r3, r6, r8
 8014240:	fb08 6613 	mls	r6, r8, r3, r6
 8014244:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 8014248:	fb0c fc03 	mul.w	ip, ip, r3
 801424c:	45a4      	cmp	ip, r4
 801424e:	d907      	bls.n	8014260 <__udivmoddi4+0x15c>
 8014250:	19e4      	adds	r4, r4, r7
 8014252:	f103 32ff 	add.w	r2, r3, #4294967295
 8014256:	d202      	bcs.n	801425e <__udivmoddi4+0x15a>
 8014258:	45a4      	cmp	ip, r4
 801425a:	f200 80b5 	bhi.w	80143c8 <__udivmoddi4+0x2c4>
 801425e:	4613      	mov	r3, r2
 8014260:	ebcc 0404 	rsb	r4, ip, r4
 8014264:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8014268:	e79c      	b.n	80141a4 <__udivmoddi4+0xa0>
 801426a:	4629      	mov	r1, r5
 801426c:	4628      	mov	r0, r5
 801426e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014272:	f1ce 0120 	rsb	r1, lr, #32
 8014276:	fa06 f30e 	lsl.w	r3, r6, lr
 801427a:	fa07 f70e 	lsl.w	r7, r7, lr
 801427e:	fa20 f901 	lsr.w	r9, r0, r1
 8014282:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8014286:	40ce      	lsrs	r6, r1
 8014288:	ea49 0903 	orr.w	r9, r9, r3
 801428c:	fbb6 faf8 	udiv	sl, r6, r8
 8014290:	ea4f 4419 	mov.w	r4, r9, lsr #16
 8014294:	fb08 661a 	mls	r6, r8, sl, r6
 8014298:	fa1f fc87 	uxth.w	ip, r7
 801429c:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
 80142a0:	fb0a f20c 	mul.w	r2, sl, ip
 80142a4:	429a      	cmp	r2, r3
 80142a6:	fa00 f40e 	lsl.w	r4, r0, lr
 80142aa:	d90a      	bls.n	80142c2 <__udivmoddi4+0x1be>
 80142ac:	19db      	adds	r3, r3, r7
 80142ae:	f10a 31ff 	add.w	r1, sl, #4294967295
 80142b2:	f080 8087 	bcs.w	80143c4 <__udivmoddi4+0x2c0>
 80142b6:	429a      	cmp	r2, r3
 80142b8:	f240 8084 	bls.w	80143c4 <__udivmoddi4+0x2c0>
 80142bc:	f1aa 0a02 	sub.w	sl, sl, #2
 80142c0:	443b      	add	r3, r7
 80142c2:	1a9b      	subs	r3, r3, r2
 80142c4:	fa1f f989 	uxth.w	r9, r9
 80142c8:	fbb3 f1f8 	udiv	r1, r3, r8
 80142cc:	fb08 3311 	mls	r3, r8, r1, r3
 80142d0:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
 80142d4:	fb01 f60c 	mul.w	r6, r1, ip
 80142d8:	429e      	cmp	r6, r3
 80142da:	d907      	bls.n	80142ec <__udivmoddi4+0x1e8>
 80142dc:	19db      	adds	r3, r3, r7
 80142de:	f101 32ff 	add.w	r2, r1, #4294967295
 80142e2:	d26b      	bcs.n	80143bc <__udivmoddi4+0x2b8>
 80142e4:	429e      	cmp	r6, r3
 80142e6:	d969      	bls.n	80143bc <__udivmoddi4+0x2b8>
 80142e8:	3902      	subs	r1, #2
 80142ea:	443b      	add	r3, r7
 80142ec:	1b9b      	subs	r3, r3, r6
 80142ee:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 80142f2:	e78e      	b.n	8014212 <__udivmoddi4+0x10e>
 80142f4:	f1c1 0e20 	rsb	lr, r1, #32
 80142f8:	fa22 f40e 	lsr.w	r4, r2, lr
 80142fc:	408b      	lsls	r3, r1
 80142fe:	4323      	orrs	r3, r4
 8014300:	fa20 f70e 	lsr.w	r7, r0, lr
 8014304:	fa06 f401 	lsl.w	r4, r6, r1
 8014308:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 801430c:	fa26 f60e 	lsr.w	r6, r6, lr
 8014310:	433c      	orrs	r4, r7
 8014312:	fbb6 f9fc 	udiv	r9, r6, ip
 8014316:	0c27      	lsrs	r7, r4, #16
 8014318:	fb0c 6619 	mls	r6, ip, r9, r6
 801431c:	fa1f f883 	uxth.w	r8, r3
 8014320:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
 8014324:	fb09 f708 	mul.w	r7, r9, r8
 8014328:	42b7      	cmp	r7, r6
 801432a:	fa02 f201 	lsl.w	r2, r2, r1
 801432e:	fa00 fa01 	lsl.w	sl, r0, r1
 8014332:	d908      	bls.n	8014346 <__udivmoddi4+0x242>
 8014334:	18f6      	adds	r6, r6, r3
 8014336:	f109 30ff 	add.w	r0, r9, #4294967295
 801433a:	d241      	bcs.n	80143c0 <__udivmoddi4+0x2bc>
 801433c:	42b7      	cmp	r7, r6
 801433e:	d93f      	bls.n	80143c0 <__udivmoddi4+0x2bc>
 8014340:	f1a9 0902 	sub.w	r9, r9, #2
 8014344:	441e      	add	r6, r3
 8014346:	1bf6      	subs	r6, r6, r7
 8014348:	b2a0      	uxth	r0, r4
 801434a:	fbb6 f4fc 	udiv	r4, r6, ip
 801434e:	fb0c 6614 	mls	r6, ip, r4, r6
 8014352:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
 8014356:	fb04 f808 	mul.w	r8, r4, r8
 801435a:	45b8      	cmp	r8, r7
 801435c:	d907      	bls.n	801436e <__udivmoddi4+0x26a>
 801435e:	18ff      	adds	r7, r7, r3
 8014360:	f104 30ff 	add.w	r0, r4, #4294967295
 8014364:	d228      	bcs.n	80143b8 <__udivmoddi4+0x2b4>
 8014366:	45b8      	cmp	r8, r7
 8014368:	d926      	bls.n	80143b8 <__udivmoddi4+0x2b4>
 801436a:	3c02      	subs	r4, #2
 801436c:	441f      	add	r7, r3
 801436e:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
 8014372:	ebc8 0707 	rsb	r7, r8, r7
 8014376:	fba0 8902 	umull	r8, r9, r0, r2
 801437a:	454f      	cmp	r7, r9
 801437c:	4644      	mov	r4, r8
 801437e:	464e      	mov	r6, r9
 8014380:	d314      	bcc.n	80143ac <__udivmoddi4+0x2a8>
 8014382:	d029      	beq.n	80143d8 <__udivmoddi4+0x2d4>
 8014384:	b365      	cbz	r5, 80143e0 <__udivmoddi4+0x2dc>
 8014386:	ebba 0304 	subs.w	r3, sl, r4
 801438a:	eb67 0706 	sbc.w	r7, r7, r6
 801438e:	fa07 fe0e 	lsl.w	lr, r7, lr
 8014392:	40cb      	lsrs	r3, r1
 8014394:	40cf      	lsrs	r7, r1
 8014396:	ea4e 0303 	orr.w	r3, lr, r3
 801439a:	e885 0088 	stmia.w	r5, {r3, r7}
 801439e:	2100      	movs	r1, #0
 80143a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80143a4:	4613      	mov	r3, r2
 80143a6:	e6f8      	b.n	801419a <__udivmoddi4+0x96>
 80143a8:	4610      	mov	r0, r2
 80143aa:	e6e0      	b.n	801416e <__udivmoddi4+0x6a>
 80143ac:	ebb8 0402 	subs.w	r4, r8, r2
 80143b0:	eb69 0603 	sbc.w	r6, r9, r3
 80143b4:	3801      	subs	r0, #1
 80143b6:	e7e5      	b.n	8014384 <__udivmoddi4+0x280>
 80143b8:	4604      	mov	r4, r0
 80143ba:	e7d8      	b.n	801436e <__udivmoddi4+0x26a>
 80143bc:	4611      	mov	r1, r2
 80143be:	e795      	b.n	80142ec <__udivmoddi4+0x1e8>
 80143c0:	4681      	mov	r9, r0
 80143c2:	e7c0      	b.n	8014346 <__udivmoddi4+0x242>
 80143c4:	468a      	mov	sl, r1
 80143c6:	e77c      	b.n	80142c2 <__udivmoddi4+0x1be>
 80143c8:	3b02      	subs	r3, #2
 80143ca:	443c      	add	r4, r7
 80143cc:	e748      	b.n	8014260 <__udivmoddi4+0x15c>
 80143ce:	4608      	mov	r0, r1
 80143d0:	e70a      	b.n	80141e8 <__udivmoddi4+0xe4>
 80143d2:	3802      	subs	r0, #2
 80143d4:	443e      	add	r6, r7
 80143d6:	e72f      	b.n	8014238 <__udivmoddi4+0x134>
 80143d8:	45c2      	cmp	sl, r8
 80143da:	d3e7      	bcc.n	80143ac <__udivmoddi4+0x2a8>
 80143dc:	463e      	mov	r6, r7
 80143de:	e7d1      	b.n	8014384 <__udivmoddi4+0x280>
 80143e0:	4629      	mov	r1, r5
 80143e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80143e6:	bf00      	nop

080143e8 <__aeabi_idiv0>:
 80143e8:	4770      	bx	lr
 80143ea:	bf00      	nop

080143ec <memcmp>:
 80143ec:	2a03      	cmp	r2, #3
 80143ee:	b470      	push	{r4, r5, r6}
 80143f0:	d926      	bls.n	8014440 <memcmp+0x54>
 80143f2:	ea40 0301 	orr.w	r3, r0, r1
 80143f6:	079b      	lsls	r3, r3, #30
 80143f8:	d011      	beq.n	801441e <memcmp+0x32>
 80143fa:	7804      	ldrb	r4, [r0, #0]
 80143fc:	780d      	ldrb	r5, [r1, #0]
 80143fe:	42ac      	cmp	r4, r5
 8014400:	d122      	bne.n	8014448 <memcmp+0x5c>
 8014402:	4402      	add	r2, r0
 8014404:	1c43      	adds	r3, r0, #1
 8014406:	e005      	b.n	8014414 <memcmp+0x28>
 8014408:	f813 4b01 	ldrb.w	r4, [r3], #1
 801440c:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8014410:	42ac      	cmp	r4, r5
 8014412:	d119      	bne.n	8014448 <memcmp+0x5c>
 8014414:	4293      	cmp	r3, r2
 8014416:	d1f7      	bne.n	8014408 <memcmp+0x1c>
 8014418:	2000      	movs	r0, #0
 801441a:	bc70      	pop	{r4, r5, r6}
 801441c:	4770      	bx	lr
 801441e:	460c      	mov	r4, r1
 8014420:	4603      	mov	r3, r0
 8014422:	681e      	ldr	r6, [r3, #0]
 8014424:	6825      	ldr	r5, [r4, #0]
 8014426:	42ae      	cmp	r6, r5
 8014428:	4618      	mov	r0, r3
 801442a:	4621      	mov	r1, r4
 801442c:	f103 0304 	add.w	r3, r3, #4
 8014430:	f104 0404 	add.w	r4, r4, #4
 8014434:	d1e1      	bne.n	80143fa <memcmp+0xe>
 8014436:	3a04      	subs	r2, #4
 8014438:	2a03      	cmp	r2, #3
 801443a:	4618      	mov	r0, r3
 801443c:	4621      	mov	r1, r4
 801443e:	d8f0      	bhi.n	8014422 <memcmp+0x36>
 8014440:	2a00      	cmp	r2, #0
 8014442:	d1da      	bne.n	80143fa <memcmp+0xe>
 8014444:	4610      	mov	r0, r2
 8014446:	e7e8      	b.n	801441a <memcmp+0x2e>
 8014448:	1b60      	subs	r0, r4, r5
 801444a:	bc70      	pop	{r4, r5, r6}
 801444c:	4770      	bx	lr
 801444e:	bf00      	nop

08014450 <memcpy>:
 8014450:	4684      	mov	ip, r0
 8014452:	ea41 0300 	orr.w	r3, r1, r0
 8014456:	f013 0303 	ands.w	r3, r3, #3
 801445a:	d16d      	bne.n	8014538 <memcpy+0xe8>
 801445c:	3a40      	subs	r2, #64	; 0x40
 801445e:	d341      	bcc.n	80144e4 <memcpy+0x94>
 8014460:	f851 3b04 	ldr.w	r3, [r1], #4
 8014464:	f840 3b04 	str.w	r3, [r0], #4
 8014468:	f851 3b04 	ldr.w	r3, [r1], #4
 801446c:	f840 3b04 	str.w	r3, [r0], #4
 8014470:	f851 3b04 	ldr.w	r3, [r1], #4
 8014474:	f840 3b04 	str.w	r3, [r0], #4
 8014478:	f851 3b04 	ldr.w	r3, [r1], #4
 801447c:	f840 3b04 	str.w	r3, [r0], #4
 8014480:	f851 3b04 	ldr.w	r3, [r1], #4
 8014484:	f840 3b04 	str.w	r3, [r0], #4
 8014488:	f851 3b04 	ldr.w	r3, [r1], #4
 801448c:	f840 3b04 	str.w	r3, [r0], #4
 8014490:	f851 3b04 	ldr.w	r3, [r1], #4
 8014494:	f840 3b04 	str.w	r3, [r0], #4
 8014498:	f851 3b04 	ldr.w	r3, [r1], #4
 801449c:	f840 3b04 	str.w	r3, [r0], #4
 80144a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80144a4:	f840 3b04 	str.w	r3, [r0], #4
 80144a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80144ac:	f840 3b04 	str.w	r3, [r0], #4
 80144b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80144b4:	f840 3b04 	str.w	r3, [r0], #4
 80144b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80144bc:	f840 3b04 	str.w	r3, [r0], #4
 80144c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80144c4:	f840 3b04 	str.w	r3, [r0], #4
 80144c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80144cc:	f840 3b04 	str.w	r3, [r0], #4
 80144d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80144d4:	f840 3b04 	str.w	r3, [r0], #4
 80144d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80144dc:	f840 3b04 	str.w	r3, [r0], #4
 80144e0:	3a40      	subs	r2, #64	; 0x40
 80144e2:	d2bd      	bcs.n	8014460 <memcpy+0x10>
 80144e4:	3230      	adds	r2, #48	; 0x30
 80144e6:	d311      	bcc.n	801450c <memcpy+0xbc>
 80144e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80144ec:	f840 3b04 	str.w	r3, [r0], #4
 80144f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80144f4:	f840 3b04 	str.w	r3, [r0], #4
 80144f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80144fc:	f840 3b04 	str.w	r3, [r0], #4
 8014500:	f851 3b04 	ldr.w	r3, [r1], #4
 8014504:	f840 3b04 	str.w	r3, [r0], #4
 8014508:	3a10      	subs	r2, #16
 801450a:	d2ed      	bcs.n	80144e8 <memcpy+0x98>
 801450c:	320c      	adds	r2, #12
 801450e:	d305      	bcc.n	801451c <memcpy+0xcc>
 8014510:	f851 3b04 	ldr.w	r3, [r1], #4
 8014514:	f840 3b04 	str.w	r3, [r0], #4
 8014518:	3a04      	subs	r2, #4
 801451a:	d2f9      	bcs.n	8014510 <memcpy+0xc0>
 801451c:	3204      	adds	r2, #4
 801451e:	d008      	beq.n	8014532 <memcpy+0xe2>
 8014520:	07d2      	lsls	r2, r2, #31
 8014522:	bf1c      	itt	ne
 8014524:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8014528:	f800 3b01 	strbne.w	r3, [r0], #1
 801452c:	d301      	bcc.n	8014532 <memcpy+0xe2>
 801452e:	880b      	ldrh	r3, [r1, #0]
 8014530:	8003      	strh	r3, [r0, #0]
 8014532:	4660      	mov	r0, ip
 8014534:	4770      	bx	lr
 8014536:	bf00      	nop
 8014538:	2a08      	cmp	r2, #8
 801453a:	d313      	bcc.n	8014564 <memcpy+0x114>
 801453c:	078b      	lsls	r3, r1, #30
 801453e:	d08d      	beq.n	801445c <memcpy+0xc>
 8014540:	f010 0303 	ands.w	r3, r0, #3
 8014544:	d08a      	beq.n	801445c <memcpy+0xc>
 8014546:	f1c3 0304 	rsb	r3, r3, #4
 801454a:	1ad2      	subs	r2, r2, r3
 801454c:	07db      	lsls	r3, r3, #31
 801454e:	bf1c      	itt	ne
 8014550:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8014554:	f800 3b01 	strbne.w	r3, [r0], #1
 8014558:	d380      	bcc.n	801445c <memcpy+0xc>
 801455a:	f831 3b02 	ldrh.w	r3, [r1], #2
 801455e:	f820 3b02 	strh.w	r3, [r0], #2
 8014562:	e77b      	b.n	801445c <memcpy+0xc>
 8014564:	3a04      	subs	r2, #4
 8014566:	d3d9      	bcc.n	801451c <memcpy+0xcc>
 8014568:	3a01      	subs	r2, #1
 801456a:	f811 3b01 	ldrb.w	r3, [r1], #1
 801456e:	f800 3b01 	strb.w	r3, [r0], #1
 8014572:	d2f9      	bcs.n	8014568 <memcpy+0x118>
 8014574:	780b      	ldrb	r3, [r1, #0]
 8014576:	7003      	strb	r3, [r0, #0]
 8014578:	784b      	ldrb	r3, [r1, #1]
 801457a:	7043      	strb	r3, [r0, #1]
 801457c:	788b      	ldrb	r3, [r1, #2]
 801457e:	7083      	strb	r3, [r0, #2]
 8014580:	4660      	mov	r0, ip
 8014582:	4770      	bx	lr

08014584 <memset>:
 8014584:	b470      	push	{r4, r5, r6}
 8014586:	0784      	lsls	r4, r0, #30
 8014588:	d046      	beq.n	8014618 <memset+0x94>
 801458a:	1e54      	subs	r4, r2, #1
 801458c:	2a00      	cmp	r2, #0
 801458e:	d041      	beq.n	8014614 <memset+0x90>
 8014590:	b2cd      	uxtb	r5, r1
 8014592:	4603      	mov	r3, r0
 8014594:	e002      	b.n	801459c <memset+0x18>
 8014596:	1e62      	subs	r2, r4, #1
 8014598:	b3e4      	cbz	r4, 8014614 <memset+0x90>
 801459a:	4614      	mov	r4, r2
 801459c:	f803 5b01 	strb.w	r5, [r3], #1
 80145a0:	079a      	lsls	r2, r3, #30
 80145a2:	d1f8      	bne.n	8014596 <memset+0x12>
 80145a4:	2c03      	cmp	r4, #3
 80145a6:	d92e      	bls.n	8014606 <memset+0x82>
 80145a8:	b2cd      	uxtb	r5, r1
 80145aa:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80145ae:	2c0f      	cmp	r4, #15
 80145b0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80145b4:	d919      	bls.n	80145ea <memset+0x66>
 80145b6:	f103 0210 	add.w	r2, r3, #16
 80145ba:	4626      	mov	r6, r4
 80145bc:	3e10      	subs	r6, #16
 80145be:	2e0f      	cmp	r6, #15
 80145c0:	f842 5c10 	str.w	r5, [r2, #-16]
 80145c4:	f842 5c0c 	str.w	r5, [r2, #-12]
 80145c8:	f842 5c08 	str.w	r5, [r2, #-8]
 80145cc:	f842 5c04 	str.w	r5, [r2, #-4]
 80145d0:	f102 0210 	add.w	r2, r2, #16
 80145d4:	d8f2      	bhi.n	80145bc <memset+0x38>
 80145d6:	f1a4 0210 	sub.w	r2, r4, #16
 80145da:	f022 020f 	bic.w	r2, r2, #15
 80145de:	f004 040f 	and.w	r4, r4, #15
 80145e2:	3210      	adds	r2, #16
 80145e4:	2c03      	cmp	r4, #3
 80145e6:	4413      	add	r3, r2
 80145e8:	d90d      	bls.n	8014606 <memset+0x82>
 80145ea:	461e      	mov	r6, r3
 80145ec:	4622      	mov	r2, r4
 80145ee:	3a04      	subs	r2, #4
 80145f0:	2a03      	cmp	r2, #3
 80145f2:	f846 5b04 	str.w	r5, [r6], #4
 80145f6:	d8fa      	bhi.n	80145ee <memset+0x6a>
 80145f8:	1f22      	subs	r2, r4, #4
 80145fa:	f022 0203 	bic.w	r2, r2, #3
 80145fe:	3204      	adds	r2, #4
 8014600:	4413      	add	r3, r2
 8014602:	f004 0403 	and.w	r4, r4, #3
 8014606:	b12c      	cbz	r4, 8014614 <memset+0x90>
 8014608:	b2c9      	uxtb	r1, r1
 801460a:	441c      	add	r4, r3
 801460c:	f803 1b01 	strb.w	r1, [r3], #1
 8014610:	42a3      	cmp	r3, r4
 8014612:	d1fb      	bne.n	801460c <memset+0x88>
 8014614:	bc70      	pop	{r4, r5, r6}
 8014616:	4770      	bx	lr
 8014618:	4614      	mov	r4, r2
 801461a:	4603      	mov	r3, r0
 801461c:	e7c2      	b.n	80145a4 <memset+0x20>
 801461e:	bf00      	nop
	...

08014640 <strlen>:
 8014640:	f890 f000 	pld	[r0]
 8014644:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8014648:	f020 0107 	bic.w	r1, r0, #7
 801464c:	f06f 0c00 	mvn.w	ip, #0
 8014650:	f010 0407 	ands.w	r4, r0, #7
 8014654:	f891 f020 	pld	[r1, #32]
 8014658:	f040 8049 	bne.w	80146ee <strlen+0xae>
 801465c:	f04f 0400 	mov.w	r4, #0
 8014660:	f06f 0007 	mvn.w	r0, #7
 8014664:	e9d1 2300 	ldrd	r2, r3, [r1]
 8014668:	f891 f040 	pld	[r1, #64]	; 0x40
 801466c:	f100 0008 	add.w	r0, r0, #8
 8014670:	fa82 f24c 	uadd8	r2, r2, ip
 8014674:	faa4 f28c 	sel	r2, r4, ip
 8014678:	fa83 f34c 	uadd8	r3, r3, ip
 801467c:	faa2 f38c 	sel	r3, r2, ip
 8014680:	bb4b      	cbnz	r3, 80146d6 <strlen+0x96>
 8014682:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8014686:	fa82 f24c 	uadd8	r2, r2, ip
 801468a:	f100 0008 	add.w	r0, r0, #8
 801468e:	faa4 f28c 	sel	r2, r4, ip
 8014692:	fa83 f34c 	uadd8	r3, r3, ip
 8014696:	faa2 f38c 	sel	r3, r2, ip
 801469a:	b9e3      	cbnz	r3, 80146d6 <strlen+0x96>
 801469c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 80146a0:	fa82 f24c 	uadd8	r2, r2, ip
 80146a4:	f100 0008 	add.w	r0, r0, #8
 80146a8:	faa4 f28c 	sel	r2, r4, ip
 80146ac:	fa83 f34c 	uadd8	r3, r3, ip
 80146b0:	faa2 f38c 	sel	r3, r2, ip
 80146b4:	b97b      	cbnz	r3, 80146d6 <strlen+0x96>
 80146b6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 80146ba:	f101 0120 	add.w	r1, r1, #32
 80146be:	fa82 f24c 	uadd8	r2, r2, ip
 80146c2:	f100 0008 	add.w	r0, r0, #8
 80146c6:	faa4 f28c 	sel	r2, r4, ip
 80146ca:	fa83 f34c 	uadd8	r3, r3, ip
 80146ce:	faa2 f38c 	sel	r3, r2, ip
 80146d2:	2b00      	cmp	r3, #0
 80146d4:	d0c6      	beq.n	8014664 <strlen+0x24>
 80146d6:	2a00      	cmp	r2, #0
 80146d8:	bf04      	itt	eq
 80146da:	3004      	addeq	r0, #4
 80146dc:	461a      	moveq	r2, r3
 80146de:	ba12      	rev	r2, r2
 80146e0:	fab2 f282 	clz	r2, r2
 80146e4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 80146e8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80146ec:	4770      	bx	lr
 80146ee:	e9d1 2300 	ldrd	r2, r3, [r1]
 80146f2:	f004 0503 	and.w	r5, r4, #3
 80146f6:	f1c4 0000 	rsb	r0, r4, #0
 80146fa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80146fe:	f014 0f04 	tst.w	r4, #4
 8014702:	f891 f040 	pld	[r1, #64]	; 0x40
 8014706:	fa0c f505 	lsl.w	r5, ip, r5
 801470a:	ea62 0205 	orn	r2, r2, r5
 801470e:	bf1c      	itt	ne
 8014710:	ea63 0305 	ornne	r3, r3, r5
 8014714:	4662      	movne	r2, ip
 8014716:	f04f 0400 	mov.w	r4, #0
 801471a:	e7a9      	b.n	8014670 <strlen+0x30>
 801471c:	20515249 	.word	0x20515249
 8014720:	646e6168 	.word	0x646e6168
 8014724:	7372656c 	.word	0x7372656c
 8014728:	6f6f7020 	.word	0x6f6f7020
 801472c:	6564206c 	.word	0x6564206c
 8014730:	74656c70 	.word	0x74656c70
 8014734:	002e6465 	.word	0x002e6465
 8014738:	20515249 	.word	0x20515249
 801473c:	646e6168 	.word	0x646e6168
 8014740:	2072656c 	.word	0x2072656c
 8014744:	65646e69 	.word	0x65646e69
 8014748:	6e692078 	.word	0x6e692078
 801474c:	696c6176 	.word	0x696c6176
 8014750:	00002e64 	.word	0x00002e64
 8014754:	44524148 	.word	0x44524148
 8014758:	4c554146 	.word	0x4c554146
 801475c:	0a212154 	.word	0x0a212154
 8014760:	00000000 	.word	0x00000000
 8014764:	20203072 	.word	0x20203072
 8014768:	38302520 	.word	0x38302520
 801476c:	31722078 	.word	0x31722078
 8014770:	30252020 	.word	0x30252020
 8014774:	72207838 	.word	0x72207838
 8014778:	25202032 	.word	0x25202032
 801477c:	20783830 	.word	0x20783830
 8014780:	20203372 	.word	0x20203372
 8014784:	78383025 	.word	0x78383025
 8014788:	00000a20 	.word	0x00000a20
 801478c:	20323172 	.word	0x20323172
 8014790:	38302520 	.word	0x38302520
 8014794:	726c2078 	.word	0x726c2078
 8014798:	30252020 	.word	0x30252020
 801479c:	70207838 	.word	0x70207838
 80147a0:	25202063 	.word	0x25202063
 80147a4:	20783830 	.word	0x20783830
 80147a8:	20727370 	.word	0x20727370
 80147ac:	78383025 	.word	0x78383025
 80147b0:	00000a20 	.word	0x00000a20
 80147b4:	20207073 	.word	0x20207073
 80147b8:	38302520 	.word	0x38302520
 80147bc:	48000a78 	.word	0x48000a78
 80147c0:	20706165 	.word	0x20706165
 80147c4:	6c706564 	.word	0x6c706564
 80147c8:	64657465 	.word	0x64657465
 80147cc:	250a000a 	.word	0x250a000a
 80147d0:	20703031 	.word	0x20703031
 80147d4:	32302528 	.word	0x32302528
 80147d8:	255b2958 	.word	0x255b2958
 80147dc:	5d583230 	.word	0x5d583230
 80147e0:	2500203a 	.word	0x2500203a
 80147e4:	20583230 	.word	0x20583230
 80147e8:	00          	.byte	0x00
 80147e9:	67          	.byte	0x67
 80147ea:	6e65      	.short	0x6e65
 80147ec:	76637200 	.word	0x76637200
 80147f0:	6e550064 	.word	0x6e550064
 80147f4:	776f6e6b 	.word	0x776f6e6b
 80147f8:	656d206e 	.word	0x656d206e
 80147fc:	67617373 	.word	0x67617373
 8014800:	78252065 	.word	0x78252065
 8014804:	63657220 	.word	0x63657220
 8014808:	65766965 	.word	0x65766965
 801480c:	6e6f2064 	.word	0x6e6f2064
 8014810:	726f7020 	.word	0x726f7020
 8014814:	64252074 	.word	0x64252074
 8014818:	6e49000a 	.word	0x6e49000a
 801481c:	706d6f63 	.word	0x706d6f63
 8014820:	6574656c 	.word	0x6574656c
 8014824:	73656d20 	.word	0x73656d20
 8014828:	65676173 	.word	0x65676173
 801482c:	20782520 	.word	0x20782520
 8014830:	65636572 	.word	0x65636572
 8014834:	64657669 	.word	0x64657669
 8014838:	206e6f20 	.word	0x206e6f20
 801483c:	74726f70 	.word	0x74726f70
 8014840:	0a642520 	.word	0x0a642520
 8014844:	30252800 	.word	0x30252800
 8014848:	29643031 	.word	0x29643031
 801484c:	2067734d 	.word	0x2067734d
 8014850:	25207825 	.word	0x25207825
 8014854:	72662073 	.word	0x72662073
 8014858:	25206d6f 	.word	0x25206d6f
 801485c:	69732873 	.word	0x69732873
 8014860:	2520657a 	.word	0x2520657a
 8014864:	203a2964 	.word	0x203a2964
 8014868:	32302500 	.word	0x32302500
 801486c:	2078      	.short	0x2078
	...

0801486f <__FUNCTION__.8397>:
 801486f:	6573 646e 414b 4343 0000                         sendKACC.

08014878 <masterMap>:
 8014878:	0000 0101 0100 0001                         ........

08014880 <__FUNCTION__.8282>:
 8014880:	6573 646e 5750 6f4d 6666 734d 0067 6e49     sendPWMoffMsg.In
 8014890:	6369 616a 696c 617a 6a63 2061 6c66 7361     icjalizacja flas
 80148a0:	6f68 6177 696e 2061 000a 6c46 7361 6f68     howania ..Flasho
 80148b0:	6177 696e 2065 5453 614d 0a20 4600 616c     wanie STMa ..Fla
 80148c0:	6873 776f 6e61 6569 5320 4148 4352 0a61     showanie SHARCa.
 80148d0:	4600 616c 6873 776f 6e61 6569 5320 4148     .Flashowanie SHA
 80148e0:	4352 2061 617a 6f6b 636e 6f7a 656e 000a     RCa zakonczone..
 80148f0:	7562 0066 7361 6573 7472 6920 206e 7325     buf.assert in %s
 8014900:	2528 2964 203a 7325 000a 3235 7220 6365     (%d): %s..52 rec
 8014910:	6965 6576 0064 7957 616c 7a63 6d61 7a20     eived.Wylaczam z
 8014920:	7361 6c69 6e61 6569 000a 7830 3535 7220     asilanie..0x55 r
 8014930:	7165 6e4f 303d 2d20 4d20 4441 204f 726f     eqOn=0 - MADO or
 8014940:	6564 6572 2064 6c61 206c 4d53 4b4f 7327     dered all SMOK's
 8014950:	6f20 6666 3000 3578 2030 6974 656d 756f      off.0x50 timeou
 8014960:	2074 202d 6361 356b 3d30 0030 6c57 6361     t - ack50=0.Wlac
 8014970:	617a 206d 617a 6973 616c 696e 2065 6f6b     zam zasilanie ko
 8014980:	646e 2520 2078 6873 7261 206b 7825 5020     nd %x shark %x P
 8014990:	4d57 2520 0a78 3000 3578 2030 4341 004b     WM %x..0x50 ACK.
 80149a0:	6361 7571 7269 6465 6420 7461 6761 6172     acquired datagra
 80149b0:	206d 6f63 6e6e 6365 6974 6e6f 6c00 736f     m connection.los
 80149c0:	2074 6164 6174 7267 6d61 6320 6e6f 656e     t datagram conne
 80149d0:	7463 6f69 006e 6f6c 7473 7220 6461 6f69     ction.lost radio
 80149e0:	6320 6e6f 656e 7463 6f69 006e                connection.

080149ec <changeStateMatrix>:
 80149ec:	959d 0800 9581 0800 9561 0800 9545 0800     ........a...E...
 80149fc:	959d 0800 95b9 0800 9829 0800 9809 0800     ........).......
 8014a0c:	959d 0800 464f 2d46 4e3e 0a43 4900 766e     ....OFF->NC..Inv
 8014a1c:	6c61 6469 7320 6174 6574 7220 7165 6575     alid state reque
 8014a2c:	7473 6465 0a2e 4e00 2d43 4f3e 4646 000a     sted...NC->OFF..
 8014a3c:	6c41 6572 6461 2079 6e69 7220 7165 6575     Already in reque
 8014a4c:	7473 6465 7320 6174 6574 0a2e 4f00 4646     sted state...OFF
 8014a5c:	3e2d 4e4f 000a 7755 2079 726f 5520 6577     ->ON..Uwy or Uwe
 8014a6c:	6d20 6165 7573 6572 6620 6961 656c 2164      measure failed!
 8014a7c:	2121 000a 6843 6365 206b 7755 5f65 6176     !!..Check Uwe_va
 8014a8c:	206c 6425 2820 6c61 7261 206d 6425 2029     l %d (alarm %d) 
 8014a9c:	000a 7755 5f65 6176 206c 6f74 6820 6769     ..Uwe_val to hig
 8014aac:	2068 6425 3e20 203d 6425 0a20 4300 6568     h %d >= %d ..Che
 8014abc:	6b63 5520 7977 765f 6c61 2520 2064 6128     ck Uwy_val %d (a
 8014acc:	616c 6d72 2520 2964 0a20 5500 7977 765f     larm %d) ..Uwy_v
 8014adc:	6c61 7420 206f 6968 6867 2520 2064 3d3e     al to high %d >=
 8014aec:	2520 2064 000a 6853 7261 2063 6964 2064      %d ..Sharc did 
 8014afc:	6f6e 2074 6572 7073 6e6f 2064 6e6f 6b20     not respond on k
 8014b0c:	6565 6170 696c 6576 6d20 7365 6173 6567     eepalive message
 8014b1c:	000a 5750 204d 6964 2064 6f6e 2074 6572     ..PWM did not re
 8014b2c:	7073 6e6f 2064 6e6f 6b20 6565 6170 696c     spond on keepali
 8014b3c:	6576 6d20 7365 6173 6567 000a 4e4f 3e2d     ve message..ON->
 8014b4c:	464f 0a46 4f00 2d4e 4e3e 0a43 7000 776f     OFF..ON->NC..pow
 8014b5c:	7265 7320 6174 6574 6320 6168 676e 2065     er state change 
 8014b6c:	6572 7361 6e6f 203a 7325 000a 5750 5f4d     reason: %s..PWM_
 8014b7c:	5453 5441 6520 7272 726f 0a20 5000 4d57     STAT error ..PWM
 8014b8c:	535f 4154 2054 7265 6f72 2072 202d 6f70     _STAT error - po
 8014b9c:	6577 6f72 006e 6843 6365 206b 7755 3d79     weron.Check Uwy=
 8014bac:	3031 5725 7755 2065 7755 2079 203d 6425     10%WUwe Uwy = %d
 8014bbc:	566d 5520 6577 3d20 2520 6d64 0a56 5500     mV Uwe = %dmV..U
 8014bcc:	7977 765f 6c61 2528 6d64 2956 6f20 7475     wy_val(%dmV) out
 8014bdc:	6973 6564 6f20 2066 6c61 6f6c 6577 2064     side of allowed 
 8014bec:	6172 676e 2065 6f63 706d 7261 6465 7420     range compared t
 8014bfc:	206f 7755 2865 6425 566d 2029 3020 302e     o Uwe(%dmV)  0.0
 8014c0c:	2a37 7755 3c65 7755 3c79 2e30 3331 552a     7*Uwe<Uwy<0.13*U
 8014c1c:	6577 0a20 5500 7977 7620 2073 7755 2065     we ..Uwy vs Uwe 
 8014c2c:	6166 6c69 6465 5000 4d57 535f 4154 2054     failed.PWM_STAT 
 8014c3c:	7265 6f72 2072 202d 6c61 7265 0074 5750     error - alert.PW
 8014c4c:	204d 4250 2033 7265 6f72 2072 000a 5750     M PB3 error ..PW
 8014c5c:	204d 4250 2033 7265 6f72 0072 5750 204d     M PB3 error.PWM 
 8014c6c:	4250 2034 7265 6f72 2072 000a 5750 204d     PB4 error ..PWM 
 8014c7c:	4250 2034 7265 6f72 0072 5750 204d 4350     PB4 error.PWM PC
 8014c8c:	3431 6520 7272 726f 0a20 5000 4d57 5020     14 error ..PWM P
 8014c9c:	3143 2034 7265 6f72 0072 5750 204d 4350     C14 error.PWM PC
 8014cac:	3531 6520 7272 726f 0a20 5000 4d57 5020     15 error ..PWM P
 8014cbc:	3143 2035 7265 6f72 0072 5750 204d 4550     C15 error.PWM PE
 8014ccc:	3331 6520 7272 726f 0a20 5000 4d57 5020     13 error ..PWM P
 8014cdc:	3145 2033 7265 6f72 0072 656d 6e61 4c69     E13 error.meaniL
 8014cec:	7420 206f 6968 6867 2520 2064 3d3e 2520      to high %d >= %
 8014cfc:	2064 000a 656d 6e61 4c69 7420 206f 6968     d ..meaniL to hi
 8014d0c:	6867 7400 6941 2072 6f74 6820 6769 2068     gh.tAir to high 
 8014d1c:	6425 252e 2064 3d3e 2520 2e64 6425 0a20     %d.%d >= %d.%d .
 8014d2c:	7400 6941 2072 6f74 6820 6769 0068 4674     .tAir to high.tF
 8014d3c:	5445 7420 206f 6968 6867 2520 2e64 6425     ET to high %d.%d
 8014d4c:	3e20 203d 6425 252e 2064 000a 4674 5445      >= %d.%d ..tFET
 8014d5c:	7420 206f 6968 6867 a500                          to high.

08014d65 <ucExpectedStackBytes.5403>:
 8014d65:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
 8014d75:	a5a5 a5a5 4449 454c 6d00                         ....IDLE.

08014d7e <__FUNCTION__.5527>:
 8014d7e:	6f6d 7564 656c 6154 6b73 6d00                    moduleTask.

08014d89 <__FUNCTION__.5514>:
 8014d89:	6f6d 7564 656c 6553 646e 6f43 6d6d 6e61     moduleSendComman
 8014d99:	0064                                        d.

08014d9b <__FUNCTION__.5536>:
 8014d9b:	6f6d 7564 656c 6e49 7469 6d00 7365 6173     moduleInit.messa
 8014dab:	6567 632e 6d6f 616d 646e 3e20 303d 2620     ge.command >=0 &
 8014dbb:	2026 656d 7373 6761 2e65 6f63 6d6d 6e61     & message.comman
 8014dcb:	2064 203c 6f6d 7564 656c 6154 6b73 6144     d < moduleTaskDa
 8014ddb:	6174 3e2d 6f63 6d6d 6e61 7364 754e 006d     ta->commandsNum.
 8014deb:	6f63 6d6d 6e61 2064 3d3e 2030 2626 6320     command >=0 && c
 8014dfb:	6d6f 616d 646e 3c20 6d20 646f 6c75 5465     ommand < moduleT
 8014e0b:	7361 446b 7461 2d61 633e 6d6f 616d 646e     askData->command
 8014e1b:	4e73 6d75 2800 6f6d 7564 656c 6154 6b73     sNum.(moduleTask
 8014e2b:	6144 6174 3e2d 7571 7565 4865 6e61 6c64     Data->queueHandl
 8014e3b:	2065 203d 5178 6575 6575 7243 6165 6574     e = xQueueCreate
 8014e4b:	6d28 646f 6c75 5465 7361 446b 7461 2d61     (moduleTaskData-
 8014e5b:	713e 6575 6575 654c 676e 6874 202c 6973     >queueLength, si
 8014e6b:	657a 666f 7128 6575 6575 654d 7373 6761     zeof(queueMessag
 8014e7b:	5f65 2974 2929 7800 6154 6b73 6547 656e     e_t))).xTaskGene
 8014e8b:	6972 4363 6572 7461 2865 6f6d 7564 656c     ricCreate(module
 8014e9b:	6154 6b73 202c 7328 6769 656e 2064 6863     Task, (signed ch
 8014eab:	7261 2a20 6d29 646f 6c75 5465 7361 446b     ar *)moduleTaskD
 8014ebb:	7461 2d61 6e3e 6d61 2c65 6d20 646f 6c75     ata->name, modul
 8014ecb:	5465 7361 446b 7461 2d61 733e 6174 6b63     eTaskData->stack
 8014edb:	6953 657a 342f 202c 7628 696f 2064 292a     Size/4, (void *)
 8014eeb:	6f6d 7564 656c 6154 6b73 6144 6174 202c     moduleTaskData, 
 8014efb:	6f6d 7564 656c 6154 6b73 6144 6174 3e2d     moduleTaskData->
 8014f0b:	7270 6f69 6972 7974 202c 554e 4c4c 202c     priority, NULL, 
 8014f1b:	6f6d 7564 656c 6154 6b73 6144 6174 3e2d     moduleTaskData->
 8014f2b:	7473 6361 2c6b 4e20 4c55 294c 3d20 203d     stack, NULL) == 
 8014f3b:	6470 4150 5353 0000 b500                         pdPASS...

08014f44 <commands>:
 8014f44:	b2b5 0800 b29b 0800 b3bd 0800 b295 0800     ................

08014f54 <__FUNCTION__.8069>:
 8014f54:	6c61 456c 6576 746e 0073                    allEvents.

08014f5e <__FUNCTION__.8112>:
 8014f5e:	7773 7469 6863 6f50 7472 7000                    switchPort.

08014f69 <__FUNCTION__.8043>:
 8014f69:	6f70 7472 7852 7000                              portRx.

08014f70 <__FUNCTION__.8027>:
 8014f70:	6f70 7472 7854 6300                              portTx.

08014f77 <__FUNCTION__.7981>:
 8014f77:	6f63 6d6d 7854 6d00                              commTx.

08014f7e <__FUNCTION__.7971>:
 8014f7e:	656d 7373 6761 5465 0078                    messageTx.

08014f88 <__FUNCTION__.8016>:
 8014f88:	6f70 7472 6144 6174 7854 7852 6f43 706d     portDataTxRxComp
 8014f98:	656c 6574 7300                                   lete.

08014f9d <__FUNCTION__.8098>:
 8014f9d:	7773 7469 6863 6f50 7472 6548 706c 7265     switchPortHelper
 8014fad:	0000 2d00                                        ...

08014fb0 <commands>:
 8014fb0:	b92d 0800 b7a9 0800 b5e9 0800 b4d1 0800     -...............
 8014fc0:	4f50 5452 425f 4655 4546 2e52 7872 7542     PORT_BUFFER.rxBu
 8014fd0:	6666 7265 6953 657a 3e20 3020 5000 524f     fferSize > 0.POR
 8014fe0:	5f54 5542 4646 5245 722e 4278 6675 6566     T_BUFFER.rxBuffe
 8014ff0:	0072 6f70 7472 754e 206d 203c 4f50 5452     r.portNum < PORT
 8015000:	5f53 554e 004d 2528 3130 6430 4d29 6773     S_NUM.(%010d)Msg
 8015010:	2520 2078 6573 746e 7420 206f 7325 003a      %x sent to %s:.
 8015020:	5854 425f 4655 4546 5f52 464f 5346 5445     TX_BUFFER_OFFSET
 8015030:	3d20 203d 0030 6f70 7472 6f43 6d6d 6e75      == 0.portCommun
 8015040:	6369 7461 726f 0000 ffff ffff ffff ffff     icator..........
 8015050:	ffff ffff ffff ffff                         ........

08015058 <__FUNCTION__.8414>:
 8015058:	5053 7249 6365 6965 6576 6144 6174 7300          SPIreceiveData.

08015067 <__FUNCTION__.8428>:
 8015067:	7073 4869 6c65 6570 4972 696e 0074          spiHelperInit.

08015075 <__FUNCTION__.8437>:
 8015075:	6865 6669 7453 7261 0074                    ehifStart.

0801507f <__FUNCTION__.8384>:
 801507f:	6863 6365 446b 7461 5261 6165 7964 7200          checkDataReady.

0801508e <__FUNCTION__.8518>:
 801508e:	6172 6964 536f 6e65 0064                    radioSend.

08015098 <__FUNCTION__.8366>:
 8015098:	6573 646e 7542 6666 7265 2500                    sendBuffer.

080150a3 <radioImage>:
 80150a3:	0525 0df0 0000 a180 0000 9985 0000 9985     %...............
 80150b3:	0000 9985 0000 9985 0000 9985 0000 fc7b     ..............{.
 80150c3:	0525 0214 0000 0000 0000 0000 0000 9985     %...............
 80150d3:	0000 9385 0000 0000 0000 d584 0000 4185     ...............A
 80150e3:	0000 9985 0000 9985 0000 9985 0000 9985     ................
 80150f3:	0000 9985 0000 9985 0000 9985 0000 9985     ................
 8015103:	0000 9985 0000 9985 0000 9985 0000 9985     ................
 8015113:	0000 9985 0000 9985 0000 9985 0000 9985     ................
 8015123:	0000 9985 0000 9985 0000 9985 0000 9985     ................
 8015133:	0000 9985 0000 9985 0000 9985 0000 9985     ................
 8015143:	f44f 40c0 f2c2 0000 4685 f000 b801 ffff     O..@.....F......
 8015153:	f44f 5278 2100 f04f 2020 f640 344f 47a0     O.xR.!O.  @.O4.G
 8015163:	f44f 5200 2100 484f 47a0 484f 8801 f421     O..R.!OH.GOH..!.
 8015173:	71a1 8001 211b f8a0 19be f000 f987 484b     .q...!........KH
 8015183:	6800 f000 f8f8 2002 f000 f89a f000 fa1a     .h..... ........
 8015193:	f000 f912 b570 2302 2200 105b 2b01 d103     ....p..#."[..+..
 80151a3:	f811 3b01 f443 7380 07dc 780c d004 1c49     ...;C..s...x..I.
 80151b3:	f800 4b01 1c52 e7f0 1c49 2cf8 da11 f811     ...KR...I..,....
 80151c3:	5b01 f004 0607 ea45 2506 43ed 2603 eb06     .[....E..%.C.&..
 80151d3:	04e4 e003 5d46 f800 6b01 1c52 1e64 d2f9     ....F]...kR.d...
 80151e3:	e7db 4610 bd70 2800 d009 0b41 d008 2901     ...Fp..(..A....)
 80151f3:	d003 2902 d001 2903 d101 f100 5000 4770     ...)...).....PpG
 8015203:	f100 4080 4770 0741 0ec9 08c0 4240 eb01     ...@pGA.....@B..
 8015213:	1040 4927 4408 4770 0741 08c0 0ec9 4240     @.'I.DpGA.....@B
 8015223:	eb01 1040 4922 3180 4408 4770 b570 f44f     ..@."I.1.DpGp.O.
 8015233:	3580 f8d5 20ac 0e11 d032 f895 10ab 29ff     .5... ..2......)
 8015243:	d02e 2902 d32c f44f 717a 4348 30c8 4c19     ...),.O.zqHC.0.L
 8015253:	4b19 2100 f853 6021 4296 d809 eb03 0681     .K.!S.!`.B......
 8015263:	6876 4296 d304 4c14 f8d5 6130 3c48 1b80     vh.B...L..0aH<..
 8015273:	1c89 2904 d3ee 2511 4b10 2100 eb04 0281     ...)...%.K.!....
 8015283:	6812 f502 62af 429a dd03 4282 dc01 4613     .h...b.B...B...F
 8015293:	460d 1c49 2912 d3f1 4807 385c 5d40 bd70     .FI..)...H\8@]p.
 80152a3:	20f5 bd70 0020 0060 0040 4201 0000 f8fb     . p. .`.@..B....
 80152b3:	0042 6044 0100 5801 0000 f8d6 ffff d08a     B.D`...X........
 80152c3:	b510 4601 2000 b672 060a d512 4a6b 7913     ...F. r.....kJ.y
 80152d3:	7954 1b1b f003 031f 2b1c d21f 7910 4b68     Ty.......+...yhK
 80152e3:	eb03 0380 1c40 7110 6019 7910 f000 001f     ....@..q.`.y....
 80152f3:	e012 4a62 1f92 7913 7954 1b1b f003 033f     ..bJ...yTy....?.
 8015303:	2b3c d20b 7910 4b5f eb03 0380 1c40 7110     <+...y_K....@..q
 8015313:	6019 7910 f000 003f 7110 2001 b662 bf40     .`.y..?..q. b.@.
 8015323:	bd10 4856 1f80 7901 7940 1a08 f000 003f     ..VH...y@y....?.
 8015333:	4770 b672 0601 d50a 4950 794a 1e52 714a     pGr.....PIJyR.Jq
 8015343:	794a f002 021f 714a 7949 4a4d e00a 494b     Jy....JqIyMJ..KI
 8015353:	1f89 794a 1e52 714a 794a f002 023f 714a     ..JyR.JqJy..?.Jq
 8015363:	7949 4a48 f842 0021 b662 4770 4943 1fc9     IyHJB.!.b.pGCI..
 8015373:	7008 bf40 4770 e92d 41f0 4d41 4604 483f     .p@.pG-..AAM.F?H
 8015383:	3580 2600 1f80 7106 7146 6006 1d80 7106     .5.&...qFq.`...q
 8015393:	7146 6006 1fc0 7006 4f3b e007 f845 1b04     Fq.`...p;O..E...
 80153a3:	eb07 4004 4788 88a0 1da4 4404 6821 2900     ...@.G.....D!h.)
 80153b3:	d1f4 602e e8bd 81f0 4e30 2500 1fb6 1db7     ...`....0N.%....
 80153c3:	6830 b990 2000 b672 7971 7932 4291 d00a     0h... r.qy2y.B..
 80153d3:	7970 492c eb01 0180 1c40 7170 6808 7971     py,I....@.pq.hqy
 80153e3:	f001 013f 7171 b662 6030 6838 b990 2000     ..?.qqb.0`8h... 
 80153f3:	b672 7979 793a 4291 d00a 7978 4920 eb01     r.yy:y.B..xy I..
 8015403:	0180 1c40 7178 6808 7979 f001 011f 7179     ..@.xq.hyy....yq
 8015413:	b662 6038 f8d6 8000 f1b8 0f00 d011 4c18     b.8`...........L
 8015423:	3480 e005 6830 4788 6030 4540 d104 1d24     .4..0h.G0`@E..$.
 8015433:	6821 2900 d1f6 e002 6820 2800 d1c0 6035     !h.).... h.(..5`
 8015443:	e7be 480e 1fc0 7800 b9b0 f8d7 8000 f1b8     ...H...x........
 8015453:	0f00 d011 4c0a 3480 e005 6838 4788 6038     .....L.4..8h.G8`
 8015463:	4540 d104 1d24 6821 2900 d1f6 e002 6820     @E..$.!h.).... h
 8015473:	2800 d1a5 603d e7a3 bf20 e7a1 0020 f359     .(..=`.. ... .Y.
 8015483:	0020 0061 0020 0060 0600 0100 b510 22a0      .a. .`........"
 8015493:	496b 486c f640 3347 4798 486a f04f 21e0     kIlH@.G3.GjHO..!
 80154a3:	f8c1 0d08 4868 f8c1 0d0c 2000 22b0 1843     ....hH..... ."C.
 80154b3:	f883 2400 1c40 2818 dbf9 2080 f881 0d23     ...$@..(... ..#.
 80154c3:	20d0 f881 0d22 2240 2100 4860 f640 334f     . ..".@".!`H@.O3
 80154d3:	4798 485f 2100 6041 21ff 7001 bd10 4a59     .G_H.!A`.!.p..YJ
 80154e3:	eb02 0080 6401 4770 495a 6808 174a f8c1     .....dpGZI.hJ...
 80154f3:	2080 4770 4b55 f833 2010 b912 f823 1010     . pGUK3.. ..#...
 8015503:	4770 1e40 d2f7 4770 b672 2101 4081 4850     pG@...pGr..!.@PH
 8015513:	6842 4311 6041 4950 f04f 5080 6008 b662     Bh.CA`PIO..P.`b.
 8015523:	4770 b672 4a4a 6851 4301 6051 494a f04f     pGr.JJQh.CQ`JIO.
 8015533:	5080 6008 b662 4770 4b44 4602 f833 0010     .P.`b.pGDK.F3...
 8015543:	f823 1012 4770 4842 f990 0000 4770 2101     #...pGBH....pG.!
 8015553:	4081 4842 6001 4770 f04f 22e0 4410 f880     .@BH.`pGO..".D..
 8015563:	1400 4770 b672 4a37 eb02 0280 6c10 6411     ..pGr.7J.....l.d
 8015573:	b662 4770 b570 4d35 4c35 2601 e017 6860     b.pGp.5M5L.&..`h
 8015583:	fab0 f080 f1c0 001f 7020 b672 7820 fa06     ........ pr. x..
 8015593:	f100 6860 4388 6060 b662 f994 0000 f835     ..`h.C``b.....5.
 80155a3:	0010 b120 f994 0000 f835 0010 4780 6860     .. .....5....G`h
 80155b3:	2800 d1e4 20ff 7020 bd70 b672 4924 8048     .(...  pp.r.$IH.
 80155c3:	b662 4770 f64b 317f f04f 20e0 6141 2107     b.pGK..1O.. Aa.!
 80155d3:	6101 481f 2105 60c1 2100 6081 8041 4770     .a.H.!.`.!.`A.pG
 80155e3:	b510 2004 f7ff fe6c 4c19 68e0 1e40 60e0     ... ..l..L.h@..`
 80155f3:	d11e 2005 60e0 8860 b140 8860 1e40 0400     ... .``.@.`.@...
 8015603:	0c00 8060 d102 f240 105f 4780 68a0 1c40     ..`...@._..G.h@.
 8015613:	60a0 68a0 68a1 0900 0400 f001 010f ea40     .`.h.h........@.
 8015623:	3001 1cc0 f7ff fe4c 490d f04f 7080 6008     .0....L..IO..p.`
 8015633:	bd10 f240 105f 4700 f240 105f 4700 0000     ..@._..G@._..G..
 8015643:	0000 0080 0020 005c fa05 0005 0020 c45a     .... .\..... .Z.
 8015653:	0020 fc59 00e0 00e1 00e0 04ed 00e0 00e2      .Y.............
 8015663:	0040 0805 e92d 5ff0 4605 b2c2 4f79 f8df     @...-.._.F..yO..
 8015673:	81e8 0c00 f640 3a47 2a01 d008 2a1c d07e     ....@.G:.*...*~.
 8015683:	2a3c d043 2a3d d13f 203e e8bd 9ff0 4604     <*C.=*?.> .....F
 8015693:	4872 6078 7da0 b110 2080 f000 f8d1 220b     rHx`.}... ....."
 80156a3:	4621 486d 47d0 2000 f888 000b f898 000a     !FmH.G. ........
 80156b3:	f898 1009 2603 4348 f898 2008 0180 4631     .....&HC... ..1F
 80156c3:	07d2 d100 2102 4348 f000 f8ba f8a8 000c     .....!HC........
 80156d3:	4861 220b f104 010b 300e 47d0 4c5e 340e     aH.".....0.G^L.4
 80156e3:	7aa0 7a61 4348 7a21 0180 07c9 d100 2602     .zazHC!z.......&
 80156f3:	4370 f000 f8a5 81a0 20c3 f000 f8a1 4955     pC....... ....UI
 8015703:	1f09 8008 6878 6038 4628 e7be f7ff fd6b     ....xh8`(F....k.
 8015713:	4681 6838 6078 4850 22fc 2100 301c f640     .F8hx`PH.".!.0@.
 8015723:	384f 47c0 4f4c 2500 371c f04f 0b15 eb05     O8.GLO.%.7O.....
 8015733:	0045 fb05 f60b eb09 0140 eb07 0446 2206     E.......@...F.."
 8015743:	4620 47d0 f817 0016 78a1 4008 28ff d06a      F.G.....x.@.(j.
 8015753:	78e0 2801 d05c 2802 d05a 2804 d05b 2805     .x.(\..(Z..([..(
 8015763:	d115 7920 0140 f000 f86b 8260 f817 0016     .. y@...k.`.....
 8015773:	28ff d003 2030 f000 f863 81a0 e000 e057     .(..0 ..c.....W.
 8015783:	78a0 28ff d003 2026 f000 f85a 81e0 7920     .x.(..& ..Z... y
 8015793:	1dc0 08c0 f000 f854 82a0 7920 1dc0 08c2     ......T... y....
 80157a3:	8aa0 2100 f040 5000 47c0 7920 1dc0 08c0     ...!@..P.G y....
 80157b3:	f000 f846 82e0 7920 1dc0 08c2 8ae0 2100     ..F... y.......!
 80157c3:	f040 5000 47c0 7920 1dc0 08c0 f000 f838     @..P.G y......8.
 80157d3:	8360 7920 1dc0 08c2 8b60 2100 f040 5000     `. y....`..!@..P
 80157e3:	47c0 2010 f000 f82c 8320 b280 2210 f040     .G. ..,. ...."@.
 80157f3:	5000 2180 47c0 f64f 70ff 8120 f817 0016     .P.!.GO..p .....
 8015803:	28ff f814 0f24 f020 0030 d00a 3010 e009     .(..$. .0....0..
 8015813:	7920 0140 e001 7920 0180 f000 f811 8260      y@... y......`.
 8015823:	e7b5 3020 7020 1c6d 2d06 db80 480c e72c     .. 0 pm..-...H,.
 8015833:	2001 0c29 d000 2000 f888 000b 2000 e724     . ).... ..... $.
 8015843:	4a04 4603 6851 1cdb b288 f023 0303 4419     .J.FQh....#....D
 8015853:	6051 4770 0020 105a 0020 a05c 0020 002d     Q`pG .Z. .\. .-.
 8015863:	0100 3e00 e92d 4ff8 4dea 4feb f895 0028     ...>-..O.M.O..(.
 8015873:	f8df a3a8 eb00 0140 48e7 f04f 0b00 6802     ......@..HO....h
 8015883:	f895 0029 eb02 04c1 3420 1d3f f107 0808     ..)..... 4?.....
 8015893:	fa1f f688 b120 2801 d05f 2802 d15b e07d     .... ..(_..([.}.
 80158a3:	7968 79a9 4288 d101 2807 d202 f8a5 b026     hy.y.B...(....&.
 80158b3:	e005 280f d203 8ce8 f420 607c 84e8 f8b5     ...(.... .|`....
 80158c3:	9026 8853 e020 88a0 fa90 f1a0 fab1 f181     &.S. ...........
 80158d3:	eb05 0141 f9b1 100c f511 6f80 d102 f44f     ..A........o..O.
 80158e3:	4180 e001 f44f 5140 ea19 0f00 d001 4208     .A..O.@Q.......B
 80158f3:	d10e f10c 0c01 f00c 00ff f885 0028 eb00     ............(...
 8015903:	0040 eb02 04c0 3420 f895 c028 459c d3da     @..... 4..(..E..
 8015913:	f895 0028 46a9 4298 d104 e8bd 4ff8 2063     ..(..F.B.....Oc 
 8015923:	f7ff bcce 48bc 6822 1d00 2180 ea41 4000     .....H"h...!A..@
 8015933:	9000 b10a f7ff fcc4 6960 b110 9800 f7ff     ........`i......
 8015943:	fcbf 9800 f7ff fcbc 2001 f889 0029 6820     ......... ..). h
 8015953:	b118 e9c7 a000 e8bd 8ff8 68e0 e9c8 0b00     ...........h....
 8015963:	2002 f885 0029 6960 b1c0 48aa 7ae1 380c     . ..).`i...H.z.8
 8015973:	7001 79a1 0909 7041 8046 7ae1 f041 0101     .p.y..ApF..zA...
 8015983:	7101 79a1 f3c1 0103 7141 79a1 eb08 1111     .q.y....Aq.y....
 8015993:	80c1 f8c0 b008 e9c7 a000 e7dc f8df c274     ..............t.
 80159a3:	7ae0 f1ac 0c0c f88c 0000 79a0 f3c0 0103     .z.........y....
 80159b3:	eb01 1010 f88c 0001 f8ac 6002 f8cc b004     ...........`....
 80159c3:	79a0 6961 eb08 1010 6803 400b 6003 6921     .yai.....h.@.`!i
 80159d3:	430b 6003 7921 0689 d51e 88a1 79e2 fa91     .C.`!y.......y..
 80159e3:	f1a1 fab1 f181 eb05 0141 f9b1 100c f3c2     ........A.......
 80159f3:	1641 f1c6 0603 4131 0616 d500 4249 f9b4     A.....1A....IB..
 8015a03:	6008 4431 7aa6 2401 40b4 1e64 400c f3c2     .`1D.z.$.@d..@..
 8015a13:	0104 408c 431c 6004 e9c7 ac00 3528 f885     ...@.C.`....(5..
 8015a23:	b001 7828 1c40 7028 e795 e92d 41f0 4c79     ..(x@.(p..-..AyL
 8015a33:	b2c3 71a0 7961 4299 d106 e8bd 41f0 2018     ...qay.B.....A. 
 8015a43:	ea40 4001 f7ff bc3c 79e0 2800 d146 4872     @..@..<..y.(F.rH
 8015a53:	4e73 f100 0214 4d73 4f73 6800 2903 d020     sN....sMsO.h.) .
 8015a63:	dc07 b161 2901 d139 b95b 69c0 6050 486f     ..a..)9.[..iP`oH
 8015a73:	e02a 2907 d01f 290f d130 6900 e018 6840     *..)...)0..i..@h
 8015a83:	e012 8841 8ca3 eb01 0141 eb00 00c1 3020     ..A.....A..... 0
 8015a93:	e002 4299 d003 1d80 8881 2900 d1f9 6800     ...B.......)...h
 8015aa3:	e00c 2b03 d203 6980 e9c2 6000 e00d 6880     ...+...i...`...h
 8015ab3:	e9c2 7000 e009 2b07 d203 6940 e9c2 5000     ...p...+..@i...P
 8015ac3:	e003 68c0 6050 485a 6010 4853 2180 3014     ...hP`ZH.`SH.!.0
 8015ad3:	ea41 4000 f7ff fbf4 2001 71e0 e8bd 81f0     A..@..... .q....
 8015ae3:	b570 4604 b2c1 f3c0 3203 4d4a 0c00 291a     p..F.....2JM...)
 8015af3:	d02c dc0b 4e48 2901 d013 2904 d041 2919     ,...HN.)...)A..)
 8015b03:	d15b f414 4f70 d02b 484a bd70 291b d022     [...pO+.JHp..)".
 8015b13:	293f d014 2964 d150 06c8 ea40 4014 60a8     ?)..d)P...@..@.`
 8015b23:	e025 6030 f990 0000 2800 db04 2102 f100     %.0`.....(...!..
 8015b33:	4080 f880 1200 2001 f885 002a e03d f3c2     .@..... ..*.=...
 8015b43:	0102 7129 f7ff fb4f 6028 e036 84a8 4610     ..)q..O.(`6....F
 8015b53:	f7ff ff6b e031 f000 f832 f7ff fe83 e02c     ..k.1...2.....,.
 8015b63:	b2c0 2818 d005 281b d101 f7ff fe7b 2000     ...(...(....{.. 
 8015b73:	bd70 2000 71e8 0e20 7168 79a8 f7ff ff55     p.. .q .hq.y..U.
 8015b83:	e7f5 6830 f990 0000 2800 db16 f7ff fb44     ..0h.....(....D.
 8015b93:	7800 b100 2001 6831 7849 4288 d101 2001     .x... 1hIx.B... 
 8015ba3:	e000 2000 f895 102a 4281 d006 f885 002a     ... ..*..B....*.
 8015bb3:	211c ea41 4000 f7ff fb83 4620 bd70 b5f0     .!A..@.... Fp...
 8015bc3:	2700 4d14 4639 84ef 2601 e01c 682a eb01     .'.M9F...&..*h..
 8015bd3:	0341 eb02 0243 7954 fa06 f304 4203 d011     A...C.Ty.....B..
 8015be3:	7813 2bff d101 7893 1d9b 8cea fa06 fc03     .x.+...x........
 8015bf3:	ea42 020c 84ea 68aa eb05 0343 eb02 0244     B......h..C...D.
 8015c03:	8812 819a 1c49 792a 428a dcdf f885 7028     ....I.*y.B....(p
 8015c13:	bdf0 0000 0020 105b 0020 185a 1b00 1900     .... .[. .Z.....
 8015c23:	1801 1900 1803 1900 1807 1900 1800 1900     ................
 8015c33:	180f 1900 0100 0500 48ff 7a01 2900 d012     .........H.z.)..
 8015c43:	2100 7201 6802 6841 6001 6042 f1a0 0324     .!.r.hAh.`B`..$.
 8015c53:	8199 3312 8199 7a41 7391 6840 2152 ea41     ...3..Az.s@hR!A.
 8015c63:	4000 f7ff bb2d 4770 4bf3 b510 3b24 8898     .@..-.pG.K..$;..
 8015c73:	4af2 f44f 61c0 f040 5000 6011 4619 f04f     .JO..a@..P.`.FO.
 8015c83:	4280 f8a2 1902 8984 317e 7a88 895b fb00     .B......~1.z[...
 8015c93:	4303 f8a2 3610 1c40 b2c0 4ae9 7288 7a92     .C...6@....J.r.z
 8015ca3:	4290 d101 2000 7288 2001 7308 bd10 b510     .B... .r. .s....
 8015cb3:	f7ff ffc2 48e0 2100 305a 7301 7b40 f04f     .....H.!Z0.s@{O.
 8015cc3:	24e0 b138 201d f7ff fafb f44f 5040 f8c4     .$8.. ....O.@P..
 8015cd3:	0180 bd10 f44f 60c0 f8c4 0100 bd10 49d6     ....O..`.......I
 8015ce3:	b510 3924 7888 4ad6 1c40 b2c0 7088 7a93     ..$9.x.J@....p.z
 8015cf3:	2200 4298 d100 708a 78c8 4bcf 1c40 b2c0     .".B...p.x.K@...
 8015d03:	70c8 335a 7a5b 4298 d100 70ca f7ff ffcf     .pZ3[z.B...p....
 8015d13:	bd10 4bc9 b510 3b12 8898 4ac8 f44f 61c0     ...K...;...JO..a
 8015d23:	f040 5000 6011 4619 f04f 4280 f8a2 1902     @..P.`.FO..B....
 8015d33:	8984 316c 7ac8 895b fb00 4303 f8a2 3614     ..l1.z[....C...6
 8015d43:	1c40 b2c0 4abf 72c8 7a92 4290 d101 2000     @....J.r.z.B... 
 8015d53:	72c8 2001 7308 bd10 49b7 b510 3912 7888     .r. .s...I...9.x
 8015d63:	4ab8 1c40 b2c0 7088 7a93 2200 4298 d100     .J@....p.z.".B..
 8015d73:	708a 78c8 4bb0 1c40 b2c0 70c8 335a 7a5b     .p.x.K@....pZ3[z
 8015d83:	4298 d100 70ca f7ff ff92 bd10 b5f0 4aaa     .B...p.........J
 8015d93:	2100 325a 7bd4 2615 4bab 4608 2701 fb00     .!Z2.{.&.K.F.'..
 8015da3:	f206 f813 e012 fa07 f50e 4225 d008 eb03     ..........%B....
 8015db3:	0242 7952 fa07 fc02 ea4c 0c01 fa1f f18c     B.Ry....L.......
 8015dc3:	1c40 2806 dbeb 489c 3824 81c1 bdf0 e92d     @..(...H$8....-.
 8015dd3:	5ff0 4605 f8df b260 b2c0 f3c5 3303 ea4f     ._.F..`......3O.
 8015de3:	4a15 f640 344f f04f 0901 f04f 0800 f10b     .J@.O4O...O.....
 8015df3:	075a 281d d07e dc13 4e94 2801 d023 2803     Z..(~....N.(#..(
 8015e03:	d079 2809 d07f 280a d177 b672 0740 f8a0     y..(...(w.r.@...
 8015e13:	8602 7b38 2800 d071 f887 900d b662 e22f     ..8{.(q.....b./.
 8015e23:	2829 d06c 282e d06b 2851 d1ed 2228 f8db     )(l..(k.Q(..("..
 8015e33:	0004 2100 47a0 f88b 9008 7a38 2800 d1ee     ...!.G....8z.(..
 8015e43:	f7ff fefa e21c 4881 f640 416c 1d00 f8c6     .......H@.lA....
 8015e53:	a000 8001 f243 01c4 8041 f24d 016e 8081     ....C...A.M.n...
 8015e63:	497b 487c f7ff f996 f04f 2020 2204 6841     {I|H....O.  ."Ah
 8015e73:	1d00 f640 3347 4798 4c77 f8a4 8300 f2af     ..@.G3.GwL......
 8015e83:	2117 2009 f7ff fb2b f2af 1179 200a f7ff     .!. ..+...y.. ..
 8015e93:	fb26 f2af 11b5 200c f7ff fb21 f2af 1147     &...... ..!...G.
 8015ea3:	200d f7ff fb1c 8820 6832 8ad1 4308 8020     . .... .2h...C .
 8015eb3:	8b10 80e0 8b50 80a0 f5a4 64c0 2000 eb02     ....P......d. ..
 8015ec3:	0140 7c4b b13b 4b65 7c0e 541e 7c49 eb04     @.K|;.eK.|.TI|..
 8015ed3:	0340 f8a3 1608 1c40 2802 ddf0 4856 300a     @.....@..(..VH.0
 8015ee3:	f8cb 0000 f100 0128 f8cb 1004 3956 8188     ......(.....V9..
 8015ef3:	3112 e006 e172 e1c6 e005 e23c e168 e18a     .1..r.....<.h...
 8015f03:	e18e 8188 e241 484c 2101 3824 7001 f8df     ....A.LH.!$8.p..
 8015f13:	c130 4a53 f89c 1008 f89c e009 ea4f 79c1     0.SJ........O..y
 8015f23:	4949 2503 8812 b289 f1b9 0f00 d101 f04f     II.%..........O.
 8015f33:	0502 fb0e fe05 f00e 05ff f880 e001 ea4f     ..............O.
 8015f43:	1585 8145 4d3e 8085 80c1 8102 d002 f04f     ..E.>M........O.
 8015f53:	0507 e000 2500 4838 f8df e0e8 3824 7405     .....%8H....$8.t
 8015f63:	3012 f880 8000 f89e c009 f89e e008 2503     .0.............%
 8015f73:	ea5f 7ece d100 2502 fb0c fc05 f00c 05ff     _..~...%........
 8015f83:	f880 c001 01ad 8145 4d2e 8085 80c1 8102     ......E..M......
 8015f93:	f8a0 800e 6831 4e2c 7f49 4319 7401 78f2     ....1h,NI..C.t.x
 8015fa3:	2101 2a04 d002 2a05 d000 2104 7932 4822     .!.*...*...!2y"H
 8015fb3:	fbb2 f2f1 4920 3812 315a 724a 2104 7441     .... I.8Z1Jr.!At
 8015fc3:	3012 f880 8009 f04f 0900 2515 fb09 fb05     .0....O....%....
 8015fd3:	eb06 074b f8a7 a006 78f8 2804 d07e 2805     ..K......x.(~..(
 8015fe3:	d115 481a 1d00 8178 f816 001b 28ff d005     ...H..x......(..
 8015ff3:	89b8 2230 f040 5000 2100 47a0 78b8 28ff     ..0"@..P.!.G.x.(
 8016003:	d005 89f8 2226 f040 5000 2100 47a0 f816     ....&"@..P.!.G..
 8016013:	001b 28ff d105 7878 28ff d102 78b8 28ff     ...(..xx.(...x.(
 8016023:	d003 4905 7a48 1c40 7248 f887 901d f897     ...IHz@.Hr......
 8016033:	0024 f040 00c0 e015 0020 605b 00e0 80e1     $.@..... .[`....
 8016043:	0020 a05c 0020 ae5c 0020 bc5c 0020 345a      .\. .\. .\. .Z4
 8016053:	0000 15d7 0020 0020 0040 0006 0040 0a02     .... . .@...@...
 8016063:	0020 0c5a f887 0024 201f 8438 f109 0901      .Z...$.. 8.....
 8016073:	8478 f1b9 0f06 dba9 f7ff fe88 4ac8 49c9     x............J.I
 8016083:	8993 81cb f8df c320 f8bc 000c 8248 273f     ...... .....H.?'
 8016093:	800f f8df a318 f8ba 700a 443b 81cb f10a     .........p;D....
 80160a3:	0912 f8b9 300a 18c7 824f 7a92 2102 fbb1     .....0..O..z.!..
 80160b3:	f7f2 fb02 1217 f109 076c 72ba f88a 8002     ........l..r....
 80160c3:	f89c 200a f040 5000 fbb1 fcf2 fb02 111c     ... @..P........
 80160d3:	72f9 435a f889 8002 2100 e000 e003 47a0     .rZC.....!.....G
 80160e3:	f04f 0b00 e025 88f8 21c8 4ab1 4341 fbb2     O...%....!.JAC..
 80160f3:	f1f1 292d d900 212d 72b9 f8a7 800c f887     ..-)..-!.r......
 8016103:	800b f8a7 800e f5b0 6fa0 d008 f5a0 60c0     .........o.....`
 8016113:	384b d007 2899 d108 f44f 70b8 e007 f24c     K8...(..O..p..L.
 8016123:	0070 e004 f24d 0070 e001 f44f 705c 8238     p...M.p...O.\p8.
 8016133:	e76d 49a0 fb0b f005 eb01 0640 f886 801c     m..I......@.....
 8016143:	8ab0 b130 7931 f040 5000 1dc9 08ca 2100     ..0.1y@..P.....!
 8016153:	47a0 8af0 b130 7931 f040 5000 1dc9 08ca     .G..0.1y@..P....
 8016163:	2100 47a0 f10b 0b01 f1bb 0f06 dbe1 f887     .!.G............
 8016173:	800d 4991 f44f 5058 f8c1 01fc 67c8 b672     ...IO.XP.....gr.
 8016183:	4888 3020 8981 8802 f021 013f 31ff fbb1     .H 0....!.?..1..
 8016193:	f3f2 fb02 1113 8041 8081 8841 8802 1c49     ......A...A...I.
 80161a3:	fbb1 f3f2 fb02 1113 0989 f88a 1003 8881     ................
 80161b3:	8800 3181 fbb1 f2f0 fb00 1012 0980 f889     ...1............
 80161c3:	0003 b662 2002 7238 487c f7ff f879 e057     ..b.. 8r|H..y.W.
 80161d3:	4979 f44f 5058 31fc 6008 b662 2500 4e75     yIO.XP.1.`b..%uN
 80161e3:	f04f 0915 fb05 f009 f816 1010 29ff d009     O............)..
 80161f3:	eb06 0040 7901 8a80 1dc9 08ca f040 5000     ..@..y......@..P
 8016203:	2100 47a0 1c6d 2d06 dbec f887 8008 200b     .!.Gm..-....... 
 8016213:	f7ff f856 e614 4865 3012 f880 a011 e02f     ..V...eH.0..../.
 8016223:	0e2e f00a 05ff 2000 fa09 f400 4234 d022     ....... ....4B".
 8016233:	fa03 f200 b2e1 b2d2 b95d 183c f884 8010     ........].<.....
 8016243:	7bbc 438c 4314 73bc 7bfc 438c 4314 73fc     .{.C.C.s.{.C.C.s
 8016253:	e011 7bfc 400c 4294 d103 183c f884 8010     ...{.@.B..<.....
 8016263:	e005 7bbc 400c 4294 d005 183c 7425 7bbc     ...{.@.B..<.%t.{
 8016273:	438c 4314 73bc 1c40 2806 dbd5 f7ff fd86     .C.C.s@..(......
 8016283:	2000 e8bd 9ff0 7bfb 2000 1839 7c0a b162     . .....{. 9..|b.
 8016293:	1e52 f012 02ff 740a d107 7bfa fa09 f100     R......t...{....
 80162a3:	7bbc 438a 400c 4322 73fa 1c40 2806 dbec     .{.C.@"C.s@..(..
 80162b3:	7bf8 4298 d001 f7ff fd69 2101 7a38 460c     .{.B....i..!8z.F
 80162c3:	f04f 3bff 2802 d122 f8df e0e8 2000 f04f     O..;.("...... O.
 80162d3:	0a15 fb00 f30a eb0e 0243 f892 c002 f1bc     ........C.......
 80162e3:	0fff d006 8c12 464b 2a1e d800 2300 4019     ......KF.*...#.@
 80162f3:	e009 f81e 3013 2bff d005 8c12 464b 2a1e     .....0.+....KF.*
 8016303:	d800 2300 401c 1c40 2806 dbe2 b1b1 6878     ...#.@@..(....xh
 8016313:	1c40 6078 d101 f8c7 b004 6831 6878 684a     @.x`......1hxhJh
 8016323:	4290 d104 204d f7fe ffcb 2021 e003 68c9     .B..M ....! ...h
 8016333:	4288 d10e 4822 f7fe ffc3 e00a 6830 68c0     .B.."H......0h.h
 8016343:	b128 6879 4281 d302 481e f7fe ffb9 f8c7     (.yh.B...H......
 8016353:	8004 b1c4 6838 1c40 6038 d101 f8c7 b000     ....8h@.8`......
 8016363:	6831 6838 680a 4290 d106 204d f7fe ffa8     1h8h.h.B..M ....
 8016373:	2021 f7fe ffa5 e008 6889 4288 d105 480b     ! .......h.B...H
 8016383:	f880 9011 e001 f8c7 8000 4628 e779 4907     ..........(Fy..I
 8016393:	0002 f101 017e 6808 d100 6848 4770 0000     ....~..h..HhpG..
 80163a3:	0020 a05c 0040 0206 0020 ae5c 0020 3c5b      .\.@... .\. .[<
 80163b3:	e200 0090 0020 bc5c 00e0 84e0 0200 0b00     .... .\.........
 80163c3:	0400 2c30 0500 2c30 e92d 5ff0 f8df 8484     ..0,..0,-.._....
 80163d3:	2400 f898 004c 46a2 b110 f8d8 0020 b918     .$..L..F.... ...
 80163e3:	f888 a018 e8bd 9ff0 2700 f04f 0901 f640     .........'O...@.
 80163f3:	3b47 e04d 2500 f8d8 1020 fa09 f005 f8b1     G;M..%.. .......
 8016403:	100d 4208 d040 f8d8 0024 eb07 0147 2205     ...B@...$...G.."
 8016413:	eb02 0241 5c82 42aa d136 eb00 0141 eb04     ..A..\.B6...A...
 8016423:	0044 eb08 0640 f106 0028 2206 47d8 220f     D...@...(..".G."
 8016433:	f8d8 0020 eb05 71d5 eb02 0161 5c42 4650     .. ....q..a.B\PF
 8016443:	4651 07eb d100 2104 40ca f002 0107 f361     QF.....!.@....a.
 8016453:	0007 f886 002b 2801 d00f 2802 d00d 2804     ....+..(...(...(
 8016463:	d001 2805 d110 f8d8 0020 8b40 f3c0 000b     ...(.... .@.....
 8016473:	0980 f886 002c 1c64 e006 f8d8 0020 8b40     ....,.d..... .@.
 8016483:	f3c0 000b 0900 e7f4 1c6d 2d10 dbb3 1c7f     ........m..-....
 8016493:	f898 004c 42b8 dcad e008 eb04 0044 eb08     ..L..B......D...
 80164a3:	0040 3028 2206 49ec 47d8 1c64 2c06 dbf4     @.(0.".I.Gd..,..
 80164b3:	f888 9018 e796 e92d 41f0 4de6 6928 2800     ......-..A.M(i.(
 80164c3:	d17e 7ea8 2700 b130 76af 6868 68a9 4008     ~..~.'0..vhh.h.@
 80164d3:	49e2 4008 6068 7ee8 b130 76ef 6868 68a9     .I.@h`.~0..vhh.h
 80164e3:	4008 f000 7080 6068 7f68 2401 b148 7fa8     .@...ph`h..$H...
 80164f3:	b938 78e8 0900 d104 77ac f243 004c f7fe     8..x.....wC.L...
 8016503:	fedf 6828 6869 4288 d001 6868 e00a 68a8     ..(hih.B..hh...h
 8016513:	4281 d106 2800 d153 e8bd 41f0 48d0 f7fe     .B...(S....A.H..
 8016523:	becf 6068 4ecf 6030 7828 07c1 d103 78f1     ..h`.N0`(x.....x
 8016533:	f021 010f 70f1 0780 d504 78f0 f020 000f     !....p.....x ...
 8016543:	1c40 70f0 78e8 0701 d10a 8aa9 b919 78f1     @..p.x.........x
 8016553:	f021 010f 70f1 7831 0789 d504 7034 e002     !....p1x....4p..
 8016563:	7831 07c9 d0fa 78f1 070a d005 7f6a b91a     1x.....x....j...
 8016573:	8aea b10a 7e6a b912 f021 01f0 70f1 78aa     ....j~..!....p.x
 8016583:	b912 7f29 b101 70b7 78f1 090b d001 7e2b     ..)....p.x....+~
 8016593:	b90b 70b7 e001 78b3 b903 7077 f8d6 3001     ...p...x..wp...0
 80165a3:	f8d5 7001 0a1b ebb3 2f17 d92d 070b d008     ...p...../-.....
 80165b3:	0703 d106 8aa9 f24b 000c eb00 4001 e040     ......K......@@.
 80165c3:	e051 0909 d007 0900 d105 8ae8 f249 010c     Q...........I...
 80165d3:	eb01 4000 e035 78b0 b130 b92a 489d 3028     ...@5..x0.*..H(0
 80165e3:	213c ea41 4000 e01c 7870 b368 7868 bb58     <!A..@..pxh.hxX.
 80165f3:	6a29 8aa8 f891 103d 0400 f001 010f ea40     )j....=.......@.
 8016603:	3001 f040 0009 e004 7873 b933 786b b123     .0@.....sx3.kx#.
 8016613:	200a f7fe fe55 746c e016 78b3 b92b b122     . ..U.lt...x+.".
 8016623:	203d f7fe fe4d 74ac e00e 090a d104 0902     = ..M..t........
 8016633:	d002 f24b 000d e004 0709 d105 0700 d003     ..K.............
 8016643:	200d f7fe fe3d 74ec 7830 7829 4288 d00a     . ..=..t0x)x.B..
 8016653:	8aa9 f000 000f 0409 ea41 3000 f040 001a     ........A..0@...
 8016663:	f7fe fe2e 742c e8bd 81f0 e92d 41f0 4605     ....,t....-..A.F
 8016673:	b2c1 f04f 5000 4c77 ea40 4215 2700 2601     ..O..PwL@..B.'.&
 8016683:	8aa3 0c28 2915 d061 dc1e 290b d079 dc0f     ..(..)a....)y...
 8016693:	2901 d032 2908 d135 7fe0 b908 f884 704c     .)2..)5.......Lp
 80166a3:	6222 8b10 f3c0 000b 4283 d142 76a6 e041     "b.......BB..vA.
 80166b3:	290e d067 2912 d125 f415 4f70 d122 76a6     .)g..)%...pO"..v
 80166c3:	7667 f7ff fef8 e01d f3c5 4207 293e d06f     gv.........B>)o.
 80166d3:	dc0a 2918 d06d 2926 d114 2806 d274 e8df     ...)m.&)...(t...
 80166e3:	f000 7173 6f71 6a6c 293f d00d 2948 d109     ..sqqolj?)..H)..
 80166f3:	7762 b1ba 76a6 77a7 e018 6801 60e1 8880     bw...v.w...h.`..
 8016703:	82a0 7726 4628 e7ae f3c5 3103 f3c1 0202     ..&w(F.....1....
 8016713:	f884 204c 08c9 77e1 f7fe fd65 6260 f7ff     ..L ...w..e.`b..
 8016723:	fe53 e07d f243 004c f7fe fdca f7ff fec3     S.}.C.L.........
 8016733:	e03c 76e6 7666 8b10 f3c0 000b 82a0 8b50     <..vfv........P.
 8016743:	f3c0 000b 82e0 f7ff fe3f e7ba 8b10 f3c0     ........?.......
 8016753:	000b 4283 d105 8b55 8ae1 f3c5 050b 42a9     ...B..U........B
 8016763:	d011 4283 d101 76a6 e000 76e6 8b10 f3c0     ...B...v...v....
 8016773:	000b 82a0 8b50 f3c0 000b 82e0 f7ff fe24     ....P.........$.
 8016783:	e7d4 e058 e02d 7b10 07c0 d00f 7e10 0901     ..X.-..{.....~..
 8016793:	4834 1d00 7101 f8b2 1023 8001 f8b2 1021     4H...q..#.....!.
 80167a3:	8041 210f ea41 4000 f7fe fd8a 2000 e75a     A..!A..@..... Z.
 80167b3:	e038 e048 e008 482c e000 482c 60a0 e00b     8.H...,H..,H.`..
 80167c3:	482b e7fb 68e0 e7f9 6820 b908 6920 b110     +H...h.. h.. i..
 80167d3:	4828 f7fe fdae 60a7 6860 68a1 4008 6060     (H.....``h.h.@``
 80167e3:	e76f 491c 280b 78c9 f021 020f d014 dc05     o..I.(.x!.......
 80167f3:	b170 2801 d014 2809 d1a7 e004 280c d00a     p..(...(.....(..
 8016803:	280d d1a2 76a6 f021 00f0 3010 70e0 e000     .(...v!....0.p..
 8016813:	70e2 74e7 e755 76e6 1c52 f022 00f0 e7f5     .p.tU..vR.".....
 8016823:	76a6 e74e ebb6 4f15 d101 2001 e000 2000     .vN....O... ... 
 8016833:	70a0 74a7 e745 2002 ebb0 4f15 d000 2600     .p.tE.. ...O...&
 8016843:	7066 7467 e73d 7022 7427 e73a 4901 7708     fpgt=."p't:..I.w
 8016853:	e631 0000 0020 d461 0000 a8e0 000f 0100     1... .a.........
 8016863:	0100 2400 0020 3e5a 010f 1101 0107 1101     ...$ .Z>........
 8016873:	0103 1101 0100 2410 48fd 4770 b672 4afd     .......$.HpGr..J
 8016883:	80d1 8010 49fc 1450 8088 b662 4770 b672     .....IP...b.pGr.
 8016893:	4af8 80d1 8010 49f8 1410 8088 b662 4770     .J.....I....b.pG
 80168a3:	b672 2000 49f3 8008 80c8 49f3 8088 b662     r.. .I.....I..b.
 80168b3:	4770 b672 2112 48ef 3008 80c1 49ee 3112     pGr..!.H.0...I.1
 80168c3:	8001 20ff 3912 8008 b662 4770 b510 4cea     ... .9..b.pG...L
 80168d3:	7ae0 7b21 0240 ea40 2001 79a1 4308 49e5     .z!{@.@.. .y.C.I
 80168e3:	1e89 8008 48e5 6800 f990 0008 2800 db0a     .....H.h.....(..
 80168f3:	f7fe fc89 79a2 79e3 2101 421a d000 2100     .....y.y.!.B...!
 8016903:	7a22 4051 7001 bd10 b510 b672 4ada 7991     "zQ@.p....r..J.y
 8016913:	4301 7191 f7ff ffda b662 bd10 b510 b672     .C.q....b.....r.
 8016923:	4ad5 7991 4381 7191 f7ff ffd0 b662 bd10     .J.y.C.q....b...
 8016933:	b510 460c 21b0 4620 f240 126d 4790 2118     ...F.! F@.m..G.!
 8016943:	4620 f7ff ff9b 2001 bd10 4608 b500 49cc      F..... ...F...I
 8016953:	6809 6001 49c9 6809 680a 6042 6849 6081     .h.`.I.h.hB`Ih.`
 8016963:	210c f7ff ff8b 2001 bd00 b510 b672 7801     .!..... ....r..x
 8016973:	f3c1 0200 49c0 720a 7840 71c8 f7ff ffa6     .....I.r@x.q....
 8016983:	b662 2001 bd10 48bc b510 3012 7800 f000     b.. ...H...0.x..
 8016993:	003f f7ff ffc3 2001 bd10 b510 7800 460c     ?...... .....x.F
 80169a3:	f3c0 0001 f001 f80d 6020 2104 4620 f7ff     ........ `.! F..
 80169b3:	ff65 2001 bd10 b510 f8d0 1001 48ae 3012     e.. .........H.0
 80169c3:	7800 f3c0 0001 f001 f814 2020 f7fe fcb1     .x........  ....
 80169d3:	2001 bd10 b510 2013 ea40 4001 f7fe fc70     . ..... @..@..p.
 80169e3:	2000 bd10 b510 2051 f7fe fc6a 2000 bd10     . ....Q ..j.. ..
 80169f3:	b510 7800 2129 ea41 4000 f7fe fc61 2001     ...x)!A..@..a.. 
 8016a03:	bd10 b538 7801 295f d102 6801 0209 d003     ..8..x_)...h....
 8016a13:	2010 f7ff ff79 e00e 6801 f990 0004 f341     . ..y....h....A.
 8016a23:	0117 f361 201f 9000 4b96 2201 4990 4668     ..a.. ...K.".IhF
 8016a33:	f240 24bb 47a0 2001 bd38 b510 460c 2204     @..$.G. 8....F."
 8016a43:	498b 4620 f640 3347 4798 2104 4620 f7ff     .I F@.G3.G.! F..
 8016a53:	ff15 2001 bd10 b510 2053 ea40 4001 f7fe     ... ....S @..@..
 8016a63:	fc2f 2000 bd10 b510 4604 f000 fc41 4a82     /.. .....F..A..J
 8016a73:	f8c2 000e b188 7821 f3c1 0300 7801 f363     ......!x.....xc.
 8016a83:	0100 7001 f8d4 1001 f8c0 1001 8811 70d1     ...p...........p
 8016a93:	1d40 2120 f7ff fefb e002 2010 f7ff ff34     @. !....... ..4.
 8016aa3:	2001 bd10 b510 460c 2001 bf00 b1b8 f000     . .....F. ......
 8016ab3:	fc4e 4971 f8c1 000e b130 880a 70ca 7801     N.qI....0....p.x
 8016ac3:	2205 eb02 0151 e007 2205 2100 4620 f640     ."..Q....".! F@.
 8016ad3:	334f 4798 2105 4620 f7ff fed0 e002 2010     O3.G.! F....... 
 8016ae3:	f7ff ff12 2001 bd10 b510 7800 2805 d805     ..... .....x.(..
 8016af3:	2121 ea41 4000 f7fe fbe3 e002 2010 f7ff     !!A..@....... ..
 8016b03:	ff03 2001 bd10 b510 460c 2001 f7ff fc3f     ... .....F. ..?.
 8016b13:	6020 2000 f7ff fc3b 6060 f003 fc94 60a0      `. ..;.``.....`
 8016b23:	f001 f897 81a0 210e 4620 f7ff fea7 2001     .......! F..... 
 8016b33:	bd10 b510 4604 7800 f020 000c 7020 4852     .....F.x ... pRH
 8016b43:	f7fe fbf7 2030 ea40 4004 f7fe fbf2 2000     ....0 @..@..... 
 8016b53:	bd10 b510 7800 460c f3c0 0200 f3c0 0140     .....x.F......@.
 8016b63:	f3c0 0083 f001 fb5a 8020 2102 4620 f7ff     ......Z. ..! F..
 8016b73:	fe85 2001 bd10 4608 493e b500 39fe 6809     ... ...F>I...9.h
 8016b83:	090a 8841 f362 010e 8041 2104 f7ff fe76     ..A.b...A..!..v.
 8016b93:	2001 bd00 b510 214b ea41 4000 f7fe fb90     . ....K!A..@....
 8016ba3:	2000 bd10 b510 f8d0 1002 b121 f241 014b     . ........!.A.K.
 8016bb3:	eb01 4000 e001 f242 004b f7fe fb81 2000     ...@..B.K...... 
 8016bc3:	bd10 e92d 5ff0 f8df 90b0 2500 4683 462c     ..-.._.....%.F,F
 8016bd3:	f1a9 0924 f640 3a47 f81b 6004 2eff d01a     ..$.@.G:...`....
 8016be3:	2d06 db04 2010 f7ff fe8f 2500 e016 eb05     .-... .....%....
 8016bf3:	0845 491f eb09 0048 2206 4607 1d09 47d0     E..I..H..".F...G
 8016c03:	2c09 dd02 f809 6018 e000 70be 2000 f364     .,.....`...p. d.
 8016c13:	0007 7178 1c6d 1c64 2c10 dbdd 462c e008     ..xqm.d..,..,F..
 8016c23:	4913 eb04 0044 2206 eb09 0040 1d09 47d0     .I..D.."..@....G
 8016c33:	1c64 2c06 dbf4 4810 f005 010f 3824 0400     d..,...H....$8..
 8016c43:	ea40 3001 f040 003f f7fe fb3a 2001 e8bd     @..0@.?...:.. ..
 8016c53:	9ff0 b510 4604 7800 f3c0 01c2 f3c0 0002     .....F.x........
 8016c63:	4408 2807 d912 2010 f7ff fe4e 2001 bd10     .D.(... ..N.. ..
 8016c73:	0000 b0e0 0040 2203 0020 4662 0020 485a     ....@.." .bF .ZH
 8016c83:	0100 ac00 0525 3713 0200 5700 48e5 f7fe     ....%..7...W.H..
 8016c93:	fb50 201e ea40 4004 f7fe fb4b 2000 e7e6     P.. @..@..K.. ..
 8016ca3:	b510 4ae1 8810 28ff d006 7990 f040 0010     ...J...(...y@...
 8016cb3:	7190 f7ff fe0b e7da 48dc 8841 8011 8800     .q.......HA.....
 8016cc3:	7090 8890 b138 f7ff fdeb 7990 f040 0010     .p..8......y@...
 8016cd3:	7190 f7ff fdfb e8bd 4010 205e f7fe baf0     .q.......@^ ....
 8016ce3:	b510 f04f 4280 f8b2 0320 4ccf f400 41c0     ..O..B.. ..L...A
 8016cf3:	4620 88a3 7980 4299 f040 0010 d003 71a0      F...y.B@......q
 8016d03:	f7ff fde4 e00b 78e1 2904 d00b 2905 d104     .......x.)...)..
 8016d13:	f8d4 000e b108 f000 fb28 2000 70e0 f7ff     ........(.. .p..
 8016d23:	fdbf e7a4 f8b2 1328 b141 f8d4 000e 7802     ......(.A......x
 8016d33:	f361 0247 7002 f000 faea e7ee 71a0 f7ff     a.G..p.......q..
 8016d43:	fdc5 e7ea e92d 41f0 4eb7 b2c2 0c05 8833     ....-..A.N....3.
 8016d53:	4604 f3c0 3103 2a26 d079 dc1f 2a14 d077     .F...1&*y....*w.
 8016d63:	dc14 4fb3 f04f 0801 2a01 d046 2a02 d071     ...OO....*F..*q.
 8016d73:	2a12 d16b b2c8 7371 2808 d003 280d d001     .*k...qs.(...(..
 8016d83:	f04f 0800 f886 800c 2000 e0c2 2a16 d079     O........ ...*y.
 8016d93:	2a1a d07d 2a1b d1ec 2008 e0ba 2a54 d073     .*}..*... ..T*s.
 8016da3:	dc0d f04f 5000 ea40 4014 2a46 d06d 2a47     ..O..P@..@F*m.G*
 8016db3:	d06c 2a52 d1dd 2b11 d169 2128 e0a1 2a57     l.R*...+i.(!..W*
 8016dc3:	d071 2a5e d070 2a82 d1d3 f2af 112b 2006     q.^*p..*....+.. 
 8016dd3:	f7fe fb85 f2af 01f7 2007 f7fe fb80 21b0     ......... .....!
 8016de3:	2006 f7fe fbb9 21a0 2007 f7fe fbb5 4991     . .....!. .....I
 8016df3:	20c0 f8c1 01fc 67c8 e071 2000 f04f 4180     . .....gq.. O..A
 8016e03:	603d f8a1 0320 7aa8 71f0 7a68 7230 f995     =`.. ..z.qhz0r..
 8016e13:	0008 2800 db10 f7fe f9f6 6839 7a49 b109     ...(......9hIz..
 8016e23:	f04f 0800 f880 8000 6838 2104 f990 0008     O.......8h.!....
 8016e33:	f100 4080 f880 1200 6838 f990 000b 2800     ...@....8h.....(
 8016e43:	db69 2102 f100 4080 f880 1200 e063 e02c     i..!...@....c.,.
 8016e53:	e048 e7ff 6838 f990 000b 2800 db0b f7fe     H...8h.....(....
 8016e63:	f9db 7800 b938 683a f992 100b f992 000c     ...x8.:h........
 8016e73:	320d f000 f878 2000 f000 f8e6 2082 f7fe     .2..x.. ..... ..
 8016e83:	fa1f e048 e040 e003 e030 e011 e017 e025     ..H.@...0.....%.
 8016e93:	f8b6 0009 ebb0 4f14 d03d 2001 f7ff fd34     .......O=.. ..4.
 8016ea3:	f8a6 5009 e037 e00f e038 72f5 2004 e030     ...P7...8..r. 0.
 8016eb3:	2b08 d130 221c 4351 f7ff fce0 e001 2b09     .+0.."QC.......+
 8016ec3:	d129 f7ff fcf6 e026 2d01 d004 2d02 d006     ).....&..-...-..
 8016ed3:	2d03 d146 e003 2002 f7ff fd16 e041 f7ff     .-F.... ....A...
 8016ee3:	fce8 e03e 2b10 d13c 2140 e008 2b0a d138     ..>..+<.@!...+8.
 8016ef3:	484d 3024 6800 b108 211e e000 2100 484a     MH$0.h...!...!JH
 8016f03:	3024 f7ff fcbb e7ea 0c20 d000 2001 7330     $0...... .... 0s
 8016f13:	2002 f7ff fcf9 4620 e8bd 81f0 2100 4a46     . .... F.....!FJ
 8016f23:	4608 eb00 0440 f812 4014 429c d104 eb00     .F..@....@.B....
 8016f33:	0040 eb02 0140 e002 1c40 2817 d3f1 b119     @...@...@..(....
 8016f43:	78b0 794a 4290 d003 2010 f7ff fcdd e7c6     .xJy.B... ......
 8016f53:	f8d1 2001 4934 3124 f1a1 0012 4790 2800     ... 4I$1.....G.(
 8016f63:	d1bd 2000 e7d8 e92d 41f0 460f 4614 f7fe     ... ..-..A.F.F..
 8016f73:	f95d 4606 482c 308a f001 f9e4 e02c 482a     ]..F,H.0....,.*H
 8016f83:	2228 2100 308a f640 334f 4798 4926 2501     (".!.0@.O3.G&I.%
 8016f93:	318a 700d 2012 7288 f814 0b01 7408 2004     .1.p. .r.....t. 
 8016fa3:	7508 0340 8348 2003 7708 774e 2000 7788     .u@.H.. .wNw. .w
 8016fb3:	2107 f001 f9fd 2101 4638 f000 f817 481f     .!.....!8F.....H
 8016fc3:	7005 481f f880 520c 2100 4638 f000 f80e     .p.H...R.!8F....
 8016fd3:	2108 2000 f001 f9ec 7820 2800 d1cf 4819     .!. .... x.(...H
 8016fe3:	8801 f081 0108 8001 1ee4 e7f5 e92d 41f0     ............-..A
 8016ff3:	1e4c 4680 43e6 f04f 4580 f44f 77c8 e00d     L..F.CO..EO..w..
 8017003:	f8b5 0b02 f8b5 1b02 1a09 b289 42b9 d3f9     .............B..
 8017013:	4640 f7fe f901 7800 ea40 0444 42b4 d1ef     @F.....x@.D..B..
 8017023:	e77a 0000 0300 5700 0020 4662 0040 3003     z......W .bF@..0
 8017033:	0020 485a 00e0 84e0 0000 bae0 0020 967f      .ZH........ ...
 8017043:	0142 0040 0040 2001 b510 49f2 f881 0178     B.@.@.. ...I..x.
 8017053:	49f1 2004 70c8 1d09 70c8 2080 f7ff fc5e     .I. .p...p. ..^.
 8017063:	e8bd 4010 2040 f7ff bc4f 2001 4770 4be9     ...@@ ..O.. pG.K
 8017073:	f893 1176 2906 d207 eb03 02c1 1c49 f883     ..v..)......I...
 8017083:	1176 6010 2000 6050 4770 b510 4ce1 f894     v..`. P`pG...L..
 8017093:	1176 2900 d011 f000 f9aa f894 2176 eb04     v..)........v!..
 80170a3:	01c2 3908 2800 d008 1e52 f884 2176 e8bd     ...9.(..R...v!..
 80170b3:	4010 2208 f640 3347 4718 bd10 49d5 2000     .@."@.G3.G...I. 
 80170c3:	f881 0176 4770 4ad3 f892 1176 b909 2000     ..v.pG.J..v.... 
 80170d3:	4770 f892 0177 1c40 b2c0 f882 0177 4288     pG..w.@.....w..B
 80170e3:	d302 2000 f882 0177 f892 0177 eb02 00c0     ... ..w...w.....
 80170f3:	6800 4770 e92d 41f0 2400 4625 4fc6 4ec5     .hpG-..A.$%F.O.N
 8017103:	f04f 0815 e015 7878 fb00 f008 eb06 0540     O.....xx......@.
 8017113:	f855 0f30 f000 f96b 0004 d005 79a0 2802     U.0...k......y.(
 8017123:	d00a 7968 07c0 d107 48bb f000 f93b f000     ..hy.....H..;...
 8017133:	f947 78b8 2800 d1e6 78b9 2000 b329 f896     G..x.(...x. )...
 8017143:	1177 eb06 01c1 42a1 d11f 79a1 1d28 2901     w......B...y(..)
 8017153:	d103 7801 f021 0108 e007 7841 07c9 d0f8     ...x!.....Ax....
 8017163:	2100 71a1 7801 f041 0108 7001 7922 b2c9     .!.q.xA....p"y..
 8017173:	f362 0141 7001 7962 b2c9 f362 0100 7001     b.A..pby..b....p
 8017183:	79e1 e01e 7001 e8bd 81f0 f896 1176 2900     .y...p......v..)
 8017193:	d0f9 48a2 f896 1177 7842 eb06 01c1 f022     ...H..w.Bx....".
 80171a3:	02fe 7042 f896 2178 b10a 680a e001 4a9c     ..Bp..x!...h...J
 80171b3:	6812 f8c0 2002 794b 7802 f363 0200 7002     .h... Ky.xc....p
 80171c3:	79c9 2901 7801 d102 f041 0104 e7da f021     .y.).x..A.....!.
 80171d3:	0104 e7d7 4890 1d00 7881 78c2 4291 d207     .....H...x.x.B..
 80171e3:	7800 2113 4348 498b eb01 0040 30d8 4770     .x.!HC.I..@..0pG
 80171f3:	2000 4770 e92d 47f0 4f87 2113 1d3f 7838     . pG-..G.O.!?.8x
 8017203:	f8df 9210 4348 eb09 0540 f899 0178 35d8     ....HC..@...x..5
 8017213:	2800 f8d5 0002 d003 f000 f8e9 4604 e004     .(...........F..
 8017223:	497f 6809 4288 d137 4c7a 2c00 d034 487a     .I.h.B7.zL.,4.zH
 8017233:	7881 2601 f04f 0802 b329 7840 2115 4348     .x.&O...).@x.!HC
 8017243:	eb09 0040 3034 f8d0 1002 f8d5 2002 4291     ..@.40....... .B
 8017253:	d119 7829 074a d504 7840 07c0 d001 71a6     ..)xJ...@x.....q
 8017263:	e011 79a0 b178 7920 f3c1 0100 4281 d10a     ...yx. y.....B..
 8017273:	f884 8006 4631 b100 2100 7121 4866 f000     ....1F...!!qfH..
 8017283:	f891 f000 f89d 7828 0700 d507 71e6 7828     ......(x.....q(x
 8017293:	f340 0040 1c40 7160 e8bd 87f0 79e0 2801     @.@.@.`q.....y.(
 80172a3:	d107 f884 8007 7828 f340 0040 1c40 7160     ......(x@.@.@.`q
 80172b3:	e001 2802 d1f0 7868 0840 d0ed 7828 7961     ...(..hx@...(xay
 80172c3:	f3c0 0040 4281 d0e7 78ba 78f9 1e49 428a     ..@..B...x.xI..B
 80172d3:	dae2 7160 7868 07c0 d002 2020 f7ff fb14     ..`qhx....  ....
 80172e3:	484d 1d00 f000 f850 e8bd 47f0 f000 b873     MH....P....G..s.
 80172f3:	4849 7881 78c2 4291 d207 7800 2115 4348     IH.x.x.B...x.!HC
 8017303:	4944 eb01 0040 3035 4770 2000 4770 b510     DI..@.50pG. pG..
 8017313:	4841 2115 7800 4348 493e eb01 0040 3030     AH.!.xHC>I..@.00
 8017323:	7942 0852 d012 f8d0 2006 6002 2200 7102     ByR...... .`.".q
 8017333:	f891 1178 b919 493a 6809 f8c0 1006 4836     ..x...:I.h....6H
 8017343:	f000 f822 e8bd 4010 f000 b83a bd10 4832     .."....@..:...2H
 8017353:	1d00 7881 b139 7840 2113 4348 492d eb01     ...x9.@x.!HC-I..
 8017363:	0040 30d9 4770 2000 4770 482b b510 1d00     @..0pG. pG+H....
 8017373:	7880 2800 d007 4828 1d00 f000 f813 e8bd     .x.(..(H........
 8017383:	4010 f000 b828 bd10 b672 7801 78c2 1c49     .@..(...r..x.xI.
 8017393:	fbb1 f3f2 fb02 1113 7001 7881 1c49 7081     .........p.xI..p
 80173a3:	b662 4770 b672 7841 78c2 1c49 fbb1 f3f2     b.pGr.Ax.xI.....
 80173b3:	fb02 1113 7041 7881 1e49 7081 b662 4770     ....Ap.xI..pb.pG
 80173c3:	b672 4815 7880 2803 f04f 0040 d201 f7ff     r..H.x.(O.@.....
 80173d3:	ba9b f7ff baa3 b672 480f 1d00 7880 2800     ......r..H...x.(
 80173e3:	f04f 0080 d001 f7ff ba8f f7ff ba97 b510     O...............
 80173f3:	4b08 2100 f893 2176 e008 eb03 04c1 6824     .K.!..v!......$h
 8017403:	4284 d102 eb03 00c1 bd10 1c49 428a dcf4     .B........I..B..
 8017413:	2000 bd10 0020 f862 0020 4c5a 0020 6864     . .. .b. .ZL .dh
 8017423:	0100 ac00 b510 4604 f990 0000 2800 db12     .......F.....(..
 8017433:	7861 f3c1 0106 2904 d104 f7fd fee4 7861     ax.....)......ax
 8017443:	09c9 7001 7860 f3c0 0106 f994 0000 f100     ...p`x..........
 8017453:	4080 f880 1200 bd10 e92d 41f0 f04f 4680     .@......-..AO..F
 8017463:	f896 1403 2000 f896 2401 f001 01f8 f002     ..... ...$......
 8017473:	04c7 4aa8 ea4f 0ce1 7811 4da7 1e4b 4607     ...JO....x.MK..F
 8017483:	b2db f1bc 0f0c d21b e8df f00c 061a 1e06     ................
 8017493:	1e1c 1832 1c4b 4337 6868 f024 0104 7803     ..2.K.7Chh$....x
 80174a3:	07db d003 7843 2b01 d900 2701 ea41 0487     ....Cx.+...'A...
 80174b3:	7841 7011 7800 f886 0405 e03e 2001 7568     Ax.p.x....>.. hu
 80174c3:	2002 e02f 2002 e016 b139 7013 68a8 f810     . /.. ..9..p.h..
 80174d3:	1b01 f886 1405 60a8 e02f 6868 1d00 6068     .......`/.hh..h`
 80174e3:	7800 07c0 d002 f044 0420 e026 2001 e019     .x....D. .&.. ..
 80174f3:	2900 d0fb 2003 7568 e7f8 7013 2902 d101     .)... hu...p.)..
 8017503:	f024 0404 f896 1405 68e8 f800 1b01 60e8     $........h.....`
 8017513:	e013 f896 0405 68e9 7008 6868 1d00 6068     .......h.phh..h`
 8017523:	e7e4 b150 f024 0404 07c0 d001 f044 0410     ..P.$.......D...
 8017533:	2000 f7fd ff1b 752f e002 6850 7800 7528     . ..../u..Ph.x(u
 8017543:	f886 4401 e8bd 81f0 4a73 f04f 4380 6910     ...D....sJO..C.i
 8017553:	b170 f64f 71c0 4288 da00 4601 1a40 6110     p.O..q.B...F@..a
 8017563:	b672 f8b3 0b02 4408 f8a3 0b48 b662 4770     r......D..H.b.pG
 8017573:	2000 f8a3 0b28 6850 1d00 6050 2000 f7fd     . ..(.Ph..P`. ..
 8017583:	bef5 e92d 41f0 4605 b2c0 4e62 4f62 f04f     ..-..A.F..bNbOO.
 8017593:	4480 2803 d03d dc23 2801 d028 2802 d11e     .D.(=.#..((..(..
 80175a3:	6870 7840 f040 0040 f884 0401 f2af 0167     ph@x@.@.......g.
 80175b3:	2013 f7fd ff94 21e0 2013 f7fd ffcd 4c57     . .....!. ....WL
 80175c3:	f44f 2000 6020 f2af 116f 2008 f7fd ff87     O..  `..o.. ....
 80175d3:	21e0 2008 f7fd ffc0 f44f 7080 6020 e096     .!. ....O..p `..
 80175e3:	f04f 0800 2880 d024 2881 d1f8 e02b 0c28     O....($..(..+.(.
 80175f3:	6070 2007 f884 020d f884 020e 2400 6870     p`. .........$ph
 8017603:	eb00 0044 1c80 f7ff ff0d 1c64 2c04 dbf6     ..D.......d..,..
 8017613:	e07d b672 7d38 b150 7d38 1e40 f010 00ff     }.r.8}P.8}@.....
 8017623:	7538 d104 b662 2005 f7fd fe4a e06f b662     8u..b.. ..J.o.b.
 8017633:	e06d f04f 5000 ea40 4015 6038 6840 6078     m.O..P@..@8`@hx`
 8017643:	f887 8015 2581 683a 6850 b120 6878 8841     .....%:hPh .xhA.
 8017653:	b109 7d7b b13b 6810 7d79 ea40 3001 f7fd     ..{};..hy}@..0..
 8017663:	fe2f 2000 e76e 7802 b1ea 4608 f7fd fdbb     /.. n..x...F....
 8017673:	60b8 6878 7901 07c9 d004 88c0 f7fd fdb3     .`xh.y..........
 8017683:	60f8 e001 f8c7 800c 6870 7800 7538 2001     .`......ph.x8u. 
 8017693:	f7fd fe6c f894 0401 f000 00c3 f040 0020     ..l.........@. .
 80176a3:	f884 0401 e031 7842 b9b2 0188 f64f 71c0     ....1.Bx....O..q
 80176b3:	6138 4288 da00 4601 1a40 6138 b672 f8b4     8a.B...F@.8ar...
 80176c3:	0b02 4408 f8a4 0b48 2008 f8a4 0b28 2001     ...D..H.. ..(.. 
 80176d3:	f7fd fe4c b662 e018 2a01 d103 1c80 f7ff     ..L.b....*......
 80176e3:	fea1 e006 2a02 d106 f241 002e eb00 4001     .....*..A......@
 80176f3:	e006 6878 e007 2a03 d105 202e ea40 4001     ..xh...*... @..@
 8017703:	f7fd fdde e7f5 1d00 6078 f505 3580 4628     ........x`...5(F
 8017713:	e718 0000 0020 545a 0020 d05b 00e0 00e1     .... .ZT .[.....
 8017723:	b570 4604 b2c0 2801 d130 4e19 0c20 6030     p..F...(0..N .0`
 8017733:	4818 f640 3547 7800 b120 4917 4817 f7fd     .H@.G5.x ..I.H..
 8017743:	fd29 e004 4816 4914 6802 4814 47a8 6830     )....H.I.h.H.G0h
 8017753:	7840 b968 4813 2118 8001 8041 f240 113f     @xh..H.!..A.@.?.
 8017763:	8081 1541 80c1 480f 2210 490f 30d8 47a8     ..A....H.".I.0.G
 8017773:	6830 7801 f04f 4080 b129 2133 f880 1212     0h.xO..@).3!....
 8017783:	2134 f880 1211 2100 f8a0 1c00 4620 bd70     4!.....!.... Fp.
 8017793:	0020 5c5a 0000 60e1 0000 61e1 0020 806d      .Z\...`...a .m.
 80177a3:	0000 5ce1 0020 ac7e 0000 44e1 e92d 41f0     ...\ .~....D-..A
 80177b3:	4605 b2c0 4e5c 4f5d 2801 d00d 2400 f04f     .F..\N]O.(...$O.
 80177c3:	0c01 2803 d030 2826 d07e 2828 d12b 6836     ...(0.&(~.((+.6h
 80177d3:	2000 f106 0310 e061 0c28 2400 6030 6830     . ....a.(..$0`0h
 80177e3:	ebc4 01c4 4420 eb07 0841 f810 1f08 f108     .... D..A.......
 80177f3:	0804 f341 0106 2900 db09 4a4d 4411 f8c8     ..A....)..MJ.D..
 8017803:	1000 7800 f340 0006 f7fd fcfd e003 f04f     ...x@.........O.
 8017813:	4080 f8c8 0000 1c64 f8c8 0004 2c02 dbde     .@....d......,..
 8017823:	2028 f7fd fd4d e07b f897 0020 2800 d077     ( ..M.{... ..(w.
 8017833:	2300 6830 f04f 0804 eb00 0e03 ebc3 00c3     .#0hO...........
 8017843:	eb07 0040 f10e 0e08 1d00 e01d 6881 f990     ..@..........h..
 8017853:	200c 5c8a 2aff d100 7304 f990 200c 5c89     . .\.*...s... .\
 8017863:	1c52 7341 7302 2900 d0f0 7b01 07c9 d003     R.As.s.)...{....
 8017873:	6801 f881 8000 e007 f89e 2000 4661 0612     .h......... aF..
 8017883:	d400 2102 6802 7011 7b41 2900 d0de 7b41     ...!.h.pA{.)..A{
 8017893:	1c5b 1e49 7341 2b02 dbcb e041 ebc0 01c0     [.I.As.+..A.....
 80178a3:	eb07 0141 1d09 00c2 fa25 f202 f3c2 4207     ..A.....%......B
 80178b3:	2a06 d900 2200 4432 7a92 f8d1 c008 441a     .*..."2D.z.....D
 80178c3:	4594 d004 608a e000 e005 734c 730c 1c40     .E...`....Ls.s@.
 80178d3:	2802 dbe3 e024 0c28 d000 2001 f887 0020     .(..$.(.... .. .
 80178e3:	2000 6831 f897 3020 4401 7a09 09ca ebc0     . 1h.. 0.D.z....
 80178f3:	01c0 eb07 0141 1d09 b113 6849 700a e00c     ....A.....Ih.p..
 8017903:	4663 4664 2a00 d001 f04f 0400 684a 7014     cFdF.*..O...Jh.p
 8017913:	d101 f04f 0302 6809 700b 1c40 2802 dbe0     ..O....h.p@..(..
 8017923:	4628 e8bd 81f0 0000 0020 605a 0020 b85d     (F...... .Z` .].
 8017933:	0040 0002 b570 b2c1 4c3d f44f 3680 f44f     @...p...=LO..6O.
 8017943:	457c 2901 d00a 2920 d107 2210 4620 f640     |E.).. )..." F@.
 8017953:	23f5 6a21 4798 bb08 2000 bd70 0c03 4a35     .#!j.G... p...5J
 8017963:	f103 0110 6011 6226 6a22 3a10 6222 6811     .....`&b"j.:"b.h
 8017973:	1c49 d101 42aa d8f7 6811 1c49 d000 4613     I....B...hI....F
 8017983:	461d 2100 eb05 0281 6813 f844 3021 eb04     .F.!.....hD.!0..
 8017993:	0281 1c49 6113 2904 dbf4 bd70 6a20 3010     ..I..a.)..p. j.0
 80179a3:	6220 42b0 d305 4924 4628 f240 12ad 4790      b.B..$I(F@....G
 80179b3:	6225 6a21 4b21 2204 481d f240 24bb 47a0     %b!j!K.".H@..$.G
 80179c3:	e7ca 491c f000 007f 6809 eb01 0180 4818     ...I.....h.....H
 80179d3:	780a 3010 0612 d400 3810 784a eb00 0082     .x.0.....8Jx....
 80179e3:	6800 788a 40d0 78ca 2101 4091 1e49 4008     .h.x.@.x.!.@I..@
 80179f3:	4770 b510 4a0f f000 007f 6812 4b0c eb02     pG...J.....h.K..
 8017a03:	0080 7802 3310 0612 d400 3b10 78c4 2201     ...x.3.....;.x."
 8017a13:	40a2 7884 1e52 40a2 40a1 4011 b672 7840     .@.xR..@.@.@r.@x
 8017a23:	eb03 0080 6803 4393 430b 6003 b662 bd10     .....h.C.C.`b...
 8017a33:	0020 7464 0020 645a 0525 efbe 0525 3713      .dt .Zd%...%..7
 8017a43:	e92d 41f0 2403 4f55 4606 f04f 0801 2502     -..A.$UO.FO....%
 8017a53:	fa08 f004 4230 d019 4620 f7fd fbdd 7801     ....0B.. F.....x
 8017a63:	19e0 7802 2a08 d211 e8df f002 080c 1004     ...x.*..........
 8017a73:	1010 0c04 b951 f880 8000 e007 2901 d105     ....Q........)..
 8017a83:	7005 e003 462a b901 2201 7002 1c64 2c12     .p..*F...".pd..,
 8017a93:	ddde e8bd 81f0 e92d 41f0 4605 b2c0 4e40     ......-..A.F..@N
 8017aa3:	2801 d005 2400 2804 d00f 2827 d14f e050     .(...$.(..'(O.P.
 8017ab3:	0c28 6070 6800 f7ff ffc3 6870 7d01 2900     (.p`.h....ph.}.)
 8017ac3:	d045 6880 f000 f870 e041 6870 7d00 b390     E..h..p.A.ph.}..
 8017ad3:	f000 f870 b378 f000 f8bc 4680 f000 f8b9     ..p.x......F....
 8017ae3:	4f2f 7839 2900 6871 d001 89c9 e000 8989     /O9x.)qh........
 8017af3:	4288 d801 2021 e026 6870 8a01 4541 d30e     .B..! &.ph..AE..
 8017b03:	f997 1001 2904 da0a 2900 da01 707c e01c     .....)...)..|p..
 8017b13:	1c49 b248 7078 2804 d117 4822 e013 8a40     I.H.xp.(.."H..@.
 8017b23:	4540 d812 f997 0001 f110 0f14 dd0d 2800     @E.............(
 8017b33:	dd02 707c e002 e00a 1e40 7078 f997 0001     ..|p....@.xp....
 8017b43:	3014 d102 202d f7fd fbbb 2001 7038 4628     .0..- ..... 8p(F
 8017b53:	e79f 2000 f7fd fb60 7800 2800 d0f9 6870     ... ..`..x.(..ph
 8017b63:	6840 f7ff ff6d 6870 f990 0015 2800 db0a     @h..m.ph.....(..
 8017b73:	f7fd fb49 7004 6870 2104 f990 0015 f100     ..I..pph.!......
 8017b83:	4080 f880 1200 2102 074a f8a2 1100 2000     .@.....!J...... 
 8017b93:	bf00 1c40 280a dbfb bf30 e7f6 0040 0002     ..@..(..0...@...
 8017ba3:	0020 685a 0100 2d00 4a2b 6010 8091 200d      .Zh...-+J.`... 
 8017bb3:	80d0 4770 b570 4928 f644 75c0 88c8 f04f     ..pGp.(ID..u..O.
 8017bc3:	4380 1e40 b280 80c8 280c d840 d105 f04f     .C@......(@...O.
 8017bd3:	0000 8108 f8a3 5a6c e039 4a1f 07c6 8912     ......lZ9..J....
 8017be3:	f04f 0401 d009 0845 40ac 4322 f44f 4480     O.....E..@"CO..D
 8017bf3:	ea44 1282 f8a3 2a6c e009 f8b3 6a6a 05f6     D.....l*....jj..
 8017c03:	d403 0846 40b4 4322 810a f8a3 5a6c b9f0     ..F..@"C....lZ..
 8017c13:	f44f 4040 f8a3 0a6c 4a10 890c e9d2 0300     O.@@..l..J......
 8017c23:	1a1b 4363 243f fbb3 f3f4 4418 6993 f44f     ..cC?$.....D.iO.
 8017c33:	747a fbb3 f3f4 680c 6912 4422 4402 4353     zt.....h.i"D.DSC
 8017c43:	fbb3 f0f0 8148 8888 80c8 2001 bd70 2000     ....H...... p.. 
 8017c53:	bd70 4801 8940 4770 0020 e65b 0100 d000     p..H@.pG .[.....
 8017c63:	b510 4604 b2c0 2801 d00c 281e d10a b672     ...F...(...(..r.
 8017c73:	f04f 5000 ea40 4114 220d 4806 f640 3347     O..P@..A.".H@.G3
 8017c83:	4798 b662 4620 bd10 220d 4902 f640 3347     .Gb. F...".I@.G3
 8017c93:	4718 0000 0020 f25b e92d 41f0 4604 4d39     .G.. .[.-..A.F9M
 8017ca3:	b2c0 0c21 2601 f995 2002 2821 d025 dc10     ..!..&... !(%...
 8017cb3:	4a34 2801 f1a2 0204 d043 2802 d047 2805     4J.(....C..(G..(
 8017cc3:	d104 f7fd fc11 f240 105f 4780 4620 e8bd     ......@._..G F..
 8017cd3:	81f0 2824 d041 2825 d04a 282c d1f6 f3c4     ..$(A.%(J.,(....
 8017ce3:	3003 f04f 3701 686b 4087 43bb fa06 f700     .0O..7kh.@.C....
 8017cf3:	1e48 00c0 4087 431f 606f 2a00 d0e6 f414     H....@.Co`.*....
 8017d03:	4f70 d100 70a9 6868 f995 1002 fa90 f0a0     pO...phh........
 8017d13:	fab0 f080 eb06 00d0 4281 da00 78a8 f995     .........B...x..
 8017d23:	1003 4281 d0d2 b240 70e8 2126 ea41 4000     ...B..@..p&!A..@
 8017d33:	f7fd fac6 78e8 2800 d1c8 2025 f7fd fac0     .....x.(..% ....
 8017d43:	e7c4 f04f 30ff 6011 70a8 70e8 e7be 6810     ..O..0.`.p.p...h
 8017d53:	7800 2800 d0ba 480c e7f0 480a f414 4f70     .x.(...H...H..pO
 8017d63:	8800 d002 ea40 4014 e001 ea20 4014 8028     ....@..@.. ..@(.
 8017d73:	2a00 d1ab 8828 2800 d1a8 2027 f7fd fad9     .*..(..(..' ....
 8017d83:	2020 e7a4 0020 745a 0500 2100 e92d 5ff0       .. .Zt...!-.._
 8017d93:	4efd f8df a3fc f8b6 5033 f8b6 0031 4005     .N......3P..1..@
 8017da3:	2000 f8a6 0033 48f9 2701 6804 e079 fa95     . ..3..H.'.hy...
 8017db3:	f0a5 fab0 f180 2909 4620 dd01 4af2 e002     .......) F...J..
 8017dc3:	4af1 3028 3212 eb06 0e41 f9be 3075 4553     .J(0.2..A...u0SE
 8017dd3:	d102 f9b0 3020 e004 f8b0 c01c eba3 030c     .... 0..........
 8017de3:	b21b f892 c011 f1bc 0f00 d123 f8b4 9062     ..........#...b.
 8017df3:	fa07 f801 f04f 0c00 ea18 0f09 d009 f9b6     ....O...........
 8017e03:	802c f1b8 0f00 dd0f f1c8 0c00 fa0f fc8c     ,...............
 8017e13:	e00a f8b4 9064 ea18 0f09 d005 f9b6 802c     ....d.........,.
 8017e23:	f1b8 0f00 da00 46c4 f9b2 800c f9b0 901e     .......F........
 8017e33:	45c8 da02 f9b0 c020 e00d f8be b055 44d8     .E.... .....U..D
 8017e43:	44c4 fa0f fc8c f1bc 0f00 dd02 f04f 0c00     .D..........O...
 8017e53:	e001 45e1 dcee ebac 0803 f892 c010 fb98     ...E............
 8017e63:	f2fc f896 8096 441a b212 f1b8 0f00 d104     .......D........
 8017e73:	429a d102 f1bc 0f01 d910 f9b0 c01e 4653     .B............SF
 8017e83:	4594 dc02 f9b0 001c 1883 f8ae 3075 f8b6     .E..........u0..
 8017e93:	0033 fa07 f201 4310 f8a6 0033 fa07 f001     3......C..3.....
 8017ea3:	4385 2d00 d183 7c30 2801 d901 1e40 7430     .C.-..0|.(..@.0t
 8017eb3:	f896 0022 2801 d902 1e40 f886 0022 f8b6     .."..(..@..."...
 8017ec3:	0033 2800 d008 211b ea41 4000 f7fd f9f8     3..(...!A..@....
 8017ed3:	f806 7f95 2000 7070 e8bd 9ff0 e92d 4ff1     ..... pp....-..O
 8017ee3:	f89d 0000 0781 48a9 6805 d503 4ca6 f44f     .......H.h...LO.
 8017ef3:	477c e004 4ca4 3528 3412 f240 37ff f89d     |G...L(5.4@..7..
 8017f03:	6001 f8bd 0002 f9b4 800c f3c6 1101 f8df     .`..............
 8017f13:	9278 f340 000a 2901 d101 81a0 e00d 2902     x.@....).......)
 8017f23:	d101 4440 e7f9 2903 d107 f3c6 0103 eb09     ..@D...)........
 8017f33:	0141 f8a1 0055 f647 78ff f016 0f30 f04f     A...U.G..x..0.O.
 8017f43:	0a00 d012 f9b4 000c 2800 dd02 f8a4 a00c     .........(......
 8017f53:	e005 f9b5 101e 4288 da01 8c28 81a0 f9b4     .......B..(.....
 8017f63:	100c f895 0027 f7ff fd44 7c60 2101 ebb1     ....'...D.`|.!..
 8017f73:	1f96 d00c 2202 ebb2 1f96 d102 f884 a011     ....."..........
 8017f83:	e006 2203 ebb2 1f96 d102 b100 2100 7461     ...".........!at
 8017f93:	7c61 4281 d00f b111 f895 0025 e001 f895     a|.B......%.....
 8017fa3:	0026 7c21 4281 db0d f8b9 0033 4338 f8a9     &.!|.B....3.8C..
 8017fb3:	0033 e8bd 8ff8 f9b4 000c 4540 d0f9 f895     3.........@E....
 8017fc3:	0024 e7ee 7420 e7ef b530 8b04 2300 4d70     $... t..0....#pM
 8017fd3:	06e4 d400 462b 818b 81cd 2401 740c 8b03     ....+F.....$.t..
 8017fe3:	055b d501 744c 818d 4d67 e00d fa92 f1a2     [...Lt..gM......
 8017ff3:	fab1 f181 fa04 f301 439a 8b43 eb05 0141     .........CC...A.
 8018003:	f8a1 3035 f8a1 3055 2a00 d1ef bd30 e92d     ..50..U0.*..0.-.
 8018013:	4ff8 f8df 9178 4604 b2c1 4d5b f8d9 3000     .O..x..F..[M...0
 8018023:	f8df c16c 2701 0c00 f04f 0800 f44f 4a7c     ..l..'..O...O.|J
 8018033:	f105 0612 f103 0228 2930 d078 dc0c 2901     ......(.0)x....)
 8018043:	d01c 2903 d077 2918 d073 2926 d114 0c20     ...)w..)s.&).. .
 8018053:	d070 f885 7030 e00f ea4f 4b14 f3c4 3e03     p...0p..O..K...>
 8018063:	fa0f fb8b 2931 d073 2932 d070 293f d027     ....1)s.2)p.?)'.
 8018073:	2963 d101 f885 8095 4620 e79a 2100 462a     c)...... F...!*F
 8018083:	f8c9 0000 eb02 0341 1c49 f8a3 c075 290f     ......A.I...u..)
 8018093:	ddf8 4652 493c f7ff ff97 f8d9 0000 f240     ..RF<I........@.
 80180a3:	32ff 4631 3028 f000 f8f4 4837 2164 3024     .21F(0....7Hd!$0
 80180b3:	f8a0 8008 3051 ea41 4000 f7fd f901 e7db     ....Q0A..@......
 80180c3:	f3ce 0b02 f7fd f88f f1bb 0f01 d101 2101     ...............!
 80180d3:	e000 2100 f885 1097 f8a5 8031 2100 e00c     ...!......1..!..
 80180e3:	eb01 0341 eb00 0343 795b f8b5 2031 fa07     ..A...C.[y..1 ..
 80180f3:	f303 431a f8a5 2031 1c49 4559 dbf0 f8d9     ...C..1 I.YE....
 8018103:	0000 8b01 0549 d503 4652 491f f7ff ff5c     ....I...RF.I..\.
 8018113:	f8d9 0000 f8b0 1040 0549 d505 f240 32ff     ......@.I...@..2
 8018123:	4631 3028 f7ff ff50 f64f 70ff e06e e04c     1F(0..P.O..pn.L.
 8018133:	e001 e060 e06d f895 002f 2800 d09c f895     ..`.m.../..(....
 8018143:	0095 2800 d198 f7ff fe21 e795 e000 e021     ...(....!.....!.
 8018153:	f1be 0f00 d001 4e0c 461a f8a6 b00e 8b10     .......N.F......
 8018163:	0540 d546 2001 2100 45e3 dd01 2002 2101     @.F.. .!.E... .!
 8018173:	ea4f 624e ea42 5080 ea40 5001 f3cb 010a     O.NbB..P@..P....
 8018183:	4308 f040 6010 e032 0020 9864 0020 7c5a     .C@..`2. .d. .Z|
 8018193:	ffff 00fc f1be 0f09 d901 4e3e 461a eb05     ..........>N.F..
 80181a3:	004e f8a0 b035 8b11 054b d522 0689 d420     N...5...K."... .
 80181b3:	f892 1024 7431 f8a0 b055 f8b5 0033 fa07     ..$.1t..U...3...
 80181c3:	f70e 4338 f8a5 0033 e013 f04f 5000 ea40     ..8C..3...O..P@.
 80181d3:	4014 6800 9000 f89d 1000 078c d400 4613     .@.h...........F
 80181e3:	f3c1 0181 8b1a 3108 408f 423a d001 f7ff     .......1.@:B....
 80181f3:	fe75 2000 e6dd 2801 d004 2807 d005 280f     u.. ...(...(...(
 8018203:	d1a3 e791 f885 702f e736 4650 f000 f837     ....../p6.PF..7.
 8018213:	e732 f885 802f f885 8030 e72d 4b1e 681b     2.../...0.-..K.h
 8018223:	b109 491c e002 491b 3328 3112 b172 4919     ...I...I(3.1r..I
 8018233:	f891 2097 b12a f8b1 0031 fa90 f0a0 fab0     ... *...1.......
 8018243:	f080 eb01 0040 f9b0 0055 4770 f9b1 000c     ....@...U.pG....
 8018253:	f9b3 201e 4282 dc02 7c49 2900 d0f5 480f     ... .B..I|.)...H
 8018263:	4770 490c 0002 f9b1 000e d101 f9b1 0020     pG.I.......... .
 8018273:	4770 4908 eb01 0040 f9b0 0035 4770 4905     pG.I..@...5.pG.I
 8018283:	f8a1 0033 2001 f881 0096 7408 f881 0022     ..3.. .....t..".
 8018293:	4770 e699 0020 9864 0020 7c5a ffff 00fc     pG.. .d. .Z|....
 80182a3:	4a53 8810 2800 d014 8810 4b52 fa90 f0a0     SJ...(....RK....
 80182b3:	fab0 f180 689b eb01 0081 eb03 0040 7843     .....h......@.Cx
 80182c3:	2300 7043 4b4c 8018 8810 2301 408b 4398     .#CpLK.....#.@.C
 80182d3:	8010 4770 e92d 41f0 2701 4d45 4e47 e018     ..pG-..A.'EMGN..
 80182e3:	79a8 1c40 71a8 8868 b198 8868 88a9 fa90     .y@..qh...h.....
 80182f3:	f0a0 fab0 f080 fa07 f400 4221 d006 483d     ..........!B..=H
 8018303:	7800 f7fd f901 79e8 1c40 71e8 8868 43a0     .x.....y@..qh..C
 8018313:	8068 79a8 f896 1f94 4288 d1e1 e8bd 81f0     h..y.....B......
 8018323:	b510 4c34 6860 4780 4931 7a08 1c40 b2c0     ..4L`h.G1I.z@...
 8018333:	7208 79c9 4288 d004 7820 e8bd 4010 f7fd     .r.y.B.. x...@..
 8018343:	b8e3 bd10 b510 4c2b 2209 60a0 2100 4828     ......+L.".`.!(H
 8018353:	f640 334f 4798 492a 2000 7008 f2af 01bf     @.O3.G*I. .p....
 8018363:	f7fd f8bd f2af 0193 2001 f7fd f8b8 2160     ......... ....`!
 8018373:	2000 f7fd f8f1 2150 2001 f7fd f8ed f2af     . ....P!. ......
 8018383:	015f 201f f7fd f8b6 7020 481e 2101 6001     _.. .... p.H.!.`
 8018393:	2102 6001 bd10 4917 2201 6048 4814 71c2     .!.`...I."H`.H.q
 80183a3:	2200 7202 7808 f7fd b8af 4912 6048 4770     .".r.x.....IH`pG
 80183b3:	4a0f 4301 8011 8051 8090 2000 f7fd b8c7     .J.C..Q.... ....
 80183c3:	b570 4606 460d b672 4c09 8820 4210 d102     p..F.Fr..L ..B..
 80183d3:	480d f7fc ff75 8820 4335 4328 8020 8860     .H..u. .5C(C .`.
 80183e3:	4328 8060 88a0 4330 80a0 b662 bd70 0000     (C`...0C..b.p...
 80183f3:	0020 d95d 0020 805a 0040 020c 0020 0070      .]. .Z.@... .p.
 8018403:	0020 947f 00e0 00e1 0200 0500 b510 4823      .............#H
 8018413:	2240 6c00 4921 f640 3347 4798 2240 2100     @".l!I@.G3.G@".!
 8018423:	481e f640 334f 4798 e8bd 4010 2014 f7fc     .H@.O3.G...@. ..
 8018433:	bf47 491a 6408 481a 7800 f7fd b865 b510     G..I.d.H.x..e...
 8018443:	f2af 0137 2018 f7fd f855 4915 7008 bd10     ..7.. ..U..I.p..
 8018453:	4a12 eb02 0080 6802 1851 d301 f04f 31ff     .J.....hQ...O..1
 8018463:	6001 4770 490d eb01 0180 6808 1c40 d000     .`pG.I.....h@...
 8018473:	6008 4770 4909 eb01 0140 8808 1c40 0400     .`pG.I..@...@...
 8018483:	0c00 d000 8008 4770 4904 4401 7808 1c40     ......pG.I.D.x@.
 8018493:	f010 00ff d000 7008 4770 0000 0020 3065     .......ppG.. .e0
 80184a3:	0020 8c5a f000 3155 f000 30aa eb01 0050      .Z...U1...0..P.
 80184b3:	f000 3133 f000 30cc eb01 0090 f000 310f     ..31...0.......1
 80184c3:	f000 30f0 eb01 1010 f000 11ff f000 20ff     ...0........... 
 80184d3:	eb01 2010 b281 eb01 4010 4770 4851 4952     ... .....@pGQHRI
 80184e3:	6800 6008 4770 b510 4c4f 21c5 6820 4788     .h.`pG..OL.! h.G
 80184f3:	6020 bd10 b510 4604 f7ff fff5 4602 4620      `.....F.....F F
 8018503:	f7ff ffd0 fbb2 f1f0 fb00 2011 2301 e006     ........... .#..
 8018513:	fa94 f1a4 fab1 f281 fa03 f102 438c 1e40     .............C@.
 8018523:	d2f6 fa94 f0a4 fab0 f080 bd10 7981 0689     .............y..
 8018533:	d501 1dc0 4770 2000 4770 7981 2203 ebb2     ....pG. pG.y."..
 8018543:	1f91 d006 06ca d504 1dc0 f3c1 1140 4408     ............@..D
 8018553:	4770 2000 4770 7981 2203 ebb2 1f91 d009     pG. pG.y."......
 8018563:	070a d507 f3c1 1240 1dc0 4410 f3c1 1100     ......@....D....
 8018573:	4408 4770 2000 4770 7981 2203 ebb2 1f91     .DpG. pG.y."....
 8018583:	d00a 1dc0 f3c1 1240 4410 f3c1 1200 4410     ......@..D.....D
 8018593:	f3c1 01c0 4408 4770 2000 4770 7981 098a     .....DpG. pG.y..
 80185a3:	d10e 1dc0 f3c1 1240 4410 f3c1 1200 4410     ......@..D.....D
 80185b3:	f3c1 02c0 4410 f3c1 0102 eb00 0041 4770     .....D......A.pG
 80185c3:	2000 4770 b570 7984 1dc2 210b 06a3 d502     . pGp..y...!....
 80185d3:	f812 1b01 310f 06e3 d504 f812 3b01 1d09     .....1.......;..
 80185e3:	4419 b289 0723 d504 f812 3b01 1d09 4419     .D..#......;...D
 80185f3:	b289 2300 f3c4 0502 e008 eb02 0643 8836     ...#........C.6.
 8018603:	f3c6 0608 4431 1c89 b289 1c5b 429d dcf4     ....1D....[..B..
 8018613:	09a2 d101 1c89 b289 8802 f361 020b 8002     ..........a.....
 8018623:	bd70 0000 0100 ac00 0020 905a e92d 43f0     p....... .Z.-..C
 8018633:	4684 e9dd 7808 9807 4293 d201 440b 3320     .F...x...B...D 3
 8018643:	4614 f04f 0e01 17e5 eb04 65d5 116d eb0c     .FO........em...
 8018653:	0585 682d 4294 ea05 0508 d10a f002 061f     ..-h.B..........
 8018663:	1ba4 1b16 f1c6 0920 fa0e f609 1e76 4035     ...... .....v.5@
 8018673:	e019 1b1e 2e1f d216 f1c6 091f fa0e f609     ................
 8018683:	1e76 43b5 e00f 683e 2e00 d017 1e76 603e     v..C..>h....v.>`
 8018693:	fab5 f685 f1c6 091f fa0e f909 4426 ea25     ............&D%.
 80186a3:	0509 f800 6b01 2d00 d1ed 3420 429c d805     .....k.-.. 4.B..
 80186b3:	428c d3c8 2400 1a5b 3b20 e7c4 e8bd 83f0     .B...$[. ;......
 80186c3:	e92d 41f0 1c5b fbb3 f4f1 fb01 3414 440a     -..A[........4.D
 80186d3:	1e52 fbb2 f3f1 fb01 2313 2200 f04f 3eff     R........#."O..>
 80186e3:	2701 f8dd c018 e062 2500 4294 d321 f102     .'....b..%.B!...
 80186f3:	0620 42b4 d21d 4293 d316 1e75 42ab d213      ..B...B..u..B..
 8018703:	429c d207 1b1d 1c6d fa07 f505 1e6d 1aa6     .B....m.....m...
 8018713:	40b5 e019 1ae6 1e76 fa07 f506 1e6d 1a9e     .@....v.....m...
 8018723:	1c76 40b5 43ed e00f 1aa5 fa07 f505 1e6d     v..@.C........m.
 8018733:	e7f8 4293 d30b f102 061f 42b3 d207 1a9d     ...B.......B....
 8018743:	1c6d fa07 f505 1e6d fa95 f5a5 e00d 429c     m.....m........B
 8018753:	d203 42a2 d301 429a d905 42a3 d205 429a     ...B...B...B...B
 8018763:	d301 42a2 d901 fa9e f5ae ea4f 1652 eb00     ...B......O.R...
 8018773:	0686 f8d6 8000 f1bc 0f00 d002 ea48 0805     ............H...
 8018783:	e001 ea28 0805 1a8d f8c6 8000 2d20 d20d     ..(......... -..
 8018793:	0955 1a56 eb00 0585 3620 f8d5 8000 fa07     U.V..... 6......
 80187a3:	f606 1e76 ea28 0806 f8c5 8000 3220 428a     ..v.(....... 2.B
 80187b3:	d39a e8bd 81f0 e92d 4ff0 b087 460d 4617     ......-..O...F.F
 80187c3:	4604 aa05 a906 f000 ff65 8aa0 f894 b004     .F......e.......
 80187d3:	f040 5300 8ae0 4a52 f040 5600 2000 eb03     @..S..RJ@..V. ..
 80187e3:	0180 eb06 0c80 6809 f8dc c000 ea01 010c     .......h........
 80187f3:	f842 1020 1c40 2804 d3f1 2300 9300 e9dd     B. .@..(...#....
 8018803:	3205 4659 4846 f7ff ff5b 2301 9300 e9dd     .2YFFH..[..#....
 8018813:	3205 4659 4630 f7ff ff53 f04f 0a24 fb95     .2YF0F..S.O.$...
 8018823:	f2fa 8b20 78e1 2600 f040 5000 f04f 39ff     .. ..x.&@..PO..9
 8018833:	f04f 0880 2901 d001 2902 d10e 9204 f04f     O....)...)....O.
 8018843:	33aa aa04 e88d 000d e9dd 3205 4659 4834     .3.........2YF4H
 8018853:	f7ff feec f04f 3355 e003 2905 d111 464b     ....O.U3...)..KF
 8018863:	9204 aa04 e88d 000d e9dd 3205 4659 482c     ...........2YF,H
 8018873:	f7ff fedc 8b21 f041 5100 1a46 fb06 f60a     ....!.A..QF.....
 8018883:	e022 2904 d120 aa04 e88d 0205 210f 9104     "..) ........!..
 8018893:	e9dd 3205 4659 4822 f7ff fec8 f880 8000     ...2YF"H........
 80188a3:	8a60 2307 f040 5200 8b20 f040 5000 e008     `..#@..R .@..P..
 80188b3:	eb02 1181 7809 eb03 0191 1a6d d404 440e     .....x....m....D
 80188c3:	1c40 7801 2980 d1f3 f880 8000 8b22 7839     @..x.)......".9x
 80188d3:	1a80 4408 7038 8b20 f040 5100 7808 2880     ...D8p .@..Q.x.(
 80188e3:	d01a 1e40 b240 2800 da02 7922 4410 b240     ..@.@..(.."y.D@.
 80188f3:	8aa2 f042 5200 eb02 02e0 f000 0007 f1c0     ..B..R..........
 8018903:	0307 7812 2001 4098 4202 d002 f884 9029     ...x. .@.B....).
 8018913:	e002 7808 f884 0029 4630 b007 e8bd 8ff0     ...x..).0F......
 8018923:	0020 e45d b510 4c5a 221e 4958 f640 3347      .]...ZL."XI@.G3
 8018933:	6860 4798 f104 000c 78c1 b921 7881 b111     `h.G.....x!..x..
 8018943:	7800 2808 d202 6861 2000 6008 e8bd 4010     .x.(..ah. .`...@
 8018953:	2054 f7fc bcb5 494e 6048 7808 f7fc bdd4     T ....NIH`.x....
 8018963:	e92d 41f0 4604 b2c1 2501 4e49 0768 360c     -..A.F...%INh..6
 8018973:	0c22 ea40 4014 2913 d075 dc17 2901 d01e     ".@..@.)u....)..
 8018983:	2910 d12d f3c4 3103 2900 d172 b672 78f0     .)-....1.)r.r..x
 8018993:	2800 d06b b662 2000 70b0 70f0 f000 fb54     .(k.b.. .p.p..T.
 80189a3:	f7fe fb8c 204c f7fc fc8b e005 2917 d019     ....L .......)..
 80189b3:	2953 d115 f7ff ffcf 2000 e8bd 81f0 4d34     S)....... ....4M
 80189c3:	60aa f7ff fd3c f7ff fd89 f000 fa35 f2af     .`..<.......5...
 80189d3:	01ab 2018 f7fc fd8e 7028 482e f7ff fcb2     ... ....(p.H....
 80189e3:	4620 e7ea 4610 f7fc fbfe 4f28 0004 f107      F...F....(O....
 80189f3:	073e d013 2220 2100 4638 f640 334f 4798     >... ".!8F@.O3.G
 8018a03:	2100 2315 fb01 f003 eb04 0240 7950 280f     .!.#......@.Py.(
 8018a13:	dc04 1c49 f827 2010 2906 dbf3 b672 7930     ..I.'.. .)..r.0y
 8018a23:	b990 78b0 b980 b662 b114 4818 303e e000     ...x..b....H>0..
 8018a33:	2000 f000 f831 b10c 2001 e000 2000 f887     . ..1.... ... ..
 8018a43:	0020 f241 004c e7ae 2c00 d002 f04f 0001      .A.L....,..O...
 8018a53:	e001 f04f 0000 f887 0021 d001 f04f 0500     ..O.....!...O...
 8018a63:	f887 5022 e003 e00d e003 e7ff 7175 b662     .."P........uqb.
 8018a73:	e7a2 2904 d001 2905 d19e 7071 7135 f000     ...)...)..qp5q..
 8018a83:	fc8e e799 f7ff fcd5 e796 0000 0020 7465     ............ .et
 8018a93:	0020 945a 0020 d665 b530 49dc 4cdc 8188      .Z. .e.0..I.L..
 8018aa3:	8508 2100 f8a4 101f b170 2501 eb00 0241     ...!....p..%..A.
 8018ab3:	8812 b132 f8b4 201f fa05 f301 431a f8a4     ..2.... .....C..
 8018ac3:	201f 1c49 290f ddf1 f8b4 001f f3c0 0009     . I..)..........
 8018ad3:	83a0 bd30 b570 4ecf 49cf 6830 7bc0 0100     ..0.p..N.I0h.{..
 8018ae3:	7008 48ca 223c 2100 383c f640 354f 47a8     .p.H<".!<8@.O5.G
 8018af3:	4cc6 3c3c 7820 f020 00c0 b2c0 f020 000f     .L<< x ..... ...
 8018b03:	1c40 7020 7960 2004 7160 7aa0 f020 00c0     @. p`y. `q.z ...
 8018b13:	b2c0 f040 0010 b2c0 f020 000f 1c80 72a0     ..@..... ......r
 8018b23:	7d20 f020 00c0 3080 f040 0010 b2c0 f020      } ....0@..... .
 8018b33:	000f 1d40 7520 48b5 8360 20e6 83a0 f7fd     ..@. u.H`.. ....
 8018b43:	fe9b 7801 0609 d503 6830 f990 000d e001     ...x....0h......
 8018b53:	f990 0003 f7fc fb6a f814 1f1e f021 01c0     ......j.....!...
 8018b63:	3180 f041 0110 b2c9 f021 010f 1d09 7021     .1A.....!.....!p
 8018b73:	6831 7a22 7c8b f363 0202 7222 4aa3 7260     1h"z.|c..."r.J`r
 8018b83:	320e 80e2 7aa2 f022 02c0 3280 f042 0210     .2...z"....2B...
 8018b93:	b2d2 f022 020f 1d12 72a2 7c8a 7ca1 f362     .."......r.|.|b.
 8018ba3:	0102 74a1 74e0 4899 222a 301c 8220 7d20     ...t.t.H*".0 . }
 8018bb3:	2100 f020 00c0 b2c0 f020 000f 7520 4893     .! ..... ... u.H
 8018bc3:	47a8 4992 4891 312a 8001 310c 8041 311a     .G.I.H*1...1A..1
 8018bd3:	8081 311a 8141 314a 8201 311a 8241 310e     ...1A.J1...1A..1
 8018be3:	83c1 311a 8401 310e 84c1 220c 2100 302a     ...1...1...".!*0
 8018bf3:	47a8 4886 302a 7981 f041 0103 7181 211a     .G.H*0.yA....q.!
 8018c03:	71c1 8081 2126 7281 214a 72c1 221a 2100     .q..&!.rJ!.r.".!
 8018c13:	308a 47a8 6830 7bc2 487c 30b4 7801 f362     .0.G0h.{|H.0.xb.
 8018c23:	1105 7001 7981 f041 01c0 b2c9 f041 0120     ...p.yA.....A. .
 8018c33:	7181 210d 71c1 460a 2100 301a 47a8 f44f     .q.!.q.F.!.0.GO.
 8018c43:	3080 f8d0 10ac 4871 30ce 6001 6831 680a     .0....qH.0.`1h.h
 8018c53:	6042 684a 6082 7b0b 7b02 f363 0200 7302     B`Jh.`.{.{c....s
 8018c63:	7b8a 7b01 f362 0141 7301 381a f7ff fcaa     .{.{b.A..s.8....
 8018c73:	4866 221a 2100 30dc 47a8 6830 46ac 7bc2     fH.".!.0.G0h.F.{
 8018c83:	4862 30dc 7801 f362 1105 7001 7981 220d     bH.0.xb....p.y."
 8018c93:	f021 01c0 3180 f041 0108 7181 e8bd 4070     !....1A....q..p@
 8018ca3:	2100 301a 4760 4859 4a58 383c 7d01 322a     .!.0`GYHXJ<8.}*2
 8018cb3:	f021 01c0 7501 4957 6809 8a09 eb01 0181     !....uWI.h......
 8018cc3:	8381 4856 7991 6800 68c0 b108 1c43 d103     ..VH.y.h.h..C...
 8018cd3:	f021 0004 7190 4770 f041 0104 7191 6010     !....qpGA....q.`
 8018ce3:	4770 484a 383c 7d01 f021 01c0 3180 7501     pGJH<8.}!....1.u
 8018cf3:	4947 8f4a 32e6 8382 3066 7982 f042 0204     GIJ..2..f0.yB...
 8018d03:	7182 6809 6001 4770 4842 4940 6800 3916     .q.h.`pGBH@I.h.9
 8018d13:	7c82 7808 f362 0002 7008 483d 31ca 6800     .|.xb....p=H.1.h
 8018d23:	f8c1 0002 4770 483b 4938 6800 390c 7c82     ....pG;H8I.h.9.|
 8018d33:	7808 f362 0002 7008 4835 31e8 6800 f8c1     .xb....p5H.1.h..
 8018d43:	0002 4770 4933 4831 6809 3050 7900 7bc9     ..pG3I1H.hP0.y.{
 8018d53:	b911 f240 4184 e000 219c eb01 1040 492c     ..@..A...!..@.,I
 8018d63:	b280 f8b1 1027 388c 4408 4928 393c 8408     ....'..8.D(I<9..
 8018d73:	4770 4a27 4825 f892 102e 3054 5c08 4925     pG'J%H....T0.\%I
 8018d83:	6809 7bc9 b911 f240 4184 e000 219c eb01     .h.{..@..A...!..
 8018d93:	1040 b280 f8b2 1027 388c 4408 491b 393c     @.....'..8.D.I<9
 8018da3:	8548 4770 b570 4a19 4b19 3a3c f893 103c     H.pGp..J.K<:..<.
 8018db3:	7e50 b121 f040 0010 7650 20c0 e003 f020     P~!.@...Pv. .. .
 8018dc3:	0010 7650 2000 8758 b281 f101 00e6 8390     ..Pv. X.........
 8018dd3:	4810 257d 6800 7bc4 480d 7e00 0900 4368     .H}%.h.{.H.~..hC
 8018de3:	b90c 012c e001 f44f 747a eb04 0040 f8b3     ..,...O.zt..@...
 8018df3:	4027 0440 eb04 4010 f8a3 0027 1a40 38d2     '@@....@..'.@..8
 8018e03:	82d0 f7fe f9e7 4901 8108 bd70 0020 1266     .......I..p. .f.
 8018e13:	0020 7465 0020 9c5a 0020 407f 0020 ac5a      .et .Z. ..@ .Z.
 8018e23:	b510 2204 2414 fbb1 f3f4 fb04 1113 5481     ...".$.........T
 8018e33:	4619 1e52 d5f7 bd10 b510 222c 2100 487b     .FR.......,".!{H
 8018e43:	f640 334f 4798 497a 2002 7008 4879 6800     @.O3.GzI. .pyH.h
 8018e53:	7b80 2800 d006 4878 8801 f021 011c f041     .{.(..xH..!...A.
 8018e63:	0101 8001 bd10 4a75 2114 f8b2 0025 1c40     ......uJ.!..%.@.
 8018e73:	fbb0 f3f1 fb01 0013 f8a2 0025 2154 4a70     ..........%.T!pJ
 8018e83:	eb01 0180 7411 496b 6809 7b89 2900 d014     .....tkI.h.{.)..
 8018e93:	4966 b920 780a 2001 b102 2000 7008 7809     fI ..x. ... .p.x
 8018ea3:	f04f 4080 2900 f8b0 1120 d002 f041 0108     O..@.).. ...A...
 8018eb3:	e001 f021 0108 f8a0 1120 4770 b570 495d     ..!..... .pGp.]I
 8018ec3:	6809 7b89 2900 d022 4d5e 4c58 f895 2f43     .h.{.)".^MXL..C/
 8018ed3:	7821 7863 2a02 da09 4291 d007 b128 eb04     !xcx.*...B..(...
 8018ee3:	0643 f895 5f42 4431 710d 4611 eb04 0243     C...B_1D.q.F..C.
 8018ef3:	4411 1d09 b110 4852 7e00 e007 f991 0000     .D....RH.~......
 8018f03:	f110 0f7d dd01 1ec0 e000 2080 7008 bd70     ..}........ .pp.
 8018f13:	e92d 41f0 4e49 f44f 717f f8b6 0025 2705     -..AINO..q..%..'
 8018f23:	1c40 fbb0 f2f1 fb01 0012 f8a6 0025 b280     @...........%...
 8018f33:	fbb0 f1f7 fb07 0511 1970 f890 4029 2154     ........p...)@T!
 8018f43:	eb01 0084 493e 7408 f104 000c f7ff fa92     ....>I.t........
 8018f53:	4838 6800 7b80 2800 d066 f8df e0d0 2d04     8H.h.{.(f......-
 8018f63:	f88e 4001 d114 f896 c029 ebbc 0204 d500     ...@....).......
 8018f73:	4252 2001 1831 f891 3029 1b19 d500 4249     RB. 1...)0....IB
 8018f83:	4291 dc01 469c 460a 1c40 2804 d3f2 4664     .B...F.F@..(..dF
 8018f93:	eb0e 0144 2301 f991 2005 f991 4004 4618     ..D..#... ...@.F
 8018fa3:	42a2 dc00 2000 f8b6 2025 f89e 4002 fbb2     .B... ..% ...@..
 8018fb3:	f2f7 4294 d00b f89e 4003 1c64 2706 fbb4     ...B.....@d..'..
 8018fc3:	fcf7 fb07 441c f88e 4003 f88e 2002 f89e     .....D...@... ..
 8018fd3:	2003 42aa d102 b100 2300 4618 f896 303c     . .B.....#.F..<0
 8018fe3:	2200 b903 2202 f88e 0000 f04f 4380 f8b3     ."..."....O..C..
 8018ff3:	4120 b110 f044 0408 e001 f024 0408 f8a3      A..D.....$.....
 8019003:	4120 f991 3004 f991 1005 4419 1f49 eb01      A...0.....DI...
 8019013:	71d1 1049 f06f 037f 4299 da00 4619 4b04     .qI.o....B...F.K
 8019023:	1e5b 7019 4310 7058 e8bd 81f0 0020 4a67     [..p.CXp.... .gJ
 8019033:	0020 437f 0020 9c5a 0040 2001 0020 7465      ..C .Z.@..  .et
 8019043:	0020 d665 0020 0070 49e1 780a 4282 d00f      .e. .p..I.x.B..
 8019053:	4ae0 7008 7e91 f360 1107 7691 4611 0409     .J.p.~`....v.F..
 8019063:	f000 000f ea41 3000 f040 0012 f7fc b928     ....A..0@.....(.
 8019073:	4770 e92d 47f0 48d8 f7ff f997 4ed4 2401     pG-..G.H.....N.$
 8019083:	7830 4fd6 1f40 4dd3 f8df 9354 f04f 0800     0x.O@..M..T.O...
 8019093:	2809 d277 e8df f000 0d05 4837 8e8e 8e8e     .(w.......7H....
 80190a3:	0048 f000 fb85 b110 f000 fb95 bb38 2100     H...........8..!
 80190b3:	e035 f000 fb7d 2800 d0f9 f000 fbb7 2800     5...}..(.......(
 80190c3:	d0f5 6878 6801 b111 686a 428a d10f 6841     ..xh.h..jh.B..Ah
 80190d3:	68aa 6880 400a 4008 4282 d108 7b28 0701     .h.h.@.@.B..({..
 80190e3:	d508 f8d9 2000 6869 6812 4291 d002 f8c5     ..... ih.h.B....
 80190f3:	8004 e006 7871 2904 d003 0780 d501 703c     ....qx.)......<p
 8019103:	e7d5 71b4 e7d3 f000 fb53 2800 d0cf 48b3     ...q....S..(...H
 8019113:	f000 fb8e 2800 d0ca f7ff fe14 2108 e8bd     .....(.......!..
 8019123:	47f0 2020 f7ff b944 2001 f7ff f99b f8d9     .G  ..D.. ......
 8019133:	0000 4cac 7bc0 f080 0101 7820 f361 1005     ...L.{.... xa...
 8019143:	7020 f000 fb35 b1f0 f000 fb8f b1d8 f000      p..5...........
 8019153:	fdb5 f7ff fe0e 2110 2020 f7ff f929 f000     .......!  ..)...
 8019163:	fcd8 f8d9 0000 7bc1 7820 f361 1005 7020     .......{ xa... p
 8019173:	4898 2115 ea41 4000 f7fc f8a2 2040 8078     .H.!A..@....@ x.
 8019183:	2001 e013 e016 2002 f7ff f96c f885 8037     . ..... ..l...7.
 8019193:	f000 fcbf f8d9 0000 7bc1 7820 f361 1005     .........{ xa...
 80191a3:	7020 2100 2020 f7ff f903 2000 e8bd 47f0      p.!  ..... ...G
 80191b3:	f7ff be84 e8bd 87f0 e92d 5ff0 4f8a f897     ........-.._.O..
 80191c3:	1021 f241 004c f04f 0801 2400 b139 f887     !.A.L.O....$9...
 80191d3:	4021 f887 8020 f7fc f873 4638 e009 f897     !@.. ...s.8F....
 80191e3:	1022 b141 f887 4022 f887 4020 f7fc f868     ".A..."@.. @..h.
 80191f3:	2000 f7ff fc51 4d79 f8df a1d4 8868 f8df     . ..Q.yM....h...
 8019203:	91d4 b140 1e40 0400 0c00 8068 d103 f88a     ..@.@.....h.....
 8019213:	8006 f8c9 4000 f89a 0005 b178 f88a 4005     .....@....x....@
 8019223:	f88a 4006 f88a 4002 2000 f7fc f9c6 f7fd     ...@...@. ......
 8019233:	ff45 2000 f7ff ff08 204c e016 f89a 0006     E.. ....L ......
 8019243:	4964 b28e b1a8 f88a 4006 f88a 8003 2000     dI.......@..... 
 8019253:	f7fc f9b3 f89a 0000 2808 d302 2015 f7ff     .........(... ..
 8019263:	f913 f242 004c eb00 4006 e8bd 5ff0 f7fc     ..B.L....@..._..
 8019273:	b827 f89a 0004 f04f 0b64 b1f8 f88a 4004     '.....O.d......@
 8019283:	f88a 8002 223e 2100 4852 f640 334f 4798     ....>".!RH@.O3.G
 8019293:	f7ff fc20 204c f7fc f813 f7ff fd04 f8a5     .. .L ..........
 80192a3:	b002 2005 f7ff fed0 f2af 00f3 f7ff f87d     ... ..........}.
 80192b3:	e8bd 5ff0 2100 2001 f7ff b87a f89a 0000     ..._.!. ..z.....
 80192c3:	1f40 2809 d254 e8df f000 0f05 3719 5353     @..(T........7SS
 80192d3:	5353 0037 7828 b1c0 702c f7ff fd02 2006     SS7.(x..,p..... 
 80192e3:	f7ff feb2 2014 8068 7828 b148 702c f7ff     ..... h.(xH.,p..
 80192f3:	fd0b 2007 f7ff fea8 f8a5 b002 7828 b938     ... ........(x8.
 8019303:	f7ff fe06 f7ff fd4e e032 f7ff fdac e02f     ......N.2...../.
 8019313:	702c f7ff fd08 2040 8068 2008 ea40 4006     ,p....@ h.. @..@
 8019323:	f7fb ffce f899 000c 06c0 d505 f7fd fee2     ................
 8019333:	f8d9 0000 f7fd fe9b f897 0020 b148 f899     .......... .H...
 8019343:	000c 07c1 d005 2102 ebb1 1f50 d001 200d     .......!..P.... 
 8019353:	e000 2008 f7ff fe78 2000 f7ff f883 f7ff     ... ..x.. ......
 8019363:	fdd7 f7ff fd1f f000 fc97 2002 f7fc f925     ........... ..%.
 8019373:	f8b9 0025 f5a0 7140 39fb d106 2001 f7ff     ..%...@q.9... ..
 8019383:	f817 e8bd 5ff0 f000 bbc4 2102 2004 f7ff     ....._.....!. ..
 8019393:	f80f f2af 3021 e8bd 5ff0 f7ff b806 b510     ....!0..._......
 80193a3:	4c0e 223e 6060 2100 480a f640 334f 4798     .L>"``.!.H@.O3.G
 80193b3:	4907 2000 4a07 7008 7e91 f360 1107 7691     .I. .J.p.~`....v
 80193c3:	8060 7020 f2af 200f e8bd 4010 f7fe bfe3     `. p... ...@....
 80193d3:	0020 a05a 0020 7465 0000 19c1 0020 a85a      .Z. .et.... .Z.
 80193e3:	0020 9c5a 0020 ee66 0020 b265 b570 4da2      .Z. .f. .e.p..M
 80193f3:	4ca2 8828 0980 f8a4 0025 6828 f3c0 0115     .L(.....%.(h....
 8019403:	f104 0029 f7ff fd0c 4e9d 8af0 f8a4 0027     ..)......N....'.
 8019413:	7da8 09c0 f884 003c 7c28 09c1 7b20 f361     .}....<.(|.. {a.
 8019423:	0082 7320 b2c1 792a f041 0002 b90a f021     .. s..*yA.....!.
 8019433:	0002 7320 89a8 f3c0 010b 8b20 f361 000b     .. s...... .a...
 8019443:	8320 89e8 f3c0 010b 8b60 f361 000b 8360      .......`.a...`.
 8019453:	488c 7980 0980 7b20 d10d f040 0001 7320     .H.y.. {..@... s
 8019463:	4889 8900 f8a4 0021 4886 f7ff f897 8800     .H....!..H......
 8019473:	f8a4 0023 e002 f020 0001 7320 7c28 0640     ..#... ... s(|@.
 8019483:	d501 2002 e008 7c68 0840 d004 8f21 2005     ... ..h|@...!.. 
 8019493:	b911 2004 e000 2003 7b21 ebb0 1f51 d00f     ... ... !{..Q...
 80194a3:	f360 1147 7321 2001 b2c9 2202 ebb2 1f51     `.G.!s. ..."..Q.
 80194b3:	d200 2000 f244 014c eb01 4000 f7fb ff00     ... D.L....@....
 80194c3:	4972 f996 2018 f9b1 0002 eb00 0040 17c3     rI... ......@...
 80194d3:	eb00 7093 eb02 00a0 b200 8048 1c80 17c1     ...p......H.....
 80194e3:	eb00 7091 1080 75e0 bd70 b570 4862 4d63     ...p...up.p.bHcM
 80194f3:	7cc0 f3c0 0003 eb00 71d0 07c6 485e eb05     .|.......q..^H..
 8019503:	0461 7d42 7be3 f3c2 0002 f3c2 1100 d004     a.B}.{..........
 8019513:	f003 03f0 ea40 00c1 e004 01c9 f003 030f     ....@...........
 8019523:	ea41 1000 4318 06d1 73e0 4a53 f04f 0001     A....C...sSJO...
 8019533:	7cd2 8f29 f3c2 0203 fa00 f002 d501 4301     .|)............C
 8019543:	e000 4381 8729 bd70 b430 484e 4b4a f8d0     ...C).p.0.NHJK..
 8019553:	1002 484a 6001 7b19 090a 7e01 f362 1107     ..JH.`.{...~b...
 8019563:	7601 7c59 f3c1 0200 7b01 f362 1104 7301     .vY|.....{b....s
 8019573:	7c19 7b02 f3c1 1440 f364 02c3 7302 f3c1     .|.{..@.d....s..
 8019583:	02c0 f880 2030 f3c1 0202 7782 f3c1 1100     ....0 .....w....
 8019593:	f880 102f 7d99 f3c1 1180 f880 103d 4838     ../..}......=.8H
 80195a3:	f990 0018 0081 4839 8041 2101 4091 1e49     ......9HA..!.@I.
 80195b3:	f244 0201 ea42 2101 8001 bc30 e716 b570     D...B..!..0...p.
 80195c3:	f7ff ff14 4c2c 4d2d 7ba0 2601 0900 280f     ....,L-M.{.&...(
 80195d3:	d21d e8df f000 1c08 1c1c 1c1c 1c1c 0c0c     ................
 80195e3:	0c0c 0c0c 0019 f8d4 0012 6068 e00f f7ff     ..........h`....
 80195f3:	ff7c 7ce1 f8b5 000d f3c1 0203 fa06 f102     |..|............
 8019603:	4308 f8a5 000d e002 f8d4 0012 60a8 7ba0     .C...........`.{
 8019613:	491e 0904 880a fa06 f304 439a 800a b291     .I.........C....
 8019623:	4630 2900 d000 2000 bd70 b510 f7ff fede     0F.)... p.......
 8019633:	4a11 2101 7b90 0900 4081 f011 0ffe d00a     .J.!.{...@......
 8019643:	f8d2 1012 4a12 6812 4291 d104 490b f881     .....J.h.B...I..
 8019653:	002e 2001 bd10 2000 bd10 b510 f7ff fec6     ... ... ........
 8019663:	4805 7b80 0901 2001 4088 f410 5f7c d002     .H.{... .@..|_..
 8019673:	e8bd 4010 e739 bd10 0020 6266 0020 7465     ...@9... .fb .et
 8019683:	0020 d665 0020 4866 0020 3c66 0020 b15a      .e. .fH .f< .Z.
 8019693:	0100 ac00 e92d 47f0 88c3 2419 4363 4cfa     ....-..G...$cC.L
 80196a3:	fbb4 f5f3 b672 4bf9 899c f8b3 64e0 b662     ....r..K.....db.
 80196b3:	881b f8df e3dc f8be 7027 f89e c02e 1bbe     ........'p......
 80196c3:	4ff4 b2b6 f81c 7007 f8df c3cc f8dc c000     .O.....p........
 80196d3:	f89c c00f f1bc 0f00 d102 f240 4884 e001     ..........@..H..
 80196e3:	f04f 089c eb08 1747 b2bf 4437 78c0 fa1f     O.....G...7D.x..
 80196f3:	f887 4627 f04f 0964 2804 d008 fb08 f809     ..'FO.d..(......
 8019703:	fbb8 f7f5 4427 fbb7 f8f3 fb03 7718 fa1f     ....'D.......w..
 8019713:	f887 4fdf f04f 0a7d 7e3f 093f fb07 f70a     ...OO.}.?~?.....
 8019723:	f1bc 0f00 d102 f44f 6cfa e001 f44f 7c7a     ......O..l..O.z|
 8019733:	eb0c 0747 047f eb06 4617 f8be 703a 1bf6     ..G......F..:p..
 8019743:	3ed2 b2b6 fb06 f609 fbb6 f5f5 442c fbb4     .>..........,D..
 8019753:	f5f3 fb03 4415 b2a5 f89e 6030 2480 b126     .....D....0`.$&.
 8019763:	2804 d002 2805 d000 24c0 442c fb94 f5f3     .(...(...$,D....
 8019773:	fb03 4415 17e5 eb04 6495 eb03 0508 3d80     ...D.....d.....=
 8019783:	fb95 f6f3 fb03 5316 17dd eb03 6395 11a4     .......S.....c..
 8019793:	119b 2804 d001 2805 d103 600c 6013 e8bd     ...(...(...`.`..
 80197a3:	87f0 00a0 6008 2003 eb00 0083 6010 e7f6     .....`. .....`..
 80197b3:	49ba 7d48 2802 d10c 48b9 7980 0982 d003     .IH}.(...H.y....
 80197c3:	2201 ebb2 1f90 d104 7e48 0600 d501 2001     ."......H~..... 
 80197d3:	4770 2000 4770 b510 48b1 f8d0 2002 48b1     pG. pG...H... .H
 80197e3:	6800 68c1 1c4b d105 49aa 1f09 7c09 0609     .h.hK....I...|..
 80197f3:	d50f e002 b109 4291 d10b 49a8 f991 1018     .......B...I....
 8019803:	f990 3014 4299 db04 6900 b140 e004 4291     ...0.B...i@....B
 8019813:	d101 2000 bd10 1d00 6801 2900 d1f7 49a2     ... .....h.)...I
 8019823:	2000 7008 f7ff fe90 2001 bd10 f7ff bec7     . .p..... ......
 8019833:	b510 4604 f7ff fef9 b120 2014 f7fe fe24     ...F.... .. ..$.
 8019843:	2001 e010 4892 7b00 0780 d401 2000 bd10     . ...H.{..... ..
 8019853:	4c95 7820 b930 f7fe fe46 f000 0007 7020     .L x0...F..... p
 8019863:	2001 bd10 1e40 7020 e7f0 e92d 5ff0 f7ff     . ..@. p..-.._..
 8019873:	fef4 f8df a21c f04f 0801 f89a 102e 4f85     ......O........O
 8019883:	1e4a fa08 f002 1f3f 7c7a ea10 0f52 d009     J.....?.z|..R...
 8019893:	7bb8 ebb1 1f10 d10b 4a84 f8d7 1012 6812     .{.......J.....h
 80198a3:	4291 d005 4882 f880 8006 2000 e8bd 9ff0     .B...H..... ....
 80198b3:	0900 fa08 f000 f410 5f7c d029 7cf8 4646     ........|_)..|FF
 80198c3:	f3c0 0403 f9b7 0012 1145 4640 2c0a da00     ........E.@F.,..
 80198d3:	2000 f7fe fcc6 42a8 d009 0428 2c0a da00     . .....B..(..,..
 80198e3:	2600 ea40 3006 f040 0031 f7fb fce9 f9b7     .&@..0@.1.......
 80198f3:	0014 1145 4620 f7fe fcbc 42a8 d008 0428     ..E. F.....B..(.
 8019903:	f004 010f ea40 3001 f040 0032 f7fb fcd8     ....@..0@.2.....
 8019913:	2001 bf00 4c67 4d61 b150 8920 b140 4860     . ..gLaMP. .@.`H
 8019923:	7980 06c0 d504 7e68 0640 d501 f7fd fc62     .y....h~@.....b.
 8019933:	f8df b184 f89b 1020 4855 f640 334f 3031     ...... .UH@.O310
 8019943:	2900 d07e 4956 7989 0709 d57a 7e69 0689     .)~.VI.y..z.i~..
 8019953:	d577 2206 2100 4798 f88a 8037 8960 f040     w..".!.G..7.`.@.
 8019963:	5500 484f f7fe fdf7 7806 f04f 0907 e059     .UOH.....xO...Y.
 8019973:	f001 000f 1c6d 1e76 fa08 f200 f3c1 1102     ....m.v.........
 8019983:	f412 4f7c d053 eb0a 0350 7bdc 2300 07c7     ..|OS...P..{.#..
 8019993:	d100 2304 40dc f004 0307 2b01 d00c 2b02     ...#.@.....+...+
 80199a3:	d00a 2b04 d001 2b05 d141 f8ba 301a f3c3     ...+...+A....0..
 80199b3:	030b eb09 1393 e005 f8ba 301a f3c3 030b     ...........0....
 80199c3:	eb09 1313 08dc d032 f89a 302e 428b d106     ......2....0.B..
 80199d3:	f8ba 701f 4017 f8ba 201c 4317 e002 f8ba     ...p.@... .C....
 80199e3:	701c 4397 f8aa 701c f83b 2010 b10a 428b     .p.C...p;.. ...B
 80199f3:	d004 1b36 1e76 4425 1c6d e013 f815 1b01     ..6.v.%Dm.......
 8019a03:	4450 f880 1027 f042 5700 8b78 1e76 f040     PD..'.B..Wx.v.@.
 8019a13:	5000 4622 4629 f640 3347 4798 f887 8025     .P"F)F@.G3.G..%.
 8019a23:	1b36 4425 7829 2980 d001 2e00 dca0 f8ba     6.%D)x.)........
 8019a33:	101c f8ba 001f f44f 427c ea22 0101 4208     ......O.|B"....B
 8019a43:	e000 e00d d100 b9a8 f8ba 1038 f8ba 000d     ..........8.....
 8019a53:	438a 4010 212b ea41 4000 f7fb fc31 e009     .C.@+!A..@..1...
 8019a63:	f89a 1037 b119 2000 f88a 0037 e002 2206     ..7.... ..7...."
 8019a73:	2100 4798 f89b 0020 b3e8 4809 f7fe fd7c     .!.G.. ....H..|.
 8019a83:	4606 2500 4f06 e034 eb0b 00c2 0040 2206     .F.%.O4.....@.."
 8019a93:	0020 7465 0020 6666 0020 9c5a 0020 d665      .et .ff .Z. .e.
 8019aa3:	0020 4866 0020 ac5a 0020 b55a 0100 ac00      .fH .Z. .Z.....
 8019ab3:	0020 a05a 0020 1266 0020 b265 f816 0015      .Z. .f. .e.....
 8019ac3:	0900 f83b 0010 f7fb fb8e 0004 d010 f894     ..;.............
 8019ad3:	0024 f3c0 1001 2802 d10a 7fe0 0901 2003     $......(....... 
 8019ae3:	f7fe fcb6 7fe0 f3c0 0103 2004 f7fe fcb0     ........... ....
 8019af3:	1c6d 79b8 e000 e003 f3c0 0002 42a8 dcdd     m..y.........B..
 8019b03:	f89a 102e 4881 5c08 2800 f43f aecf 2001     .....H.\.(?.... 
 8019b13:	e6cc e92d 5ff0 f8df 91f8 4f7e f899 102f     ..-.._....~O../.
 8019b23:	79b8 b159 f040 0020 71b8 487b f7fe f8ac     .yY.@. ..q{H....
 8019b33:	4638 f7fe fcfb 210d 7001 e002 f020 0020     8F.....!.p.. . .
 8019b43:	71b8 f7fd fad7 0004 79b8 d00d f040 0010     .q.......y..@...
 8019b53:	71b8 4872 8484 486f f7fe fcef 7862 2106     .qrH..oH....bx.!
 8019b63:	eb01 0152 7001 e002 f020 0010 71b8 f8df     ..R..p.. ....q..
 8019b73:	a1b0 2500 f89a 0020 f8df b1a8 f04f 0801     ...%.. .....O...
 8019b83:	b310 f8b9 001c f3c0 0409 e01b fa94 f0a4     ................
 8019b93:	fab0 f680 fa08 f006 4384 f83a 0016 f7fb     .........C:.....
 8019ba3:	fb22 b178 f80b 6005 7901 1c6d 1dc9 08ce     ".x....`.ym.....
 8019bb3:	8a80 4632 f040 5100 eb0b 0005 f640 3347     ..2F@..Q....@.G3
 8019bc3:	4798 4435 2c00 d1e1 2080 4c52 f80b 0005     .G5D.,... RL....
 8019bd3:	79a0 1c6d f040 0008 71a0 4620 f7fe fcbb     .ym.@....q F....
 8019be3:	7005 79a0 f020 0007 71a0 f89a 0020 2800     .p.y ....q.. ..(
 8019bf3:	d04a f8b9 001f 0a80 d046 494b 2000 7008     J.......F.KI. .p
 8019c03:	4620 f7fe fcb9 4604 f8b9 001f f400 467c      F.....F......|F
 8019c13:	e038 4630 f7fe fc6e 4607 fa08 f000 4683     8.0F..n..F.....F
 8019c23:	4386 f83a 0017 f7fb fade 0005 d02a f8b9     .C:.........*...
 8019c33:	001c ea1b 0f00 d02c eb09 0007 f890 0027     ......,.......'.
 8019c43:	0101 f5b1 7f00 db01 f240 11ff 4a36 4628     ........@...6J(F
 8019c53:	f7fe fdb1 8821 f04f 5200 f360 0108 8021     ....!.O..R`...!.
 8019c63:	7969 7820 f361 1007 7020 78e9 b2c0 f361     iy xa... p.x..a.
 8019c73:	0043 f804 0b02 4827 7981 eb02 01f1 ea4f     C.....'H.y....O.
 8019c83:	7171 7181 2e00 d1c4 e8bd 5ff0 4821 f7fe     qq.q......._!H..
 8019c93:	bc99 4a25 2100 e7da 4b21 f893 0020 2800     ..%J.!..!K.. ..(
 8019ca3:	d00b 200a 2200 f833 1010 b119 f041 5100     ... ."3.....A..Q
 8019cb3:	f881 2025 1c40 280f ddf5 4770 b5f0 4e18     ..% @..(..pG...N
 8019cc3:	f896 0020 2800 d020 210a f836 0011 b1c8     .. ..( ..!6.....
 8019cd3:	f040 5000 8ac2 f890 3025 f042 5200 b18b     @..P....%0B..R..
 8019ce3:	7903 8b40 331f 095c f040 5300 2000 e007     .y@..3\.@..S. ..
 8019cf3:	eb03 0580 682d eb02 0780 43ed 603d 1c40     ....-h.....C=`@.
 8019d03:	42a0 dbf5 1c49 290f dddf bdf0 0020 6666     .B..I..).... .ff
 8019d13:	0020 7465 0020 ee66 0020 0867 0020 1266      .et .f. .g. .f.
 8019d23:	0020 b265 0020 1667 0020 b05a b530 49ee      .e. .g. .Z.0..I
 8019d33:	8809 4cee f44f 65f0 8824 8843 00e4 fbb4     ...LO..e$.C.....
 8019d43:	f4f5 8800 0189 4420 0040 fb90 f4f1 fb01     ...... D@.......
 8019d53:	0014 eb01 72d1 1052 eba0 0043 4290 dd01     .....rR...C..B..
 8019d63:	1a40 bd30 4252 4290 dafb 4408 bd30 b530     @.0.RB.B...D0.0.
 8019d73:	4604 f7ff ffdb 4adc 3020 8811 eb01 10a0     .F.....J 0......
 8019d83:	8811 fb90 f3f1 fb01 0013 b280 8110 8861     ..............a.
 8019d93:	eb01 1040 8811 4dd6 0149 fbb0 f2f1 fb01     ..@....MI.......
 8019da3:	0012 8060 b280 0940 81a8 4620 f7ff ffbe     ..`...@... F....
 8019db3:	81e8 bd30 b5f0 4606 4ccd 8871 89a0 4dca     ..0....F.Lq....M
 8019dc3:	ebc0 1051 8829 4408 8829 f8df c320 fb90     ..Q.)..D)... ...
 8019dd3:	f2f1 fb01 0112 f8bc 0000 eb01 1150 0900     ............P...
 8019de3:	fb91 f7f0 4630 f7ff ffa1 f9b4 100e 227d     ....0F........}"
 8019df3:	1a41 7930 2319 4350 0112 eb02 0040 4abd     A.0y.#PC....@..J
 8019e03:	1c49 fbb2 f2f0 f8bc 0000 4351 4358 01ba     I.........QCXC..
 8019e13:	fb91 f1f2 f8b5 21e8 4401 0652 0ad2 1a0b     .......!.DR.....
 8019e23:	4353 f9b5 21e6 fb02 3101 fb91 f0f0 f8a5     SC...!...1......
 8019e33:	01e6 f8b5 01e6 80e0 2000 6020 80a0 2107     .........  `...!
 8019e43:	72a1 72e0 1568 8120 8261 2032 8220 bdf0     .r.rh. .a.2  ...
 8019e53:	b570 f7ff ff6b 4ca6 f9b4 1008 4281 db02     p...k..L.....B..
 8019e63:	4249 4281 dd08 7aa0 1e40 f010 00ff 72a0     IB.B...z@......r
 8019e73:	d05a 2000 72e0 e009 7ae1 1c49 b2c9 72e1     Z.. .r...zI....r
 8019e83:	2919 d303 2119 72e1 2107 72a1 88a1 b205     .)...!.r.!.r....
 8019e93:	1b49 b209 80a1 8a22 b18a 1e52 0412 0c12     I....."...R.....
 8019ea3:	8222 d10c 8a62 1e92 b212 8262 2a00 dd02     "...b.....b..*..
 8019eb3:	2232 8222 e003 2201 8262 2240 8122 f9b4     2""...."b.@""...
 8019ec3:	3012 6826 4098 d503 4242 1112 4252 e000     .0&h.@..BB..RB..
 8019ed3:	1102 18b2 6022 d503 4252 1092 4252 e000     ...."`..RB..RB..
 8019ee3:	1092 88e6 2800 eb02 0246 da03 4240 1040     .....(..F...@B@.
 8019ef3:	4240 e000 1040 4410 2900 da03 4249 4119     @B..@..D.)..IB.A
 8019f03:	4249 e000 4119 4408 497b 1040 424a 4290     IB...A.D{I@.JB.B
 8019f13:	da01 4288 dd04 f643 71ff 4290 da00 4601     ...B..C..q.B...F
 8019f23:	4876 8001 80a5 2001 bd70 e92d 47f0 4d6f     vH..... p.-..GoM
 8019f33:	4604 b2c1 f3c0 3303 2706 78aa 0c00 f04f     .F.....3.'.x..O.
 8019f43:	0804 f64f 7cff f04f 0a07 f1a5 0908 f04f     ..O..|O.......O.
 8019f53:	4680 290c d038 dc11 2901 d021 2904 d132     .F.)8....)!..)2.
 8019f63:	4862 78c1 1e48 b2c0 2a0b d22c e8df f002     bH.xH....*,.....
 8019f73:	b2b2 b2b2 7364 7373 7773 008e f04f 0800     ....dssssw..O...
 8019f83:	290d d049 290f d1ea 1f52 f04f 5000 ea40     .)I..)..R.O..P@.
 8019f93:	4014 2a05 d230 e8df f002 807e 918a 0095     .@.*0.....~.....
 8019fa3:	f8c9 0000 f8b6 1600 f001 0104 1c89 f8a6     ................
 8019fb3:	1600 f886 a208 f886 a209 7800 b108 f886     ...........x....
 8019fc3:	a207 f8a6 7144 e085 2b0b d118 f8d9 1000     ....Dq...+......
 8019fd3:	1cc9 f000 f952 f8c9 0004 f8d9 1000 788a     ....R..........x
 8019fe3:	7849 f000 f89a b140 f8d9 0004 8800 8028     Ix....@.......(.
 8019ff3:	2003 70e8 f885 8002 e069 200c e011 2b09     . .p....i.. ...+
 801a003:	d165 f8a6 c624 f8a6 c626 f8a6 0622 2001     e...$...&...".. 
 801a013:	f8a6 061a 2005 e04d 2b0b d105 f8a6 861a     ..... M..+......
 801a023:	200b f000 f859 e052 f414 4f70 d14f f000     . ..Y.R...pOO...
 801a033:	f8e6 200a 70a8 e04a 70e8 b151 2901 d149     ... .pJ..pQ..)I.
 801a043:	f8a6 8144 f8b6 0800 f040 0001 f8a6 0800     ..D.....@.......
 801a053:	e040 200b e017 70e8 bb79 200d e013 f8b6     @.. ...py.. ....
 801a063:	061e 2104 f000 f8f6 8829 4288 d10a f8b6     ...!....)..B....
 801a073:	062c 2104 f000 f8ee 8829 4288 d102 f8b6     ,..!....)..B....
 801a083:	0618 b1d0 2001 f000 f827 e023 f000 f8cf     ..... ..'.#.....
 801a093:	b198 2000 e7f7 70af e00d f7ff fe68 f885     ... ...p....h...
 801a0a3:	a002 70ef f8a6 8618 f8a6 c62c e00f f7ff     ...p......,.....
 801a0b3:	fe81 2008 70a8 70ef e009 e00b f7ff fe57     ... .p.p......W.
 801a0c3:	2009 e7ae f7ff fec4 b908 2001 e7a9 2000     . ......... ... 
 801a0d3:	e8bd 87f0 4620 e7fb 4904 7088 210e ea41     .... F...I.p.!A.
 801a0e3:	4000 f7fb b8ed 0000 0040 2206 0020 c05a     .@......@.." .Z.
 801a0f3:	0020 7667 0f00 4042 ffff 00c0 0040 0808      .gv..B@....@...
 801a103:	2219 fbb0 f2f2 4962 e002 4282 d003 1c89     ."....bI...B....
 801a113:	8808 2800 d1f9 8808 4770 b5f0 4603 8800     ...(....pG...F..
 801a123:	2519 460c 4616 4368 f7ff ffea 2800 d065     .%.F.FhC.....(e.
 801a133:	8818 07aa f5a0 61c0 394b d10c 2060 f8a2     .......aK9..` ..
 801a143:	080a f640 60bf f8a2 0808 8818 8859 4348     ..@..`......Y.HC
 801a153:	4368 4950 e01f f240 11b9 fbb0 f7f1 fb01     hCPI..@.........
 801a163:	0017 b960 205a f8a2 080a f241 4046 f8a2     ..`.Z ....A.F@..
 801a173:	0808 8818 8859 4348 4368 4947 e00b 2062     ....Y.HChCGI..b 
 801a183:	f8a2 080a f241 3075 f8a2 0808 8818 8859     ....A.u0......Y.
 801a193:	4348 4942 4368 fbb1 f0f0 f8a2 0804 f8b2     HCBIhC..........
 801a1a3:	0804 8899 fbb0 f0f1 f8a2 0802 8859 2001     ............Y.. 
 801a1b3:	b104 2000 1a09 1c60 fb91 f0f0 f8a2 0806     ... ..`.........
 801a1c3:	00f0 ea40 0044 f040 00f0 f8a2 0800 f44f     ..@.D.@.......O.
 801a1d3:	3180 f8d1 00ac 0e00 d009 f891 00ab 2802     .1.............(
 801a1e3:	d305 28ff d003 f891 01a8 0040 e000 200e     ...(......@.... 
 801a1f3:	f8a2 0a68 201f f8a2 0a66 2001 bdf0 4828     ..h.. ..f.. ..(H
 801a203:	f8b0 16bc f021 0101 f8a0 16bc 2200 8002     ....!........"..
 801a213:	f64f 71ff f8a0 14e0 f8a0 14e2 f200 40d4     O..q...........@
 801a223:	8042 2101 8041 f64f 71f7 8001 4770 f04f     B..!A.O..q..pGO.
 801a233:	4080 f8b0 1618 0709 d50a 2102 f8a0 1144     .@.........!..D.
 801a243:	2101 f8a0 1a68 2100 f8a0 161a 2001 4770     .!..h..!..... pG
 801a253:	2000 4770 b530 4a0e 4c12 e009 fbb4 f3f3     . pG0..J.L......
 801a263:	b29b 1a5d 4285 dc02 440b 4283 da03 1c92     ..]..B...D.B....
 801a273:	8813 2b00 d1f2 8810 bd30 4602 4608 e002     ...+....0..F.F..
 801a283:	4291 d003 3008 8801 2900 d1f9 4770 0000     .B...0...)..pG..
 801a293:	0000 54f0 9a08 008a 1308 0030 ca08 0000     ...T......0.....
 801a2a3:	0040 4401 0e00 00a6 e92d 41f0 4606 4d67     @..D....-..A.FgM
 801a2b3:	0c33 b2c0 2700 7b2a f04f 0c01 b2dc f04f     3....'*{O.....O.
 801a2c3:	38ff f3c6 3103 282a d035 dc16 2801 d029     .8...1*(5....().
 801a2d3:	2803 d03b 2812 d050 2826 d10b 0c30 d109     .(;..(P.&(..0...
 801a2e3:	0610 d407 485a f7fb f824 2080 f000 f8d9     ....ZH..$.. ....
 801a2f3:	f000 f8dd 4630 e8bd 81f0 282d d018 283e     ....0F....-(..>(
 801a303:	d01c f04f 5300 ea43 4416 284b d05c 284c     ..O..SC..DK(\.L(
 801a313:	d1f0 b379 2901 d035 2902 d035 2903 d1e7     ..y..)5..)5..)..
 801a323:	742f e7e5 7818 f885 0033 f885 c00e e7e1     /t...x..3.......
 801a333:	f885 4031 e7dc f885 4032 e7d9 ebbc 4f16     ..1@....2@.....O
 801a343:	d101 2001 e000 2000 74a8 e7d1 f9b5 0004     ... ... .t......
 801a353:	2800 dd05 1e40 b200 80a8 b908 f000 f8a7     .(..@...........
 801a363:	7d28 2808 d207 69a8 1c40 61a8 d1c2 f8c5     (}.(...i@..a....
 801a373:	8018 e7bf e003 61af e7bc 7529 e7b8 75af     .......a..)u...u
 801a383:	756f e7b5 75ef e7b3 f885 c015 2a13 d1af     ou...u.......*..
 801a393:	6820 2800 d0ac 6860 b160 79a9 6828 ebc1      h.(..`h`..y(h..
 801a3a3:	02c1 1c49 eb00 0082 71a9 221c 4621 f640     ..I......q."!F@.
 801a3b3:	3347 4798 6ae9 7a2a 6820 eb01 0182 6008     G3.G.j*z h.....`
 801a3c3:	7a28 1c40 7228 e793 b129 2901 d024 2902     (z@.(r..)..)$..)
 801a3d3:	d190 2040 e78a f8d4 0002 61e8 f8d4 0006     ..@ .......a....
 801a3e3:	6228 f8d4 000a 6268 7ba0 07c0 d100 4680     (b....hb.{.....F
 801a3f3:	f8c5 8028 62ef 7be0 f885 0030 602f 8820     ..(..b.{..0./` .
 801a403:	f3c0 000b 80a8 71af 7820 0900 71e8 722f     .......q x...q/r
 801a413:	2020 7268 2010 e769 f8d4 0006 61e8 f8d4       hr. i......a..
 801a423:	000a 6228 f8d4 000e 6268 f8d4 0002 62a8     ..(b....hb.....b
 801a433:	62ef 2080 f885 0030 8820 f3c0 000e 80a8     .b. ..0. .......
 801a443:	72af 2020 e752 4801 6980 4770 0020 8a67     .r  R..H.ipG .g.
 801a453:	0400 2410 b510 4cb4 7ce2 b108 2101 e000     ...$...L.|...!..
 801a463:	2100 428a d00d 74e1 49af f000 000f 311c     .!.B...t.I.....1
 801a473:	0409 ea41 3000 f040 0010 f7fa ff21 2001     ..A..0@.....!.. 
 801a483:	75a0 bd10 b570 4da8 4604 7be8 42a0 d007     .u..p..M.F.{.B..
 801a493:	2048 ea40 4004 f7fa ff13 2001 7428 73ec     H @..@..... (t.s
 801a4a3:	bd70 49a1 7b0a 0612 d400 7308 4770 e92d     p..I.{.....spG-.
 801a4b3:	47f0 4e9d 2501 4630 f896 4036 7cb1 7b80     .G.N.%0F..6@.|.{
 801a4c3:	2700 b111 b950 4628 e005 b138 7c70 b928     .'..P.(F..8.p|(.
 801a4d3:	7df0 b918 4638 73b0 f7fc f9b8 7db0 2800     .}..8F.s.....}.(
 801a4e3:	d12f 7df0 2800 d1fb 7c30 2800 d1f8 7b31     /..}.(..0|.(..1{
 801a4f3:	f04f 38ff 06c8 d54d 2910 d023 2911 d030     O..8..M..)#..)0.
 801a503:	2913 d1ed 7cf0 bbf0 f9b6 0004 1c40 d007     .)...|......@...
 801a513:	7a30 7a71 4288 d203 79b0 79f1 4288 d333     0zqz.B...y.y.B3.
 801a523:	6830 79b1 0400 f001 010f ea40 3001 f040     0h.y......@..0@.
 801a533:	0046 f7fa fec5 2014 7330 2401 2000 f7ff     F...... 0s.$. ..
 801a543:	ffa1 e0c7 2000 f7ff ff85 2011 7330 2404     ..... ..... 0s.$
 801a553:	2001 f7ff ff97 7db0 2800 d1f2 7c30 2800     . .....}.(..0|.(
 801a563:	d1ef 4872 62f0 7a71 1d02 eb02 0281 6032     ..rH.bqz......2`
 801a573:	1c49 008a 2100 f640 334f 4798 2004 f7ff     I....!@.O3.G. ..
 801a583:	ff69 2013 e0a5 e001 2004 e050 7d70 2800     i.. ..... P.p}.(
 801a593:	d05b e04b f8df 9198 0688 d573 7c72 7cb0     [.K.......s.r|.|
 801a5a3:	4282 d00a 7470 b2c0 b100 4862 2117 ea41     .B..pt....bH.!A.
 801a5b3:	4000 f7fa fe85 75f5 e08c 2920 d011 2921     .@.....u.. )..!)
 801a5c3:	d01e 2923 d1bd 7cf0 bb70 f9b6 0004 2800     ..#)...|p......(
 801a5d3:	dc03 7ab1 b1d1 1c80 d118 2005 f7ff ff3a     ...z....... ..:.
 801a5e3:	e020 2000 f7ff ff36 2021 7330 2401 4620      .. ..6.! 0s.$ F
 801a5f3:	f7ff ff48 7db0 2800 d16c 7c30 2800 d169     ..H..}.(l.0|.(i.
 801a603:	2005 f7ff ff27 72f7 2023 e062 4848 3010     . ..'..r# b.HH.0
 801a613:	f7fa fe56 7af0 b918 2047 f7fa fe51 72f5     ..V..z..G ..Q..r
 801a623:	2024 7330 2401 e055 7d70 b118 2000 f7ff     $ 0s.$U.p}... ..
 801a633:	ff11 e04f 7d30 1f40 2809 d24b e8df f000     ..O.0}@..(K.....
 801a643:	0505 0d05 4a4a 4a4a 0010 88b0 2800 d141     ....JJJJ.....(A.
 801a653:	f7ff ff00 f8a6 8004 e03c 2000 f7ff ff12     ........<.. ....
 801a663:	f9b6 0004 1c80 d006 f06f 0001 80b0 4648     ........o.....HF
 801a673:	f7fa fe26 72f5 7d30 2402 2808 d02a 2403     ..&..r0}.$.(*..$
 801a683:	e028 e7ff 0648 d511 2940 d002 2941 d121     (...H...@)..A)!.
 801a693:	e007 2000 f7ff fede 2041 7330 7db0 2400     ... ....A 0s.}.$
 801a6a3:	b9c0 4648 f7fa fe0c 2042 e012 0608 d511     ..HF....B ......
 801a6b3:	2980 d002 2981 d10d e007 2000 f7ff feca     .)...)..... ....
 801a6c3:	2081 7330 7db0 2400 b920 481b f7fa fdf8     . 0s.}.$ ..H....
 801a6d3:	2082 7330 f886 4036 f896 0031 b170 f896     . 0s..6@..1.p...
 801a6e3:	0033 07c1 d001 2405 e008 0781 d502 f444     3......$......D.
 801a6f3:	64a0 e003 0740 d501 0620 0c04 f896 0033     .d..@... .....3.
 801a703:	0700 d504 f896 0032 b108 0620 0c04 8eb0     ......2... .....
 801a713:	42a0 d007 2028 86b4 ea40 4004 e8bd 47f0     .B..( ..@..@...G
 801a723:	f7fa bdce e8bd 87f0 0020 8a67 0020 002d     ........ .g. .-.
 801a733:	0100 4700 0020 bc5c 0400 2400 faff e5f5     ...G .\....$....
 801a743:	c5d5 a5b5 8595 6575 4555 2535 0515 0000     ......ueUE5%....
 801a753:	0000 e70d 0000 ec0b 0000 4c09 0000 0000     ...........L....
 801a763:	ffff a7f8 ffff eff2 ffff c3ee ffff 46e8     ...............F
 801a773:	ffff fae0 ffff 0bdc ffff fed5 ffff 6acf     ...............j
 801a783:	ffff 82c7 ffff 9abe ffff 97b5 ffff 7daf     ...............}
 801a793:	ffff 9ca7 ffff 22a0 0f20 805e 1120 220e     ......." .^. .."
 801a7a3:	1820 8920 1820 f8b9 0020 0020 0000 9309      . . ... . .....
 801a7b3:	0000 000d ff01 0428 e33f 0100 b000 73ff     ......(.?......s
 801a7c3:	73b3 03c8 2839 ff29 c9eb 9970 0128 b179     .s..9()...p.(.y.
 801a7d3:	58ff 0889 1191 0813 ff30 0878 c07c 6800     .X......0.x.|..h
 801a7e3:	053f 28ef 3f03 000b 0903 f39f 9fbf 28f4     ?..(.?.........(
 801a7f3:	1510 0057 030b 00fe 9f07 0592 2928 2394     ..W.........().#
 801a803:	28ff 1514 3f2f 3f0e ff2b 0990 8927 9927     .(../?.?+...'.'.
 801a813:	a927 307a a319 1910 9f01 9003 3530 32ef     '.z0........05.2
 801a823:	32d0 00d1 a20b 14d0 38ff 9007 9108 3307     .2.......8.....3
 801a833:	ff18 f737 0029 01e2 d432 28ff 3f01 2fc7     ..7.)...2..(.?./
 801a843:	2fd4 dfd1 d02f 64d0 0838 8d5d ff28 3f02     ./../..d8.].(..?
 801a853:	90eb 9608 3307 08f7 f737 0b00 73e5 28c5     .....3..7....s.(
 801a863:	01ff b67a 5803 1512 fd08 0056 cb59 6970     ..z..X....V.Y.pi
 801a873:	18d0 ff39 af04 0609 3f49 a003 f9df 3906     ..9.....I?.....9
 801a883:	6980 1500 00da 02ff 0890 4228 784c f728     .i........(BLx(.
 801a893:	9904 0078 8807 083f e595 1098 060f 0f18     ..x...?.........
 801a8a3:	4530 0838 ff68 0028 75c0 0998 590e 10fe     0E8.h.(..u...Y..
 801a8b3:	874d 0000 9704 8780 20fe 0543 8690 24d0     M........ C....$
 801a8c3:	0438 9fff 00f5 e6b6 9200 ff07 0864 0865     8...........d.e.
 801a8d3:	5903 895f 08ff 6265 6309 e009 ff30 8737     .Y_...eb.c..0.7.
 801a8e3:	0200 5591 4390 3fff 9003 9035 3213 ffda     ...U.C.?..5..2..
 801a8f3:	d532 c573 3558 b474 08fe 285b 7403 28b7     2.s.X5t...[(.t.(
 801a903:	7105 b8ff 850c 0739 a898 ff28 8603 9fb8     .q....9...(.....
 801a913:	28f8 8105 b8ff 0228 ca70 a509 ff08 e0a3     .(....(.p.......
 801a923:	0c15 3e45 0902 45bd 8318 8970 5803 8700     ..E>...E..p..X..
 801a933:	ff78 890d 0028 09c8 7912 11ff 0417 3697     x...(....y.....6
 801a943:	2ff3 ffd5 a505 9b28 b842 55f1 39ef d805     ./....(.B..U.9..
 801a953:	0108 000f 57cf d4fb 1048 a707 0328 b784     .....W..H...(...
 801a963:	28ff 7603 75b6 90b8 ff19 890d c37f 7803     .(.v.u.........x
 801a973:	5800 07ff 3958 e009 6c16 ff16 a6f8 093c     .X..X9...l....<.
 801a983:	5900 9306 00ff 3f59 9005 2806 ef0f f9cf     .Y....Y?...(....
 801a993:	9304 8100 8fb6 ffc3 0428 b874 8403 0028     ........(.t...(.
 801a9a3:	cbef 9004 0002 0725 0f28 dfef 38f9 001d     ......%.(....8..
 801a9b3:	f305 1a38 a4ff f004 390a d403 ff08 0738     ..8......9....8.
 801a9c3:	94a0 4290 0790 00fe 0b09 153f a4a0 2290     ...B......?...."
 801a9d3:	00fc 186f 0329 390c 0539 ff90 90c8 2819     ..o.)..99......(
 801a9e3:	1513 3f57 08ee 0521 c4a0 1f08 77ce 7f28     ..W?..!......w(.
 801a9f3:	8404 90b4 9008 0049 5f19 9060 0388 0829     ......I.._`...).
 801aa03:	2f07 4301 7cff 28c0 7001 71a1 ffc2 c87d     ./.C.|.(.p.q..}.
 801aa13:	c972 9858 a37e 08ff 0083 2802 1511 ef2f     r.X.~......(../.
 801aa23:	b470 b571 3101 32db ffdc 11d0 0d39 2790     p.q..1.2....9..'
 801aa33:	0727 90ff 2817 9811 2886 ff78 8894 8993     '....(...(x.....
 801aa43:	4628 d94c e0bf 3f19 900d 0037 0717 007e     (FL....?..7...~.
 801aa53:	64c3 8894 6528 1094 ff17 0029 f9e0 4628     .d..(e....)...(F
 801aa63:	294d 00ea c80b 0b00 00f8 180b 21d0 38fb     M)...........!.8
 801aa73:	0107 a829 18d0 0338 91fb 0086 4649 f64c     ..)...8.....IFL.
 801aa83:	7608 00fe 4619 f5ff 0a39 2328 93ff 2828     .v...F..9.(#..((
 801aa93:	9223 0906 7f68 1813 3f28 08e0 0a3f ff1d     #...h...(?..?...
 801aaa3:	4d46 2608 5807 0874 34ff 5603 7658 6308     FM.&.Xt..4.VXv.c
 801aab3:	f728 7301 00ac 1c4d ba7c ff90 2706 9076     (..s..M.|....'v.
 801aac3:	9485 7807 48ff 3800 2408 8811 ff3f 7809     ...x.H.8.$..?..x
 801aad3:	0039 0839 0023 19ff 1813 1913 9808 ff6c     9.9.#.........l.
 801aae3:	06f8 62c8 6308 e008 30ff 8967 956a 1990     ...b.c...0g.j...
 801aaf3:	ff00 6ca8 6878 5186 3689 87fd 3f00 2f15     ...lxh.Q.6...?./
 801ab03:	2fdc 2fdb da77 0390 e300 90f1 0823 7a05     ././w.......#..z
 801ab13:	d302 0839 72f1 90b4 0009 fda7 200b 07a7     ..9..r....... ..
 801ab23:	5891 4728 5d4e 0078 10fd 073f 0900 0079     .X(GN]x...?...y.
 801ab33:	df09 280b 9813 0059 890b bb28 9488 1d08     ...(..Y...(.....
 801ab43:	0898 0344 6273 10ee 880b 6328 1318 3990     ..D.sb....(c...9
 801ab53:	fd58 0894 08a3 9434 6407 bf05 0565 30e0     X.....4..d..e..0
 801ab63:	5803 8538 ff00 0015 8800 0845 3724 37f9     .X8.......E.$7.7
 801ab73:	8318 7d00 904d 0800 ff3a 3b08 7226 6103     ...}M...:..;&r.a
 801ab83:	a87a 0cff 3d82 780e 0ca8 ff81 0b3d 0228     z....=.x....=.(.
 801ab93:	b878 18e0 28bf f001 3c08 0006 18b9 90fb     x....(...<......
 801aba3:	1110 0217 b888 8212 12ff 0981 093a 003b     ............:.;.
 801abb3:	bf02 da32 ba7f b67d a509 ffe0 2806 7a02     ..2...}......(.z
 801abc3:	00a4 e034 0aff 1791 2528 a290 7f28 9425     ..4.....(%..(.%.
 801abd3:	28c3 1512 0055 dd39 200a 9a19 26e0 c503     .(..U.9.. ...&..
 801abe3:	2921 00a7 a0eb 2300 1b18 009a 4103 78ff     !).....#.....A.x
 801abf3:	2814 8a02 e1a4 ffba 1792 0029 60ec 0103     .(........)..`..
 801ac03:	e0ff 9230 2815 9225 da42 4300 1803 e127     ..0..(%.B..C..'.
 801ac13:	00ba 2627 1de1 102a 3021 0103 1508 4919     ..'&..*.!0.....I
 801ac23:	0304 73ff fd2b f63f 0028 ff3f 78cc 3269     ...s+.?.(.?..xi2
 801ac33:	03d6 1398 89ff b927 c827 a964 7f65 e0a9     ......'.'.d.e...
 801ac43:	643a 65ab 00ab ff05 65ac 32ac 03da 009a     :d.e.....e.2....
 801ac53:	62ff 8903 b626 b909 7f5f 0896 03a6 038a     .b..&..._.......
 801ac63:	0068 770d 09c6 00c9 b60d 8b03 1b00 6cff     h..w...........l
 801ac73:	6300 0737 a903 ef2f 62da 63ac eb09 623a     .c7.../..b.c..:b
 801ac83:	fbab ab63 0710 63a9 2fa9 ffd6 0200 182f     ..c....c./..../.
 801ac93:	3800 8903 08ff 1348 0318 3f94 ff04 1864     .8....H....?..d.
 801aca3:	1865 31e0 17f1 3eef 35e4 1057 610b 570c     e..1...>.5W..a.W
 801acb3:	3eff 34de 08f7 1386 ef16 b66c 0633 1f18     .>.4......l.3...
 801acc3:	d73f ff6c 11b6 6286 6306 e006 60f7 d13f     ?.l....b.c...`?.
 801acd3:	0710 3fc0 64cd 19ff 1965 31e0 1790 ff26     ...?.d..e..1..&.
 801ace3:	51b6 1346 5186 0356 56ff 6200 8cd0 0339     .QF..QV..V.b..9.
 801acf3:	ff08 1398 5118 038a 2645 74ff 7427 4608     .....Q..E&.t't.F
 801ad03:	6613 7f00 3663 36f7 00ab 0802 eb4b c80f     .f..c6.6....K...
 801ad13:	4d00 10ee 3041 f53f 18ff 7a0c 7bca 28cb     .M..A0?....z.{.(
 801ad23:	3f40 2844 8703 4712 1b04 2105 e0ff 1117     @?D(...G...!....
 801ad33:	9017 0619 ff89 9b28 a94a 8812 58f8 38bf     ......(.J....X.8
 801ad43:	9002 7007 02c8 474b d0ff 38f7 3242 70d7     ...p..KG...8B2.p
 801ad53:	ffb8 f8ff 3938 fe2b 503f d0ff 3810 7306     ....89+.?P...8.s
 801ad63:	f0b8 df48 0339 0890 048e 7873 ffb9 0228     ..H.9.....sx..(.
 801ad73:	c871 19f0 043d 09fe 81e1 75c8 7fb4 0ec9     q...=......u....
 801ad83:	49dd 5500 0419 0498 b413 ff03 1249 0c79     .I.U........I.y.
 801ad93:	3889 c710 f4df 7811 8404 cb0b 04d8 38fb     .8.....x.......8
 801ada3:	0409 b0c7 b974 0890 e0ff 1279 3139 3708     ....t.....y.91.7
 801adb3:	def9 d303 d845 3904 4100 c770 6aff 2857     ....E..9.Ap..jW(
 801adc3:	9f26 2b80 bffc e53f abe2 d72f 9b08 5739     &..+..?.../...9W
 801add3:	25c0 0251 9f6d 8b00 0819 7e6d a500 d0b8     .%Q.m.....m~....
 801ade3:	3848 cf04 7f00 81ff 32c8 72d7 ffb4 aef4     H8.......2.r....
 801adf3:	5300 9e26 00c0 ca35 a500 bc76 4f08 3d08     .S&...5...v..O.=
 801ae03:	2737 5025 3900 ff82 0328 b975 4890 c37e     7'%P.9..(.u..H~.
 801ae13:	5cff e198 0803 7883 ff39 9168 3188 3879     .\.....x9.h..1y8
 801ae23:	0991 5eff 9f29 5e01 0881 fb19 3989 9102     ...^)..^.....9..
 801ae33:	7edc 08cc fb8c c878 8703 8838 2fc8 fadc     .~....x...8../..
 801ae43:	1128 0079 8911 78c8 13c9 88ff 8813 8908     (.y....x........
 801ae53:	c988 7f13 1389 3889 9006 0a08 ebd9 c889     .......8........
 801ae63:	2918 0000 2000 203c 4e7f 4c20 0627 7220     .)... < .N L'. r
 801ae73:	0b00 26ff 2c20 2820 0427 b724 3fa6 1e9e     ...& , ('.$..?..
 801ae83:	398f 0610 d49b 3fef f014 0600 d085 0639     .9.....?......9.
 801ae93:	06da 0b85 850e 083f 3701 8403 b8f9 8936     ......?..7....6.
 801aea3:	9502 9f3f 0890 df27 27a8 2788 1c98 32c7     ..?...'..'.'...2
 801aeb3:	ffd1 f100 f100 5955 39e0 32ff 55d9 5503     ......UY.9.2.U.U
 801aec3:	2815 ffa1 8549 35f0 7738 6128 99ff 9098     .(..I..58w(a....
 801aed3:	f009 3e15 bf09 0438 2628 889c 3507 ff26     ...>..8.(&...5&.
 801aee3:	889b 0828 9998 5028 4cfb 0058 6903 3555     ..(...(P.LX..iU5
 801aef3:	3655 03ef 0d57 0967 1245 6617 53fd 0700     U6..W.g.E..f.S..
 801af03:	0983 9063 6888 38ff d332 2b55 f290 df09     ..c..h.82.U+....
 801af13:	55b2 5514 0529 931d 7f11 0949 2893 4e4f     .U.U).....I..(ON
 801af23:	0063 ff35 0093 54f1 0089 91f1 036f 8309     c.5....T....o...
 801af33:	040d 0f9f 0349 f715 11c9 1e89 9399 57fc     ....I..........W
 801af43:	fbf9 9866 4700 6a88 e028 bf18 8954 09f0     ..f..G.j(...T...
 801af53:	2d38 0909 ff54 00b9 0df1 04b8 2889 a1ff     8-..T........(..
 801af63:	8341 0a55 f100 ff58 0d59 0869 0d79 f039     A.U...X.Y.i.y.9.
 801af73:	0a7f 0238 b900 9961 2001 29f7 b96c 4528     ..8...a.. .)l.(E
 801af83:	ec35 d32f 2fef 2fd0 1bd8 0989 2681 a8ff     5./.././.....&..
 801af93:	3812 8109 100c ff39 9004 2b00 3fff 906e     .8....9....+.?n.
 801afa3:	10dd 0500 2f6b 00d3 3989 7f00 32f1 3fd3     ....k/...9...2.?
 801afb3:	2fd5 07d9 d6bb 2d10 f23f 4b00 0c02 2741     ./.....-?..K..A'
 801afc3:	cfc5 d332 d132 5701 2301 0591 90ef 910c     ..2.2..W.#......
 801afd3:	071a 0353 fc9f 00ff 28ba 9828 90c6 ef02     ..S......((.....
 801afe3:	5707 0338 9b00 9112 bf0b 6300 2806 8903     .W8........c.(..
 801aff3:	7301 eb04 c903 6507 10ac 6085 5b37 cfff     .s.....e...`7[..
 801b003:	2694 08c8 1281 bf25 0028 e5c1 e839 5f08     .&....%.(...9.._
 801b013:	ff74 28b5 7901 59b6 0885 56ff 610c 023c     t..(.y.Y...V.a<.
 801b023:	5109 c728 9c28 08a6 0d3d 0097 d1b1 ff90     .Q(.(...=.......
 801b033:	2f85 55d3 32c9 28db 28e7 e69e 3b08 6300     ./.U.2.(.(...;.c
 801b043:	e00c ba30 6108 1803 60db bb37 7300 af30     ..0..a...`7..s0.
 801b053:	1e3f 84d0 d106 1648 60d1 327f 91d4 6404     ?.....H..`.2...d
 801b063:	6509 1d00 13f3 0f19 08eb 1321 0818 fb89     .e........!.....
 801b073:	f96c 3310 0390 3789 fa54 1300 0860 2f51     l..3...7T...`.Q/
 801b083:	12d4 3925 d3f9 e908 371c 8811 6600 f728     ..%9.....7...f(.
 801b093:	9529 02c3 3901 a628 f748 9079 0048 6805     )....9(.H.y.H..h
 801b0a3:	a628 ed40 0079 e811 0011 1321 0d18 98b5     (.@.y.....!.....
 801b0b3:	0f00 0069 1941 0d39 2171 55bf 28f9 9429     ..i.A.9.q!.U.().
 801b0c3:	00a3 6927 00ff 0066 9000 1b18 eb28 0ea4     ..'i..f.....(...
 801b0d3:	0500 0348 011b 1090 29bf 4bfa 9060 0000     ..H......).K`...
 801b0e3:	7005 29af 43fa 0050 7103 d503 bf03 11d0     .p.).CP..q......
 801b0f3:	f938 0200 1710 fe60 5f01 8080 40c0 0020     8.....`.._...@ .
 801b103:	ff04 0404 0101 2d28 0d90 3f03 09de 1073     ......(-...?..s.
 801b113:	f001 f000 f001 f001 0001 01f0 01f0 01f0     ................
 801b123:	01f0 01f0 01f0 01f0 01f0 f000 f001 f001     ................
 801b133:	f001 f001 f001 f001 f001 0001 01f0 01f0     ................
 801b143:	01f0 01f0 0170 00f8 ffff 00ff ff00 ffff     ....p...........
 801b153:	ffff ffff ffff 00ff ff00 0004 9900 05c7     ................
 801b163:	0005 9a00 0005 0008 9a00 10f5 0009 9b00     ................
 801b173:	1205 000a 9900 00b7 000b 9b00 1023 0010     ............#...
 801b183:	9900 0035 0011 9900 0045 0016 9a00 01b3     ..5.....E.......
 801b193:	0017 9a00 0493 0019 9800 01e7 001a 9800     ................
 801b1a3:	02cb 001c 9a00 0149 001d 9a00 0067 001e     ......I.....g...
 801b1b3:	9800 00ab 001f 9800 0291 0024 9900 0151     ..........$...Q.
 801b1c3:	0028 9900 0563 0029 9900 009b 002a 9a00     (...c.).....*...
 801b1d3:	00d7 002b 9800 01fb 002c 9900 0517 002d     ..+.....,.....-.
 801b1e3:	9b00 0db3 0c04 341c 684c 9880 a8a4 b0ac     .......4Lh......
 801b1f3:	b8b4 bcbc 0020 806d 0000 f20e 0000 8012     .... .m.........
 801b203:	ff01 d432 eb28 504d 6d1f 1fff 2825 9fff     ..2.(.MP.m..%(..
 801b213:	03f6 ff63 017b 8028 01d0 1939 7baf 7900     ..c.{.(...9..{.y
 801b223:	0007 8019 0300 fb67 0178 0500 7691 2814     ......g.x....v.(
 801b233:	fffd 9045 10a0 501b 0092 1bff 2240 3936     ..E....P....@"69
 801b243:	ce14 fffe 3018 70d0 0c39 0ea5 3fff 1ff9     .....0.p9....?..
 801b253:	a517 ce0e fffe 5823 fd39 0ea1 2090 28af     ......#X9.... .(
 801b263:	3f01 0032 d007 0700 ff1f 7090 3828 4115     .?2........p(8.A
 801b273:	ff2b 71ff 2b70 72ff 1171 ff80 0104 0f28     +..qp+.rq.....(.
 801b283:	f1cf 611b 12ff 2980 40fd 2804 ff00 00cb     ...a...).@.(....
 801b293:	400c 0438 5091 00fa 092b 6700 2b77 77ff     .@8..P..+..gw+.w
 801b2a3:	ff75 0490 d629 654b 05d2 38df e002 d114     u...).Ke...8....
 801b2b3:	0510 85d0 08fe dc05 3905 e002 0324 50ff     .........9..$..P
 801b2c3:	0028 70c0 0008 5f08 0340 e001 00a1 a133     (..p..._@.....3.
 801b2d3:	6108 90fb 0007 3605 0604 06f0 38ff 9004     .a.....6.....8..
 801b2e3:	2880 3f00 bfe2 eb28 9145 4690 0500 ff62     .(.?..(.E..F..b.
 801b2f3:	1076 22e0 40d0 1038 9fff 90f4 2d07 2d23     v..".@8......-#-
 801b303:	ff10 3406 3005 0704 b637 ffbf 38f4 f006     ...4.0..7....8..
 801b313:	0007 f02f 00fa ca2f 2900 2d60 2d01 cf02     ../.../..)`-.-..
 801b323:	8114 2104 a308 0f00 09a0 00f6 45fb 0070     ...!.........Ep.
 801b333:	0589 022d 1f29 e000 0931 0021 308f 000b     ..-.)...1.!..0..
 801b343:	d695 0b30 5203 9500 0072 120b ff3e 2d09     ..0..R..r...>..-
 801b353:	2d03 1404 0483 43ff 0128 f3cf 3109 f53f     .-.....C(....1?.
 801b363:	00f6 1115 9520 1f97 906c 10ff f529 6049     .... ...l...).I`
 801b373:	3b28 dd15 00b6 925b 208c 0500 7552 20bf     (;....[.. ..Ru. 
 801b383:	0028 00c1 0885 740b 00ea 136d 1908 087a     (......t..m...z.
 801b393:	830d 412d 7aeb 0037 77d9 2508 0090 ff75     ..-A.z7..w.%..u.
 801b3a3:	f021 3906 9802 0400 01eb 0885 1489 2708     !..9...........'
 801b3b3:	0128 4a72 2920 707c 9429 2910 a700 1815     (.rJ )|p)..)....
 801b3c3:	d529 2073 7d29 2970 1092 2129 ea18 c500     ).s )}p)..)!....
 801b3d3:	0075 8017 b300 3e15 ef37 412d 422d 0f09     u......>7.-A-B..
 801b3e3:	007e fff0 3900 3f02 0325 1212 c2bf 2008     ~....9.?%...... 
 801b3f3:	2008 1878 1d0f 28ff 7404 2802 c300 ff02     . x....(.t.(....
 801b403:	02f2 0438 02f3 0238 3faf 7314 0003 9223     ..8...8..?.s..#.
 801b413:	0b09 fd0c 0023 0c0f 2208 7028 5fe5 78c2     ....#...."(p._.x
 801b423:	f022 0002 052f 1101 f17f 7200 d03f 1003     ".../......r?...
 801b433:	0900 f07f 0790 7191 d332 bd09 2fbf 3fd3     .......q2..../.?
 801b443:	90c6 4810 900f 20df 103f 0190 2901 9061     ...H... ?....)a.
 801b453:	01ff 611b 0f44 ff03 dd1f 026c 1161 0338     ...aD.....l.a.8.
 801b463:	6f02 a1fc 0eff 6d1f 2521 fece df29 43fa     .o.....m!%..)..C
 801b473:	f084 1014 fa13 ffa1 280e 4602 cf14 28d4     .........(.F...(
 801b483:	02ff 144e d42f 0200 5f00 7100 711e 001e     ..N./...._.q.q..
 801b493:	2405 0508 00bf 2800 9d70 0061 0203 09ff     .$.....(p.a.....
 801b4a3:	1321 2811 a03f ff01 e128 814e 3090 00f0     !..(?...(.N..0..
 801b4b3:	38ff 9131 6a01 0901 fb10 1203 bd09 0928     .81..j........(.
 801b4c3:	02a0 ff1b 9252 1b02 f842 3d07 02d7 0790     ....R...B..=....
 801b4d3:	e502 0832 f0cd bf32 0639 1628 6192 3508     ..2...2.9.(..a.5
 801b4e3:	f93f 0218 08ff f273 0ea1 2218 28ff d001     ?.....s....".(..
 801b4f3:	3802 1ffd ff5a 7231 2317 2616 8137 3feb     .8..Z.1r.#.&7..?
 801b503:	02d7 83bd 2b28 2190 ff3f a1ef 290e 43d6     ....(+.!?....).C
 801b513:	0080 02fd 630b 106a 0109 d332 32af 03d1     .....cj...2..2..
 801b523:	0063 0379 eb10 bad0 0900 1205 41bf 2694     c.y..........A.&
 801b533:	c72a ff2f 00d3 9202 9002 3f53 03ff 0294     *./.......S?....
 801b543:	6390 ca29 fd4a 0062 7303 d432 d532 fe03     .c).J.b..s2.2...
 801b553:	4501 547c 1303 0090 f728 8703 0050 8015     .E|T....(...P...
 801b563:	03f0 ff28 3800 f1a9 2883 3e00 a2fd 6308     ..(..8...(.>...c
 801b573:	2090 0309 7528 9a3f 3287 03d3 0863 0855     . ..(u?..2..c.U.
 801b583:	ff8f d32f ca29 7042 60f0 39fb 0012 8007     ../.).Bp.`.9....
 801b593:	30f0 0028 3dfb 038c 706b 2012 30e0 f1ff     .0(..=..kp. .0..
 801b5a3:	2840 3c00 f485 ea10 1300 0082 604f 2100     @(.<........O`.!
 801b5b3:	e060 ff20 030c 023d 7a3f ff2b 76ef 7470     `. ...=.?z+..vpt
 801b5c3:	0051 9015 0028 c7bf 0cf0 3c10 0807 e03f     Q...(......<..?.
 801b5d3:	10fd 7708 5f3f 0328 5077 e1f1 8710 2708     ...w?_(.wP.....'
 801b5e3:	2108 0128 517a 03ff 1202 0832 7021 fd11     .!(.zQ....2.!p..
 801b5f3:	0203 c01b 0d72 d821 fe01 0902 8049 0340     ....r.!.....I.@.
 801b603:	2872 fb01 5779 3f00 0d71 0810 ce07 7d00     r(..yW.?q......}
 801b613:	3122 0872 016b 1077 c532 01d3 8323 c94b     "1r.k.w.2...#.K.
 801b623:	b110 8700 0309 03b2 0cd3 7538 7308 10e0     ..........8u.s..
 801b633:	7308 cd3f 0084 9015 01d8 103d 0579 c781     .s?.......=.y...
 801b643:	7050 1840 0c7f 0821 9883 ff02 020e d132     Pp@...!.......2.
 801b653:	3928 5515 2fff 70d1 0410 8020 fe10 0b00     (9.U./.p.. .....
 801b663:	e063 2b14 3fff f666 5d28 0790 732a 83f1     c..+.?f.(]..*s..
 801b673:	ff2b 3def 035a 1930 988b 8000 40b7 d52f     +..=Z.0......@/.
 801b683:	491a ff00 b503 abfa 504b 0300 0270 6073     .I......KP..p.s`
 801b693:	0300 ff71 10d0 0338 11d0 f939 00ef 9002     ..q...8...9.....
 801b6a3:	0800 001b 2902 f5df 3841 b97b 4105 3809     .....)..A8{..A.8
 801b6b3:	03fd 0b00 1b28 28d8 9a01 9877 e81b 9702     ....(..(..w.....
 801b6c3:	a018 0228 fd97 0018 e837 3f28 0415 f728     ..(.....7.(?..(.
 801b6d3:	9673 052c f94f 19d0 fb28 940f 2d00 0d28     s.,.O...(....-(.
 801b6e3:	0994 7728 4c14 2099 0e3d 0128 0f18 00fe     ..(w.L. =.(.....
 801b6f3:	5a45 aa11 0b28 0aac 28ff 9094 9008 3f09     EZ..(....(.....?
 801b703:	fe07 3500 2878 9e30 2809 ab03 0a9d 2100     ...5x(0..(.....!
 801b713:	0088 a903 0300 ffba b875 08d1 0838 0890     ........u...8...
 801b723:	29ff 4afa 2868 9001 ff08 481b 181f de2f     .).Jh(.....H../.
 801b733:	0300 00be 882f 581b 581f 4113 fa59 1f08     ..../..X.X.AY...
 801b743:	004b 4533 2898 4ce7 e8ff 2028 9893 1428     K.3E.(.L..( ..(.
 801b753:	f74d 9098 1888 9993 28ec bf0f f89f 681b     M........(.....h
 801b763:	6c1f 3908 7f00 1f09 28f0 44e7 08e8 7b21     .l.9.....(.D..!{
 801b773:	b87b 9700 3808 9007 c100 4aff 2878 4df9     {....8.....Jx(.M
 801b783:	3fab bf1e b87c 08f0 0639 1118 ff1f 3f17     .?..|...9......?
 801b793:	7010 28b9 cc00 09ff 09f8 0538 8918 ff29     .p.(......8...).
 801b7a3:	e100 3f49 7902 08b9 98ff 1628 084e 7428     ..I?.y....(.N.(t
 801b7b3:	fb91 91ec 9108 9014 28c8 fd16 104d 3297     .........(..M..2
 801b7c3:	21de 9017 fe08 0d00 1f08 286d 4616 fb18     .!........m(.F..
 801b7d3:	b889 5508 0428 2890 df1b 2148 1f14 0811     ...U(..(..H!....
 801b7e3:	9023 ff78 b881 8818 b889 1421 90bb 000c     #.x.......!.....
 801b7f3:	f5b9 6849 7910 ef0c de32 3818 e101 f078     ..Ih.y..2..8..x.
 801b803:	cf58 3a38 18f0 5905 1b18 4514 a8ff 4800     X.8:...Y...E...H
 801b813:	0029 18e4 ff84 28b8 4414 12e9 1129 a9ef     )......(.D..)...
 801b823:	3818 1012 1129 0478 89fd 1300 11f8 1368     .8..).x.......h.
 801b833:	2b68 ffff 0a9c a869 fa93 bd6b 02a8 f835     h+....i...k...5.
 801b843:	8904 007b 38c7 02ff 898b f021 0f28 7f9a     ..{..8....!.(...
 801b853:	1bc8 21e8 2159 0858 ebd5 884b 9f10 0818     ...!Y!X...K.....
 801b863:	28a3 930d 08be 1197 0428 5d3f 6748 7f77     .(......(.?]Hgw.
 801b873:	00b9 0c49 3b89 4007 609d 1109 0b20 51f0     ..I..;.@.`.. ..Q
 801b883:	5108 1b02 d8cf 1b0a 00fe 2f5b de32 fa29     .Q........[/2.).
 801b893:	6842 e07d 5309 f068 3928 3819 be6b 2d07     Bh}..Sh.(9.8k..-
 801b8a3:	2929 48fd 0028 986f 3bfb 000d 390d 29f0     )).H(.o..;...9.)
 801b8b3:	093d b0fb 0019 3913 0228 0945 b0bf 2889     =......9(.E....(
 801b8c3:	4d02 1909 2959 feff 6841 18d0 0a38 dfcf     .M..Y)..Ah..8...
 801b8d3:	29e8 49fe 0068 7851 d7f0 3828 0105 0b29     .).Ih.Qx..(8..).
 801b8e3:	1f08 861f 1fdb 0812 a121 0808 3f1d 86f7     ........!....?..
 801b8f3:	8519 0428 a109 1738 d138 2b03 ec53 3f0d     ..(...8.8..+S..?
 801b903:	0158 d432 7907 7b50 ba01 1702 0401 20bd     X.2..yP{....... 
 801b913:	171f dd06 bd9c 0594 1f37 2126 0c87 0385     ........7.&!....
 801b923:	64df 017b 1779 2500 2d81 7067 0303 b100     .d{.y..%.-gp....
 801b933:	9503 03cb 1506 04db 0491 3f7d 0786 9401     ..........}?....
 801b943:	9f2d 1472 0480 0820 0309 0fb3 cf7b 04f2     -.r... .....{...
 801b953:	2209 8014 0403 6fcf f3cf 5090 1700 03a3     .".....o...P....
 801b963:	b906 4d3b 0777 0413 702d 2708 f506 20d8     ..;Mw...-p.'... 
 801b973:	0609 20d5 0309 0b50 08ef de00 2f08 05dc     ... ..P....../..
 801b983:	0939 5b0f 8014 08ec 1819 0305 0040 9805     9..[........@...
 801b993:	6003 10e2 980d 0518 070f 6d27 7a05 9537     .`........'m.z7.
 801b9a3:	082d cc21 db0f 207c 0f0b 7ddb 20a6 7e0b     -.!...| ...}. .~
 801b9b3:	0f33 1715 2711 1107 fe40 1107 1210 11c1     3....'..@.......
 801b9c3:	0811 ff31 1178 01f0 0339 5090 3ff3 041f     ..1.x...9..P.?..
 801b9d3:	16f3 73f5 0c16 3526 0838 1611 f906 e177     ...s..&58.....w.
 801b9e3:	f91e 0f08 03fe cfd3 32f0 00d3 2f72 d3d5     .........2..r/..
 801b9f3:	ef05 00da 0511 c105 153b 9757 2090 6306     ........;.W.. .c
 801ba03:	0051 313b 5316 06f6 21c7 1c26 7775 77c6     Q.;1.S...!&.uw.w
 801ba13:	fec6 0500 77d0 16c6 1706 ff04 023f 871f     .....w......?...
 801ba23:	5222 0739 a5ff 320e 94d1 1b01 ff41 d12f     "R9....2....A./.
 801ba33:	f93f 701b 881f 006b 0002 114f 1108 712d     ?..p..k...O...-q
 801ba43:	1f00 04ff 0ea5 461f fc3f 7f1b 1f71 1688     .......F?...q...
 801ba53:	1716 1e14 bbc5 3037 7d06 440c 00e1 f203     ......70.}.D....
 801ba63:	0cff 3c21 9103 3ff0 ff0a 0090 5390 1111     ..!<...?.....S..
 801ba73:	1011 08fe e00f 0910 3721 28a3 0c7f 0145     ........!7.(..E.
 801ba83:	5111 1004 a91e 0d74 0195 f087 9b05 03d4     .Q....t.........
 801ba93:	1164 2c8b 4781 a908 0392 9705 0663 1eab     d..,.G......c...
 801baa3:	dca9 a516 e905 0312 0604 13a9 df2d d830     ............-.0.
 801bab3:	3900 0531 756d ff03 0d07 0857 f027 3965     .91.mu....W.'.e9
 801bac3:	05ff 7570 2512 35e0 ff3f 9202 e005 0945     ..pu.%.5?.....E.
 801bad3:	3d54 047f 5408 1090 233f 5302 05ff 1471     T=...T..?#.S..q.
 801bae3:	400c 0239 71a8 1a00 0941 00bd 4587 5003     .@9..q..A....E.P
 801baf3:	c505 00f6 2f81 98d1 3f83 90ce bf00 04f0     ...../...?......
 801bb03:	0238 2090 b11d 9f32 32d0 32d1 07d2 0067     8.. ..2..2.2..g.
 801bb13:	3289 d6ff d732 fece 1819 ff19 90e7 1b00     .2..2...........
 801bb23:	7410 f0b0 00f7 0128 cb07 9b7a 9121 02ff     .t....(...z.!...
 801bb33:	1033 f237 f521 ff1f 21e4 21e5 90e3 1110     3.7.!....!.!....
 801bb43:	c0f5 eb04 15c0 a529 ea29 ff43 d020 3980     ......).).C. ..9
 801bb53:	d06d 3840 04ff 5a28 519a 033f 7f28 9812     m.@8..(Z.Q?.(...
 801bb63:	1141 0e20 0101 ffa9 11f1 2881 a220 1b41     A. ........( .A.
 801bb73:	a1fd 2508 0828 0290 0190 00ba 0a27 bd04     ...%(.......'...
 801bb83:	d002 0020 f52f 467d 2f08 46f5 0861 0812     .. ./.}F./.Fa...
 801bb93:	ff0f c191 b21b 033f b191 1bbf 03c2 0324     ......?.......$.
 801bba3:	0525 029d 08ff 0925 0324 0842 ff52 1212     %.....%.$.B.R...
 801bbb3:	420c 1b38 520c 38ff 0219 2812 9020 ef03     .B8..R.8...( ...
 801bbc3:	431b 231b 7f10 a5a4 ff0e a318 0328 f3cf     .C.#........(...
 801bbd3:	10d0 39bf 0304 9036 0183 865b 0cff 3d63     ...9..6...[...c=
 801bbe3:	0303 3f24 efe4 2503 e23f bf00 11a3 6f10     ..$?...%?......o
 801bbf3:	0308 3288 a910 3810 d306 7fbf 2834 9c7a     ...2...8....4(z.
 801bc03:	00a3 609f 08ff d003 3940 0806 ff24 1211     ...`....@9..$...
 801bc13:	4208 2212 033f 00f2 1205 2918 4307 4bea     .B."?......).C.K
 801bc23:	3f20 91f5 9d00 0071 5003 0428 ffe0 0900      ?....q..P(.....
 801bc33:	2801 4ef5 2871 0c5f 0190 1009 0900 0050     .(.Nq(_.......P.
 801bc43:	5517 0081 6003 1b30 3081 601b 1700 70fd     .U...`0..0.`...p
 801bc53:	1f08 1203 0208 1213 090f 0920 0021 0015     .......... .!...
 801bc63:	0011 0023 bf4d a000 1011 00e0 350a d603     ..#.M........5..
 801bc73:	3700 6046 0f40 0002 730f ff03 5134 2823     .7F`@....s..4Q#(
 801bc83:	e002 1303 a3ff 2308 2411 4309 ff0c 3b13     .......#.$.C...;
 801bc93:	0302 1113 2863 7c67 03c0 6d00 3301 734e     ....c(g|...m.3Ns
 801bca3:	2700 8355 2700 2013 1327 2710 0023 a527     .'U..'. '..'#.'.
 801bcb3:	5023 8327 6509 2101 00f1 6207 00f2 f207     #P'..e.!...b....
 801bcc3:	5f08 0300 0484 0413 24f5 c701 0033 4403     ._.......$..3..D
 801bcd3:	b38b f78c 90b4 0003 c309 a31b ff1f 1fe4     ................
 801bce3:	1fe5 d1e3 3907 02c7 f51f 7903 e901 0f02     .....9.....y....
 801bcf3:	3f20 07b7 b07b 0b00 7c30 0508 bf40 e71b      ?..{...0|..@...
 801bd03:	d72f d62f 430a ff2f 2fd3 2fd2 2fd1 1bd0     /./..C/../././..
 801bd13:	183d cf3d 0128 5e3f 097d 1765 d7fd b307     =.=.(.?^}.e.....
 801bd23:	1b48 1fd8 91e0 48fd 550f 1c21 f11f 0f28     H......H.U!...(.
 801bd33:	98ff 1b58 28e8 7101 ffb8 d928 08a0 1428     ..X..(.q..(...(.
 801bd43:	384e 09fe 21e3 28e8 46fa 2889 01ff ba70     N8...!.(.F.(..p.
 801bd53:	a703 7f28 dd98 014c 7ab7 8aa1 6927 2815     ..(...L..z..'i.(
 801bd63:	02f7 0aa0 7308 1811 1813 08ef 9089 1728     .....s........(.
 801bd73:	0077 77c0 f0ff 3837 9704 9087 ff48 123f     w..w..78....H.?.
 801bd83:	8797 0892 0f3f 1fef 9013 16e8 fd53 6745     ....?.......S.Eg
 801bd93:	90fb 0048 b94d 09d2 0238 91bb 1008 145b     ..H.M...8.....[.
 801bda3:	874c 8d00 fb57 17d0 1d00 3847 1102 3f47     L...W.....G8..G?
 801bdb3:	f028 07c0 7804 e900 8500 4dff 1b19 288a     (....x.....M...(
 801bdc3:	987b e3cc 1c1f f300 1706 7712 9089 700c     {..........w...p
 801bdd3:	431e 931f af26 cb0e 1f13 2712 77b7 2112     .C..&......'.w.!
 801bde3:	2683 f1d7 5818 9300 38df 38f0 053d 2519     .&...X...8.8=..%
 801bdf3:	063f e0e7 8138 3500 3111 3f00 ffc7 851f     ?...8..5.1.?....
 801be03:	0990 8a2d 9a04 1bff 1f7a 2888 e001 ff09     ..-.....z..(....
 801be13:	1028 09f0 f83c 8521 04ee 7f61 0d94 0300     (...<.!...a.....
 801be23:	1b40 ff30 0090 0b03 0c03 f01b 28ff 153d     @.0..........(=.
 801be33:	28f0 9f1f dbf0 e01b 2101 911b 8f01 404e     .(.......!....N@
 801be43:	28ef 9260 0040 80a9 f093 00fe 200d 0928     .(`.@........ (.
 801be53:	6096 1428 4faf 9100 0090 1005 1908 e74e     .`(..O........N.
 801be63:	28b0 007f 0031 9009 1b10 10f7 fa29 8d03     .(..1.......)...
 801be73:	a028 2800 e1f7 904c 0b00 1130 2840 a057     (..(..L...0.@(W.
 801be83:	20a0 0d00 01a0 485f 5f08 a5ff ce0e 28fe     . ...._H._.....(
 801be93:	45f9 faa4 2b04 02fb f903 a04d 0ea1 71ff     .E...+....M....q
 801bea3:	f041 3911 700b fe41 d70b 1108 7c28 61eb     A..9.pA.....(|.a
 801beb3:	7f78 0311 0040 8171 0740 770d e041 0711     x...@.q.@..wA...
 801bec3:	410d f221 1d11 ddff 101f e03f 0000 fd7e     .A!.......?...~.
 801bed3:	18ba 7501 6dba 7e80 bfba d81f f521 b876     ...u.m.~....!.v.
 801bee3:	f100 ff38 8903 a8f7 073d 1c90 e0ff e038     ..8.....=.....8.
 801bef3:	2b19 91fd af2a 083f 0c90 bd04 0038 1903     .+..*.?.....8...
 801bf03:	28af 9e02 00ea 5c23 0b03 faf9 0700 0048     .(....#\......H.
 801bf13:	2903 fa28 8a4e 1beb 00d9 1adf 4f01 1bd8     .)(.N........O..
 801bf23:	ffe8 f51f b877 08f0 0238 3fbb 0109 1477     ....w...8..?..w.
 801bf33:	984e 7310 9fd9 4897 0f3f 1a7c 0215 46c9     N..s...H?.|....F
 801bf43:	9867 0828 4312 1d20 8891 650a 288f 957d     g.(..C ....e.(}.
 801bf53:	098c 2a9d 0085 a827 08f6 8a23 3ab8 70bd     ...*..'...#..:.p
 801bf63:	d1b8 7308 0639 ad08 6501 1bf8 02e8 7f19     ...s9....e......
 801bf73:	1b28 90d8 030b 21bc ffd7 1810 280b 4cff     (......!.....(.L
 801bf83:	90cb 18f7 b881 5b10 70de 03b8 89fd 1501     .......[.p......
 801bf93:	f0f9 3c69 9104 00be 3f15 d220 3808 db01     ..i<.....? ..8..
 801bfa3:	7f41 f06c 390c 9104 0008 ff11 0817 2899     A.l..9.........(
 801bfb3:	ef7d 78a9 9cff 08dc 0b38 f31f ff79 18b8     }..x....8...y...
 801bfc3:	e089 0949 3e89 02ff 0138 1628 084e ff3f     ..I..>..8.(.N.?.
 801bfd3:	280b 9084 1b08 1848 881f b889 053f 0508     .(....H.....?...
 801bfe3:	8908 6f08 7eff 7894 7c58 7ec4 ff12 d27a     ...o.~.xX|.~..z.
 801bff3:	ce72 947e 8918 08bb 0089 292f 0200 5d00     r.~......./)...]
 801c003:	fe38 3d03 28f0 4602 a018 ff28 0228 184e     8..=.(.F..(.(.N.
 801c013:	0128 989a 00fe faad e843 7e28 6c94 0876     (.......C.(~.lv.
 801c023:	76ed 00b8 f895 6811 df02 b8fd 4b08 0328     .v.....h.....K(.
 801c033:	0898 581b 90bf 1b28 1f48 2011 17cb 1fff     ...X..(.H.. ....
 801c043:	21f2 f0f3 380c bf08 0890 6c00 de32 0900     .!...8.....l2...
 801c053:	bf03 1890 6c00 d879 6107 feff 2100 28d7     .....ly..a...!.(
 801c063:	440a f067 ff07 fd39 d779 27e0 d789 05fe     .Dg...9.y..'....
 801c073:	773b 0a28 674c d72f 007b 3902 2b31 3fff     ;w(.Lg/.{..91+.?
 801c083:	1066 fb2f 7400 5409 0019 0919 7d3f 2109     f./..t.T....?}.!
 801c093:	9061 0020 0a02 0cec f0d8 f001 f001 0001     a. .............
 801c0a3:	0002 22a5 7f2b 3ffa 2b76 3ffe 0032 5503     ..."+..?v+.?2..U
 801c0b3:	0023 520b 1300 00a4 a203 0b00 f955 0300     #..R........U...
 801c0c3:	00d5 9c0b 0300 0074 5503 0098 7803 0300     ......t..U...x..
 801c0d3:	007e 9203 2f00 3cff 0302 0a06 130e 3f18     ~..../.<.......?
 801c0e3:	211d 2926 2e2c 0000 71f0 f030 f001 3001     .!&),....q0....0
 801c0f3:	f801 ff00 0005 4b06 e406 8007 0000 ffff     .......K........
 801c103:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c113:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c123:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c133:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c143:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c153:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c163:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c173:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c183:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c193:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c1a3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c1b3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c1c3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c1d3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c1e3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c1f3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c203:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c213:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c223:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c233:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c243:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c253:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c263:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c273:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c283:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c293:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c2a3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c2b3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c2c3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c2d3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c2e3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c2f3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c303:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c313:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c323:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c333:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c343:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c353:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c363:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c373:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c383:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c393:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c3a3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c3b3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c3c3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c3d3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c3e3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c3f3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c403:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c413:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c423:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c433:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c443:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c453:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c463:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c473:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c483:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c493:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c4a3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c4b3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c4c3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c4d3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c4e3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c4f3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c503:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c513:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c523:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c533:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c543:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c553:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c563:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c573:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c583:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c593:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c5a3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c5b3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c5c3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c5d3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c5e3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c5f3:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c603:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c613:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801c623:	0000 c585 1700 0100 0010 0100 0004 0000     ................
 801c633:	0000 0001 0001 0001 0001 0203 0000 8a00     ................
 801c643:	0041 ff26 0000 0000 fb00 00f0 0000 0000     A.&.............
	...
 801c663:	fb00 00e8 0000 0000 0000 8d00 002f 001e     ............/...
	...
 801c67f:	0000 0700 0703 0002 0000 0104 0070 0022     ............p.".
 801c68f:	0000 9500 00cb 0006 0000 0700 0080 9c00     ................
 801c69f:	00a5 ab11 efcd ab01 efcd 0402 0000 05ff     ................
 801c6af:	7c58 009c 0000 e3a4 0a00 8264 0405 00ff     X|........d.....
 801c6bf:	00ff 00ff 0000 81a6 0200 0101 0000 95a8     ................
 801c6cf:	2000 0000 0000 0000 0000 0000 0000 0000     . ..............
 801c6df:	0000 0000 2000 0101 2000 0202 2000 0303     ..... ... ... ..
 801c6ef:	2000 0000 f7a9 1600 f9ff 40f0 f9ff 40f0     . .........@...@
 801c6ff:	0100 a086 0000 0000 0000 ffff ff00 0000     ................
 801c70f:	c1ab 0000 0000 f9ab 0100 0001 af00 006f     ..............o.
 801c71f:	006b 0000 0000 ff00 0000 0000 0000 ff00     k...............
 801c72f:	0000 0000 0000 ff00 0000 0018 0000 fc00     ................
 801c73f:	fc08 0007 0a01 0101 0002 0000 0000 ff00     ................
 801c74f:	0000 0000 0000 ff00 0000 0000 0000 ff00     ................
 801c75f:	0100 0008 0000 fe00 fe70 006f 0a01 0101     ........p.o.....
 801c76f:	0001 0000 0000 ff00 0000 0000 0000 ff00     ................
 801c77f:	0000 0100 0245 018a 00ff 0308 0000 c1b8     ....E...........
 801c78f:	1300 cdab 01ef cdab 02ef 0700 feff 0501     ................
 801c79f:	0000 ec2c 0001 ce00 008b 012b 0101 0005     ..,.......+.....
 801c7af:	4000 0400 0000 4b06 4000 0400 0000 e406     .@.....K.@......
 801c7bf:	4000 0400 0000 8007 4000 0400 0000 0000     .@.......@......
	...
 801c7d7:	09d2 0100 0000 0000 0000 0000 0000 0000     ................
	...
 801cc8b:	0100 0405 0000 0000 0100 8405 0000 0000     ................
 801cc9b:	0000 80f5 355c c707 ffff ffff ffff ffff     ....\5..........
 801ccab:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ccbb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cccb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ccdb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cceb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ccfb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd0b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd1b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd2b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd3b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd4b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd5b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd6b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd7b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd8b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cd9b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cdab:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cdbb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cdcb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cddb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cdeb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cdfb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce0b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce1b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce2b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce3b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce4b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce5b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce6b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce7b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce8b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ce9b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ceab:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cebb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cecb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cedb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801ceeb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cefb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf0b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf1b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf2b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf3b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf4b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf5b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf6b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf7b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf8b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cf9b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cfab:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cfbb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cfcb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cfdb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cfeb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801cffb:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d00b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d01b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d02b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d03b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d04b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d05b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d06b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d07b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d08b:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
 801d09b:	ffff ffff ffff ffff ad00                         .........

0801d0a4 <commands>:
 801d0a4:	c3ad 0800 c86d 0800 cd11 0800 6f43 6e6e     ....m.......Conn
 801d0b4:	6365 6574 2064 6f74 6d20 7361 6574 2072     ected to master 
 801d0c4:	2528 3830 3a78 3025 7838 253a 3830 2978     (%08x:%08x:%08x)
 801d0d4:	202e 7753 7469 6863 6e69 2067 6f74 7220     . Switching to r
 801d0e4:	6461 6f69 6320 6e6f 656e 7463 6f69 2e6e     adio connection.
 801d0f4:	000a 7250 746f 636f 6c6f 6d20 7361 6574     ..Protocol maste
 801d104:	2072 7573 7070 726f 7374 6320 6168 6e6e     r supports chann
 801d114:	6c65 2073 616d 6b73 203a 7825 000a 6f70     els mask: %x..po
 801d124:	7472 6144 6174 7854 7852 6f43 706d 656c     rtDataTxRxComple
 801d134:	6574 7028 726f 4e74 6d75 202c 4f50 5452     te(portNum, PORT
 801d144:	545f 5059 5f45 5053 2c49 5220 5458 5f58     _TYPE_SPI, RXTX_
 801d154:	4f43 504d 454c 4554 525f 2958 3e20 203d     COMPLETE_RX) >= 
 801d164:	0030 6d28 7475 7865 3d20 7820 6553 616d     0.(mutex = xSema
 801d174:	6870 726f 4365 6572 7461 4d65 7475 7865     phoreCreateMutex
 801d184:	2928 0029 7073 0069 6f4e 6d20 7461 6863     ()).spi.No match
 801d194:	6e69 2067 6f70 7472 6620 726f 6d20 7365     ing port for mes
 801d1a4:	6173 6567 7720 7469 2068 6461 7264 7365     sage with addres
 801d1b4:	2073 7825 6620 756f 646e 0a2e 7000 726f     s %x found...por
 801d1c4:	4474 7461 5461 5278 4378 6d6f 6c70 7465     tDataTxRxComplet
 801d1d4:	2865 2c70 5020 524f 5f54 5954 4550 535f     e(p, PORT_TYPE_S
 801d1e4:	4950 202c 5852 5854 435f 4d4f 4c50 5445     PI, RXTX_COMPLET
 801d1f4:	5f45 5852 2029 3d3e 3020 5600 6c6f 6d75     E_RX) >= 0.Volum
 801d204:	2065 6168 2073 6863 6e61 6567 0a64 5000     e has changed..P
 801d214:	776f 7265 7320 6174 6574 6820 7361 6320     ower state has c
 801d224:	6168 676e 6465 7420 206f 7825 000a 654e     hanged to %x..Ne
 801d234:	7774 726f 206b 7473 7461 2065 6168 2073     twork state has 
 801d244:	6863 6e61 6567 0a64 5300 6d61 6c70 2065     changed..Sample 
 801d254:	6172 6574 6820 7361 6320 6168 676e 6465     rate has changed
 801d264:	000a 6f43 6e6e 6365 6974 6e6f 7720 7469     ..Connection wit
 801d274:	2068 6570 7265 2820 3025 7838 253a 3830     h peer (%08x:%08
 801d284:	3a78 3025 7838 2029 6f6c 7473 0a2e 4300     x:%08x) lost...C
 801d294:	6261 656c 6320 6e6f 656e 7463 6f69 206e     able connection 
 801d2a4:	6977 6874 7020 6565 2072 2528 3830 3a78     with peer (%08x:
 801d2b4:	3025 7838 253a 3830 2978 6c20 736f 2e74     %08x:%08x) lost.
 801d2c4:	000a 6144 6174 7267 6d61 6320 6e6f 656e     ..Datagram conne
 801d2d4:	7463 6f69 206e 6977 6874 7020 6565 2072     ction with peer 
 801d2e4:	2528 3830 3a78 3025 7838 253a 3830 2978     (%08x:%08x:%08x)
 801d2f4:	6c20 736f 2e74 000a 7325 203a 6144 6174      lost...%s: Data
 801d304:	7267 6d61 6320 6e6f 656e 7463 6f69 206e     gram connection 
 801d314:	6977 6874 7020 6565 2072 2528 3830 3a78     with peer (%08x:
 801d324:	3025 7838 253a 3830 2978 6520 7473 6261     %08x:%08x) estab
 801d334:	696c 6873 6465 0a2e 2500 3a73 4320 6261     lished...%s: Cab
 801d344:	656c 6320 6e6f 656e 7463 6f69 206e 6977     le connection wi
 801d354:	6874 7020 6565 2072 6520 7473 6261 696c     th peer  establi
 801d364:	6873 6465 0a2e 4d00 6c75 6974 6c53 7661     shed...MultiSlav
 801d374:	0065 6953 676e 656c 6c53 7661 0065 6f4c     e.SingleSlave.Lo
 801d384:	7473 6320 6e6f 656e 7463 6f69 206e 6977     st connection wi
 801d394:	6874 6d20 7361 6574 2072 2528 3830 3a78     th master (%08x:
 801d3a4:	3025 7838 253a 3830 2978 002e 6966 7372     %08x:%08x)..firs
 801d3b4:	0074 6573 6f63 646e 4c00 6f6f 696b 676e     t.second.Looking
 801d3c4:	6620 726f 2520 2073 7325 2020 616d 7473      for %s %s  mast
 801d3d4:	7265 7720 7469 2068 614d 496e 2044 7825     er with ManID %x
 801d3e4:	203a 6600 756f 646e 2820 3025 7838 253a     : .found (%08x:%
 801d3f4:	3830 3a78 3025 7838 2029 000a 6f6e 2074     08x:%08x) ..not 
 801d404:	6f66 6e75 0a64 5400 7972 6e69 2067 6f74     found..Trying to
 801d414:	7020 6961 2072 6977 6874 6d20 7361 6574      pair with maste
 801d424:	2072 6977 6874 6d20 6e61 4449 3d20 2520     r with manID = %
 801d434:	2078 6564 4976 2064 203d 7825 0a20 4300     x devId = %x ..C
 801d444:	6e6f 656e 7463 6f69 206e 6166 6c69 6465     onnection failed
 801d454:	202e 7254 6979 676e 7320 6365 6e6f 6164     . Trying seconda
 801d464:	7972 6120 2073 2061 6166 6c6c 6162 6b63     ry as a fallback
 801d474:	0a2e 4300 6e6f 656e 7463 6f69 206e 6166     ...Connection fa
 801d484:	6c69 6465 0a2e 4d00 7361 6574 2072 6f6e     iled...Master no
 801d494:	2074 6f66 6e75 2e64 000a 6568 706c 7265     t found...helper
 801d4a4:	2620 2026 6568 706c 7265 3e2d 6172 6964      && helper->radi
 801d4b4:	4d6f 646f 6c75 0065 6f70 7472 6144 6174     oModule.portData
 801d4c4:	7854 7852 6f43 706d 656c 6574 6d28 7365     TxRxComplete(mes
 801d4d4:	6173 6567 3e2d 6f70 7472 754e 2c6d 5020     sage->portNum, P
 801d4e4:	524f 5f54 5954 4550 535f 4950 202c 5852     ORT_TYPE_SPI, RX
 801d4f4:	5854 435f 4d4f 4c50 5445 5f45 5854 2029     TX_COMPLETE_TX) 
 801d504:	3d3e 3020 4900 696e 6974 6c61 7a69 6e69     >= 0.Initializin
 801d514:	2067 6152 6964 206f 6f4d 7564 656c 2520     g Radio Module %
 801d524:	0a64 1b00 335b 6d31 6152 6964 206f 6c66     d...[31mRadio fl
 801d534:	7361 2068 6e69 6176 696c 2e64 5220 7061     ash invalid. Rap
 801d544:	616c 6963 676e 1b2e 6d5b 000a 6152 6964     lacing..[m..Radi
 801d554:	206f 6c66 7361 2068 6176 696c 2e64 000a     o flash valid...
 801d564:	6f46 6e75 2064 6152 6964 206f 6f4d 7564     Found Radio Modu
 801d574:	656c 2820 3025 7838 253a 3830 3a78 3025     le (%08x:%08x:%0
 801d584:	7838 0a29 5300 616c 6576 6920 696e 6974     8x)..Slave initi
 801d594:	6c61 7a69 6465 202e 7453 7461 7375 2520     alized. Status %
 801d5a4:	3430 2078 000a 6944 2064 6f6e 2074 6966     04x ..Did not fi
 801d5b4:	646e 5220 6461 6f69 4d20 646f 6c75 2065     nd Radio Module 
 801d5c4:	6425 000a 6944 6373 6e6f 656e 7463 6e69     %d..Disconnectin
 801d5d4:	2067 6570 7265 2820 3025 7838 253a 3830     g peer (%08x:%08
 801d5e4:	3a78 3025 7838 2e29 000a 5748 6f43 6d6d     x:%08x)...HWComm
 801d5f4:	5053 4849 6c65 6570 0072 0000               SPIHelper...

0801d600 <commands>:
 801d600:	cf71 0800 cf45 0800 454c 2044 6c62 6e69     q...E...LED blin
 801d610:	656b 0072                                   ker.

0801d614 <buffer>:
 801d614:	89d8 2001 9208 2001                         ... ... 

0801d61c <__FUNCTION__.5638>:
 801d61c:	6461 5463 7361 006b                         adcTask.

0801d624 <k10>:
 801d624:	0021 0000 014a 0000                         !...J...

0801d62c <__FUNCTION__.5660>:
 801d62c:	4441 4943 696e 0074 5378 6d65 7061 6f68     ADCInit.xSemapho
 801d63c:	6572 6154 656b 4128 4344 785f 6553 616d     reTake(ADC_xSema
 801d64c:	6870 726f 2c65 7020 726f 4d74 5841 445f     phore, portMAX_D
 801d65c:	4c45 5941 2920 3d20 203d 6470 5254 4555     ELAY ) == pdTRUE
 801d66c:	4100 4344 7800 6154 6b73 7243 6165 6574     .ADC.xTaskCreate
 801d67c:	6128 6364 6154 6b73 202c 7328 6769 656e     (adcTask, (signe
 801d68c:	2064 6863 7261 2a20 2229 4441 2243 202c     d char *)"ADC", 
 801d69c:	7830 3031 3030 2f20 3420 202c 554e 4c4c     0x1000 / 4, NULL
 801d6ac:	202c 2c31 4e20 4c55 294c 3d20 203d 6470     , 1, NULL) == pd
 801d6bc:	4150 5353 7800 6154 6b73 7243 6165 6574     PASS.xTaskCreate
 801d6cc:	6128 6364 7250 746f 546f 7361 2c6b 2820     (adcProtoTask, (
 801d6dc:	6973 6e67 6465 6320 6168 2072 292a 4122     signed char *)"A
 801d6ec:	4344 2c22 3020 3178 3030 2030 202f 2c34     DC", 0x1000 / 4,
 801d6fc:	4e20 4c55 2c4c 3120 202c 554e 4c4c 2029      NULL, 1, NULL) 
 801d70c:	3d3d 7020 5064 5341 0053 0000               == pdPASS...

0801d718 <__FUNCTION__.8063>:
 801d718:	7874 5053 0049 0000                         txSPI...

0801d720 <__FUNCTION__.8088>:
 801d720:	6f63 666e 6769 7275 4465 414d 6f66 5372     configureDMAforS
 801d730:	4950 4100                                        PI.

0801d733 <__FUNCTION__.8107>:
 801d733:	4441 5f43 7768 6e49 7469 4100 4344 785f     ADC_hwInit.ADC_x
 801d743:	6553 616d 6870 726f 2065 3d21 4e20 4c55     Semaphore != NUL
 801d753:	004c 0000 7800 6553 616d 6870 726f 5465     L....xSemaphoreT
 801d763:	6b61 2865 7073 4469 7461 5b61 7073 4e69     ake(spiData[spiN
 801d773:	6d75 2e5d 5378 6d65 7061 6f68 6572 202c     um].xSemaphore, 
 801d783:	6f70 7472 414d 5f58 4544 414c 2059 2029     portMAX_DELAY ) 
 801d793:	3d3d 7020 5464 5552 0045 0000 6100 7373     == pdTRUE....ass
 801d7a3:	7265 2074 6e69 2520 2873 6425 3a29 2520     ert in %s(%d): %
 801d7b3:	0a73 0000 4e00                                   s....

0801d7b8 <conTypeCh>:
 801d7b8:	464e 5550                                   NFPU

0801d7bc <__FUNCTION__.8745>:
 801d7bc:	6564 7562 4967 696e 0074 7852 7c00 2520     debugInit.Rx.| %
 801d7cc:	3230 0078 2520 7c64 2500 6433 007c 7854     02x. %d|.%3d|.Tx
 801d7dc:	4f00 004e 464f 0046 002d 3333 3300 332e     .ON.OFF.-.33.3.3
 801d7ec:	3100 3a39 3634 343a 0038 614a 206e 3531     .19:46:48.Jan 15
 801d7fc:	3220 3130 0038 7542 6c69 2064 6974 656d      2018.Build time
 801d80c:	2520 2073 7325 7220 7665 7369 6f69 3a6e      %s %s revision:
 801d81c:	7325 000a 4556 0052 6568 7061 203a 6c61     %s..VER.heap: al
 801d82c:	6f6c 7363 253a 2064 7266 6565 3a73 6425     locs:%d frees:%d
 801d83c:	6120 6c6c 636f 7461 6465 253a 2064 616c      allocated:%d la
 801d84c:	7473 6120 6c6c 636f 7320 7a69 3a65 6425     st alloc size:%d
 801d85c:	0a20 2b00 2d2d 2d2d 2d2d 2d2d 2d2d 7571      ..+----------qu
 801d86c:	7565 2b65 2d2d 632d 756f 746e 2d2b 6564     eue+---count+-de
 801d87c:	7571 7565 2b65 652d 716e 6575 6575 2d2b     queue+-enqueue+-
 801d88c:	2d2d 2d2d 616d 2b78 2d2d 2d2d 7566 6c6c     ----max+----full
 801d89c:	2d2b 2d2d 6d65 7470 2b79 000a 6568 7061     +---empty+..heap
 801d8ac:	315f 335f 0032 257c 3531 7c73 3825 7c64     _1_32.|%15s|%8d|
 801d8bc:	3825 7c64 3825 7c64 3825 7c64 3825 7c64     %8d|%8d|%8d|%8d|
 801d8cc:	3825 7c64 000a 6568 7061 335f 5f33 3931     %8d|..heap_33_19
 801d8dc:	0032 6568 7061 355f 3231 355f 3231 6800     2.heap_512_512.h
 801d8ec:	6165 5f70 3135 5f33 3031 3432 6800 6165     eap_513_1024.hea
 801d8fc:	5f70 3031 3532 325f 3131 0032 2d2b 2d2d     p_1025_2112.+---
 801d90c:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2b 2d2d     ------------+---
 801d91c:	2d2d 2d2d 2b2d 2d2d 2d2d 2d2d 2d2d 2d2b     -----+--------+-
 801d92c:	2d2d 2d2d 2d2d 2b2d 2d2d 2d2d 2d2d 2d2d     -------+--------
 801d93c:	2d2b 2d2d 2d2d 2d2d 2b2d 2d2d 2d2d 2d2d     +--------+------
 801d94c:	2d2d 0a2b 2500 3a64 6420 7665 6449 253d     --+..%d: devId=%
 801d95c:	3830 2078 616d 496e 3d64 3025 7838 7020     08x manId=%08x p
 801d96c:	6f72 4964 3d64 3025 7838 7320 706d 526c     rodId=%08x smplR
 801d97c:	7461 3d65 3625 4864 207a 7374 6550 6972     ate=%6dHz tsPeri
 801d98c:	646f 253d 6434 7375 6420 7874 7546 6c6c     od=%4dus dtxFull
 801d99c:	253d 6438 7420 4e78 436f 6e6f 3d6e 3825     =%8d txNoConn=%8
 801d9ac:	2064 7473 7461 7375 253d 3430 0a78 2b00     d status=%04x..+
 801d9bc:	2d2d 2d2d 2d2b 2d2d 2d2b 2b2d 2d2d 2d2b     ----+---+--+--+-
 801d9cc:	2b2d 2b2d 2b2d 2d2d 2d2d 2d2b 722d 642e     -+-+-+----+--r.d
 801d9dc:	7665 2b2e 2d2d 2e72 616d 2e6e 2d2b 2e72     ev.+--r.man.+-r.
 801d9ec:	7270 646f 2b2e 752d 4370 6e6f 2d6e 752b     prod.+-upConn-+u
 801d9fc:	4370 6e6f 446e 2b61 752d 7470 6d69 2d65     pConnDa+-uptime-
 801da0c:	6c2b 7361 5374 6565 2b6e 7874 7546 6c6c     +lastSeen+txFull
 801da1c:	7244 642b 6373 7352 5274 2b78 7364 5263     Dr+dscRstRx+dscR
 801da2c:	7473 7854 0a2b 7c00 3425 7c73 6325 6325     stTx+..|%4s|%c%c
 801da3c:	6325 257c 3230 7c78 3025 7832 007c 6325     %c|%02x|%02x|.%c
 801da4c:	6325 257c 7c63 6325 257c 3430 7c78 3025     %c|%c|%c|%04x|%0
 801da5c:	7838 257c 3830 7c78 3025 7838 257c 6438     8x|%08x|%08x|%8d
 801da6c:	257c 6438 257c 6438 257c 6438 257c 6438     |%8d|%8d|%8d|%8d
 801da7c:	257c 6438 257c 6438 0a7c 2000 7c20 7c20     |%8d|%8d|..  | |
 801da8c:	7c20 2020 2020 207c 2020 2020 2020 7c20      |    |        |
 801da9c:	2020 2020 2020 2020 207c 2020 2020 2020             |       
 801daac:	7c20 2020 2020 2020 2020 207c 2020 2020      |        |     
 801dabc:	2020 7c20 2020 2020 2020 2020 207c 2020        |        |   
 801dacc:	2020 2020 7c20 2020 2020 2020 2020 207c          |        | 
 801dadc:	2020 2020 2020 7c20 2020 2020 2020 2020            |        
 801daec:	0a7c 2b00 2d2d 2d2d 2d2b 2d2d 2d2b 2b2d     |..+----+---+--+
 801dafc:	2d2d 2d2b 2b2d 2b2d 2b2d 2d2d 2d2d 2d2b     --+--+-+-+----+-
 801db0c:	2d2d 2d2d 2d2d 2b2d 2d2d 2d2d 2d2d 2d2d     -------+--------
 801db1c:	2d2b 2d2d 2d2d 2d2d 2b2d 2d2d 2d2d 2d2d     +--------+------
 801db2c:	2d2d 2d2b 2d2d 2d2d 2d2d 2b2d 2d2d 2d2d     --+--------+----
 801db3c:	2d2d 2d2d 2d2b 2d2d 2d2d 2d2d 2b2d 2d2d     ----+--------+--
 801db4c:	2d2d 2d2d 2d2d 2d2b 2d2d 2d2d 2d2d 2b2d     ------+--------+
 801db5c:	2d2d 2d2d 2d2d 2d2d 0a2b 2500 2073 7755     --------+..%s Uw
 801db6c:	5f65 6176 3a6c 7325 6425 252e 3330 5664     e_val:%s%d.%03dV
 801db7c:	202c 7755 5f79 6176 3a6c 7325 6425 252e     , Uwy_val:%s%d.%
 801db8c:	3330 5664 202c 656d 6e61 4c69 253a 2573     03dV, meaniL:%s%
 801db9c:	2e64 3025 6433 2c41 6d20 6165 696e 3a48     d.%03dA, meaniH:
 801dbac:	7325 6425 252e 3330 4164 202c 7755 4979     %s%d.%03dA, UwyI
 801dbbc:	253a 2573 2e64 3025 6433 2c56 5520 6577     :%s%d.%03dV, Uwe
 801dbcc:	3a49 7325 6425 252e 3330 5664 202c 7750     I:%s%d.%03dV, Pw
 801dbdc:	3a79 7325 6425 252e 3330 5764 202c 7750     y:%s%d.%03dW, Pw
 801dbec:	3a65 7325 6425 252e 3330 5764 202c 7750     e:%s%d.%03dW, Pw
 801dbfc:	2d65 7750 3a79 7325 6425 252e 3330 5764     e-Pwy:%s%d.%03dW
 801dc0c:	202c 4d73 7861 4c69 253a 2573 2e64 3025     , sMaxiL:%s%d.%0
 801dc1c:	6433 2c41 7320 614d 7678 3a4c 7325 6425     3dA, sMaxvL:%s%d
 801dc2c:	252e 3330 5664 6b20 253d 4073 7755 3a79     .%03dV k=%s@Uwy:
 801dc3c:	7325 6425 252e 3330 5664 0a20 7400 6d65     %s%d.%03dV ..tem
 801dc4c:	3170 253a 2e64 6425 2c43 7420 6d65 3270     p1:%d.%dC, temp2
 801dc5c:	253a 2e64 6425 0a43 2d00 2d2d 2d2d 2d2d     :%d.%dC..-------
 801dc6c:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 801dc7c:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 801dc8c:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 801dc9c:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 801dcac:	2d2d 2d2d 2d2d 2d2d 2d2d 000a 7325 4400     ----------..%s.D
 801dcbc:	4f49 5944 203a 205b 5b5d 5d20 205b 5b5d     IODY: [ ][ ][ ][
 801dccc:	5d20 205b 0a5d 7800 6154 6b73 7243 6165      ][ ]..xTaskCrea
 801dcdc:	6574 6428 6154 6b73 202c 7328 6769 656e     te(dTask, (signe
 801dcec:	2064 6863 7261 2a20 2229 2244 202c 7830     d char *)"D", 0x
 801dcfc:	3031 3030 2f20 3420 202c 554e 4c4c 202c     1000 / 4, NULL, 
 801dd0c:	2c31 4e20 4c55 294c 3d20 203d 6470 4150     1, NULL) == pdPA
 801dd1c:	5353 7700                                        SS.

0801dd1f <__FUNCTION__.7458>:
 801dd1f:	6177 6374 6468 676f 6e49 7469 0a00 2121     watchdogInit..!!
 801dd2f:	2121 2121 6f53 656d 7420 7361 736b 6420     !!!!Some tasks d
 801dd3f:	6469 6e20 746f 7220 7365 6f70 646e 2820     id not respond (
 801dd4f:	6566 2064 616d 6b73 2520 2978 202e 7554     fed mask %x). Tu
 801dd5f:	6e72 6f20 6666 7420 6568 7020 776f 7265     rn off the power
 801dd6f:	2121 2121 0a21 5700 7461 6863 6f64 0067     !!!!!..Watchdog.
 801dd7f:	5478 7361 436b 6572 7461 2865 6177 6374     xTaskCreate(watc
 801dd8f:	6468 676f 6154 6b73 202c 7328 6769 656e     hdogTask, (signe
 801dd9f:	2064 6863 7261 2a20 2229 6157 6374 6468     d char *)"Watchd
 801ddaf:	676f 2c22 3120 3230 2034 202f 2c34 4e20     og", 1024 / 4, N
 801ddbf:	4c55 2c4c 3120 202c 554e 4c4c 2029 3d3d     ULL, 1, NULL) ==
 801ddcf:	7020 5064 5341 0053 6853 7261 2063 6d69      pdPASS.Sharc im
 801dddf:	6761 2065 7270 676f 6172 6d6d 6e69 2e67     age programming.
 801ddef:	2e2e 0a2e 5500 726e 6365 676f 696e 657a     .....Unrecognize
 801ddff:	2064 6c66 7361 2068 6863 7069 6620 726f     d flash chip for
 801de0f:	7320 6168 6372 2820 616d 496e 3d64 3025      sharc (manId=%0
 801de1f:	7832 6d20 6d65 7954 6570 253d 3230 2078     2x memType=%02x 
 801de2f:	656d 436d 7061 253d 3230 0a78 4600 756f     memCap=%02x..Fou
 801de3f:	646e 6620 616c 6873 6320 6968 2070 6f66     nd flash chip fo
 801de4f:	2072 6873 7261 2063 6d28 6e61 6449 253d     r sharc (manId=%
 801de5f:	3230 2078 656d 546d 7079 3d65 3025 7832     02x memType=%02x
 801de6f:	6d20 6d65 6143 3d70 3025 7832 000a 6853      memCap=%02x..Sh
 801de7f:	7261 2063 6d69 6761 2065 6576 6972 6966     arc image verifi
 801de8f:	6163 6974 6e6f 6620 6961 656c 2064 7461     cation failed at
 801de9f:	3020 2578 3630 0a78 5300 6168 6372 6920      0x%06x..Sharc i
 801deaf:	616d 6567 7020 6f72 7267 6d61 696d 676e     mage programming
 801debf:	7320 6375 6563 7373 000a                     success..

0801dec9 <__FUNCTION__.8826>:
 801dec9:	7073 5469 536f 6970 754e 006d               spiToSpiNum.

0801ded5 <CSWTCH.29>:
 801ded5:	2830 1820 0810 7300                              0( ....

0801dedc <__FUNCTION__.8884>:
 801dedc:	6873 7261 5f63 7073 5f69 6e69 7469 0100          sharc_spi_init.

0801deeb <config1>:
 801deeb:	0601 b409 0207 4050 0601 b409 0205 4050     ......P@......P@
 801defb:	0601 b409 0207 4050 0601 b409 0206 4050     ......P@......P@

0801df0b <config2>:
 801df0b:	1010 0000 0000 026d 0000 0180 62aa 01fa     ......m......b..
 801df1b:	44f2 1010 0000 0000 026d 0000 0004 241b     .D......m......$
 801df2b:	01fa 44f2 1010 0000 0000 026d 0000 0050     ...D......m...P.
 801df3b:	82a2 61ea 64a2 1010 0000 0000 026d 0000     ...a.d......m...
 801df4b:	0001 0102 61ea 64a2                         .....a.d

0801df53 <__FUNCTION__.8930>:
 801df53:	7768 6f42 7261 4964 696e 0074 7073 4e69     hwBoardInit.spiN
 801df63:	6d75 3e20 203d 0030 7073 4469 7461 5b61     um >= 0.spiData[
 801df73:	7073 5469 536f 6970 754e 286d 2828 5053     spiToSpiNum(((SP
 801df83:	5f49 7954 6570 6544 2066 292a 2820 2828     I_TypeDef *) (((
 801df93:	6975 746e 3233 745f 3029 3478 3030 3030     uint32_t)0x40000
 801dfa3:	3030 2930 2b20 3020 3378 3038 2930 2929     000) + 0x3800)))
 801dfb3:	2e5d 5378 6d65 7061 6f68 6572 2120 203d     ].xSemaphore != 
 801dfc3:	554e 4c4c 7800 6553 616d 6870 726f 5465     NULL.xSemaphoreT
 801dfd3:	6b61 2865 7073 4469 7461 5b61 7073 5469     ake(spiData[spiT
 801dfe3:	536f 6970 754e 286d 2828 5053 5f49 7954     oSpiNum(((SPI_Ty
 801dff3:	6570 6544 2066 292a 2820 2828 6975 746e     peDef *) (((uint
 801e003:	3233 745f 3029 3478 3030 3030 3030 2930     32_t)0x40000000)
 801e013:	2b20 3020 3378 3038 2930 2929 2e5d 5378      + 0x3800)))].xS
 801e023:	6d65 7061 6f68 6572 202c 6f70 7472 414d     emaphore, portMA
 801e033:	5f58 4544 414c 2059 2029 3d3d 7020 5464     X_DELAY ) == pdT
 801e043:	5552 0045 6553 7474 6e69 2067 4c50 204c     RUE.Setting PLL 
 801e053:	7266 7165 7420 206f 3232 352e 3937 4d32     freq to 22.5792M
 801e063:	7a48 000a 4c50 204c 7266 7165 6120 726c     Hz..PLL freq alr
 801e073:	6165 7964 7320 7465 7420 206f 3232 352e     eady set to 22.5
 801e083:	3937 4d32 7a48 000a 6553 7474 6e69 2067     792MHz..Setting 
 801e093:	4c50 204c 7266 7165 7420 206f 3432 352e     PLL freq to 24.5
 801e0a3:	3637 484d 0a7a 5000 4c4c 6620 6572 2071     76MHz..PLL freq 
 801e0b3:	6c61 6572 6461 2079 6573 2074 6f74 3220     already set to 2
 801e0c3:	2e34 3735 4d36 7a48 000a 4c50 204c 6572     4.576MHz..PLL re
 801e0d3:	6573 2e74 000a 7257 6e6f 2067 7266 7165     set...Wrong freq
 801e0e3:	6575 636e 2079 6863 736f 6e65 000a 4c50     uency chosen..PL
 801e0f3:	204c 7265 6f72 2072 2528 2964 0a21 5700     L error (%d)!..W
 801e103:	6961 2074 3031 3030 736d 7420 206f 7473     ait 1000ms to st
 801e113:	6261 6c69 7a69 2065 6f70 6577 2072 6562     abilize power be
 801e123:	6f66 6572 6520 7478 7265 616e 206c 6564     fore external de
 801e133:	6976 6563 2073 6f63 666e 6769 7275 7461     vices configurat
 801e143:	6f69 0a6e 7300 6970 6144 6174 735b 6970     ion..spiData[spi
 801e153:	6f54 7053 4e69 6d75 2828 5328 4950 545f     ToSpiNum(((SPI_T
 801e163:	7079 4465 6665 2a20 2029 2828 2828 6975     ypeDef *) ((((ui
 801e173:	746e 3233 745f 3029 3478 3030 3030 3030     nt32_t)0x4000000
 801e183:	2930 2b20 3020 3078 3030 3031 3030 2930     0) + 0x00010000)
 801e193:	2b20 3020 3378 3030 2930 2929 2e5d 5378      + 0x3000)))].xS
 801e1a3:	6d65 7061 6f68 6572 2120 203d 554e 4c4c     emaphore != NULL
 801e1b3:	7800 6553 616d 6870 726f 5465 6b61 2865     .xSemaphoreTake(
 801e1c3:	7073 4469 7461 5b61 7073 5469 536f 6970     spiData[spiToSpi
 801e1d3:	754e 286d 2828 5053 5f49 7954 6570 6544     Num(((SPI_TypeDe
 801e1e3:	2066 292a 2820 2828 7528 6e69 3374 5f32     f *) ((((uint32_
 801e1f3:	2974 7830 3034 3030 3030 3030 2029 202b     t)0x40000000) + 
 801e203:	7830 3030 3130 3030 3030 2029 202b 7830     0x00010000) + 0x
 801e213:	3033 3030 2929 5d29 782e 6553 616d 6870     3000)))].xSemaph
 801e223:	726f 2c65 7020 726f 4d74 5841 445f 4c45     ore, portMAX_DEL
 801e233:	5941 2920 3d20 203d 6470 5254 4555 6600     AY ) == pdTRUE.f
 801e243:	6953 657a 6300 6766 252e 3d73 7830 3025     Size.cfg.%s=0x%0
 801e253:	7832 0a20 6600 5243 0043 6361 356b 0030     2x ..fCRC.ack50.
 801e263:	6f66 7475 3232 6300 696b 316e 3134 6400     fout22.ckin141.d
 801e273:	7369 6261 656c 615f 656c 7472 0073 6d65     isable_alerts.em
 801e283:	7470 5f79 7562 6666 7265 0073 7274 6361     pty_buffers.trac
 801e293:	5f65 656d 7373 6761 7365 6b00 5f61 6570     e_messages.ka_pe
 801e2a3:	6972 646f 6b00 5f61 6974 656d 756f 0074     riod.ka_timeout.
 801e2b3:	6f64 6e5f 746f 735f 6e65 5f64 7473 7461     do_not_send_stat
 801e2c3:	7375 6e00 5f6f 7372 5f74 6d61 0070 616d     us.no_rst_amp.ma
 801e2d3:	496e 0064 6f6b 646e 6f50 006d 6c66 6761     nId.kondPom.flag
 801e2e3:	0073 3978 6432 6c65 7961 7800 4c50 644c     s.x92delay.xPLLd
 801e2f3:	6c65 7961 7300 6174 7374 6300 6e6f 6544     elay.stats.conDe
 801e303:	616c 0079 7270 746f 006f 6c64 7665 6c65     lay.proto.dlevel
 801e313:	7300 6168 6372 5053 5349 6570 6465 7300     .sharcSPISpeed.s
 801e323:	6168 6372 7250 676f 6172 526d 7465 7972     harcProgramRetry
 801e333:	7400 7265 316d 6441 7264 7400 7265 326d     .term1Addr.term2
 801e343:	6441 7264 6d00 6773 6f52 6e75 4d64 7861     Addr.msgRoundMax
 801e353:	305b 005d 736d 5267 756f 646e 614d 5b78     [0].msgRoundMax[
 801e363:	5d31 6d00 6773 6f52 6e75 5464 6d69 5b65     1].msgRoundTime[
 801e373:	5d30 6d00 6773 6f52 6e75 5464 6d69 5b65     0].msgRoundTime[
 801e383:	5d31 6d00 6773 7755 5b65 5d30 6d00 6773     1].msgUwe[0].msg
 801e393:	7755 5b65 5d31 6d00 6773 7755 5b79 5d30     Uwe[1].msgUwy[0]
 801e3a3:	6d00 6773 7755 5b79 5d31 6d00 6773 6149     .msgUwy[1].msgIa
 801e3b3:	6776 305b 005d 736d 4967 7661 5b67 5d31     vg[0].msgIavg[1]
 801e3c3:	6d00 6773 6d49 7861 305b 005d 736d 4967     .msgImax[0].msgI
 801e3d3:	616d 5b78 5d31 6d00 6773 6554 706d 305b     max[1].msgTemp[0
 801e3e3:	005d 736d 5467 6d65 5b70 5d31 6900 616d     ].msgTemp[1].ima
 801e3f3:	5f78 6c61 7261 006d 5f74 6961 5f72 616d     x_alarm.t_air_ma
 801e403:	0078 5f74 6566 5f74 616d 0078 6574 706d     x.t_fet_max.temp
 801e413:	745f 6d69 0065 7775 5279 6e61 6567 7500     _time.uwyRange.u
 801e423:	6577 615f 616c 6d72 7500 7977 615f 616c     we_alarm.uwy_ala
 801e433:	6d72 6100 6e5f 6d6f 6100 645f 6e65 6200     rm.a_nom.a_den.b
 801e443:	7000 776f 7265 6e4f 6544 616c 0079 6d61     .powerOnDelay.am
 801e453:	4570 616e 6c62 4465 6c65 7961 3035 6100     pEnableDelay50.a
 801e463:	706d 6e45 6261 656c 6544 616c 3979 0032     mpEnableDelay92.
 801e473:	6d61 4570 616e 6c62 4465 6c65 7961 3835     ampEnableDelay58
 801e483:	7000 6c6c 3269 0063 6c70 526c 7465 7972     .plli2c.pllRetry
 801e493:	754e 006d 6f70 616c 0072 6974 656d 756f     Num.polar.timeou
 801e4a3:	3574 0030 4543 004e 4550 3152 5000 5245     t50.CEN.PER1.PER
 801e4b3:	0032                                        2.

0801e4b5 <__FUNCTION__.8601>:
 801e4b5:	7571 7565 5465 0058 6f50 6577 2072 7473     queueTX.Power st
 801e4c5:	7461 2065 6168 2073 6863 6e61 6567 0a64     ate has changed.
 801e4d5:	6400 7461 4c61 6e65 7467 2068 3d3c 4d20     .dataLength <= M
 801e4e5:	5841 505f 5941 4f4c 4441 0100                    AX_PAYLOAD.

0801e4f0 <pF.4906>:
 801e4f0:	0001                                        ..

0801e4f2 <pF.4909>:
 801e4f2:	0005                                        ..

0801e4f4 <pF.4911>:
 801e4f4:	0f02 3d00                                        ...

0801e4f7 <pF.4913>:
 801e4f7:	003d                                        =.

0801e4f9 <pF.4915>:
 801e4f9:	0005                                        ..

0801e4fb <pF.4917>:
 801e4fb:	0005                                        ..

0801e4fd <pF.4919>:
 801e4fd:	0003                                        ..

0801e4ff <pF.4921>:
 801e4ff:	0621 0100                                        !..

0801e502 <pF.4923>:
 801e502:	0001                                        ..

0801e504 <pF.4925>:
 801e504:	0003                                        ..

0801e506 <pF.4927>:
 801e506:	0301 0100                                        ...

0801e509 <pF.4929>:
 801e509:	0301 0200                                        ...

0801e50c <pF.4931>:
 801e50c:	0302 0005                                   ....

0801e510 <pF.4933>:
 801e510:	0009                                        ..

0801e512 <pF.4935>:
 801e512:	0009                                        ..

0801e514 <pF.4937>:
 801e514:	0005                                        ..

0801e516 <pF.4939>:
 801e516:	150e 0900                                        ...

0801e519 <pF.4941>:
 801e519:	0209 0700                                        ...

0801e51c <pF.4943>:
 801e51c:	0007                                        ..

0801e51e <pF.4955>:
	...

0801e51f <pF.4958>:
 801e51f:	0002                                        ..

0801e521 <pF.4960>:
 801e521:	0001                                        ..

0801e523 <pF.4962>:
	...

0801e524 <pF.4964>:
	...

0801e525 <pF.4966>:
 801e525:	0001                                        ..

0801e527 <pF.4968>:
	...

0801e528 <pF.4970>:
	...

0801e529 <pF.4972>:
	...

0801e52a <pF.4974>:
 801e52a:	0001                                        ..

0801e52c <pF.4976>:
 801e52c:	0702 0001                                   ....

0801e530 <pF.4978>:
 801e530:	0001                                        ..

0801e532 <pF.4980>:
 801e532:	0001                                        ..

0801e534 <pF.4982>:
 801e534:	0003                                        ..

0801e536 <pF.4986>:
 801e536:	000b                                        ..

0801e538 <pF.4989>:
 801e538:	0f06 0006                                   ....

0801e53c <pF.4991>:
 801e53c:	0002                                        ..

0801e53e <pF.4993>:
 801e53e:	0513 0052                                   ..R.

0801e542 <pF.4995>:
 801e542:	020b 0605 21ff                                   .....

0801e547 <pF.4997>:
 801e547:	0621 0b00                                        !..

0801e54a <pF.4999>:
 801e54a:	020b 0300                                        ...

0801e54d <pF.5001>:
 801e54d:	0003                                        ..

0801e54f <pF.5003>:
 801e54f:	0003                                        ..

0801e551 <pF.5005>:
 801e551:	0003                                        ..

0801e553 <pF.5007>:
 801e553:	0a17 0103 01fd                                   .....

0801e558 <pF.5009>:
 801e558:	0001                                        ..

0801e55a <pF.5011>:
 801e55a:	0006                                        ..

0801e55c <pF.5013>:
 801e55c:	0003                                        ..

0801e55e <pF.5025>:
 801e55e:	0b02 0005                                   ....

0801e562 <pF.5028>:
	...

0801e563 <pF.5030>:
	...

0801e564 <pF.5032>:
	...

0801e565 <pF.5036>:
 801e565:	010b 2102 fb06                              ...!..

0801e56b <pF.5039>:
 801e56b:	0601 020b fd05                              ......

0801e571 <pF.5041>:
 801e571:	010b 2102 fb0a                              ...!..

0801e577 <pF.5043>:
 801e577:	0301 ff01                                   ....

0801e57b <pF.5055>:
 801e57b:	0301 0100                                        ...

0801e57e <pF.5060>:
 801e57e:	ff01                                        ..

0801e580 <pParams.4494>:
 801e580:	0525 07b0                                   %...

0801e584 <pParams.4498>:
 801e584:	0525 3713                                   %..7

0801e588 <__EH_FRAME_BEGIN__>:
 801e588:	0000 0000                                   ....
