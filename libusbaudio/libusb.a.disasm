In archive libusb.a:

usb_device.o:     file format elf32-littlearm


Disassembly of section .text.MX_USB_DEVICE_Init:

00000000 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceHS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
   0:	b510      	push	{r4, lr}
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceHS, &HS_Desc, DEVICE_HS);
   2:	4c07      	ldr	r4, [pc, #28]	; (20 <MX_USB_DEVICE_Init+0x20>)
   4:	4907      	ldr	r1, [pc, #28]	; (24 <MX_USB_DEVICE_Init+0x24>)
   6:	2201      	movs	r2, #1
   8:	4620      	mov	r0, r4
   a:	f7ff fffe 	bl	0 <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceHS, &USBD_AUDIO);
   e:	4620      	mov	r0, r4
  10:	4905      	ldr	r1, [pc, #20]	; (28 <MX_USB_DEVICE_Init+0x28>)
  12:	f7ff fffe 	bl	0 <USBD_RegisterClass>

  USBD_Start(&hUsbDeviceHS);
  16:	4620      	mov	r0, r4

}
  18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceHS, &HS_Desc, DEVICE_HS);

  USBD_RegisterClass(&hUsbDeviceHS, &USBD_AUDIO);

  USBD_Start(&hUsbDeviceHS);
  1c:	f7ff bffe 	b.w	0 <USBD_Start>
	...

usbd_conf.o:     file format elf32-littlearm


Disassembly of section .text.HAL_PCD_MspInit:

00000000 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	4b2e      	ldr	r3, [pc, #184]	; (bc <HAL_PCD_MspInit+0xbc>)
   4:	6802      	ldr	r2, [r0, #0]
   6:	429a      	cmp	r2, r3
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   a:	d155      	bne.n	b8 <HAL_PCD_MspInit+0xb8>
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	4b2c      	ldr	r3, [pc, #176]	; (c0 <HAL_PCD_MspInit+0xc0>)
   e:	681c      	ldr	r4, [r3, #0]
  10:	2502      	movs	r5, #2
  12:	2c00      	cmp	r4, #0
  14:	d037      	beq.n	86 <HAL_PCD_MspInit+0x86>
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  16:	2400      	movs	r4, #0
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  18:	230d      	movs	r3, #13
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  1a:	2703      	movs	r7, #3
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  1c:	260a      	movs	r6, #10
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  1e:	a903      	add	r1, sp, #12
  20:	4828      	ldr	r0, [pc, #160]	; (c4 <HAL_PCD_MspInit+0xc4>)
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  22:	9303      	str	r3, [sp, #12]
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  24:	9504      	str	r5, [sp, #16]
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  26:	9405      	str	r4, [sp, #20]
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  28:	9706      	str	r7, [sp, #24]
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  2a:	9607      	str	r6, [sp, #28]
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2c:	f7ff fffe 	bl	0 <HAL_GPIO_Init>
	  
	  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
  30:	2328      	movs	r3, #40	; 0x28
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  32:	a903      	add	r1, sp, #12
  34:	4824      	ldr	r0, [pc, #144]	; (c8 <HAL_PCD_MspInit+0xc8>)
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
	  
	  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
  36:	9303      	str	r3, [sp, #12]
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  38:	9504      	str	r5, [sp, #16]
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  3a:	9405      	str	r4, [sp, #20]
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  3c:	9706      	str	r7, [sp, #24]
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  3e:	9607      	str	r6, [sp, #28]
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  40:	f7ff fffe 	bl	0 <HAL_GPIO_Init>
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	    GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_10|GPIO_PIN_11 
  44:	f643 4323 	movw	r3, #15395	; 0x3c23
      |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  48:	a903      	add	r1, sp, #12
  4a:	4820      	ldr	r0, [pc, #128]	; (cc <HAL_PCD_MspInit+0xcc>)
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	    GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_10|GPIO_PIN_11 
  4c:	9303      	str	r3, [sp, #12]
      |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  4e:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  50:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  52:	9706      	str	r7, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  54:	9607      	str	r6, [sp, #28]
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  56:	f7ff fffe 	bl	0 <HAL_GPIO_Init>

      /* Peripheral clock enable */
      __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
  5a:	4b1d      	ldr	r3, [pc, #116]	; (d0 <HAL_PCD_MspInit+0xd0>)
  5c:	9400      	str	r4, [sp, #0]
  5e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  60:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  64:	631a      	str	r2, [r3, #48]	; 0x30
  66:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  68:	f002 5200 	and.w	r2, r2, #536870912	; 0x20000000
  6c:	9200      	str	r2, [sp, #0]
  6e:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
  70:	9401      	str	r4, [sp, #4]
  72:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  74:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
  78:	631a      	str	r2, [r3, #48]	; 0x30
  7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  7c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  80:	9301      	str	r3, [sp, #4]
  82:	9b01      	ldr	r3, [sp, #4]
  84:	e018      	b.n	b8 <HAL_PCD_MspInit+0xb8>

      /**USB_OTG_HS GPIO Configuration
      PB14     ------> USB_OTG_HS_DM
      PB15     ------> USB_OTG_HS_DP
      */
      GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
  86:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  8a:	9303      	str	r3, [sp, #12]
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  8c:	2303      	movs	r3, #3
  8e:	9306      	str	r3, [sp, #24]
      GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
  90:	230c      	movs	r3, #12
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  92:	eb0d 0103 	add.w	r1, sp, r3
  96:	480d      	ldr	r0, [pc, #52]	; (cc <HAL_PCD_MspInit+0xcc>)
      */
      GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
  98:	9307      	str	r3, [sp, #28]
      /**USB_OTG_HS GPIO Configuration
      PB14     ------> USB_OTG_HS_DM
      PB15     ------> USB_OTG_HS_DP
      */
      GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  9a:	9504      	str	r5, [sp, #16]
      GPIO_InitStruct.Pull = GPIO_NOPULL;
  9c:	9405      	str	r4, [sp, #20]
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  9e:	f7ff fffe 	bl	0 <HAL_GPIO_Init>

      /* Peripheral clock enable */
      __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
  a2:	4b0b      	ldr	r3, [pc, #44]	; (d0 <HAL_PCD_MspInit+0xd0>)
  a4:	9402      	str	r4, [sp, #8]
  a6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  a8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  ac:	631a      	str	r2, [r3, #48]	; 0x30
  ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  b0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
  b4:	9302      	str	r3, [sp, #8]
  b6:	9b02      	ldr	r3, [sp, #8]
      //HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
      /* USER CODE BEGIN USB_OTG_HS_MspInit 1 */

      /* USER CODE END USB_OTG_HS_MspInit 1 */
    }
}
  b8:	b009      	add	sp, #36	; 0x24
  ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
  bc:	40040000 	.word	0x40040000
  c0:	00000000 	.word	0x00000000
  c4:	40020800 	.word	0x40020800
  c8:	40020000 	.word	0x40020000
  cc:	40020400 	.word	0x40020400
  d0:	40023800 	.word	0x40023800

Disassembly of section .text.HAL_PCD_MspDeInit:

00000000 <HAL_PCD_MspDeInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	4b15      	ldr	r3, [pc, #84]	; (58 <HAL_PCD_MspDeInit+0x58>)
   4:	6802      	ldr	r2, [r0, #0]
   6:	429a      	cmp	r2, r3
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	d124      	bne.n	54 <HAL_PCD_MspDeInit+0x54>
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   a:	4b14      	ldr	r3, [pc, #80]	; (5c <HAL_PCD_MspDeInit+0x5c>)
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	681a      	ldr	r2, [r3, #0]
   e:	4b14      	ldr	r3, [pc, #80]	; (60 <HAL_PCD_MspDeInit+0x60>)
  10:	b192      	cbz	r2, 38 <HAL_PCD_MspDeInit+0x38>
  12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  14:	4813      	ldr	r0, [pc, #76]	; (64 <HAL_PCD_MspDeInit+0x64>)
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  16:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  1a:	631a      	str	r2, [r3, #48]	; 0x30
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  1c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  1e:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  22:	631a      	str	r2, [r3, #48]	; 0x30
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  24:	210d      	movs	r1, #13
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  26:	f7ff fffe 	bl	0 <HAL_GPIO_DeInit>
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  2a:	2138      	movs	r1, #56	; 0x38
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2c:	480e      	ldr	r0, [pc, #56]	; (68 <HAL_PCD_MspDeInit+0x68>)
  2e:	f7ff fffe 	bl	0 <HAL_GPIO_DeInit>
	  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  32:	f643 4123 	movw	r1, #15395	; 0x3c23
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
	  
	  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
  36:	e005      	b.n	44 <HAL_PCD_MspDeInit+0x44>
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  38:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  3a:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  3e:	631a      	str	r2, [r3, #48]	; 0x30
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  40:	f44f 4140 	mov.w	r1, #49152	; 0xc000
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	    GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_10|GPIO_PIN_11 
  44:	4809      	ldr	r0, [pc, #36]	; (28 <HAL_GPIO_DeInit+0x28>)
  46:	f7ff fffe 	bl	0 <HAL_GPIO_DeInit>
      |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  4a:	204d      	movs	r0, #77	; 0x4d
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	    GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_10|GPIO_PIN_11 
  4c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  50:	f7ff bffe 	b.w	0 <HAL_NVIC_DisableIRQ>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  54:	bd08      	pop	{r3, pc}
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  56:	bf00      	nop
  58:	40040000 	.word	0x40040000

      /* Peripheral clock enable */
      __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
  5c:	00000000 	.word	0x00000000
  60:	40023800 	.word	0x40023800
  64:	40020800 	.word	0x40020800
  68:	40020000 	.word	0x40020000
  6c:	40020400 	.word	0x40020400

Disassembly of section .text.HAL_PCD_SetupStageCallback:

00000000 <HAL_PCD_SetupStageCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f500 7161 	add.w	r1, r0, #900	; 0x384
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	f7ff bffe 	b.w	0 <USBD_LL_SetupStage>

Disassembly of section .text.HAL_PCD_DataOutStageCallback:

00000000 <HAL_PCD_DataOutStageCallback>:
   0:	231c      	movs	r3, #28
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	fb03 0301 	mla	r3, r3, r1, r0
   6:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
   a:	f8d3 21e8 	ldr.w	r2, [r3, #488]	; 0x1e8
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   e:	f7ff bffe 	b.w	0 <USBD_LL_DataOutStage>

Disassembly of section .text.HAL_PCD_DataInStageCallback:

00000000 <HAL_PCD_DataInStageCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	231c      	movs	r3, #28
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	fb03 0301 	mla	r3, r3, r1, r0
   6:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
   a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	f7ff bffe 	b.w	0 <USBD_LL_DataInStage>

Disassembly of section .text.HAL_PCD_SOFCallback:

00000000 <HAL_PCD_SOFCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f7ff bffe 	b.w	0 <USBD_LL_SOF>

Disassembly of section .text.HAL_PCD_ResetCallback:

00000000 <HAL_PCD_ResetCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	68c1      	ldr	r1, [r0, #12]
   4:	4604      	mov	r4, r0
   6:	3100      	adds	r1, #0
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	bf18      	it	ne
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   a:	2101      	movne	r1, #1
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  10:	f7ff fffe 	bl	0 <USBD_LL_SetSpeed>
  14:	f8d4 03b4 	ldr.w	r0, [r4, #948]	; 0x3b4
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  1c:	f7ff bffe 	b.w	0 <USBD_LL_Reset>

Disassembly of section .text.HAL_PCD_SuspendCallback:

00000000 <HAL_PCD_SuspendCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	4604      	mov	r4, r0
   4:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	f7ff fffe 	bl	0 <USBD_LL_Suspend>
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	6822      	ldr	r2, [r4, #0]
   e:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
  12:	f043 0301 	orr.w	r3, r3, #1
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  16:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  1a:	6a23      	ldr	r3, [r4, #32]
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  1c:	b123      	cbz	r3, 28 <HAL_PCD_SuspendCallback+0x28>
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  1e:	4a03      	ldr	r2, [pc, #12]	; (2c <HAL_PCD_SuspendCallback+0x2c>)
  20:	6913      	ldr	r3, [r2, #16]
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  22:	f043 0306 	orr.w	r3, r3, #6
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  26:	6113      	str	r3, [r2, #16]
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  28:	bd10      	pop	{r4, pc}
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  2a:	bf00      	nop
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2c:	e000ed00 	.word	0xe000ed00

Disassembly of section .text.HAL_PCD_ResumeCallback:

00000000 <HAL_PCD_ResumeCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f7ff bffe 	b.w	0 <USBD_LL_Resume>

Disassembly of section .text.HAL_PCD_ISOOUTIncompleteCallback:

00000000 <HAL_PCD_ISOOUTIncompleteCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f7ff bffe 	b.w	0 <USBD_LL_IsoOUTIncomplete>

Disassembly of section .text.HAL_PCD_ISOINIncompleteCallback:

00000000 <HAL_PCD_ISOINIncompleteCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f7ff bffe 	b.w	0 <USBD_LL_IsoINIncomplete>

Disassembly of section .text.HAL_PCD_ConnectCallback:

00000000 <HAL_PCD_ConnectCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f7ff bffe 	b.w	0 <USBD_LL_DevConnected>

Disassembly of section .text.HAL_PCD_DisconnectCallback:

00000000 <HAL_PCD_DisconnectCallback>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f7ff bffe 	b.w	0 <USBD_LL_DevDisconnected>

Disassembly of section .text.USBD_LL_Init:

00000000 <USBD_LL_Init>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	7806      	ldrb	r6, [r0, #0]
   4:	2e01      	cmp	r6, #1
   6:	d12f      	bne.n	68 <USBD_LL_Init+0x68>
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	4c18      	ldr	r4, [pc, #96]	; (6c <USBD_LL_Init+0x6c>)
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   a:	4a19      	ldr	r2, [pc, #100]	; (70 <USBD_LL_Init+0x70>)
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	f8c4 03b4 	str.w	r0, [r4, #948]	; 0x3b4
  10:	230b      	movs	r3, #11
  12:	e884 000c 	stmia.w	r4, {r2, r3}
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  16:	4b17      	ldr	r3, [pc, #92]	; (74 <USBD_LL_Init+0x74>)
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  18:	f8c0 4220 	str.w	r4, [r0, #544]	; 0x220
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  1c:	681b      	ldr	r3, [r3, #0]
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  1e:	61e6      	str	r6, [r4, #28]
  20:	2500      	movs	r5, #0
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  22:	42ab      	cmp	r3, r5
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  24:	bf14      	ite	ne
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  26:	462b      	movne	r3, r5
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  28:	2302      	moveq	r3, #2
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  2a:	60e3      	str	r3, [r4, #12]
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  2c:	4620      	mov	r0, r4
  2e:	bf14      	ite	ne
	  
	  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
  30:	2301      	movne	r3, #1
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  32:	2302      	moveq	r3, #2
  34:	61a3      	str	r3, [r4, #24]
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
	  
	  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
  36:	6125      	str	r5, [r4, #16]
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  38:	6165      	str	r5, [r4, #20]
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
  3a:	6225      	str	r5, [r4, #32]
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  3c:	6265      	str	r5, [r4, #36]	; 0x24
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  3e:	62e5      	str	r5, [r4, #44]	; 0x2c
	  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  40:	6325      	str	r5, [r4, #48]	; 0x30
  42:	6365      	str	r5, [r4, #52]	; 0x34
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	    GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_10|GPIO_PIN_11 
  44:	f7ff fffe 	bl	0 <HAL_PCD_Init>
      |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  48:	f44f 7100 	mov.w	r1, #512	; 0x200
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	    GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_10|GPIO_PIN_11 
  4c:	4620      	mov	r0, r4
      |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  4e:	f7ff fffe 	bl	0 <HAL_PCDEx_SetRxFiFo>
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  52:	2280      	movs	r2, #128	; 0x80
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  54:	4629      	mov	r1, r5
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  56:	4620      	mov	r0, r4
  58:	f7ff fffe 	bl	0 <HAL_PCDEx_SetTxFiFo>

      /* Peripheral clock enable */
      __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
  5c:	f44f 72ba 	mov.w	r2, #372	; 0x174
  60:	4631      	mov	r1, r6
  62:	4620      	mov	r0, r4
  64:	f7ff fffe 	bl	0 <HAL_PCDEx_SetTxFiFo>
  68:	2000      	movs	r0, #0
  6a:	bd70      	pop	{r4, r5, r6, pc}
  6c:	00000000 	.word	0x00000000
    __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
  70:	40040000 	.word	0x40040000
  74:	00000000 	.word	0x00000000

Disassembly of section .text.USBD_LL_DeInit:

00000000 <USBD_LL_DeInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_DeInit>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_Start:

00000000 <USBD_LL_Start>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_Start>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_Stop:

00000000 <USBD_LL_Stop>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_Stop>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_OpenEP:

00000000 <USBD_LL_OpenEP>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	461c      	mov	r4, r3
   4:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	4613      	mov	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   a:	4622      	mov	r2, r4
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	f7ff fffe 	bl	0 <HAL_PCD_EP_Open>
  10:	2000      	movs	r0, #0
  12:	bd10      	pop	{r4, pc}

Disassembly of section .text.USBD_LL_CloseEP:

00000000 <USBD_LL_CloseEP>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_Close>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_FlushEP:

00000000 <USBD_LL_FlushEP>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_Flush>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_StallEP:

00000000 <USBD_LL_StallEP>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_SetStall>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_ClearStallEP:

00000000 <USBD_LL_ClearStallEP>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_ClrStall>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_IsStallEP:

00000000 <USBD_LL_IsStallEP>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f011 0f80 	tst.w	r1, #128	; 0x80
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   4:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   8:	bf18      	it	ne
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   a:	f001 037f 	andne.w	r3, r1, #127	; 0x7f
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   e:	f04f 001c 	mov.w	r0, #28
  12:	bf15      	itete	ne
  14:	fb00 2103 	mlane	r1, r0, r3, r2
	     PB11     ------> USB_OTG_HS_ULPI_D4
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  18:	fb00 2101 	mlaeq	r1, r0, r1, r2
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	  GPIO_InitStruct.Pull = GPIO_NOPULL;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
  1c:	f891 003a 	ldrbne.w	r0, [r1, #58]	; 0x3a
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  20:	f891 01de 	ldrbeq.w	r0, [r1, #478]	; 0x1de
	     PB12     ------> USB_OTG_HS_ULPI_D5
	     PB13     ------> USB_OTG_HS_ULPI_D6
	     PB5     ------> USB_OTG_HS_ULPI_D7 
	  */
	  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
	  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  24:	4770      	bx	lr

Disassembly of section .text.USBD_LL_SetUSBAddress:

00000000 <USBD_LL_SetUSBAddress>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_SetAddress>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_Transmit:

00000000 <USBD_LL_Transmit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_Transmit>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_PrepareReceive:

00000000 <USBD_LL_PrepareReceive>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_Receive>
   a:	2000      	movs	r0, #0
    {
      /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

      /* USER CODE END USB_OTG_HS_MspInit 0 */
      
      if(externalPhy)
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_GetRxDataSize:

00000000 <USBD_LL_GetRxDataSize>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	b508      	push	{r3, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_HS)
   2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
   6:	f7ff fffe 	bl	0 <HAL_PCD_EP_GetRxCount>
   a:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_Delay:

00000000 <USBD_LL_Delay>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
   0:	f7ff bffe 	b.w	0 <HAL_Delay>

usbd_desc.o:     file format elf32-littlearm


Disassembly of section .text.USBD_HS_DeviceDescriptor:

00000000 <USBD_HS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_HS_DeviceDesc);
   0:	2312      	movs	r3, #18
   2:	800b      	strh	r3, [r1, #0]
   4:	4800      	ldr	r0, [pc, #0]	; (8 <USBD_HS_DeviceDescriptor+0x8>)
   6:	4770      	bx	lr
   8:	00000000 	.word	0x00000000

Disassembly of section .text.USBD_HS_LangIDStrDescriptor:

00000000 <USBD_HS_LangIDStrDescriptor>:
   0:	2304      	movs	r3, #4
   2:	800b      	strh	r3, [r1, #0]
   4:	4800      	ldr	r0, [pc, #0]	; (8 <USBD_HS_LangIDStrDescriptor+0x8>)
   6:	4770      	bx	lr
   8:	00000014 	.word	0x00000014

Disassembly of section .text.USBD_HS_ManufacturerStrDescriptor:

00000000 <USBD_HS_ManufacturerStrDescriptor>:
   0:	b510      	push	{r4, lr}
   2:	4c04      	ldr	r4, [pc, #16]	; (14 <USBD_HS_ManufacturerStrDescriptor+0x14>)
   4:	4804      	ldr	r0, [pc, #16]	; (18 <USBD_HS_ManufacturerStrDescriptor+0x18>)
   6:	460a      	mov	r2, r1
   8:	4621      	mov	r1, r4
   a:	f7ff fffe 	bl	0 <USBD_GetString>
   e:	4620      	mov	r0, r4
  10:	bd10      	pop	{r4, pc}
  12:	bf00      	nop
	...

Disassembly of section .text.USBD_HS_SerialStrDescriptor:

00000000 <USBD_HS_SerialStrDescriptor>:
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4b24      	ldr	r3, [pc, #144]	; (98 <USBD_HS_SerialStrDescriptor+0x98>)
   6:	b08e      	sub	sp, #56	; 0x38
   8:	e9d3 4500 	ldrd	r4, r5, [r3]
   c:	4b23      	ldr	r3, [pc, #140]	; (9c <USBD_HS_SerialStrDescriptor+0x9c>)
   e:	aa01      	add	r2, sp, #4
  10:	460e      	mov	r6, r1
  12:	f103 0c10 	add.w	ip, r3, #16
  16:	4617      	mov	r7, r2
  18:	6818      	ldr	r0, [r3, #0]
  1a:	6859      	ldr	r1, [r3, #4]
  1c:	4696      	mov	lr, r2
  1e:	e8ae 0003 	stmia.w	lr!, {r0, r1}
  22:	3308      	adds	r3, #8
  24:	4563      	cmp	r3, ip
  26:	4672      	mov	r2, lr
  28:	d1f6      	bne.n	18 <USBD_HS_SerialStrDescriptor+0x18>
  2a:	781b      	ldrb	r3, [r3, #0]
  2c:	f88e 3000 	strb.w	r3, [lr]
  30:	4b1b      	ldr	r3, [pc, #108]	; (a0 <USBD_HS_SerialStrDescriptor+0xa0>)
  32:	aa06      	add	r2, sp, #24
  34:	f103 0c10 	add.w	ip, r3, #16
  return USBD_HS_DeviceDesc;
}
  38:	4691      	mov	r9, r2
  3a:	6818      	ldr	r0, [r3, #0]
  3c:	6859      	ldr	r1, [r3, #4]
  3e:	4696      	mov	lr, r2
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
  40:	e8ae 0003 	stmia.w	lr!, {r0, r1}
  return USBD_LangIDDesc;
}
  44:	3308      	adds	r3, #8
  46:	4563      	cmp	r3, ip
  48:	4672      	mov	r2, lr
  4a:	d1f6      	bne.n	3a <USBD_HS_SerialStrDescriptor+0x3a>
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  4c:	881b      	ldrh	r3, [r3, #0]
  USBD_GetString ((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
  4e:	f8ae 3000 	strh.w	r3, [lr]
  52:	220e      	movs	r2, #14
  54:	2100      	movs	r1, #0
  56:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
  return USBD_StrDesc;
}
  5a:	f7ff fffe 	bl	0 <memset>
  5e:	f10d 0a17 	add.w	sl, sp, #23
  62:	f04f 083c 	mov.w	r8, #60	; 0x3c
  66:	4642      	mov	r2, r8
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  68:	4620      	mov	r0, r4
  6a:	4629      	mov	r1, r5
  volatile uint64_t *puid = (void*)0x1FFF7A10;
  uint64_t uid = *puid;
  6c:	f7ff fffe 	bl	0 <__aeabi_llsr>
  70:	f000 000f 	and.w	r0, r0, #15
  const char dtostr[]="0123456789ABCDEF";
  74:	4438      	add	r0, r7
  76:	f1a8 0804 	sub.w	r8, r8, #4
  7a:	7803      	ldrb	r3, [r0, #0]
  7c:	f80a 3f01 	strb.w	r3, [sl, #1]!
  80:	f118 0f04 	cmn.w	r8, #4
  84:	d1ef      	bne.n	66 <USBD_HS_SerialStrDescriptor+0x66>
  86:	4648      	mov	r0, r9
  88:	4632      	mov	r2, r6
  8a:	4906      	ldr	r1, [pc, #24]	; (a4 <USBD_HS_SerialStrDescriptor+0xa4>)
  8c:	f7ff fffe 	bl	0 <USBD_GetString>
  90:	4804      	ldr	r0, [pc, #16]	; (a4 <USBD_HS_SerialStrDescriptor+0xa4>)
  92:	b00e      	add	sp, #56	; 0x38
  94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  char str[32] = "                 ";
  98:	1fff7a10 	.word	0x1fff7a10
  9c:	00000001 	.word	0x00000001
	...

Disassembly of section .text.USBD_HS_ProductStrDescriptor:

00000000 <USBD_HS_ProductStrDescriptor>:
   0:	b510      	push	{r4, lr}
   2:	4c04      	ldr	r4, [pc, #16]	; (14 <USBD_HS_ProductStrDescriptor+0x14>)
   4:	4804      	ldr	r0, [pc, #16]	; (18 <USBD_HS_ProductStrDescriptor+0x18>)
   6:	460a      	mov	r2, r1
   8:	4621      	mov	r1, r4
   a:	f7ff fffe 	bl	0 <USBD_GetString>
   e:	4620      	mov	r0, r4
  10:	bd10      	pop	{r4, pc}
  12:	bf00      	nop
  14:	00000000 	.word	0x00000000
  18:	00000012 	.word	0x00000012

Disassembly of section .text.USBD_HS_ConfigStrDescriptor:

00000000 <USBD_HS_ConfigStrDescriptor>:
   0:	b510      	push	{r4, lr}
   2:	4c04      	ldr	r4, [pc, #16]	; (14 <USBD_HS_ConfigStrDescriptor+0x14>)
   4:	4804      	ldr	r0, [pc, #16]	; (18 <USBD_HS_ConfigStrDescriptor+0x18>)
   6:	460a      	mov	r2, r1
   8:	4621      	mov	r1, r4
   a:	f7ff fffe 	bl	0 <USBD_GetString>
   e:	4620      	mov	r0, r4
  10:	bd10      	pop	{r4, pc}
  12:	bf00      	nop
  14:	00000000 	.word	0x00000000
  18:	00000024 	.word	0x00000024

Disassembly of section .text.USBD_HS_InterfaceStrDescriptor:

00000000 <USBD_HS_InterfaceStrDescriptor>:
   0:	b510      	push	{r4, lr}
   2:	4c04      	ldr	r4, [pc, #16]	; (14 <USBD_HS_InterfaceStrDescriptor+0x14>)
   4:	4804      	ldr	r0, [pc, #16]	; (18 <USBD_HS_InterfaceStrDescriptor+0x18>)
   6:	460a      	mov	r2, r1
   8:	4621      	mov	r1, r4
   a:	f7ff fffe 	bl	0 <USBD_GetString>
   e:	4620      	mov	r0, r4
  10:	bd10      	pop	{r4, pc}
  12:	bf00      	nop
  14:	00000000 	.word	0x00000000
  18:	00000031 	.word	0x00000031

stm32f4xx_it.o:     file format elf32-littlearm


Disassembly of section .text.OTG_HS_IRQHandler:

00000000 <OTG_HS_IRQHandler>:
void OTG_HS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_HS_IRQn 0 */

  /* USER CODE END OTG_HS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_HS);
   0:	4801      	ldr	r0, [pc, #4]	; (8 <OTG_HS_IRQHandler+0x8>)
   2:	f7ff bffe 	b.w	0 <HAL_PCD_IRQHandler>
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

stm32f4xx_hal_msp.o:     file format elf32-littlearm


Disassembly of section .text.HAL_MspInit:

00000000 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
   0:	4770      	bx	lr

main.o:     file format elf32-littlearm


Disassembly of section .text.libUSBStartup:

00000000 <libUSBStartup>:

/* USER CODE END 0 */
int externalPhy = 0;
int libUSBStartup(int ulpi);
int libUSBStartup(int ulpi)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   2:	4b19      	ldr	r3, [pc, #100]	; (68 <libUSBStartup+0x68>)
   4:	2200      	movs	r2, #0
  externalPhy = ulpi;
   6:	6018      	str	r0, [r3, #0]
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
   8:	4b18      	ldr	r3, [pc, #96]	; (6c <libUSBStartup+0x6c>)
/* USER CODE END 0 */
int externalPhy = 0;
int libUSBStartup(int ulpi);
int libUSBStartup(int ulpi)
{
  externalPhy = ulpi;
   a:	9200      	str	r2, [sp, #0]
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
   c:	6b19      	ldr	r1, [r3, #48]	; 0x30
   e:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  12:	6319      	str	r1, [r3, #48]	; 0x30
  14:	6b19      	ldr	r1, [r3, #48]	; 0x30
  16:	f001 0180 	and.w	r1, r1, #128	; 0x80
  1a:	9100      	str	r1, [sp, #0]
  1c:	9900      	ldr	r1, [sp, #0]
  1e:	9201      	str	r2, [sp, #4]
  20:	6b19      	ldr	r1, [r3, #48]	; 0x30
  __HAL_RCC_GPIOC_CLK_ENABLE();
  22:	f041 0104 	orr.w	r1, r1, #4
  26:	6319      	str	r1, [r3, #48]	; 0x30
  28:	6b19      	ldr	r1, [r3, #48]	; 0x30
  2a:	f001 0104 	and.w	r1, r1, #4
  2e:	9101      	str	r1, [sp, #4]
  30:	9901      	ldr	r1, [sp, #4]
  32:	9202      	str	r2, [sp, #8]
  34:	6b19      	ldr	r1, [r3, #48]	; 0x30
  __HAL_RCC_GPIOA_CLK_ENABLE();
  36:	f041 0101 	orr.w	r1, r1, #1
  3a:	6319      	str	r1, [r3, #48]	; 0x30
  3c:	6b19      	ldr	r1, [r3, #48]	; 0x30
  3e:	f001 0101 	and.w	r1, r1, #1
  42:	9102      	str	r1, [sp, #8]
  44:	9902      	ldr	r1, [sp, #8]
  46:	9203      	str	r2, [sp, #12]
  48:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  __HAL_RCC_GPIOB_CLK_ENABLE();
  4a:	f042 0202 	orr.w	r2, r2, #2
  4e:	631a      	str	r2, [r3, #48]	; 0x30
  50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  52:	f003 0302 	and.w	r3, r3, #2
  56:	9303      	str	r3, [sp, #12]
  58:	9b03      	ldr	r3, [sp, #12]
  5a:	f7ff fffe 	bl	0 <MX_USB_DEVICE_Init>
  /* Configure the system clock */
  //  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USB_DEVICE_Init();
  5e:	2001      	movs	r0, #1
  60:	b005      	add	sp, #20

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  /* USER CODE END 3 */
  return 1;
}
  62:	f85d fb04 	ldr.w	pc, [sp], #4
  66:	bf00      	nop
  68:	00000000 	.word	0x00000000
  6c:	40023800 	.word	0x40023800

Disassembly of section .text.SystemClock_Config:

00000000 <SystemClock_Config>:
   0:	b530      	push	{r4, r5, lr}
   2:	b095      	sub	sp, #84	; 0x54

/* USER CODE END 0 */
int externalPhy = 0;
int libUSBStartup(int ulpi);
int libUSBStartup(int ulpi)
{
   4:	2400      	movs	r4, #0
  externalPhy = ulpi;
   6:	4b21      	ldr	r3, [pc, #132]	; (8c <SystemClock_Config+0x8c>)
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
   8:	9401      	str	r4, [sp, #4]
/* USER CODE END 0 */
int externalPhy = 0;
int libUSBStartup(int ulpi);
int libUSBStartup(int ulpi)
{
  externalPhy = ulpi;
   a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
*/
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
   c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
  10:	641a      	str	r2, [r3, #64]	; 0x40
  12:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  14:	4a1e      	ldr	r2, [pc, #120]	; (90 <SystemClock_Config+0x90>)
  16:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  1a:	9301      	str	r3, [sp, #4]
  1c:	9b01      	ldr	r3, [sp, #4]
  1e:	9402      	str	r4, [sp, #8]
  20:	6813      	ldr	r3, [r2, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
  22:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  26:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  2a:	6013      	str	r3, [r2, #0]
  2c:	6813      	ldr	r3, [r2, #0]
  2e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  32:	9302      	str	r3, [sp, #8]
  34:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
  36:	2301      	movs	r3, #1
  38:	9308      	str	r3, [sp, #32]
  3a:	9309      	str	r3, [sp, #36]	; 0x24
  3c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  40:	930f      	str	r3, [sp, #60]	; 0x3c
  42:	230c      	movs	r3, #12
  44:	9310      	str	r3, [sp, #64]	; 0x40
  46:	23f0      	movs	r3, #240	; 0xf0
  48:	2502      	movs	r5, #2
  __HAL_RCC_GPIOB_CLK_ENABLE();
  4a:	9311      	str	r3, [sp, #68]	; 0x44
  4c:	a808      	add	r0, sp, #32
  4e:	2305      	movs	r3, #5
  50:	9313      	str	r3, [sp, #76]	; 0x4c
  52:	950e      	str	r5, [sp, #56]	; 0x38
  54:	9512      	str	r5, [sp, #72]	; 0x48
  56:	f7ff fffe 	bl	0 <HAL_RCC_OscConfig>
  5a:	230f      	movs	r3, #15
  5c:	4621      	mov	r1, r4
  /* Configure the system clock */
  //  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USB_DEVICE_Init();
  5e:	9303      	str	r3, [sp, #12]
  60:	a803      	add	r0, sp, #12

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  /* USER CODE END 3 */
  return 1;
}
  62:	2390      	movs	r3, #144	; 0x90
  64:	9305      	str	r3, [sp, #20]
  66:	9504      	str	r5, [sp, #16]
  68:	9406      	str	r4, [sp, #24]
  6a:	9407      	str	r4, [sp, #28]
  6c:	f7ff fffe 	bl	0 <HAL_RCC_ClockConfig>
  70:	f7ff fffe 	bl	0 <HAL_RCC_GetHCLKFreq>

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
  74:	f44f 737a 	mov.w	r3, #1000	; 0x3e8

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();
  78:	fbb0 f0f3 	udiv	r0, r0, r3
  7c:	f7ff fffe 	bl	0 <HAL_SYSTICK_Config>
  80:	2004      	movs	r0, #4
  82:	f7ff fffe 	bl	0 <HAL_SYSTICK_CLKSourceConfig>
  86:	b015      	add	sp, #84	; 0x54

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
  88:	bd30      	pop	{r4, r5, pc}
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();
  8a:	bf00      	nop
  8c:	40023800 	.word	0x40023800
  90:	40007000 	.word	0x40007000

Disassembly of section .text.Error_Handler:

00000000 <Error_Handler>:
   0:	e7fe      	b.n	0 <Error_Handler>

stm32f4xx_hal.o:     file format elf32-littlearm


Disassembly of section .text.HAL_MspInit:

00000000 <HAL_MspInit>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_MspDeInit:

00000000 <HAL_MspDeInit>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_DeInit:

00000000 <HAL_DeInit>:
   0:	b510      	push	{r4, lr}
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	4b09      	ldr	r3, [pc, #36]	; (28 <HAL_DeInit+0x28>)
   4:	f04f 32ff 	mov.w	r2, #4294967295
   8:	2400      	movs	r4, #0
   a:	621a      	str	r2, [r3, #32]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	621c      	str	r4, [r3, #32]
   e:	625a      	str	r2, [r3, #36]	; 0x24
  10:	625c      	str	r4, [r3, #36]	; 0x24
  12:	611a      	str	r2, [r3, #16]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	611c      	str	r4, [r3, #16]
  16:	615a      	str	r2, [r3, #20]
  18:	615c      	str	r4, [r3, #20]
  1a:	619a      	str	r2, [r3, #24]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  1c:	619c      	str	r4, [r3, #24]
  1e:	f7ff fffe 	bl	0 <HAL_DeInit>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
  22:	4620      	mov	r0, r4
  24:	bd10      	pop	{r4, pc}
  26:	bf00      	nop
  
  /* Init the low level hardware */
  HAL_MspInit();
  28:	40023800 	.word	0x40023800

Disassembly of section .text.HAL_InitTick:

00000000 <HAL_InitTick>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	b510      	push	{r4, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	4b08      	ldr	r3, [pc, #32]	; (24 <HAL_InitTick+0x24>)
   4:	4604      	mov	r4, r0
   6:	6818      	ldr	r0, [r3, #0]
   8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	fbb0 f0f3 	udiv	r0, r0, r3
  10:	f7ff fffe 	bl	0 <HAL_SYSTICK_Config>
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	2200      	movs	r2, #0
  16:	4621      	mov	r1, r4
  18:	f04f 30ff 	mov.w	r0, #4294967295
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  1c:	f7ff fffe 	bl	0 <HAL_NVIC_SetPriority>
  20:	2000      	movs	r0, #0

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
  22:	bd10      	pop	{r4, pc}
  24:	00000000 	.word	0x00000000

Disassembly of section .text.HAL_Init:

00000000 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	4b0b      	ldr	r3, [pc, #44]	; (30 <HAL_Init+0x30>)
   4:	681a      	ldr	r2, [r3, #0]
   6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   a:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	681a      	ldr	r2, [r3, #0]
   e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  12:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	681a      	ldr	r2, [r3, #0]
  16:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  1a:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  1c:	2003      	movs	r0, #3
  1e:	f7ff fffe 	bl	0 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
  22:	2000      	movs	r0, #0
  24:	f7ff fffe 	bl	0 <HAL_Init>
  
  /* Init the low level hardware */
  HAL_MspInit();
  28:	f7ff fffe 	bl	0 <HAL_Init>
  
  /* Return function status */
  return HAL_OK;
}
  2c:	2000      	movs	r0, #0
  2e:	bd08      	pop	{r3, pc}
  30:	40023c00 	.word	0x40023c00

Disassembly of section .text.HAL_IncTick:

00000000 <HAL_IncTick>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_IncTick+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6813      	ldr	r3, [r2, #0]
   4:	3301      	adds	r3, #1
   6:	6013      	str	r3, [r2, #0]
   8:	4770      	bx	lr
   a:	bf00      	nop
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	00000000 	.word	0x00000000

Disassembly of section .text.HAL_GetTick:

00000000 <HAL_GetTick>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <HAL_GetTick+0x8>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6818      	ldr	r0, [r3, #0]
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

Disassembly of section .text.HAL_Delay:

00000000 <HAL_Delay>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	b513      	push	{r0, r1, r4, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	9001      	str	r0, [sp, #4]
   4:	f7ff fffe 	bl	0 <HAL_Delay>
   8:	4604      	mov	r4, r0
   a:	f7ff fffe 	bl	0 <HAL_Delay>
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   e:	9b01      	ldr	r3, [sp, #4]
  10:	1b00      	subs	r0, r0, r4
  12:	4298      	cmp	r0, r3
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	d3f9      	bcc.n	a <HAL_Delay+0xa>
  16:	b002      	add	sp, #8
  18:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_SuspendTick:

00000000 <HAL_SuspendTick>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_SuspendTick+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6813      	ldr	r3, [r2, #0]
   4:	f023 0302 	bic.w	r3, r3, #2
   8:	6013      	str	r3, [r2, #0]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e000e010 	.word	0xe000e010

Disassembly of section .text.HAL_ResumeTick:

00000000 <HAL_ResumeTick>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_ResumeTick+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6813      	ldr	r3, [r2, #0]
   4:	f043 0302 	orr.w	r3, r3, #2
   8:	6013      	str	r3, [r2, #0]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e000e010 	.word	0xe000e010

Disassembly of section .text.HAL_GetHalVersion:

00000000 <HAL_GetHalVersion>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4800      	ldr	r0, [pc, #0]	; (4 <HAL_GetHalVersion+0x4>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	4770      	bx	lr
   4:	01050100 	.word	0x01050100

Disassembly of section .text.HAL_GetREVID:

00000000 <HAL_GetREVID>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <HAL_GetREVID+0x8>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6818      	ldr	r0, [r3, #0]
   4:	0c00      	lsrs	r0, r0, #16
   6:	4770      	bx	lr
   8:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_GetDEVID:

00000000 <HAL_GetDEVID>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4b02      	ldr	r3, [pc, #8]	; (c <HAL_GetDEVID+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6818      	ldr	r0, [r3, #0]
   4:	f3c0 000b 	ubfx	r0, r0, #0, #12
   8:	4770      	bx	lr
   a:	bf00      	nop
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_DBGMCU_EnableDBGSleepMode:

00000000 <HAL_DBGMCU_EnableDBGSleepMode>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6853      	ldr	r3, [r2, #4]
   4:	f043 0301 	orr.w	r3, r3, #1
   8:	6053      	str	r3, [r2, #4]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_DBGMCU_DisableDBGSleepMode:

00000000 <HAL_DBGMCU_DisableDBGSleepMode>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6853      	ldr	r3, [r2, #4]
   4:	f023 0301 	bic.w	r3, r3, #1
   8:	6053      	str	r3, [r2, #4]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_DBGMCU_EnableDBGStopMode:

00000000 <HAL_DBGMCU_EnableDBGStopMode>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_DBGMCU_EnableDBGStopMode+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6853      	ldr	r3, [r2, #4]
   4:	f043 0302 	orr.w	r3, r3, #2
   8:	6053      	str	r3, [r2, #4]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_DBGMCU_DisableDBGStopMode:

00000000 <HAL_DBGMCU_DisableDBGStopMode>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_DBGMCU_DisableDBGStopMode+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6853      	ldr	r3, [r2, #4]
   4:	f023 0302 	bic.w	r3, r3, #2
   8:	6053      	str	r3, [r2, #4]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_DBGMCU_EnableDBGStandbyMode:

00000000 <HAL_DBGMCU_EnableDBGStandbyMode>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6853      	ldr	r3, [r2, #4]
   4:	f043 0304 	orr.w	r3, r3, #4
   8:	6053      	str	r3, [r2, #4]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_DBGMCU_DisableDBGStandbyMode:

00000000 <HAL_DBGMCU_DisableDBGStandbyMode>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	; (c <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	6853      	ldr	r3, [r2, #4]
   4:	f023 0304 	bic.w	r3, r3, #4
   8:	6053      	str	r3, [r2, #4]
   a:	4770      	bx	lr
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	e0042000 	.word	0xe0042000

Disassembly of section .text.HAL_EnableCompensationCell:

00000000 <HAL_EnableCompensationCell>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	2101      	movs	r1, #1
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	fa91 f2a1 	rbit	r2, r1
   6:	4b03      	ldr	r3, [pc, #12]	; (14 <HAL_EnableCompensationCell+0x14>)
   8:	fab2 f282 	clz	r2, r2
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	4413      	add	r3, r2
   e:	009b      	lsls	r3, r3, #2
  10:	6019      	str	r1, [r3, #0]
  12:	4770      	bx	lr
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	1089c100 	.word	0x1089c100

Disassembly of section .text.HAL_DisableCompensationCell:

00000000 <HAL_DisableCompensationCell>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	2201      	movs	r2, #1
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   2:	fa92 f2a2 	rbit	r2, r2
   6:	4b04      	ldr	r3, [pc, #16]	; (18 <HAL_DisableCompensationCell+0x18>)
   8:	fab2 f282 	clz	r2, r2
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	4413      	add	r3, r2
   e:	009b      	lsls	r3, r3, #2
  10:	2200      	movs	r2, #0
  12:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	1089c100 	.word	0x1089c100

Disassembly of section .text.HAL_EnableMemorySwappingBank:

00000000 <HAL_EnableMemorySwappingBank>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	f44f 7380 	mov.w	r3, #256	; 0x100
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   4:	fa93 f3a3 	rbit	r3, r3
   8:	fab3 f383 	clz	r3, r3
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
  10:	f503 231c 	add.w	r3, r3, #638976	; 0x9c000
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	009b      	lsls	r3, r3, #2
  16:	2201      	movs	r2, #1
  18:	601a      	str	r2, [r3, #0]
  1a:	4770      	bx	lr

Disassembly of section .text.HAL_DisableMemorySwappingBank:

00000000 <HAL_DisableMemorySwappingBank>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
   0:	f44f 7380 	mov.w	r3, #256	; 0x100
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   4:	fa93 f3a3 	rbit	r3, r3
   8:	fab3 f383 	clz	r3, r3
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
   c:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
  10:	f503 231c 	add.w	r3, r3, #638976	; 0x9c000
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  14:	009b      	lsls	r3, r3, #2
  16:	2200      	movs	r2, #0
  18:	601a      	str	r2, [r3, #0]
  1a:	4770      	bx	lr

stm32f4xx_hal_pcd.o:     file format elf32-littlearm


Disassembly of section .text.HAL_PCD_MspInit:

00000000 <HAL_PCD_MspInit>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_Init:

00000000 <HAL_PCD_Init>:
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   2:	4606      	mov	r6, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	b08b      	sub	sp, #44	; 0x2c
   6:	2800      	cmp	r0, #0
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	d062      	beq.n	d0 <HAL_PCD_Init+0xd0>
   a:	2303      	movs	r3, #3
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	4634      	mov	r4, r6
   e:	f880 3381 	strb.w	r3, [r0, #897]	; 0x381
  12:	f7ff fffe 	bl	0 <HAL_PCD_Init>
  16:	f854 0b10 	ldr.w	r0, [r4], #16
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  1a:	f7ff fffe 	bl	0 <USB_DisableGlobalInt>
  1e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20:	466d      	mov	r5, sp
  22:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  26:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  28:	e894 0003 	ldmia.w	r4, {r0, r1}
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2c:	e885 0003 	stmia.w	r5, {r0, r1}
  30:	1d37      	adds	r7, r6, #4
  32:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  36:	6830      	ldr	r0, [r6, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	f7ff fffe 	bl	0 <USB_CoreInit>
  3c:	2100      	movs	r1, #0
  3e:	6830      	ldr	r0, [r6, #0]
  40:	f7ff fffe 	bl	0 <USB_SetCurrentMode>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	2100      	movs	r1, #0
  46:	4633      	mov	r3, r6
  48:	4632      	mov	r2, r6
  4a:	f106 0410 	add.w	r4, r6, #16
  4e:	2501      	movs	r5, #1
  50:	4608      	mov	r0, r1
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
  52:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
  56:	87d1      	strh	r1, [r2, #62]	; 0x3e
      {
        if (ep_intr & 0x1U)
  58:	3101      	adds	r1, #1
  5a:	290f      	cmp	r1, #15
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
  5c:	f882 5039 	strb.w	r5, [r2, #57]	; 0x39
  60:	f882 003b 	strb.w	r0, [r2, #59]	; 0x3b
  64:	6410      	str	r0, [r2, #64]	; 0x40
  66:	6450      	str	r0, [r2, #68]	; 0x44
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
  68:	64d0      	str	r0, [r2, #76]	; 0x4c
  6a:	f102 021c 	add.w	r2, r2, #28
  6e:	d1f0      	bne.n	52 <HAL_PCD_Init+0x52>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
  70:	2200      	movs	r2, #0
  72:	4611      	mov	r1, r2
            
            if(hpcd->Init.dma_enable == 1U)
  74:	f883 21dc 	strb.w	r2, [r3, #476]	; 0x1dc
  78:	87da      	strh	r2, [r3, #62]	; 0x3e
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
  7a:	f883 11dd 	strb.w	r1, [r3, #477]	; 0x1dd
  7e:	f883 11df 	strb.w	r1, [r3, #479]	; 0x1df
  82:	f8c3 11e4 	str.w	r1, [r3, #484]	; 0x1e4
  86:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
  8a:	f8c3 11f0 	str.w	r1, [r3, #496]	; 0x1f0
  8e:	6830      	ldr	r0, [r6, #0]
  90:	f102 0540 	add.w	r5, r2, #64	; 0x40
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
  94:	eb00 0085 	add.w	r0, r0, r5, lsl #2
  98:	3201      	adds	r2, #1
  9a:	2a0f      	cmp	r2, #15
            if(hpcd->Init.dma_enable == 1U)
  9c:	6041      	str	r1, [r0, #4]
  9e:	f103 031c 	add.w	r3, r3, #28
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
  a2:	d1e7      	bne.n	74 <HAL_PCD_Init+0x74>
  a4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  a6:	466d      	mov	r5, sp
  a8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
  aa:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  ac:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  ae:	e894 0003 	ldmia.w	r4, {r0, r1}
  b2:	e885 0003 	stmia.w	r5, {r0, r1}
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
  b6:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
  ba:	6830      	ldr	r0, [r6, #0]
  bc:	f7ff fffe 	bl	0 <USB_DevInit>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
  c0:	2301      	movs	r3, #1
  c2:	f886 3381 	strb.w	r3, [r6, #897]	; 0x381
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
  c6:	6830      	ldr	r0, [r6, #0]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
  c8:	f7ff fffe 	bl	0 <USB_DevDisconnect>
  cc:	2000      	movs	r0, #0
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
  ce:	e000      	b.n	d2 <HAL_PCD_Init+0xd2>
        ep_intr >>= 1U;
  d0:	2001      	movs	r0, #1
  d2:	b00b      	add	sp, #44	; 0x2c
  d4:	bdf0      	pop	{r4, r5, r6, r7, pc}

Disassembly of section .text.HAL_PCD_MspDeInit:

00000000 <HAL_PCD_MspDeInit>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_Start:

00000000 <HAL_PCD_Start>:
   0:	b510      	push	{r4, lr}
   2:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	2b01      	cmp	r3, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	4604      	mov	r4, r0
   a:	d00c      	beq.n	26 <HAL_PCD_Start+0x26>
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	2301      	movs	r3, #1
   e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  12:	6800      	ldr	r0, [r0, #0]
  14:	f7ff fffe 	bl	0 <USB_DevConnect>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	6820      	ldr	r0, [r4, #0]
  1a:	f7ff fffe 	bl	0 <USB_EnableGlobalInt>
  1e:	2000      	movs	r0, #0
  20:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	bd10      	pop	{r4, pc}
  26:	2002      	movs	r0, #2
  28:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_Stop:

00000000 <HAL_PCD_Stop>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b510      	push	{r4, lr}
   2:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	2b01      	cmp	r3, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	4604      	mov	r4, r0
   a:	d00f      	beq.n	2c <HAL_PCD_Stop+0x2c>
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	2301      	movs	r3, #1
   e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  12:	6800      	ldr	r0, [r0, #0]
  14:	f7ff fffe 	bl	0 <USB_DisableGlobalInt>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	6820      	ldr	r0, [r4, #0]
  1a:	f7ff fffe 	bl	0 <USB_StopDevice>
  1e:	6820      	ldr	r0, [r4, #0]
  20:	f7ff fffe 	bl	0 <USB_DevDisconnect>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	2000      	movs	r0, #0
  26:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  2a:	bd10      	pop	{r4, pc}
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2c:	2002      	movs	r0, #2
  2e:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_DeInit:

00000000 <HAL_PCD_DeInit>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	b158      	cbz	r0, 1e <HAL_PCD_DeInit+0x1e>
   6:	2303      	movs	r3, #3
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	f880 3381 	strb.w	r3, [r0, #897]	; 0x381
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	f7ff fffe 	bl	0 <HAL_PCD_DeInit>
  10:	4620      	mov	r0, r4
  12:	f7ff fffe 	bl	0 <HAL_PCD_DeInit>
  16:	2000      	movs	r0, #0
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	f884 0381 	strb.w	r0, [r4, #897]	; 0x381
  1c:	bd10      	pop	{r4, pc}
  1e:	2001      	movs	r0, #1
  20:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_DataOutStageCallback:

00000000 <HAL_PCD_DataOutStageCallback>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_DataInStageCallback:

00000000 <HAL_PCD_DataInStageCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_SetupStageCallback:

00000000 <HAL_PCD_SetupStageCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_SOFCallback:

00000000 <HAL_PCD_SOFCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_ResetCallback:

00000000 <HAL_PCD_ResetCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_SuspendCallback:

00000000 <HAL_PCD_SuspendCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_ResumeCallback:

00000000 <HAL_PCD_ResumeCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_ISOOUTIncompleteCallback:

00000000 <HAL_PCD_ISOOUTIncompleteCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_ISOINIncompleteCallback:

00000000 <HAL_PCD_ISOINIncompleteCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_ConnectCallback:

00000000 <HAL_PCD_ConnectCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_DisconnectCallback:

00000000 <HAL_PCD_DisconnectCallback>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_IRQHandler:

00000000 <HAL_PCD_IRQHandler>:
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	f8d0 a000 	ldr.w	sl, [r0]
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	b087      	sub	sp, #28
   a:	4604      	mov	r4, r0
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	4650      	mov	r0, sl
   e:	f7ff fffe 	bl	0 <USB_GetMode>
  12:	2800      	cmp	r0, #0
  14:	f040 8277 	bne.w	506 <HAL_PCD_IRQHandler+0x506>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	6820      	ldr	r0, [r4, #0]
  1a:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
  1e:	2800      	cmp	r0, #0
  20:	f000 8271 	beq.w	506 <HAL_PCD_IRQHandler+0x506>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	6820      	ldr	r0, [r4, #0]
  26:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
  2a:	0785      	lsls	r5, r0, #30
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2c:	bf41      	itttt	mi
  2e:	6822      	ldrmi	r2, [r4, #0]
  30:	6953      	ldrmi	r3, [r2, #20]
  32:	f003 0302 	andmi.w	r3, r3, #2
  36:	6153      	strmi	r3, [r2, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	6820      	ldr	r0, [r4, #0]
  3a:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
  3e:	f410 2000 	ands.w	r0, r0, #524288	; 0x80000
  42:	d04a      	beq.n	da <HAL_PCD_IRQHandler+0xda>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	6820      	ldr	r0, [r4, #0]
  46:	f7ff fffe 	bl	0 <USB_ReadDevAllOutEpInterrupt>
  4a:	f50a 6630 	add.w	r6, sl, #2816	; 0xb00
  4e:	4607      	mov	r7, r0
  50:	46a1      	mov	r9, r4
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
  52:	2500      	movs	r5, #0
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
  54:	2f00      	cmp	r7, #0
  56:	d041      	beq.n	dc <HAL_PCD_IRQHandler+0xdc>
      {
        if (ep_intr & 0x1U)
  58:	07f8      	lsls	r0, r7, #31
  5a:	d538      	bpl.n	ce <HAL_PCD_IRQHandler+0xce>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
  5c:	fa5f fb85 	uxtb.w	fp, r5
  60:	4659      	mov	r1, fp
  62:	6820      	ldr	r0, [r4, #0]
  64:	f7ff fffe 	bl	0 <USB_ReadDevOutEPInterrupt>
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
  68:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U)
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
  6c:	4680      	mov	r8, r0
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
  6e:	d021      	beq.n	b4 <HAL_PCD_IRQHandler+0xb4>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
  70:	2301      	movs	r3, #1
  72:	60b3      	str	r3, [r6, #8]
            
            if(hpcd->Init.dma_enable == 1U)
  74:	6921      	ldr	r1, [r4, #16]
  76:	4299      	cmp	r1, r3
  78:	d10c      	bne.n	94 <HAL_PCD_IRQHandler+0x94>
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
  7a:	6931      	ldr	r1, [r6, #16]
  7c:	f8d9 01e4 	ldr.w	r0, [r9, #484]	; 0x1e4
  80:	f3c1 0112 	ubfx	r1, r1, #0, #19
  84:	1a41      	subs	r1, r0, r1
  86:	f8c9 11f4 	str.w	r1, [r9, #500]	; 0x1f4
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
  8a:	f8d9 11e8 	ldr.w	r1, [r9, #488]	; 0x1e8
  8e:	4408      	add	r0, r1
  90:	f8c9 01e8 	str.w	r0, [r9, #488]	; 0x1e8
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
  94:	4659      	mov	r1, fp
  96:	4620      	mov	r0, r4
  98:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
            if(hpcd->Init.dma_enable == 1U)
  9c:	6921      	ldr	r1, [r4, #16]
  9e:	2901      	cmp	r1, #1
  a0:	d108      	bne.n	b4 <HAL_PCD_IRQHandler+0xb4>
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
  a2:	b93d      	cbnz	r5, b4 <HAL_PCD_IRQHandler+0xb4>
  a4:	f8d4 21f0 	ldr.w	r2, [r4, #496]	; 0x1f0
  a8:	b922      	cbnz	r2, b4 <HAL_PCD_IRQHandler+0xb4>
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
  aa:	f504 7261 	add.w	r2, r4, #900	; 0x384
  ae:	6820      	ldr	r0, [r4, #0]
  b0:	f7ff fffe 	bl	0 <USB_EP0_OutStart>
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
  b4:	f018 0f08 	tst.w	r8, #8
  b8:	d004      	beq.n	c4 <HAL_PCD_IRQHandler+0xc4>
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
  ba:	4620      	mov	r0, r4
  bc:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
  c0:	2308      	movs	r3, #8
  c2:	60b3      	str	r3, [r6, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
  c4:	f018 0f10 	tst.w	r8, #16
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
  c8:	bf1c      	itt	ne
  ca:	2310      	movne	r3, #16
  cc:	60b3      	strne	r3, [r6, #8]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
  ce:	3501      	adds	r5, #1
        ep_intr >>= 1U;
  d0:	087f      	lsrs	r7, r7, #1
  d2:	3620      	adds	r6, #32
  d4:	f109 091c 	add.w	r9, r9, #28
  d8:	e7bc      	b.n	54 <HAL_PCD_IRQHandler+0x54>
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
  da:	4605      	mov	r5, r0
        epnum++;
        ep_intr >>= 1U;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
  dc:	6820      	ldr	r0, [r4, #0]
  de:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
  e2:	0341      	lsls	r1, r0, #13
  e4:	f140 809b 	bpl.w	21e <HAL_PCD_IRQHandler+0x21e>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
  e8:	6820      	ldr	r0, [r4, #0]
  ea:	f7ff fffe 	bl	0 <USB_ReadDevAllInEpInterrupt>
  ee:	4626      	mov	r6, r4
  f0:	9003      	str	r0, [sp, #12]
  f2:	f50a 6810 	add.w	r8, sl, #2304	; 0x900
      
      epnum = 0U;
  f6:	2500      	movs	r5, #0
      
      while ( ep_intr )
  f8:	9b03      	ldr	r3, [sp, #12]
  fa:	2b00      	cmp	r3, #0
  fc:	f000 808f 	beq.w	21e <HAL_PCD_IRQHandler+0x21e>
      {
        if (ep_intr & 0x1U) /* In ITR */
 100:	9b03      	ldr	r3, [sp, #12]
 102:	07da      	lsls	r2, r3, #31
 104:	f140 8083 	bpl.w	20e <HAL_PCD_IRQHandler+0x20e>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 108:	fa5f f985 	uxtb.w	r9, r5
 10c:	4649      	mov	r1, r9
 10e:	6820      	ldr	r0, [r4, #0]
 110:	f7ff fffe 	bl	0 <USB_ReadDevInEPInterrupt>

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 114:	07c3      	lsls	r3, r0, #31
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U) /* In ITR */
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 116:	4607      	mov	r7, r0

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 118:	d520      	bpl.n	15c <HAL_PCD_IRQHandler+0x15c>
          {
            fifoemptymsk = 0x1U << epnum;
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 11a:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 11e:	2101      	movs	r1, #1
 120:	40a9      	lsls	r1, r5
 122:	ea23 0301 	bic.w	r3, r3, r1
 126:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 12a:	2301      	movs	r3, #1
 12c:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if (hpcd->Init.dma_enable == 1U)
 130:	6923      	ldr	r3, [r4, #16]
 132:	2b01      	cmp	r3, #1
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 134:	bf01      	itttt	eq
 136:	6c72      	ldreq	r2, [r6, #68]	; 0x44
 138:	6c33      	ldreq	r3, [r6, #64]	; 0x40
 13a:	189b      	addeq	r3, r3, r2
 13c:	6473      	streq	r3, [r6, #68]	; 0x44
            }
                                      
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 13e:	4649      	mov	r1, r9
 140:	4620      	mov	r0, r4
 142:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>

            if (hpcd->Init.dma_enable == 1U)
 146:	6921      	ldr	r1, [r4, #16]
 148:	2901      	cmp	r1, #1
 14a:	d107      	bne.n	15c <HAL_PCD_IRQHandler+0x15c>
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 14c:	b935      	cbnz	r5, 15c <HAL_PCD_IRQHandler+0x15c>
 14e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 150:	b923      	cbnz	r3, 15c <HAL_PCD_IRQHandler+0x15c>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 152:	f504 7261 	add.w	r2, r4, #900	; 0x384
 156:	6820      	ldr	r0, [r4, #0]
 158:	f7ff fffe 	bl	0 <USB_EP0_OutStart>
              }
            }           
          }
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 15c:	0738      	lsls	r0, r7, #28
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 15e:	bf44      	itt	mi
 160:	2308      	movmi	r3, #8
 162:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 166:	06f9      	lsls	r1, r7, #27
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 168:	bf44      	itt	mi
 16a:	2310      	movmi	r3, #16
 16c:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 170:	067a      	lsls	r2, r7, #25
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 172:	bf44      	itt	mi
 174:	2340      	movmi	r3, #64	; 0x40
 176:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 17a:	07bb      	lsls	r3, r7, #30
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 17c:	bf44      	itt	mi
 17e:	2302      	movmi	r3, #2
 180:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 184:	063f      	lsls	r7, r7, #24
 186:	d542      	bpl.n	20e <HAL_PCD_IRQHandler+0x20e>
  * @param  epnum : endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 188:	6823      	ldr	r3, [r4, #0]
 18a:	9304      	str	r3, [sp, #16]
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 18c:	6d37      	ldr	r7, [r6, #80]	; 0x50
 18e:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 190:	1bdb      	subs	r3, r3, r7
  
  if (len > ep->maxpacket)
 192:	6c37      	ldr	r7, [r6, #64]	; 0x40
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 194:	429f      	cmp	r7, r3
 196:	bf28      	it	cs
 198:	461f      	movcs	r7, r3
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 19a:	9b04      	ldr	r3, [sp, #16]
 19c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 1a0:	f107 0b03 	add.w	fp, r7, #3
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 1a4:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 1a8:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 1ac:	9305      	str	r3, [sp, #20]
 1ae:	9b05      	ldr	r3, [sp, #20]
 1b0:	699b      	ldr	r3, [r3, #24]
 1b2:	b29b      	uxth	r3, r3
 1b4:	455b      	cmp	r3, fp
 1b6:	d80c      	bhi.n	1d2 <HAL_PCD_IRQHandler+0x1d2>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0U)
 1b8:	bb4f      	cbnz	r7, 20e <HAL_PCD_IRQHandler+0x20e>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 1ba:	9b04      	ldr	r3, [sp, #16]
 1bc:	2201      	movs	r2, #1
 1be:	f503 6900 	add.w	r9, r3, #2048	; 0x800
 1c2:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 1c6:	40aa      	lsls	r2, r5
 1c8:	ea23 0302 	bic.w	r3, r3, r2
 1cc:	f8c9 3034 	str.w	r3, [r9, #52]	; 0x34
 1d0:	e01d      	b.n	20e <HAL_PCD_IRQHandler+0x20e>
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
 1d2:	6d32      	ldr	r2, [r6, #80]	; 0x50
 1d4:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 1d6:	4293      	cmp	r3, r2
 1d8:	d9ee      	bls.n	1b8 <HAL_PCD_IRQHandler+0x1b8>
          ep->xfer_count < ep->xfer_len &&
 1da:	2b00      	cmp	r3, #0
 1dc:	d0ec      	beq.n	1b8 <HAL_PCD_IRQHandler+0x1b8>
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
    
    if (len > ep->maxpacket)
 1de:	6c37      	ldr	r7, [r6, #64]	; 0x40
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 1e0:	9804      	ldr	r0, [sp, #16]
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 1e2:	1a9b      	subs	r3, r3, r2
 1e4:	429f      	cmp	r7, r3
 1e6:	bf28      	it	cs
 1e8:	461f      	movcs	r7, r3
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 1ea:	7c23      	ldrb	r3, [r4, #16]
 1ec:	9300      	str	r3, [sp, #0]
 1ee:	464a      	mov	r2, r9
 1f0:	b2bb      	uxth	r3, r7
 1f2:	6c71      	ldr	r1, [r6, #68]	; 0x44
 1f4:	f7ff fffe 	bl	0 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 1f8:	6c73      	ldr	r3, [r6, #68]	; 0x44
 1fa:	443b      	add	r3, r7
 1fc:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 1fe:	6d33      	ldr	r3, [r6, #80]	; 0x50
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 200:	f107 0b03 	add.w	fp, r7, #3
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 204:	443b      	add	r3, r7
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 206:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 20a:	6533      	str	r3, [r6, #80]	; 0x50
 20c:	e7cf      	b.n	1ae <HAL_PCD_IRQHandler+0x1ae>
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
        ep_intr >>= 1U;
 20e:	9b03      	ldr	r3, [sp, #12]
 210:	085b      	lsrs	r3, r3, #1
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
 212:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 214:	9303      	str	r3, [sp, #12]
 216:	361c      	adds	r6, #28
 218:	f108 0820 	add.w	r8, r8, #32
 21c:	e76c      	b.n	f8 <HAL_PCD_IRQHandler+0xf8>
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 21e:	6820      	ldr	r0, [r4, #0]
 220:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 224:	2800      	cmp	r0, #0
 226:	da0d      	bge.n	244 <HAL_PCD_IRQHandler+0x244>
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 228:	f8da 3804 	ldr.w	r3, [sl, #2052]	; 0x804
 22c:	f023 0301 	bic.w	r3, r3, #1
 230:	f8ca 3804 	str.w	r3, [sl, #2052]	; 0x804
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
#endif /* USB_OTG_GLPMCFG_LPMEN */
      {
        HAL_PCD_ResumeCallback(hpcd);
 234:	4620      	mov	r0, r4
 236:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 23a:	6822      	ldr	r2, [r4, #0]
 23c:	6953      	ldr	r3, [r2, #20]
 23e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 242:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 244:	6820      	ldr	r0, [r4, #0]
 246:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 24a:	0506      	lsls	r6, r0, #20
 24c:	d50b      	bpl.n	266 <HAL_PCD_IRQHandler+0x266>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 24e:	f8da 3808 	ldr.w	r3, [sl, #2056]	; 0x808
 252:	07d8      	lsls	r0, r3, #31
 254:	d502      	bpl.n	25c <HAL_PCD_IRQHandler+0x25c>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 256:	4620      	mov	r0, r4
 258:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 25c:	6822      	ldr	r2, [r4, #0]
 25e:	6953      	ldr	r3, [r2, #20]
 260:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 264:	6153      	str	r3, [r2, #20]
      }
    }
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 266:	6820      	ldr	r0, [r4, #0]
 268:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 26c:	04c1      	lsls	r1, r0, #19
 26e:	d543      	bpl.n	2f8 <HAL_PCD_IRQHandler+0x2f8>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 270:	f50a 6600 	add.w	r6, sl, #2048	; 0x800
 274:	6873      	ldr	r3, [r6, #4]
 276:	f023 0301 	bic.w	r3, r3, #1
 27a:	6073      	str	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 27c:	2100      	movs	r1, #0
 27e:	6820      	ldr	r0, [r4, #0]
 280:	f7ff fffe 	bl	0 <USB_FlushTxFifo>
 284:	f50a 6310 	add.w	r3, sl, #2304	; 0x900
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 288:	2200      	movs	r2, #0
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 28a:	21ff      	movs	r1, #255	; 0xff
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 28c:	6860      	ldr	r0, [r4, #4]
 28e:	4282      	cmp	r2, r0
 290:	d205      	bcs.n	29e <HAL_PCD_IRQHandler+0x29e>
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 292:	6099      	str	r1, [r3, #8]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 294:	3201      	adds	r2, #1
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 296:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
 29a:	3320      	adds	r3, #32
 29c:	e7f6      	b.n	28c <HAL_PCD_IRQHandler+0x28c>
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 29e:	f04f 33ff 	mov.w	r3, #4294967295
 2a2:	61b3      	str	r3, [r6, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 2a4:	69f3      	ldr	r3, [r6, #28]
 2a6:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 2aa:	61f3      	str	r3, [r6, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 2ac:	6b23      	ldr	r3, [r4, #48]	; 0x30
 2ae:	b153      	cbz	r3, 2c6 <HAL_PCD_IRQHandler+0x2c6>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 2b0:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 2b4:	f043 030b 	orr.w	r3, r3, #11
 2b8:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 2bc:	6c73      	ldr	r3, [r6, #68]	; 0x44
 2be:	f043 030b 	orr.w	r3, r3, #11
 2c2:	6473      	str	r3, [r6, #68]	; 0x44
 2c4:	e007      	b.n	2d6 <HAL_PCD_IRQHandler+0x2d6>
      else
      {
#ifdef USB_OTG_DOEPINT_OTEPSPR
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
#else
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 2c6:	6973      	ldr	r3, [r6, #20]
 2c8:	f043 030b 	orr.w	r3, r3, #11
 2cc:	6173      	str	r3, [r6, #20]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 2ce:	6933      	ldr	r3, [r6, #16]
 2d0:	f043 030b 	orr.w	r3, r3, #11
 2d4:	6133      	str	r3, [r6, #16]
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 2d6:	f8da 3800 	ldr.w	r3, [sl, #2048]	; 0x800
 2da:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 2de:	f8ca 3800 	str.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 2e2:	f504 7261 	add.w	r2, r4, #900	; 0x384
 2e6:	7c21      	ldrb	r1, [r4, #16]
 2e8:	6820      	ldr	r0, [r4, #0]
 2ea:	f7ff fffe 	bl	0 <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 2ee:	6822      	ldr	r2, [r4, #0]
 2f0:	6953      	ldr	r3, [r2, #20]
 2f2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 2f6:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 2f8:	6820      	ldr	r0, [r4, #0]
 2fa:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 2fe:	0482      	lsls	r2, r0, #18
 300:	d57d      	bpl.n	3fe <HAL_PCD_IRQHandler+0x3fe>
    {
      USB_ActivateSetup(hpcd->Instance);
 302:	6820      	ldr	r0, [r4, #0]
 304:	f7ff fffe 	bl	0 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 308:	6822      	ldr	r2, [r4, #0]
 30a:	68d3      	ldr	r3, [r2, #12]
 30c:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 310:	60d3      	str	r3, [r2, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 312:	6820      	ldr	r0, [r4, #0]
 314:	f7ff fffe 	bl	0 <USB_GetDevSpeed>
 318:	b948      	cbnz	r0, 32e <HAL_PCD_IRQHandler+0x32e>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 31a:	f44f 7300 	mov.w	r3, #512	; 0x200
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 31e:	6822      	ldr	r2, [r4, #0]
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 320:	60e0      	str	r0, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 322:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 324:	68d3      	ldr	r3, [r2, #12]
 326:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 32a:	60d3      	str	r3, [r2, #12]
 32c:	e05f      	b.n	3ee <HAL_PCD_IRQHandler+0x3ee>
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 32e:	2303      	movs	r3, #3
 330:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 332:	2340      	movs	r3, #64	; 0x40
 334:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response 
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access 
        latency to the Data FIFO */
        
        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 336:	f7ff fffe 	bl	0 <HAL_RCC_GetHCLKFreq>
		
        if((hclk >= 14200000)&&(hclk < 15000000))
 33a:	4b74      	ldr	r3, [pc, #464]	; (50c <HAL_PCD_IRQHandler+0x50c>)
 33c:	4a74      	ldr	r2, [pc, #464]	; (510 <HAL_PCD_IRQHandler+0x510>)
 33e:	4403      	add	r3, r0
 340:	4293      	cmp	r3, r2
 342:	6823      	ldr	r3, [r4, #0]
 344:	d803      	bhi.n	34e <HAL_PCD_IRQHandler+0x34e>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xF << 10) & USB_OTG_GUSBCFG_TRDT);
 346:	68da      	ldr	r2, [r3, #12]
 348:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
 34c:	e04e      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 15000000)&&(hclk < 16000000))
 34e:	4a71      	ldr	r2, [pc, #452]	; (514 <HAL_PCD_IRQHandler+0x514>)
 350:	4971      	ldr	r1, [pc, #452]	; (518 <HAL_PCD_IRQHandler+0x518>)
 352:	4402      	add	r2, r0
 354:	428a      	cmp	r2, r1
 356:	d803      	bhi.n	360 <HAL_PCD_IRQHandler+0x360>
        {
          /* hclk Clock Range between 15-16 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xE << 10) & USB_OTG_GUSBCFG_TRDT);
 358:	68da      	ldr	r2, [r3, #12]
 35a:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 35e:	e045      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 16000000)&&(hclk < 17200000))
 360:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 364:	496d      	ldr	r1, [pc, #436]	; (51c <HAL_PCD_IRQHandler+0x51c>)
 366:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 36a:	428a      	cmp	r2, r1
 36c:	d803      	bhi.n	376 <HAL_PCD_IRQHandler+0x376>
        {
          /* hclk Clock Range between 16-17.2 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xD << 10) & USB_OTG_GUSBCFG_TRDT);
 36e:	68da      	ldr	r2, [r3, #12]
 370:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 374:	e03a      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 17200000)&&(hclk < 18500000))
 376:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 37a:	4969      	ldr	r1, [pc, #420]	; (520 <HAL_PCD_IRQHandler+0x520>)
 37c:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 380:	428a      	cmp	r2, r1
 382:	d803      	bhi.n	38c <HAL_PCD_IRQHandler+0x38c>
        {
          /* hclk Clock Range between 17.2-18.5 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xC << 10) & USB_OTG_GUSBCFG_TRDT);
 384:	68da      	ldr	r2, [r3, #12]
 386:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 38a:	e02f      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 18500000)&&(hclk < 20000000))
 38c:	4a65      	ldr	r2, [pc, #404]	; (524 <HAL_PCD_IRQHandler+0x524>)
 38e:	4966      	ldr	r1, [pc, #408]	; (528 <HAL_PCD_IRQHandler+0x528>)
 390:	4402      	add	r2, r0
 392:	428a      	cmp	r2, r1
 394:	d803      	bhi.n	39e <HAL_PCD_IRQHandler+0x39e>
        {
          /* hclk Clock Range between 18.5-20 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xB << 10) & USB_OTG_GUSBCFG_TRDT);
 396:	68da      	ldr	r2, [r3, #12]
 398:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 39c:	e026      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 20000000)&&(hclk < 21800000))
 39e:	4a63      	ldr	r2, [pc, #396]	; (52c <HAL_PCD_IRQHandler+0x52c>)
 3a0:	4963      	ldr	r1, [pc, #396]	; (530 <HAL_PCD_IRQHandler+0x530>)
 3a2:	4402      	add	r2, r0
 3a4:	428a      	cmp	r2, r1
 3a6:	d803      	bhi.n	3b0 <HAL_PCD_IRQHandler+0x3b0>
        {
          /* hclk Clock Range between 20-21.8 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xA << 10) & USB_OTG_GUSBCFG_TRDT);
 3a8:	68da      	ldr	r2, [r3, #12]
 3aa:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 3ae:	e01d      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 21800000)&&(hclk < 24000000))
 3b0:	4a60      	ldr	r2, [pc, #384]	; (534 <HAL_PCD_IRQHandler+0x534>)
 3b2:	4961      	ldr	r1, [pc, #388]	; (538 <HAL_PCD_IRQHandler+0x538>)
 3b4:	4402      	add	r2, r0
 3b6:	428a      	cmp	r2, r1
 3b8:	d803      	bhi.n	3c2 <HAL_PCD_IRQHandler+0x3c2>
        {
          /* hclk Clock Range between 21.8-24 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9 << 10) & USB_OTG_GUSBCFG_TRDT);
 3ba:	68da      	ldr	r2, [r3, #12]
 3bc:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 3c0:	e014      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 24000000)&&(hclk < 27700000))
 3c2:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 3c6:	495d      	ldr	r1, [pc, #372]	; (53c <HAL_PCD_IRQHandler+0x53c>)
 3c8:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 3cc:	428a      	cmp	r2, r1
 3ce:	d803      	bhi.n	3d8 <HAL_PCD_IRQHandler+0x3d8>
        {
          /* hclk Clock Range between 24-27.7 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8 << 10) & USB_OTG_GUSBCFG_TRDT);
 3d0:	68da      	ldr	r2, [r3, #12]
 3d2:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 3d6:	e009      	b.n	3ec <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 27700000)&&(hclk < 32000000))
 3d8:	4a59      	ldr	r2, [pc, #356]	; (540 <HAL_PCD_IRQHandler+0x540>)
 3da:	495a      	ldr	r1, [pc, #360]	; (544 <HAL_PCD_IRQHandler+0x544>)
 3dc:	4402      	add	r2, r0
 3de:	428a      	cmp	r2, r1
        {
          /* hclk Clock Range between 27.7-32 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7 << 10) & USB_OTG_GUSBCFG_TRDT);
 3e0:	68da      	ldr	r2, [r3, #12]
 3e2:	bf94      	ite	ls
 3e4:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
        }
        
        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-180 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6 << 10) & USB_OTG_GUSBCFG_TRDT);
 3e8:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 3ec:	60da      	str	r2, [r3, #12]
        }  
      }
      
      HAL_PCD_ResetCallback(hpcd);
 3ee:	4620      	mov	r0, r4
 3f0:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 3f4:	6822      	ldr	r2, [r4, #0]
 3f6:	6953      	ldr	r3, [r2, #20]
 3f8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 3fc:	6153      	str	r3, [r2, #20]
    }

    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 3fe:	6820      	ldr	r0, [r4, #0]
 400:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 404:	06c3      	lsls	r3, r0, #27
 406:	d538      	bpl.n	47a <HAL_PCD_IRQHandler+0x47a>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 408:	6822      	ldr	r2, [r4, #0]
 40a:	6993      	ldr	r3, [r2, #24]
 40c:	f023 0310 	bic.w	r3, r3, #16
 410:	6193      	str	r3, [r2, #24]
      
      temp = USBx->GRXSTSP;
 412:	f8da 6020 	ldr.w	r6, [sl, #32]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 416:	f3c6 4343 	ubfx	r3, r6, #17, #4
 41a:	2b02      	cmp	r3, #2
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
      
      temp = USBx->GRXSTSP;
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 41c:	f006 070f 	and.w	r7, r6, #15
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 420:	d114      	bne.n	44c <HAL_PCD_IRQHandler+0x44c>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 422:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 426:	4033      	ands	r3, r6
 428:	b313      	cbz	r3, 470 <HAL_PCD_IRQHandler+0x470>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 42a:	231c      	movs	r3, #28
 42c:	fb03 4707 	mla	r7, r3, r7, r4
 430:	f3c6 160a 	ubfx	r6, r6, #4, #11
 434:	4632      	mov	r2, r6
 436:	f8d7 11e8 	ldr.w	r1, [r7, #488]	; 0x1e8
 43a:	4650      	mov	r0, sl
 43c:	f7ff fffe 	bl	0 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 440:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 444:	4433      	add	r3, r6
 446:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 44a:	e00c      	b.n	466 <HAL_PCD_IRQHandler+0x466>
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 44c:	2b06      	cmp	r3, #6
 44e:	d10f      	bne.n	470 <HAL_PCD_IRQHandler+0x470>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 450:	2208      	movs	r2, #8
 452:	f504 7161 	add.w	r1, r4, #900	; 0x384
 456:	4650      	mov	r0, sl
 458:	f7ff fffe 	bl	0 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 45c:	231c      	movs	r3, #28
 45e:	fb03 4707 	mla	r7, r3, r7, r4
 462:	f3c6 160a 	ubfx	r6, r6, #4, #11
 466:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 46a:	441e      	add	r6, r3
 46c:	f8c7 61f4 	str.w	r6, [r7, #500]	; 0x1f4
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 470:	6822      	ldr	r2, [r4, #0]
 472:	6993      	ldr	r3, [r2, #24]
 474:	f043 0310 	orr.w	r3, r3, #16
 478:	6193      	str	r3, [r2, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 47a:	6820      	ldr	r0, [r4, #0]
 47c:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 480:	0707      	lsls	r7, r0, #28
 482:	d507      	bpl.n	494 <HAL_PCD_IRQHandler+0x494>
    {
      HAL_PCD_SOFCallback(hpcd);
 484:	4620      	mov	r0, r4
 486:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 48a:	6822      	ldr	r2, [r4, #0]
 48c:	6953      	ldr	r3, [r2, #20]
 48e:	f003 0308 	and.w	r3, r3, #8
 492:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 494:	6820      	ldr	r0, [r4, #0]
 496:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 49a:	02c6      	lsls	r6, r0, #11
 49c:	d508      	bpl.n	4b0 <HAL_PCD_IRQHandler+0x4b0>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 49e:	b2e9      	uxtb	r1, r5
 4a0:	4620      	mov	r0, r4
 4a2:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 4a6:	6822      	ldr	r2, [r4, #0]
 4a8:	6953      	ldr	r3, [r2, #20]
 4aa:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 4ae:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 4b0:	6820      	ldr	r0, [r4, #0]
 4b2:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 4b6:	0280      	lsls	r0, r0, #10
 4b8:	d508      	bpl.n	4cc <HAL_PCD_IRQHandler+0x4cc>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 4ba:	b2e9      	uxtb	r1, r5
 4bc:	4620      	mov	r0, r4
 4be:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 4c2:	6822      	ldr	r2, [r4, #0]
 4c4:	6953      	ldr	r3, [r2, #20]
 4c6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 4ca:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 4cc:	6820      	ldr	r0, [r4, #0]
 4ce:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 4d2:	0041      	lsls	r1, r0, #1
 4d4:	d507      	bpl.n	4e6 <HAL_PCD_IRQHandler+0x4e6>
    {
      HAL_PCD_ConnectCallback(hpcd);
 4d6:	4620      	mov	r0, r4
 4d8:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 4dc:	6822      	ldr	r2, [r4, #0]
 4de:	6953      	ldr	r3, [r2, #20]
 4e0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 4e4:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 4e6:	6820      	ldr	r0, [r4, #0]
 4e8:	f7ff fffe 	bl	0 <USB_ReadInterrupts>
 4ec:	0742      	lsls	r2, r0, #29
 4ee:	d50a      	bpl.n	506 <HAL_PCD_IRQHandler+0x506>
    {
      temp = hpcd->Instance->GOTGINT;
 4f0:	6823      	ldr	r3, [r4, #0]
 4f2:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 4f4:	076b      	lsls	r3, r5, #29
 4f6:	d502      	bpl.n	4fe <HAL_PCD_IRQHandler+0x4fe>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 4f8:	4620      	mov	r0, r4
 4fa:	f7ff fffe 	bl	0 <HAL_PCD_IRQHandler>
      }
      hpcd->Instance->GOTGINT |= temp;
 4fe:	6822      	ldr	r2, [r4, #0]
 500:	6853      	ldr	r3, [r2, #4]
 502:	432b      	orrs	r3, r5
 504:	6053      	str	r3, [r2, #4]
    }
  }
}
 506:	b007      	add	sp, #28
 508:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 50c:	ff275340 	.word	0xff275340
 510:	000c34ff 	.word	0x000c34ff
 514:	ff1b1e40 	.word	0xff1b1e40
 518:	000f423f 	.word	0x000f423f
 51c:	00124f7f 	.word	0x00124f7f
 520:	0013d61f 	.word	0x0013d61f
 524:	fee5b660 	.word	0xfee5b660
 528:	0016e35f 	.word	0x0016e35f
 52c:	feced300 	.word	0xfeced300
 530:	001b773f 	.word	0x001b773f
 534:	feb35bc0 	.word	0xfeb35bc0
 538:	002191bf 	.word	0x002191bf
 53c:	0038751f 	.word	0x0038751f
 540:	fe5954e0 	.word	0xfe5954e0
 544:	00419cdf 	.word	0x00419cdf

Disassembly of section .text.HAL_PCD_DevConnect:

00000000 <HAL_PCD_DevConnect>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b510      	push	{r4, lr}
   2:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	2b01      	cmp	r3, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	4604      	mov	r4, r0
   a:	d009      	beq.n	20 <HAL_PCD_DevConnect+0x20>
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	2301      	movs	r3, #1
   e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  12:	6800      	ldr	r0, [r0, #0]
  14:	f7ff fffe 	bl	0 <USB_DevConnect>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	2000      	movs	r0, #0
  1a:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  1e:	bd10      	pop	{r4, pc}
  20:	2002      	movs	r0, #2
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_DevDisconnect:

00000000 <HAL_PCD_DevDisconnect>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b510      	push	{r4, lr}
   2:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	2b01      	cmp	r3, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	4604      	mov	r4, r0
   a:	d009      	beq.n	20 <HAL_PCD_DevDisconnect+0x20>
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	2301      	movs	r3, #1
   e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  12:	6800      	ldr	r0, [r0, #0]
  14:	f7ff fffe 	bl	0 <USB_DevDisconnect>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	2000      	movs	r0, #0
  1a:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  1e:	bd10      	pop	{r4, pc}
  20:	2002      	movs	r0, #2
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_SetAddress:

00000000 <HAL_PCD_SetAddress>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b510      	push	{r4, lr}
   2:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	2b01      	cmp	r3, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	4604      	mov	r4, r0
   a:	d009      	beq.n	20 <HAL_PCD_SetAddress+0x20>
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	2301      	movs	r3, #1
   e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  12:	6800      	ldr	r0, [r0, #0]
  14:	f7ff fffe 	bl	0 <USB_SetDevAddress>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	2000      	movs	r0, #0
  1a:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  1e:	bd10      	pop	{r4, pc}
  20:	2002      	movs	r0, #2
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_EP_Open:

00000000 <HAL_PCD_EP_Open>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b24e      	sxtb	r6, r1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	2e00      	cmp	r6, #0
   6:	4604      	mov	r4, r0
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	f04f 051c 	mov.w	r5, #28
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  10:	bfb5      	itete	lt
  12:	fb05 4100 	mlalt	r1, r5, r0, r4
  16:	fb05 4101 	mlage	r1, r5, r1, r4
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  1a:	3138      	addlt	r1, #56	; 0x38
  1c:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  20:	b2c0      	uxtb	r0, r0
  22:	2e00      	cmp	r6, #0
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	bfb8      	it	lt
  26:	80c8      	strhlt	r0, [r1, #6]
  28:	2b02      	cmp	r3, #2
  2a:	70cb      	strb	r3, [r1, #3]
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2c:	ea4f 75d6 	mov.w	r5, r6, lsr #31
  30:	bf04      	itt	eq
  32:	2300      	moveq	r3, #0
  34:	710b      	strbeq	r3, [r1, #4]
  36:	7008      	strb	r0, [r1, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	704d      	strb	r5, [r1, #1]
  3a:	608a      	str	r2, [r1, #8]
  3c:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
  40:	2b01      	cmp	r3, #1
  42:	d009      	beq.n	58 <HAL_PCD_EP_Open+0x58>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	2301      	movs	r3, #1
  46:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  4a:	6820      	ldr	r0, [r4, #0]
  4c:	f7ff fffe 	bl	0 <USB_ActivateEndpoint>
  50:	2000      	movs	r0, #0
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
  52:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
  56:	bd70      	pop	{r4, r5, r6, pc}
      {
        if (ep_intr & 0x1U)
  58:	2002      	movs	r0, #2
  5a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.HAL_PCD_EP_Close:

00000000 <HAL_PCD_EP_Close>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b24b      	sxtb	r3, r1
   2:	2b00      	cmp	r3, #0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	b510      	push	{r4, lr}
   6:	f04f 021c 	mov.w	r2, #28
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   a:	4604      	mov	r4, r0
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  10:	bfb5      	itete	lt
  12:	fb02 4100 	mlalt	r1, r2, r0, r4
  16:	fb02 4101 	mlage	r1, r2, r1, r4
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  1a:	3138      	addlt	r1, #56	; 0x38
  1c:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  20:	0fdb      	lsrs	r3, r3, #31
  22:	7008      	strb	r0, [r1, #0]
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	704b      	strb	r3, [r1, #1]
  26:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
  2a:	2b01      	cmp	r3, #1
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2c:	d009      	beq.n	42 <HAL_PCD_EP_Close+0x42>
  2e:	2301      	movs	r3, #1
  30:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  34:	6820      	ldr	r0, [r4, #0]
  36:	f7ff fffe 	bl	0 <USB_DeactivateEndpoint>
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  3a:	2000      	movs	r0, #0
  3c:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  40:	bd10      	pop	{r4, pc}
  42:	2002      	movs	r0, #2
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_EP_Receive:

00000000 <HAL_PCD_EP_Receive>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	201c      	movs	r0, #28
   a:	fb00 4005 	mla	r0, r0, r5, r4
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   e:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
  12:	2300      	movs	r3, #0
  14:	f8c0 21e8 	str.w	r2, [r0, #488]	; 0x1e8
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  1c:	f880 31dd 	strb.w	r3, [r0, #477]	; 0x1dd
  20:	f880 51dc 	strb.w	r5, [r0, #476]	; 0x1dc
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	6923      	ldr	r3, [r4, #16]
  26:	2b01      	cmp	r3, #1
  28:	bf08      	it	eq
  2a:	f8c0 21ec 	streq.w	r2, [r0, #492]	; 0x1ec
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2e:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
  32:	2a01      	cmp	r2, #1
  34:	d013      	beq.n	5e <HAL_PCD_EP_Receive+0x5e>
  36:	211c      	movs	r1, #28
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	2201      	movs	r2, #1
  3a:	fb01 4105 	mla	r1, r1, r5, r4
  3e:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  42:	f501 71ee 	add.w	r1, r1, #476	; 0x1dc
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  46:	b2da      	uxtb	r2, r3
  48:	6820      	ldr	r0, [r4, #0]
  4a:	b915      	cbnz	r5, 52 <HAL_PCD_EP_Receive+0x52>
  4c:	f7ff fffe 	bl	0 <USB_EP0StartXfer>
  50:	e001      	b.n	6 <USB_EPStartXfer+0x6>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
  52:	f7ff fffe 	bl	0 <USB_EPStartXfer>
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
  56:	2000      	movs	r0, #0
      {
        if (ep_intr & 0x1U)
  58:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
  5c:	bd38      	pop	{r3, r4, r5, pc}
  5e:	2002      	movs	r0, #2
  60:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.HAL_PCD_EP_GetRxCount:

00000000 <HAL_PCD_EP_GetRxCount>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	231c      	movs	r3, #28
   6:	fb03 0001 	mla	r0, r3, r1, r0
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   a:	f8b0 01f4 	ldrh.w	r0, [r0, #500]	; 0x1f4
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   e:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_EP_Transmit:

00000000 <HAL_PCD_EP_Transmit>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	201c      	movs	r0, #28
   a:	fb00 4005 	mla	r0, r0, r5, r4
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   e:	64c3      	str	r3, [r0, #76]	; 0x4c
  10:	2300      	movs	r3, #0
  12:	6503      	str	r3, [r0, #80]	; 0x50
  14:	2301      	movs	r3, #1
  16:	6442      	str	r2, [r0, #68]	; 0x44
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  1c:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
  20:	6923      	ldr	r3, [r4, #16]
  22:	2b01      	cmp	r3, #1
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	bf08      	it	eq
  26:	6482      	streq	r2, [r0, #72]	; 0x48
  28:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2c:	2a01      	cmp	r2, #1
  2e:	d012      	beq.n	56 <HAL_PCD_EP_Transmit+0x56>
  30:	211c      	movs	r1, #28
  32:	2201      	movs	r2, #1
  34:	fb01 4105 	mla	r1, r1, r5, r4
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  3c:	3138      	adds	r1, #56	; 0x38
  3e:	b2da      	uxtb	r2, r3
  40:	6820      	ldr	r0, [r4, #0]
  42:	b915      	cbnz	r5, 4a <HAL_PCD_EP_Transmit+0x4a>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	f7ff fffe 	bl	0 <USB_EP0StartXfer>
  48:	e001      	b.n	6 <USB_EPStartXfer+0x6>
  4a:	f7ff fffe 	bl	0 <USB_EPStartXfer>
  4e:	2000      	movs	r0, #0
  50:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
      
      while ( ep_intr )
  54:	bd38      	pop	{r3, r4, r5, pc}
  56:	2002      	movs	r0, #2
      {
        if (ep_intr & 0x1U)
  58:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.HAL_PCD_EP_SetStall:

00000000 <HAL_PCD_EP_SetStall>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	b24b      	sxtb	r3, r1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	2b00      	cmp	r3, #0
   6:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   a:	f04f 021c 	mov.w	r2, #28
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   e:	bfb5      	itete	lt
  10:	fb02 0105 	mlalt	r1, r2, r5, r0
  14:	fb02 0101 	mlage	r1, r2, r1, r0
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	3138      	addlt	r1, #56	; 0x38
  1a:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  1e:	2201      	movs	r2, #1
  20:	0fdb      	lsrs	r3, r3, #31
  22:	b2ed      	uxtb	r5, r5
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	708a      	strb	r2, [r1, #2]
  26:	700d      	strb	r5, [r1, #0]
  28:	704b      	strb	r3, [r1, #1]
  2a:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2e:	4293      	cmp	r3, r2
  30:	4604      	mov	r4, r0
  32:	d00f      	beq.n	54 <HAL_PCD_EP_SetStall+0x54>
  34:	f880 2380 	strb.w	r2, [r0, #896]	; 0x380
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	6800      	ldr	r0, [r0, #0]
  3a:	f7ff fffe 	bl	0 <USB_EPSetStall>
  3e:	b92d      	cbnz	r5, 4c <HAL_PCD_EP_SetStall+0x4c>
  40:	f504 7261 	add.w	r2, r4, #900	; 0x384
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	7c21      	ldrb	r1, [r4, #16]
  46:	6820      	ldr	r0, [r4, #0]
  48:	f7ff fffe 	bl	0 <USB_EP0_OutStart>
  4c:	2000      	movs	r0, #0
  4e:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
  52:	bd38      	pop	{r3, r4, r5, pc}
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
  54:	2002      	movs	r0, #2
  56:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.HAL_PCD_EP_ClrStall:

00000000 <HAL_PCD_EP_ClrStall>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	b24b      	sxtb	r3, r1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	2b00      	cmp	r3, #0
   6:	4605      	mov	r5, r0
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	f04f 021c 	mov.w	r2, #28
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  10:	bfb5      	itete	lt
  12:	fb02 5100 	mlalt	r1, r2, r0, r5
  16:	fb02 5101 	mlage	r1, r2, r1, r5
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  1a:	3138      	addlt	r1, #56	; 0x38
  1c:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  20:	0fdb      	lsrs	r3, r3, #31
  22:	2400      	movs	r4, #0
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	708c      	strb	r4, [r1, #2]
  26:	7008      	strb	r0, [r1, #0]
  28:	704b      	strb	r3, [r1, #1]
  2a:	f895 3380 	ldrb.w	r3, [r5, #896]	; 0x380
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2e:	2b01      	cmp	r3, #1
  30:	d009      	beq.n	46 <HAL_PCD_EP_ClrStall+0x46>
  32:	2301      	movs	r3, #1
  34:	f885 3380 	strb.w	r3, [r5, #896]	; 0x380
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
  38:	6828      	ldr	r0, [r5, #0]
  3a:	f7ff fffe 	bl	0 <USB_EPClearStall>
  3e:	f885 4380 	strb.w	r4, [r5, #896]	; 0x380
  42:	4620      	mov	r0, r4
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
  44:	bd38      	pop	{r3, r4, r5, pc}
  46:	2002      	movs	r0, #2
  48:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.HAL_PCD_EP_Flush:

00000000 <HAL_PCD_EP_Flush>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	b510      	push	{r4, lr}
   2:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	2b01      	cmp	r3, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   8:	4604      	mov	r4, r0
   a:	d011      	beq.n	30 <HAL_PCD_EP_Flush+0x30>
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	2301      	movs	r3, #1
   e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  12:	060b      	lsls	r3, r1, #24
  14:	d505      	bpl.n	22 <HAL_PCD_EP_Flush+0x22>
  16:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  1a:	6800      	ldr	r0, [r0, #0]
  1c:	f7ff fffe 	bl	0 <USB_FlushTxFifo>
  20:	e002      	b.n	28 <HAL_PCD_EP_Flush+0x28>
  22:	6800      	ldr	r0, [r0, #0]
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
  24:	f7ff fffe 	bl	0 <USB_FlushRxFifo>
  28:	2000      	movs	r0, #0
  2a:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
  2e:	bd10      	pop	{r4, pc}
  30:	2002      	movs	r0, #2
  32:	bd10      	pop	{r4, pc}

Disassembly of section .text.HAL_PCD_ActivateRemoteWakeup:

00000000 <HAL_PCD_ActivateRemoteWakeup>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	f8d3 2808 	ldr.w	r2, [r3, #2056]	; 0x808
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   a:	07d2      	lsls	r2, r2, #31
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   c:	bf42      	ittt	mi
   e:	685a      	ldrmi	r2, [r3, #4]
  10:	f042 0201 	orrmi.w	r2, r2, #1
  14:	605a      	strmi	r2, [r3, #4]
  16:	2000      	movs	r0, #0
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
  18:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_DeActivateRemoteWakeup:

00000000 <HAL_PCD_DeActivateRemoteWakeup>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   6:	f022 0201 	bic.w	r2, r2, #1
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   e:	2000      	movs	r0, #0
  10:	4770      	bx	lr

Disassembly of section .text.HAL_PCD_GetState:

00000000 <HAL_PCD_GetState>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
   0:	f890 0381 	ldrb.w	r0, [r0, #897]	; 0x381
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   4:	4770      	bx	lr

stm32f4xx_hal_pcd_ex.o:     file format elf32-littlearm


Disassembly of section .text.HAL_PCDEx_SetTxFiFo:

00000000 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
   0:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
   2:	6804      	ldr	r4, [r0, #0]
   4:	6a60      	ldr	r0, [r4, #36]	; 0x24
  
  if(fifo == 0U)
   6:	b919      	cbnz	r1, 10 <HAL_PCDEx_SetTxFiFo+0x10>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
   8:	ea40 4302 	orr.w	r3, r0, r2, lsl #16
   c:	62a3      	str	r3, [r4, #40]	; 0x28
   e:	e016      	b.n	3e <HAL_PCDEx_SetTxFiFo+0x3e>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
  10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
  12:	2500      	movs	r5, #0
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
  14:	eb00 4313 	add.w	r3, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
  18:	1e4e      	subs	r6, r1, #1
  1a:	b2e8      	uxtb	r0, r5
  1c:	4286      	cmp	r6, r0
  1e:	f105 0501 	add.w	r5, r5, #1
  22:	d906      	bls.n	32 <HAL_PCDEx_SetTxFiFo+0x32>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
  24:	3040      	adds	r0, #64	; 0x40
  26:	eb04 0080 	add.w	r0, r4, r0, lsl #2
  2a:	6840      	ldr	r0, [r0, #4]
  2c:	eb03 4310 	add.w	r3, r3, r0, lsr #16
  30:	e7f3      	b.n	1a <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
  32:	313f      	adds	r1, #63	; 0x3f
  34:	eb04 0481 	add.w	r4, r4, r1, lsl #2
  38:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  3c:	6063      	str	r3, [r4, #4]
  }
  
  return HAL_OK;
}
  3e:	2000      	movs	r0, #0
  40:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.HAL_PCDEx_SetRxFiFo:

00000000 <HAL_PCDEx_SetRxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
   0:	6803      	ldr	r3, [r0, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
   2:	2000      	movs	r0, #0
   4:	6259      	str	r1, [r3, #36]	; 0x24
  
  if(fifo == 0U)
   6:	4770      	bx	lr

stm32f4xx_ll_usb.o:     file format elf32-littlearm


Disassembly of section .text.USB_CoreInit:

00000000 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   0:	b084      	sub	sp, #16
   2:	b538      	push	{r3, r4, r5, lr}
   4:	ad05      	add	r5, sp, #20
   6:	e885 000e 	stmia.w	r5, {r1, r2, r3}
   a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   c:	2b01      	cmp	r3, #1
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	4604      	mov	r4, r0
  10:	d117      	bne.n	42 <USB_CoreInit+0x42>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	6383      	str	r3, [r0, #56]	; 0x38
  1a:	68c3      	ldr	r3, [r0, #12]
  1c:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  24:	60c3      	str	r3, [r0, #12]
  26:	68c3      	ldr	r3, [r0, #12]
  28:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2c:	60c3      	str	r3, [r0, #12]
  2e:	9b11      	ldr	r3, [sp, #68]	; 0x44
  30:	2b01      	cmp	r3, #1
    if(cfg.use_external_vbus == 1U)
  32:	bf02      	ittt	eq
  34:	68c3      	ldreq	r3, [r0, #12]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
  3a:	60c3      	streq	r3, [r0, #12]
  3c:	f7ff fffe 	bl	0 <USB_CoreInit>
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	e008      	b.n	54 <USB_CoreInit+0x54>
  42:	68c3      	ldr	r3, [r0, #12]
  44:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  48:	60c3      	str	r3, [r0, #12]
  4a:	f7ff fffe 	bl	0 <USB_CoreInit>
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	63a3      	str	r3, [r4, #56]	; 0x38
  54:	9b08      	ldr	r3, [sp, #32]
  56:	2b01      	cmp	r3, #1
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	bf02      	ittt	eq
  5a:	68a3      	ldreq	r3, [r4, #8]
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	f043 0320 	orreq.w	r3, r3, #32
  60:	60a3      	streq	r3, [r4, #8]
  62:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }  

  return HAL_OK;
}
  66:	2000      	movs	r0, #0
  68:	b004      	add	sp, #16
  6a:	4770      	bx	lr

Disassembly of section .text.USB_EnableGlobalInt:

00000000 <USB_EnableGlobalInt>:
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0301 	orr.w	r3, r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	6083      	str	r3, [r0, #8]
   8:	2000      	movs	r0, #0
   a:	4770      	bx	lr

Disassembly of section .text.USB_DisableGlobalInt:

00000000 <USB_DisableGlobalInt>:
   0:	6883      	ldr	r3, [r0, #8]
   2:	f023 0301 	bic.w	r3, r3, #1
   6:	6083      	str	r3, [r0, #8]
   8:	2000      	movs	r0, #0
   a:	4770      	bx	lr

Disassembly of section .text.USB_SetCurrentMode:

00000000 <USB_SetCurrentMode>:
   0:	b508      	push	{r3, lr}
   2:	68c3      	ldr	r3, [r0, #12]
   4:	2901      	cmp	r1, #1
   6:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
   a:	60c3      	str	r3, [r0, #12]
   c:	d104      	bne.n	18 <USB_SetCurrentMode+0x18>
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	68c3      	ldr	r3, [r0, #12]
  10:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  14:	60c3      	str	r3, [r0, #12]
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	e004      	b.n	22 <USB_SetCurrentMode+0x22>
  18:	b919      	cbnz	r1, 22 <USB_SetCurrentMode+0x22>
  1a:	68c3      	ldr	r3, [r0, #12]
  1c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	60c3      	str	r3, [r0, #12]
  22:	2032      	movs	r0, #50	; 0x32
  24:	f7ff fffe 	bl	0 <HAL_Delay>
  28:	2000      	movs	r0, #0
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	bd08      	pop	{r3, pc}

Disassembly of section .text.USB_DevInit:

00000000 <USB_DevInit>:
   0:	b084      	sub	sp, #16
   2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	4604      	mov	r4, r0
   8:	a807      	add	r0, sp, #28
   a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  10:	9e11      	ldr	r6, [sp, #68]	; 0x44
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	4688      	mov	r8, r1
  1a:	63a3      	str	r3, [r4, #56]	; 0x38
  1c:	b91e      	cbnz	r6, 26 <USB_DevInit+0x26>

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  20:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  24:	63a3      	str	r3, [r4, #56]	; 0x38
  26:	2300      	movs	r3, #0
  28:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2c:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
  30:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
    if(cfg.use_external_vbus == 1U)
  34:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	2b01      	cmp	r3, #1
  38:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  3c:	d106      	bne.n	4c <USB_DevInit+0x4c>
  3e:	9909      	ldr	r1, [sp, #36]	; 0x24
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	b129      	cbz	r1, 4e <USB_DevInit+0x4e>
  42:	4619      	mov	r1, r3
  44:	4620      	mov	r0, r4
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	f7ff fffe 	bl	0 <USB_DevInit>
  4a:	e003      	b.n	54 <USB_DevInit+0x54>
  4c:	2103      	movs	r1, #3
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	4620      	mov	r0, r4
  50:	f7ff fffe 	bl	0 <USB_DevInit>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  54:	2110      	movs	r1, #16
  56:	4620      	mov	r0, r4
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	f7ff fffe 	bl	0 <USB_DevInit>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	4620      	mov	r0, r4
  5e:	f7ff fffe 	bl	0 <USB_DevInit>
  62:	2300      	movs	r3, #0
  64:	f04f 32ff 	mov.w	r2, #4294967295
  }  

  return HAL_OK;
}
  68:	612b      	str	r3, [r5, #16]
  6a:	4619      	mov	r1, r3
  6c:	616b      	str	r3, [r5, #20]
  6e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  72:	61aa      	str	r2, [r5, #24]
  74:	f04f 0eff 	mov.w	lr, #255	; 0xff
  return HAL_OK;
}
  78:	61eb      	str	r3, [r5, #28]
  7a:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7e:	4543      	cmp	r3, r8
  80:	d00c      	beq.n	9c <USB_DevInit+0x9c>
  82:	f8d2 c000 	ldr.w	ip, [r2]
  return HAL_OK;
}
  86:	f1bc 0f00 	cmp.w	ip, #0
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	bfb4      	ite	lt
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	6010      	strlt	r0, [r2, #0]
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8e:	6011      	strge	r1, [r2, #0]
  90:	3301      	adds	r3, #1
  92:	6111      	str	r1, [r2, #16]
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	f8c2 e008 	str.w	lr, [r2, #8]
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  98:	3220      	adds	r2, #32
  9a:	e7f0      	b.n	7e <USB_DevInit+0x7e>
  9c:	2200      	movs	r2, #0
  9e:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	4611      	mov	r1, r2
  a4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  a8:	f04f 0eff 	mov.w	lr, #255	; 0xff
  }
  HAL_Delay(50U);
  ac:	4542      	cmp	r2, r8
  ae:	d00c      	beq.n	ca <USB_DevInit+0xca>
  
  return HAL_OK;
}
  b0:	f8d3 c000 	ldr.w	ip, [r3]
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	f1bc 0f00 	cmp.w	ip, #0
  b8:	bfb4      	ite	lt
  ba:	6018      	strlt	r0, [r3, #0]
  bc:	6019      	strge	r1, [r3, #0]
  be:	3201      	adds	r2, #1
  c0:	6119      	str	r1, [r3, #16]
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	f8c3 e008 	str.w	lr, [r3, #8]
  c6:	3320      	adds	r3, #32
  c8:	e7f0      	b.n	ac <USB_DevInit+0xac>
  ca:	692b      	ldr	r3, [r5, #16]
  cc:	2f01      	cmp	r7, #1
  ce:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  
  if (cfg.vbus_sensing_enable == 0U)
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	612b      	str	r3, [r5, #16]
  d4:	d108      	bne.n	e8 <USB_DevInit+0xe8>
  d6:	4b15      	ldr	r3, [pc, #84]	; (12c <USB_DevInit+0x12c>)
  d8:	632b      	str	r3, [r5, #48]	; 0x30
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  da:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  dc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e0:	f043 0303 	orr.w	r3, r3, #3
  e4:	632b      	str	r3, [r5, #48]	; 0x30
  e6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  e8:	2300      	movs	r3, #0
  ea:	61a3      	str	r3, [r4, #24]

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  ec:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  f0:	6163      	str	r3, [r4, #20]
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
  f2:	b91f      	cbnz	r7, fc <USB_DevInit+0xfc>
  f4:	69a3      	ldr	r3, [r4, #24]
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
  f6:	f043 0310 	orr.w	r3, r3, #16
  fa:	61a3      	str	r3, [r4, #24]
  fc:	69a2      	ldr	r2, [r4, #24]
  fe:	4b0c      	ldr	r3, [pc, #48]	; (130 <USB_DevInit+0x130>)
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 100:	4313      	orrs	r3, r2
 102:	61a3      	str	r3, [r4, #24]
 104:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 106:	b11b      	cbz	r3, 110 <USB_DevInit+0x110>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 108:	69a3      	ldr	r3, [r4, #24]
 10a:	f043 0308 	orr.w	r3, r3, #8
 10e:	61a3      	str	r3, [r4, #24]
  USB_FlushRxFifo(USBx);
 110:	2e01      	cmp	r6, #1
 112:	bf01      	itttt	eq
 114:	69a3      	ldreq	r3, [r4, #24]
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 116:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 11a:	f043 0304 	orreq.w	r3, r3, #4
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 11e:	61a3      	streq	r3, [r4, #24]
  USBx_DEVICE->DOEPMSK = 0U;
 120:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 124:	2000      	movs	r0, #0
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 126:	b004      	add	sp, #16
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 128:	4770      	bx	lr
 12a:	bf00      	nop
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 12c:	00800100 	.word	0x00800100
 130:	803c3800 	.word	0x803c3800

Disassembly of section .text.USB_FlushTxFifo:

00000000 <USB_FlushTxFifo>:
   0:	0189      	lsls	r1, r1, #6
   2:	f041 0120 	orr.w	r1, r1, #32
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	4a06      	ldr	r2, [pc, #24]	; (20 <USB_FlushTxFifo+0x20>)
   8:	6101      	str	r1, [r0, #16]
   a:	3a01      	subs	r2, #1
   c:	d005      	beq.n	1a <USB_FlushTxFifo+0x1a>
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	6903      	ldr	r3, [r0, #16]
  10:	f013 0320 	ands.w	r3, r3, #32
  14:	d1f9      	bne.n	a <USB_FlushTxFifo+0xa>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	4618      	mov	r0, r3
  18:	4770      	bx	lr
  1a:	2003      	movs	r0, #3
  1c:	4770      	bx	lr

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	bf00      	nop
  20:	00030d41 	.word	0x00030d41

Disassembly of section .text.USB_FlushRxFifo:

00000000 <USB_FlushRxFifo>:
   0:	2310      	movs	r3, #16
   2:	4a06      	ldr	r2, [pc, #24]	; (1c <USB_FlushRxFifo+0x1c>)
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	6103      	str	r3, [r0, #16]
   6:	3a01      	subs	r2, #1
   8:	d005      	beq.n	16 <USB_FlushRxFifo+0x16>
   a:	6903      	ldr	r3, [r0, #16]
   c:	f013 0310 	ands.w	r3, r3, #16
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	d1f9      	bne.n	6 <USB_FlushRxFifo+0x6>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	4618      	mov	r0, r3
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	4770      	bx	lr
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	2003      	movs	r0, #3
  18:	4770      	bx	lr
  1a:	bf00      	nop
  1c:	00030d41 	.word	0x00030d41

Disassembly of section .text.USB_SetDevSpeed:

00000000 <USB_SetDevSpeed>:
   0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	4319      	orrs	r1, r3
   6:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
   a:	2000      	movs	r0, #0
   c:	4770      	bx	lr

Disassembly of section .text.USB_GetDevSpeed:

00000000 <USB_GetDevSpeed>:
   0:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
   4:	f500 6200 	add.w	r2, r0, #2048	; 0x800
   8:	f013 0006 	ands.w	r0, r3, #6
   c:	d012      	beq.n	34 <USB_GetDevSpeed+0x34>
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	6893      	ldr	r3, [r2, #8]
  10:	f003 0306 	and.w	r3, r3, #6
  14:	2b02      	cmp	r3, #2
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	d00c      	beq.n	32 <USB_GetDevSpeed+0x32>
  18:	6893      	ldr	r3, [r2, #8]
  1a:	f003 0306 	and.w	r3, r3, #6

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	2b06      	cmp	r3, #6
  20:	d007      	beq.n	32 <USB_GetDevSpeed+0x32>
  22:	6893      	ldr	r3, [r2, #8]
  24:	f003 0306 	and.w	r3, r3, #6
  28:	2b04      	cmp	r3, #4
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	bf14      	ite	ne
  2c:	2000      	movne	r0, #0
  2e:	2002      	moveq	r0, #2
  30:	4770      	bx	lr
    if(cfg.use_external_vbus == 1U)
  32:	2003      	movs	r0, #3
  34:	4770      	bx	lr

Disassembly of section .text.USB_ActivateEndpoint:

00000000 <USB_ActivateEndpoint>:
   0:	b570      	push	{r4, r5, r6, lr}
   2:	784b      	ldrb	r3, [r1, #1]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	780e      	ldrb	r6, [r1, #0]
   6:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
   a:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	2b01      	cmp	r3, #1
  10:	d11b      	bne.n	4a <USB_ActivateEndpoint+0x4a>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	40b3      	lsls	r3, r6
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	b29b      	uxth	r3, r3
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	4323      	orrs	r3, r4
  18:	61d3      	str	r3, [r2, #28]
  1a:	780e      	ldrb	r6, [r1, #0]
  1c:	f44f 6510 	mov.w	r5, #2304	; 0x900

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	eb05 1546 	add.w	r5, r5, r6, lsl #5
  24:	582b      	ldr	r3, [r5, r0]
  26:	041a      	lsls	r2, r3, #16
  28:	d42a      	bmi.n	80 <USB_ActivateEndpoint+0x80>
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	582c      	ldr	r4, [r5, r0]
  2c:	688a      	ldr	r2, [r1, #8]
  2e:	f044 5380 	orr.w	r3, r4, #268435456	; 0x10000000
    if(cfg.use_external_vbus == 1U)
  32:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	f3c2 020a 	ubfx	r2, r2, #0, #11
  3a:	431a      	orrs	r2, r3
  3c:	78cb      	ldrb	r3, [r1, #3]
  3e:	ea42 4383 	orr.w	r3, r2, r3, lsl #18
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  42:	ea43 5386 	orr.w	r3, r3, r6, lsl #22
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	502b      	str	r3, [r5, r0]
  48:	e01a      	b.n	80 <USB_ActivateEndpoint+0x80>
  4a:	f44f 3580 	mov.w	r5, #65536	; 0x10000
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	fa05 f306 	lsl.w	r3, r5, r6
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	4323      	orrs	r3, r4
  54:	61d3      	str	r3, [r2, #28]
  56:	780c      	ldrb	r4, [r1, #0]
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	f44f 6330 	mov.w	r3, #2816	; 0xb00
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	eb03 1444 	add.w	r4, r3, r4, lsl #5
  60:	5823      	ldr	r3, [r4, r0]
  62:	041b      	lsls	r3, r3, #16
  64:	d40c      	bmi.n	80 <USB_ActivateEndpoint+0x80>
  }  

  return HAL_OK;
}
  66:	5822      	ldr	r2, [r4, r0]
  68:	688b      	ldr	r3, [r1, #8]
  6a:	f3c3 050a 	ubfx	r5, r3, #0, #11
  6e:	f042 5380 	orr.w	r3, r2, #268435456	; 0x10000000
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  72:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  76:	78ca      	ldrb	r2, [r1, #3]
  return HAL_OK;
}
  78:	432b      	orrs	r3, r5
  7a:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7e:	5023      	str	r3, [r4, r0]
  80:	2000      	movs	r0, #0
  82:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.USB_ActivateDedicatedEndpoint:

00000000 <USB_ActivateDedicatedEndpoint>:
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	784b      	ldrb	r3, [r1, #1]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	780f      	ldrb	r7, [r1, #0]
   6:	2b01      	cmp	r3, #1
   8:	f04f 0620 	mov.w	r6, #32
   c:	f500 6500 	add.w	r5, r0, #2048	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	d12e      	bne.n	70 <USB_ActivateDedicatedEndpoint+0x70>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	f44f 6310 	mov.w	r3, #2304	; 0x900
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	fb16 3607 	smlabb	r6, r6, r7, r3
  1a:	5983      	ldr	r3, [r0, r6]
  1c:	041a      	lsls	r2, r3, #16

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	d40e      	bmi.n	3e <USB_ActivateDedicatedEndpoint+0x3e>
  20:	688b      	ldr	r3, [r1, #8]
  22:	5984      	ldr	r4, [r0, r6]
  24:	f3c3 020a 	ubfx	r2, r3, #0, #11
  28:	f044 5380 	orr.w	r3, r4, #268435456	; 0x10000000
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  30:	431a      	orrs	r2, r3
    if(cfg.use_external_vbus == 1U)
  32:	78cb      	ldrb	r3, [r1, #3]
  34:	ea42 4383 	orr.w	r3, r2, r3, lsl #18
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  38:	ea43 5387 	orr.w	r3, r3, r7, lsl #22
  3c:	5183      	str	r3, [r0, r6]
  3e:	4e27      	ldr	r6, [pc, #156]	; (dc <USB_ActivateDedicatedEndpoint+0xdc>)
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	6888      	ldr	r0, [r1, #8]
  42:	6832      	ldr	r2, [r6, #0]
  44:	780c      	ldrb	r4, [r1, #0]
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	f042 5380 	orr.w	r3, r2, #268435456	; 0x10000000
  4a:	f3c0 000a 	ubfx	r0, r0, #0, #11
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	78ca      	ldrb	r2, [r1, #3]
  50:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  54:	4303      	orrs	r3, r0
  56:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
  }
 
  if(cfg.dma_enable == ENABLE)
  5a:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5e:	6033      	str	r3, [r6, #0]
  60:	2201      	movs	r2, #1
  62:	6be9      	ldr	r1, [r5, #60]	; 0x3c
  64:	fa02 f304 	lsl.w	r3, r2, r4
  }  

  return HAL_OK;
}
  68:	b29b      	uxth	r3, r3
  6a:	430b      	orrs	r3, r1
  6c:	63eb      	str	r3, [r5, #60]	; 0x3c
  6e:	e033      	b.n	d8 <USB_ActivateDedicatedEndpoint+0xd8>
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	f44f 6e30 	mov.w	lr, #2816	; 0xb00
  74:	fb16 ec07 	smlabb	ip, r6, r7, lr
  return HAL_OK;
}
  78:	f850 300c 	ldr.w	r3, [r0, ip]
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7c:	041b      	lsls	r3, r3, #16
  7e:	d424      	bmi.n	ca <USB_ActivateDedicatedEndpoint+0xca>
  80:	f850 400c 	ldr.w	r4, [r0, ip]
  return HAL_OK;
}
  84:	688a      	ldr	r2, [r1, #8]
  86:	f3c2 030a 	ubfx	r3, r2, #0, #11
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	f444 4200 	orr.w	r2, r4, #32768	; 0x8000
  8e:	431a      	orrs	r2, r3
  90:	78cb      	ldrb	r3, [r1, #3]
  92:	4c12      	ldr	r4, [pc, #72]	; (dc <USB_ActivateDedicatedEndpoint+0xdc>)
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	ea42 4283 	orr.w	r2, r2, r3, lsl #18
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  98:	ea42 5387 	orr.w	r3, r2, r7, lsl #22
  9c:	f840 300c 	str.w	r3, [r0, ip]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  a0:	780f      	ldrb	r7, [r1, #0]
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	fb16 e607 	smlabb	r6, r6, r7, lr
  a6:	eb00 030e 	add.w	r3, r0, lr
  }
  HAL_Delay(50U);
  aa:	4430      	add	r0, r6
  ac:	6023      	str	r3, [r4, #0]
  ae:	6020      	str	r0, [r4, #0]
  
  return HAL_OK;
}
  b0:	6822      	ldr	r2, [r4, #0]
  b2:	6888      	ldr	r0, [r1, #8]
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	78cb      	ldrb	r3, [r1, #3]
  b6:	f3c0 000a 	ubfx	r0, r0, #0, #11
  ba:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  be:	4302      	orrs	r2, r0
  c0:	ea42 4383 	orr.w	r3, r2, r3, lsl #18
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c4:	ea43 5387 	orr.w	r3, r3, r7, lsl #22
  c8:	6023      	str	r3, [r4, #0]
  ca:	7809      	ldrb	r1, [r1, #0]
  cc:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  ce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  
  if (cfg.vbus_sensing_enable == 0U)
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	408b      	lsls	r3, r1
  d4:	4313      	orrs	r3, r2
  d6:	63eb      	str	r3, [r5, #60]	; 0x3c
  d8:	2000      	movs	r0, #0
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  da:	bdf0      	pop	{r4, r5, r6, r7, pc}
  dc:	00000000 	.word	0x00000000

Disassembly of section .text.USB_DeactivateEndpoint:

00000000 <USB_DeactivateEndpoint>:
   0:	b530      	push	{r4, r5, lr}
   2:	784c      	ldrb	r4, [r1, #1]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	780a      	ldrb	r2, [r1, #0]
   6:	f8d0 583c 	ldr.w	r5, [r0, #2108]	; 0x83c
   a:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	2c01      	cmp	r4, #1
  10:	d116      	bne.n	40 <USB_DeactivateEndpoint+0x40>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	fa04 f202 	lsl.w	r2, r4, r2
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	b292      	uxth	r2, r2
  18:	ea25 0202 	bic.w	r2, r5, r2
  1c:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	780d      	ldrb	r5, [r1, #0]
  20:	69da      	ldr	r2, [r3, #28]
  22:	40ac      	lsls	r4, r5
  24:	b2a4      	uxth	r4, r4
  26:	ea22 0404 	bic.w	r4, r2, r4
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	61dc      	str	r4, [r3, #28]
  2c:	780a      	ldrb	r2, [r1, #0]
  2e:	f44f 6310 	mov.w	r3, #2304	; 0x900
    if(cfg.use_external_vbus == 1U)
  32:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	581a      	ldr	r2, [r3, r0]
  38:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  3c:	501a      	str	r2, [r3, r0]
  3e:	e014      	b.n	6a <USB_DeactivateEndpoint+0x6a>
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	2401      	movs	r4, #1
  42:	fa04 f202 	lsl.w	r2, r4, r2
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	ea25 4202 	bic.w	r2, r5, r2, lsl #16
  4a:	63da      	str	r2, [r3, #60]	; 0x3c
  4c:	780d      	ldrb	r5, [r1, #0]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	69da      	ldr	r2, [r3, #28]
  50:	40ac      	lsls	r4, r5
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	ea22 4404 	bic.w	r4, r2, r4, lsl #16
  56:	61dc      	str	r4, [r3, #28]
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	780a      	ldrb	r2, [r1, #0]
  5a:	f44f 6330 	mov.w	r3, #2816	; 0xb00
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  62:	581a      	ldr	r2, [r3, r0]
  64:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  }  

  return HAL_OK;
}
  68:	501a      	str	r2, [r3, r0]
  6a:	2000      	movs	r0, #0
  6c:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.USB_DeactivateDedicatedEndpoint:

00000000 <USB_DeactivateDedicatedEndpoint>:
   0:	b570      	push	{r4, r5, r6, lr}
   2:	784c      	ldrb	r4, [r1, #1]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	780e      	ldrb	r6, [r1, #0]
   6:	2c01      	cmp	r4, #1
   8:	f04f 0220 	mov.w	r2, #32
   c:	f500 6500 	add.w	r5, r0, #2048	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	d10f      	bne.n	32 <USB_DeactivateDedicatedEndpoint+0x32>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	f44f 6310 	mov.w	r3, #2304	; 0x900
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	fb12 3306 	smlabb	r3, r2, r6, r3
  1a:	581a      	ldr	r2, [r3, r0]
  1c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	501a      	str	r2, [r3, r0]
  22:	780a      	ldrb	r2, [r1, #0]
  24:	69eb      	ldr	r3, [r5, #28]
  26:	4094      	lsls	r4, r2
  28:	b2a4      	uxth	r4, r4
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	ea23 0404 	bic.w	r4, r3, r4
  2e:	61ec      	str	r4, [r5, #28]
  30:	e00f      	b.n	52 <USB_DeactivateDedicatedEndpoint+0x52>
    if(cfg.use_external_vbus == 1U)
  32:	f44f 6330 	mov.w	r3, #2816	; 0xb00
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	fb12 3306 	smlabb	r3, r2, r6, r3
  3a:	581a      	ldr	r2, [r3, r0]
  3c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	501a      	str	r2, [r3, r0]
  42:	7809      	ldrb	r1, [r1, #0]
  44:	69ea      	ldr	r2, [r5, #28]
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  4a:	408b      	lsls	r3, r1
  4c:	ea22 0303 	bic.w	r3, r2, r3
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  50:	61eb      	str	r3, [r5, #28]
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	2000      	movs	r0, #0
  54:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.USB_EPStartXfer:

00000000 <USB_EPStartXfer>:
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2:	784b      	ldrb	r3, [r1, #1]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	2b01      	cmp	r3, #1
   6:	780b      	ldrb	r3, [r1, #0]
   8:	f040 809e 	bne.w	148 <USB_EPStartXfer+0x148>
   c:	2420      	movs	r4, #32
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f44f 6510 	mov.w	r5, #2304	; 0x900
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	694e      	ldr	r6, [r1, #20]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	fb14 5303 	smlabb	r3, r4, r3, r5
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	4403      	add	r3, r0
  1a:	b9b6      	cbnz	r6, 4a <USB_EPStartXfer+0x4a>
  1c:	691e      	ldr	r6, [r3, #16]

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
  22:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
  26:	611e      	str	r6, [r3, #16]
  28:	780b      	ldrb	r3, [r1, #0]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	fb14 5303 	smlabb	r3, r4, r3, r5
  2e:	4403      	add	r3, r0
  30:	691e      	ldr	r6, [r3, #16]
    if(cfg.use_external_vbus == 1U)
  32:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	611e      	str	r6, [r3, #16]
  38:	780b      	ldrb	r3, [r1, #0]
  3a:	fb14 5403 	smlabb	r4, r4, r3, r5
  3e:	4404      	add	r4, r0
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	6923      	ldr	r3, [r4, #16]
  42:	0cdb      	lsrs	r3, r3, #19
  44:	04db      	lsls	r3, r3, #19
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	6123      	str	r3, [r4, #16]
  48:	e03f      	b.n	ca <USB_EPStartXfer+0xca>
  4a:	691e      	ldr	r6, [r3, #16]
  4c:	0cf6      	lsrs	r6, r6, #19
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	04f6      	lsls	r6, r6, #19
  50:	611e      	str	r6, [r3, #16]
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	780b      	ldrb	r3, [r1, #0]
  54:	fb14 5303 	smlabb	r3, r4, r3, r5
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	4403      	add	r3, r0
  5a:	691e      	ldr	r6, [r3, #16]
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
  60:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
  64:	611e      	str	r6, [r3, #16]
  }  

  return HAL_OK;
}
  66:	780e      	ldrb	r6, [r1, #0]
  68:	f8d1 e008 	ldr.w	lr, [r1, #8]
  6c:	694b      	ldr	r3, [r1, #20]
  6e:	fb14 5606 	smlabb	r6, r4, r6, r5
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  72:	4406      	add	r6, r0
  74:	4473      	add	r3, lr
  76:	3b01      	subs	r3, #1
  return HAL_OK;
}
  78:	fbb3 f3fe 	udiv	r3, r3, lr
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7c:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 230 <USB_EPStartXfer+0x230>
  80:	6937      	ldr	r7, [r6, #16]
  82:	04db      	lsls	r3, r3, #19
  return HAL_OK;
}
  84:	ea03 0e0e 	and.w	lr, r3, lr
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  88:	ea4e 0307 	orr.w	r3, lr, r7
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	6133      	str	r3, [r6, #16]
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8e:	780b      	ldrb	r3, [r1, #0]
  90:	694e      	ldr	r6, [r1, #20]
  92:	fb14 5303 	smlabb	r3, r4, r3, r5
  
  if ( mode == USB_OTG_HOST_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  96:	4403      	add	r3, r0
  98:	f3c6 0612 	ubfx	r6, r6, #0, #19
  9c:	691f      	ldr	r7, [r3, #16]
  9e:	433e      	orrs	r6, r7
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  a0:	611e      	str	r6, [r3, #16]
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	78cb      	ldrb	r3, [r1, #3]
  a4:	2b01      	cmp	r3, #1
  a6:	f040 80bc 	bne.w	222 <USB_EPStartXfer+0x222>
  }
  HAL_Delay(50U);
  aa:	780b      	ldrb	r3, [r1, #0]
  ac:	fb14 5303 	smlabb	r3, r4, r3, r5
  
  return HAL_OK;
}
  b0:	4403      	add	r3, r0
  b2:	691e      	ldr	r6, [r3, #16]
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	f026 46c0 	bic.w	r6, r6, #1610612736	; 0x60000000
  b8:	611e      	str	r6, [r3, #16]
  ba:	780b      	ldrb	r3, [r1, #0]
  bc:	fb14 5403 	smlabb	r4, r4, r3, r5
  c0:	4404      	add	r4, r0
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	6923      	ldr	r3, [r4, #16]
  c4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  c8:	6123      	str	r3, [r4, #16]
  ca:	2a01      	cmp	r2, #1
  cc:	d106      	bne.n	dc <USB_EPStartXfer+0xdc>
  ce:	780b      	ldrb	r3, [r1, #0]
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	690c      	ldr	r4, [r1, #16]
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  d6:	f8c3 4914 	str.w	r4, [r3, #2324]	; 0x914
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  da:	e00c      	b.n	f6 <USB_EPStartXfer+0xf6>
  dc:	78cb      	ldrb	r3, [r1, #3]
  de:	2b01      	cmp	r3, #1

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e0:	d00c      	beq.n	fc <USB_EPStartXfer+0xfc>
  e2:	694b      	ldr	r3, [r1, #20]
  e4:	b13b      	cbz	r3, f6 <USB_EPStartXfer+0xf6>
  e6:	780e      	ldrb	r6, [r1, #0]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  e8:	f8d0 4834 	ldr.w	r4, [r0, #2100]	; 0x834

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  ec:	2301      	movs	r3, #1
  ee:	40b3      	lsls	r3, r6
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  f0:	4323      	orrs	r3, r4
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
  f2:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
  f6:	78cb      	ldrb	r3, [r1, #3]
  f8:	2b01      	cmp	r3, #1
  fa:	d111      	bne.n	120 <USB_EPStartXfer+0x120>
  fc:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 100:	f413 7f80 	tst.w	r3, #256	; 0x100
 104:	780b      	ldrb	r3, [r1, #0]
 106:	f04f 0420 	mov.w	r4, #32
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 10a:	f44f 6510 	mov.w	r5, #2304	; 0x900
 10e:	fb14 5303 	smlabb	r3, r4, r3, r5
  USB_FlushRxFifo(USBx);
 112:	581c      	ldr	r4, [r3, r0]
 114:	bf0c      	ite	eq
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 116:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 11a:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 11e:	501c      	str	r4, [r3, r0]
  USBx_DEVICE->DOEPMSK = 0U;
 120:	780c      	ldrb	r4, [r1, #0]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 122:	f44f 6310 	mov.w	r3, #2304	; 0x900
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 126:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 12a:	58c4      	ldr	r4, [r0, r3]
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 12c:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 130:	50c4      	str	r4, [r0, r3]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 132:	78cb      	ldrb	r3, [r1, #3]
 134:	2b01      	cmp	r3, #1
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 136:	d178      	bne.n	22a <USB_EPStartXfer+0x22a>
 138:	780c      	ldrb	r4, [r1, #0]
 13a:	8a8b      	ldrh	r3, [r1, #20]
 13c:	9200      	str	r2, [sp, #0]
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 13e:	68c9      	ldr	r1, [r1, #12]
 140:	4622      	mov	r2, r4
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 142:	f7ff fffe 	bl	0 <USB_EPStartXfer>
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 146:	e070      	b.n	22a <USB_EPStartXfer+0x22a>
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 148:	2420      	movs	r4, #32
 14a:	f44f 6630 	mov.w	r6, #2816	; 0xb00
 14e:	fb14 6303 	smlabb	r3, r4, r3, r6
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 152:	4403      	add	r3, r0
 154:	691d      	ldr	r5, [r3, #16]
 156:	0ced      	lsrs	r5, r5, #19
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 158:	04ed      	lsls	r5, r5, #19
 15a:	611d      	str	r5, [r3, #16]
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 15c:	780b      	ldrb	r3, [r1, #0]
 15e:	fb14 6303 	smlabb	r3, r4, r3, r6
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 162:	4403      	add	r3, r0
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 164:	691d      	ldr	r5, [r3, #16]
 166:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 16a:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 16e:	611d      	str	r5, [r3, #16]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 170:	694f      	ldr	r7, [r1, #20]
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 172:	780b      	ldrb	r3, [r1, #0]
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 174:	688d      	ldr	r5, [r1, #8]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 176:	b987      	cbnz	r7, 19a <USB_EPStartXfer+0x19a>
 178:	fb14 6303 	smlabb	r3, r4, r3, r6
 17c:	4403      	add	r3, r0
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 17e:	f3c5 0512 	ubfx	r5, r5, #0, #19
 182:	691f      	ldr	r7, [r3, #16]
 184:	433d      	orrs	r5, r7
 186:	611d      	str	r5, [r3, #16]
  
  if (cfg.dma_enable == 1U)
 188:	780b      	ldrb	r3, [r1, #0]
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 18a:	fb14 6403 	smlabb	r4, r4, r3, r6
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 18e:	4404      	add	r4, r0
 190:	6923      	ldr	r3, [r4, #16]
 192:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 196:	6123      	str	r3, [r4, #16]
 198:	e01c      	b.n	1d4 <USB_EPStartXfer+0x1d4>
    
    i= USBx_DEVICE->DTHRCTL;
 19a:	fb14 6303 	smlabb	r3, r4, r3, r6
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 19e:	4403      	add	r3, r0
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 1a0:	442f      	add	r7, r5
 1a2:	f8df e08c 	ldr.w	lr, [pc, #140]	; 230 <USB_EPStartXfer+0x230>

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 1a6:	3f01      	subs	r7, #1
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 1a8:	fbb7 f5f5 	udiv	r5, r7, r5
 1ac:	691f      	ldr	r7, [r3, #16]
 1ae:	ea4f 4cc5 	mov.w	ip, r5, lsl #19
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 1b2:	ea0c 0e0e 	and.w	lr, ip, lr
 1b6:	ea4e 0707 	orr.w	r7, lr, r7
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 1ba:	611f      	str	r7, [r3, #16]
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 1bc:	780b      	ldrb	r3, [r1, #0]
 1be:	fb14 6403 	smlabb	r4, r4, r3, r6
 1c2:	4404      	add	r4, r0
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 1c4:	688b      	ldr	r3, [r1, #8]
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 1c6:	6926      	ldr	r6, [r4, #16]
 1c8:	b2ad      	uxth	r5, r5
 1ca:	436b      	muls	r3, r5
 1cc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 1d0:	4333      	orrs	r3, r6
 1d2:	6123      	str	r3, [r4, #16]
  }
  
  return HAL_OK;
}
 1d4:	2a01      	cmp	r2, #1
 1d6:	bf01      	itttt	eq
 1d8:	780b      	ldrbeq	r3, [r1, #0]
 1da:	68ca      	ldreq	r2, [r1, #12]
 1dc:	eb00 1343 	addeq.w	r3, r0, r3, lsl #5
 1e0:	f8c3 2b14 	streq.w	r2, [r3, #2836]	; 0xb14
 1e4:	78cb      	ldrb	r3, [r1, #3]
 1e6:	2b01      	cmp	r3, #1
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0U;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 1e8:	d111      	bne.n	20e <USB_EPStartXfer+0x20e>
 1ea:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 1ee:	f413 7f80 	tst.w	r3, #256	; 0x100
 
  do
  {
    if (++count > 200000U)
 1f2:	780b      	ldrb	r3, [r1, #0]
 1f4:	f04f 0220 	mov.w	r2, #32
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 1f8:	f44f 6430 	mov.w	r4, #2816	; 0xb00
 1fc:	fb12 4303 	smlabb	r3, r2, r3, r4
  
  return HAL_OK;
 200:	58c2      	ldr	r2, [r0, r3]
 
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 202:	bf0c      	ite	eq
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
  
  return HAL_OK;
}
 204:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
 208:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 20c:	50c2      	str	r2, [r0, r3]
 20e:	780a      	ldrb	r2, [r1, #0]
 210:	f44f 6330 	mov.w	r3, #2816	; 0xb00
  
  do
  {
    if (++count > 200000U)
 214:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 218:	58c2      	ldr	r2, [r0, r3]
 21a:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
  
  return HAL_OK;
 21e:	50c2      	str	r2, [r0, r3]
 220:	e003      	b.n	22a <USB_EPStartXfer+0x22a>
  
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 222:	2a01      	cmp	r2, #1
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
  
  return HAL_OK;
}
 224:	f47f af5d 	bne.w	e2 <USB_EPStartXfer+0xe2>
 228:	e751      	b.n	ce <USB_EPStartXfer+0xce>
 22a:	2000      	movs	r0, #0
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 22c:	b003      	add	sp, #12
 22e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 230:	1ff80000 	.word	0x1ff80000

Disassembly of section .text.USB_EP0StartXfer:

00000000 <USB_EP0StartXfer>:
   0:	784b      	ldrb	r3, [r1, #1]
   2:	2b01      	cmp	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	b570      	push	{r4, r5, r6, lr}
   6:	780b      	ldrb	r3, [r1, #0]
   8:	d163      	bne.n	d2 <USB_EP0StartXfer+0xd2>
   a:	2420      	movs	r4, #32
   c:	f44f 6510 	mov.w	r5, #2304	; 0x900
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	694e      	ldr	r6, [r1, #20]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	fb14 5303 	smlabb	r3, r4, r3, r5
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	4403      	add	r3, r0
  18:	b9b6      	cbnz	r6, 48 <USB_EP0StartXfer+0x48>
  1a:	691e      	ldr	r6, [r3, #16]
  1c:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
  24:	611e      	str	r6, [r3, #16]
  26:	780b      	ldrb	r3, [r1, #0]
  28:	fb14 5303 	smlabb	r3, r4, r3, r5
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2c:	4403      	add	r3, r0
  2e:	691e      	ldr	r6, [r3, #16]
  30:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
    if(cfg.use_external_vbus == 1U)
  34:	611e      	str	r6, [r3, #16]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	780b      	ldrb	r3, [r1, #0]
  38:	fb14 5403 	smlabb	r4, r4, r3, r5
  3c:	4404      	add	r4, r0
  3e:	6923      	ldr	r3, [r4, #16]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	0cdb      	lsrs	r3, r3, #19
  42:	04db      	lsls	r3, r3, #19
  44:	6123      	str	r3, [r4, #16]
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	e027      	b.n	98 <USB_EP0StartXfer+0x98>
  48:	691e      	ldr	r6, [r3, #16]
  4a:	0cf6      	lsrs	r6, r6, #19
  4c:	04f6      	lsls	r6, r6, #19
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	611e      	str	r6, [r3, #16]
  50:	780b      	ldrb	r3, [r1, #0]
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	fb14 5403 	smlabb	r4, r4, r3, r5
  56:	4404      	add	r4, r0
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	6923      	ldr	r3, [r4, #16]
  5a:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5e:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
  62:	6123      	str	r3, [r4, #16]
  64:	688b      	ldr	r3, [r1, #8]
  }  

  return HAL_OK;
}
  66:	694c      	ldr	r4, [r1, #20]
  68:	780d      	ldrb	r5, [r1, #0]
  6a:	429c      	cmp	r4, r3
  6c:	bf88      	it	hi
  6e:	614b      	strhi	r3, [r1, #20]
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	2420      	movs	r4, #32
  72:	f44f 6310 	mov.w	r3, #2304	; 0x900
  76:	fb14 3505 	smlabb	r5, r4, r5, r3
  return HAL_OK;
}
  7a:	4405      	add	r5, r0
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7c:	692e      	ldr	r6, [r5, #16]
  7e:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  82:	612e      	str	r6, [r5, #16]
  return HAL_OK;
}
  84:	780d      	ldrb	r5, [r1, #0]
  86:	fb14 3305 	smlabb	r3, r4, r5, r3
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	4403      	add	r3, r0
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	694c      	ldr	r4, [r1, #20]
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8e:	691d      	ldr	r5, [r3, #16]
  90:	f3c4 0412 	ubfx	r4, r4, #0, #19
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	432c      	orrs	r4, r5
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  96:	611c      	str	r4, [r3, #16]
  98:	2a01      	cmp	r2, #1
  9a:	780b      	ldrb	r3, [r1, #0]
  9c:	d105      	bne.n	aa <USB_EP0StartXfer+0xaa>
  9e:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	690a      	ldr	r2, [r1, #16]
  a4:	f8c3 2914 	str.w	r2, [r3, #2324]	; 0x914
  a8:	e009      	b.n	be <USB_EP0StartXfer+0xbe>
  }
  HAL_Delay(50U);
  aa:	694a      	ldr	r2, [r1, #20]
  ac:	b13a      	cbz	r2, be <USB_EP0StartXfer+0xbe>
  ae:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
  
  return HAL_OK;
}
  b2:	2401      	movs	r4, #1
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	fa04 f303 	lsl.w	r3, r4, r3
  b8:	4313      	orrs	r3, r2
  ba:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
  be:	780a      	ldrb	r2, [r1, #0]
  c0:	f44f 6310 	mov.w	r3, #2304	; 0x900
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  c8:	58c2      	ldr	r2, [r0, r3]
  ca:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
  ce:	50c2      	str	r2, [r0, r3]
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	e03e      	b.n	150 <USB_EP0StartXfer+0x150>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	2420      	movs	r4, #32
  d4:	f44f 6630 	mov.w	r6, #2816	; 0xb00
  d8:	fb14 6303 	smlabb	r3, r4, r3, r6
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  dc:	4403      	add	r3, r0
  de:	691d      	ldr	r5, [r3, #16]

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e0:	0ced      	lsrs	r5, r5, #19
  e2:	04ed      	lsls	r5, r5, #19
  e4:	611d      	str	r5, [r3, #16]
  e6:	780b      	ldrb	r3, [r1, #0]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  e8:	fb14 6303 	smlabb	r3, r4, r3, r6

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  ec:	4403      	add	r3, r0
  ee:	691d      	ldr	r5, [r3, #16]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  f0:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
  f4:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
  f8:	611d      	str	r5, [r3, #16]
  fa:	694b      	ldr	r3, [r1, #20]
  fc:	b10b      	cbz	r3, 102 <USB_EP0StartXfer+0x102>
  fe:	688b      	ldr	r3, [r1, #8]
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 100:	614b      	str	r3, [r1, #20]
 102:	780b      	ldrb	r3, [r1, #0]
 104:	f44f 6530 	mov.w	r5, #2816	; 0xb00
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 108:	fb14 5303 	smlabb	r3, r4, r3, r5
 10c:	4403      	add	r3, r0
 10e:	2a01      	cmp	r2, #1
  USB_FlushRxFifo(USBx);
 110:	691e      	ldr	r6, [r3, #16]
 112:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 116:	611e      	str	r6, [r3, #16]
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 118:	780b      	ldrb	r3, [r1, #0]
 11a:	fb14 5403 	smlabb	r4, r4, r3, r5
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 11e:	4404      	add	r4, r0
  USBx_DEVICE->DOEPMSK = 0U;
 120:	688b      	ldr	r3, [r1, #8]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 122:	6926      	ldr	r6, [r4, #16]
 124:	f3c3 0312 	ubfx	r3, r3, #0, #19
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 128:	ea43 0306 	orr.w	r3, r3, r6
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 12c:	6123      	str	r3, [r4, #16]
 12e:	d106      	bne.n	13e <USB_EP0StartXfer+0x13e>
 130:	780b      	ldrb	r3, [r1, #0]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 132:	2220      	movs	r2, #32
 134:	fb12 5303 	smlabb	r3, r2, r3, r5
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 138:	4403      	add	r3, r0
 13a:	68ca      	ldr	r2, [r1, #12]
 13c:	615a      	str	r2, [r3, #20]
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 13e:	780a      	ldrb	r2, [r1, #0]
 140:	f44f 6330 	mov.w	r3, #2816	; 0xb00
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 144:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 148:	58c2      	ldr	r2, [r0, r3]
 14a:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 14e:	50c2      	str	r2, [r0, r3]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 150:	2000      	movs	r0, #0
 152:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.USB_WritePacket:

00000000 <USB_WritePacket>:
   0:	b510      	push	{r4, lr}
   2:	f89d 4008 	ldrb.w	r4, [sp, #8]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	b96c      	cbnz	r4, 24 <USB_WritePacket+0x24>
   8:	3303      	adds	r3, #3
   a:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f023 0303 	bic.w	r3, r3, #3
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	eb00 3202 	add.w	r2, r0, r2, lsl #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	440b      	add	r3, r1
  18:	4299      	cmp	r1, r3
  1a:	d003      	beq.n	24 <USB_WritePacket+0x24>
  1c:	f851 0b04 	ldr.w	r0, [r1], #4

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	6010      	str	r0, [r2, #0]
  22:	e7f9      	b.n	18 <USB_WritePacket+0x18>
  24:	2000      	movs	r0, #0
  26:	bd10      	pop	{r4, pc}

Disassembly of section .text.USB_ReadPacket:

00000000 <USB_ReadPacket>:
   0:	3203      	adds	r2, #3
   2:	f022 0203 	bic.w	r2, r2, #3
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	440a      	add	r2, r1
   8:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
   c:	4291      	cmp	r1, r2
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	d003      	beq.n	18 <USB_ReadPacket+0x18>
  10:	6803      	ldr	r3, [r0, #0]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	f841 3b04 	str.w	r3, [r1], #4
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	e7f9      	b.n	c <USB_ReadPacket+0xc>
  18:	4608      	mov	r0, r1
  1a:	4770      	bx	lr

Disassembly of section .text.USB_EPSetStall:

00000000 <USB_EPSetStall>:
   0:	784b      	ldrb	r3, [r1, #1]
   2:	2b01      	cmp	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	b510      	push	{r4, lr}
   6:	f04f 0220 	mov.w	r2, #32
   a:	780c      	ldrb	r4, [r1, #0]
   c:	d114      	bne.n	38 <USB_EPSetStall+0x38>
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f44f 6310 	mov.w	r3, #2304	; 0x900
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	fb12 3304 	smlabb	r3, r2, r4, r3
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	58c2      	ldr	r2, [r0, r3]
  18:	2a00      	cmp	r2, #0
  1a:	bfa2      	ittt	ge
  1c:	58c2      	ldrge	r2, [r0, r3]

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
  22:	50c2      	strge	r2, [r0, r3]
  24:	780a      	ldrb	r2, [r1, #0]
  26:	f44f 6310 	mov.w	r3, #2304	; 0x900
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  2e:	58c2      	ldr	r2, [r0, r3]
  30:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
    if(cfg.use_external_vbus == 1U)
  34:	50c2      	str	r2, [r0, r3]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	e013      	b.n	60 <USB_EPSetStall+0x60>
  38:	f44f 6330 	mov.w	r3, #2816	; 0xb00
  3c:	fb12 3304 	smlabb	r3, r2, r4, r3
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	58c2      	ldr	r2, [r0, r3]
  42:	2a00      	cmp	r2, #0
  44:	bfa2      	ittt	ge
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	58c2      	ldrge	r2, [r0, r3]
  48:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
  4c:	50c2      	strge	r2, [r0, r3]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	780a      	ldrb	r2, [r1, #0]
  50:	f44f 6330 	mov.w	r3, #2816	; 0xb00
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  54:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	58c2      	ldr	r2, [r0, r3]
  5a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5e:	50c2      	str	r2, [r0, r3]
  60:	2000      	movs	r0, #0
  62:	bd10      	pop	{r4, pc}

Disassembly of section .text.USB_EPClearStall:

00000000 <USB_EPClearStall>:
   0:	784b      	ldrb	r3, [r1, #1]
   2:	b530      	push	{r4, r5, lr}
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	2b01      	cmp	r3, #1
   6:	780b      	ldrb	r3, [r1, #0]
   8:	bf0c      	ite	eq
   a:	f44f 6510 	moveq.w	r5, #2304	; 0x900
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f44f 6530 	movne.w	r5, #2816	; 0xb00
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	2220      	movs	r2, #32
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	fb12 5303 	smlabb	r3, r2, r3, r5
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	581c      	ldr	r4, [r3, r0]
  1a:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	501c      	str	r4, [r3, r0]
  20:	78cb      	ldrb	r3, [r1, #3]
  22:	3b02      	subs	r3, #2
  24:	2b01      	cmp	r3, #1
  26:	d806      	bhi.n	36 <USB_EPClearStall+0x36>
  28:	780b      	ldrb	r3, [r1, #0]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	fb12 5203 	smlabb	r2, r2, r3, r5
  2e:	5813      	ldr	r3, [r2, r0]
  30:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    if(cfg.use_external_vbus == 1U)
  34:	5013      	str	r3, [r2, r0]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	2000      	movs	r0, #0
  38:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.USB_StopDevice:

00000000 <USB_StopDevice>:
   0:	b538      	push	{r3, r4, r5, lr}
   2:	f500 612e 	add.w	r1, r0, #2784	; 0xae0
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	4604      	mov	r4, r0
   8:	f500 6310 	add.w	r3, r0, #2304	; 0x900
   c:	22ff      	movs	r2, #255	; 0xff
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	609a      	str	r2, [r3, #8]
  10:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
  14:	3320      	adds	r3, #32
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	428b      	cmp	r3, r1
  18:	d1f9      	bne.n	e <USB_StopDevice+0xe>
  1a:	2500      	movs	r5, #0
  1c:	f04f 32ff 	mov.w	r2, #4294967295

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	f8c4 2818 	str.w	r2, [r4, #2072]	; 0x818
  24:	4620      	mov	r0, r4
  26:	f8c4 5810 	str.w	r5, [r4, #2064]	; 0x810
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	f8c4 5814 	str.w	r5, [r4, #2068]	; 0x814
  2e:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
    if(cfg.use_external_vbus == 1U)
  32:	f7ff fffe 	bl	0 <USB_StopDevice>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	2110      	movs	r1, #16
  38:	4620      	mov	r0, r4
  3a:	f7ff fffe 	bl	0 <USB_StopDevice>
  3e:	4628      	mov	r0, r5
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.USB_SetDevAddress:

00000000 <USB_SetDevAddress>:
   0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
   8:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
   c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	0109      	lsls	r1, r1, #4
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	430b      	orrs	r3, r1
  18:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  1c:	2000      	movs	r0, #0

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	4770      	bx	lr

Disassembly of section .text.USB_DevConnect:

00000000 <USB_DevConnect>:
   0:	b508      	push	{r3, lr}
   2:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	f023 0302 	bic.w	r3, r3, #2
   a:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	2003      	movs	r0, #3
  10:	f7ff fffe 	bl	0 <HAL_Delay>
  14:	2000      	movs	r0, #0
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	bd08      	pop	{r3, pc}

Disassembly of section .text.USB_DevDisconnect:

00000000 <USB_DevDisconnect>:
   0:	b508      	push	{r3, lr}
   2:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	f043 0302 	orr.w	r3, r3, #2
   a:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	2003      	movs	r0, #3
  10:	f7ff fffe 	bl	0 <HAL_Delay>
  14:	2000      	movs	r0, #0
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	bd08      	pop	{r3, pc}

Disassembly of section .text.USB_ReadInterrupts:

00000000 <USB_ReadInterrupts>:
   0:	6942      	ldr	r2, [r0, #20]
   2:	6980      	ldr	r0, [r0, #24]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	4010      	ands	r0, r2
   6:	4770      	bx	lr

Disassembly of section .text.USB_ReadDevAllOutEpInterrupt:

00000000 <USB_ReadDevAllOutEpInterrupt>:
   0:	f500 6300 	add.w	r3, r0, #2048	; 0x800
   4:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
   8:	69db      	ldr	r3, [r3, #28]
   a:	4018      	ands	r0, r3
   c:	0c00      	lsrs	r0, r0, #16
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	4770      	bx	lr

Disassembly of section .text.USB_ReadDevAllInEpInterrupt:

00000000 <USB_ReadDevAllInEpInterrupt>:
   0:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
   8:	69db      	ldr	r3, [r3, #28]
   a:	4018      	ands	r0, r3
   c:	b280      	uxth	r0, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	4770      	bx	lr

Disassembly of section .text.USB_ReadDevOutEPInterrupt:

00000000 <USB_ReadDevOutEPInterrupt>:
   0:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	eb03 1141 	add.w	r1, r3, r1, lsl #5
   8:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   c:	688a      	ldr	r2, [r1, #8]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	6940      	ldr	r0, [r0, #20]
  10:	4010      	ands	r0, r2
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	4770      	bx	lr

Disassembly of section .text.USB_ReadDevInEPInterrupt:

00000000 <USB_ReadDevInEPInterrupt>:
   0:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
   4:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
   8:	eb00 1041 	add.w	r0, r0, r1, lsl #5
   c:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	fa23 f101 	lsr.w	r1, r3, r1
  14:	01c9      	lsls	r1, r1, #7
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	6880      	ldr	r0, [r0, #8]
  18:	b2c9      	uxtb	r1, r1
  1a:	4311      	orrs	r1, r2
  1c:	4008      	ands	r0, r1

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	4770      	bx	lr

Disassembly of section .text.USB_ClearInterrupts:

00000000 <USB_ClearInterrupts>:
   0:	6943      	ldr	r3, [r0, #20]
   2:	4319      	orrs	r1, r3
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	6141      	str	r1, [r0, #20]
   6:	4770      	bx	lr

Disassembly of section .text.USB_GetMode:

00000000 <USB_GetMode>:
   0:	6940      	ldr	r0, [r0, #20]
   2:	f000 0001 	and.w	r0, r0, #1
   6:	4770      	bx	lr

Disassembly of section .text.USB_ActivateSetup:

00000000 <USB_ActivateSetup>:
   0:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
   4:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
   8:	f023 0307 	bic.w	r3, r3, #7
   c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  14:	689a      	ldr	r2, [r3, #8]
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	f002 0206 	and.w	r2, r2, #6
  1a:	2a04      	cmp	r2, #4
  1c:	bf02      	ittt	eq

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
  22:	f042 0203 	orreq.w	r2, r2, #3
  26:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	685a      	ldr	r2, [r3, #4]
  2c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  30:	605a      	str	r2, [r3, #4]
    if(cfg.use_external_vbus == 1U)
  32:	2000      	movs	r0, #0
  34:	4770      	bx	lr

Disassembly of section .text.USB_EP0_OutStart:

00000000 <USB_EP0_OutStart>:
   0:	b510      	push	{r4, lr}
   2:	2400      	movs	r4, #0
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
   8:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
   c:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  10:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  14:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	f044 0418 	orr.w	r4, r4, #24
  1c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  24:	2901      	cmp	r1, #1
  26:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
  2e:	bf08      	it	eq
  30:	f04f 2380 	moveq.w	r3, #2147516416	; 0x80008000
    if(cfg.use_external_vbus == 1U)
  34:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  38:	bf04      	itt	eq
  3a:	f8c0 2b14 	streq.w	r2, [r0, #2836]	; 0xb14
  3e:	f8c0 3b00 	streq.w	r3, [r0, #2816]	; 0xb00
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  42:	2000      	movs	r0, #0
  44:	bd10      	pop	{r4, pc}

Disassembly of section .text.USB_CoreReset:

00000000 <USB_CoreReset>:
   0:	4b0a      	ldr	r3, [pc, #40]	; (2c <USB_CoreReset+0x2c>)
   2:	3b01      	subs	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	d101      	bne.n	a <USB_CoreReset+0xa>
   6:	2003      	movs	r0, #3
   8:	4770      	bx	lr
   a:	6902      	ldr	r2, [r0, #16]
   c:	2a00      	cmp	r2, #0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	daf8      	bge.n	2 <USB_CoreReset+0x2>
  10:	6903      	ldr	r3, [r0, #16]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	4a06      	ldr	r2, [pc, #24]	; (2c <USB_CoreReset+0x2c>)
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	f043 0301 	orr.w	r3, r3, #1
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	6103      	str	r3, [r0, #16]
  1a:	3a01      	subs	r2, #1
  1c:	d0f3      	beq.n	6 <USB_CoreReset+0x6>

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	6903      	ldr	r3, [r0, #16]
  20:	f013 0301 	ands.w	r3, r3, #1
  24:	d1f9      	bne.n	1a <USB_CoreReset+0x1a>
  26:	4618      	mov	r0, r3
  28:	4770      	bx	lr
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	bf00      	nop
  2c:	00030d41 	.word	0x00030d41

Disassembly of section .text.USB_HostInit:

00000000 <USB_HostInit>:
   0:	b084      	sub	sp, #16
   2:	b538      	push	{r3, r4, r5, lr}
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	4604      	mov	r4, r0
   6:	a805      	add	r0, sp, #20
   8:	e880 000e 	stmia.w	r0, {r1, r2, r3}
   c:	2300      	movs	r3, #0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  18:	63a3      	str	r3, [r4, #56]	; 0x38
  1a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  1c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	63a3      	str	r3, [r4, #56]	; 0x38
  22:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  24:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  28:	63a3      	str	r3, [r4, #56]	; 0x38
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	9b07      	ldr	r3, [sp, #28]
  2c:	2b03      	cmp	r3, #3
  2e:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    if(cfg.use_external_vbus == 1U)
  32:	d107      	bne.n	44 <USB_HostInit+0x44>
  34:	f1b4 4fa0 	cmp.w	r4, #1342177280	; 0x50000000
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  38:	d004      	beq.n	44 <USB_HostInit+0x44>
  3a:	f043 0304 	orr.w	r3, r3, #4
  3e:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  42:	e003      	b.n	4c <USB_HostInit+0x4c>
  44:	f023 0304 	bic.w	r3, r3, #4
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  48:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  4c:	2110      	movs	r1, #16
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	4620      	mov	r0, r4
  50:	f7ff fffe 	bl	0 <USB_HostInit>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  54:	4620      	mov	r0, r4
  56:	f7ff fffe 	bl	0 <USB_HostInit>
  }
 
  if(cfg.dma_enable == ENABLE)
  5a:	2300      	movs	r3, #0
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	9906      	ldr	r1, [sp, #24]
  5e:	f504 62a0 	add.w	r2, r4, #1280	; 0x500
  62:	f04f 30ff 	mov.w	r0, #4294967295
  }  

  return HAL_OK;
}
  66:	461d      	mov	r5, r3
  68:	428b      	cmp	r3, r1
  6a:	d004      	beq.n	76 <USB_HostInit+0x76>
  6c:	6090      	str	r0, [r2, #8]
  6e:	3301      	adds	r3, #1
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	60d5      	str	r5, [r2, #12]
  72:	3220      	adds	r2, #32
  74:	e7f8      	b.n	68 <USB_HostInit+0x68>
  76:	2101      	movs	r1, #1
  return HAL_OK;
}
  78:	4620      	mov	r0, r4
  7a:	f7ff fffe 	bl	0 <USB_HostInit>
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7e:	20c8      	movs	r0, #200	; 0xc8
  80:	f7ff fffe 	bl	0 <HAL_Delay>
  return HAL_OK;
}
  84:	2300      	movs	r3, #0
  86:	61a3      	str	r3, [r4, #24]
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  88:	f1b4 4fa0 	cmp.w	r4, #1342177280	; 0x50000000
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	f04f 33ff 	mov.w	r3, #4294967295
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  90:	6163      	str	r3, [r4, #20]
  92:	d108      	bne.n	a6 <USB_HostInit+0xa6>
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	2380      	movs	r3, #128	; 0x80
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  96:	6263      	str	r3, [r4, #36]	; 0x24
  98:	f503 03c0 	add.w	r3, r3, #6291456	; 0x600000
  9c:	62a3      	str	r3, [r4, #40]	; 0x28
  9e:	4b0e      	ldr	r3, [pc, #56]	; (d8 <USB_HostInit+0xd8>)
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  a0:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a4:	e008      	b.n	b8 <USB_HostInit+0xb8>
  a6:	f44f 7300 	mov.w	r3, #512	; 0x200
  }
  HAL_Delay(50U);
  aa:	6263      	str	r3, [r4, #36]	; 0x24
  ac:	f103 7380 	add.w	r3, r3, #16777216	; 0x1000000
  
  return HAL_OK;
}
  b0:	62a3      	str	r3, [r4, #40]	; 0x28
  b2:	4b0a      	ldr	r3, [pc, #40]	; (dc <USB_HostInit+0xdc>)
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  b8:	9b08      	ldr	r3, [sp, #32]
  ba:	b91b      	cbnz	r3, c4 <USB_HostInit+0xc4>
  bc:	69a3      	ldr	r3, [r4, #24]
  be:	f043 0310 	orr.w	r3, r3, #16
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	61a3      	str	r3, [r4, #24]
  c4:	69a2      	ldr	r2, [r4, #24]
  c6:	4b06      	ldr	r3, [pc, #24]	; (e0 <USB_HostInit+0xe0>)
  c8:	4313      	orrs	r3, r2
  ca:	61a3      	str	r3, [r4, #24]
  cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	2000      	movs	r0, #0
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	b004      	add	sp, #16
  d4:	4770      	bx	lr
  d6:	bf00      	nop
  d8:	004000e0 	.word	0x004000e0
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  dc:	00e00300 	.word	0x00e00300

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e0:	a3200008 	.word	0xa3200008

Disassembly of section .text.USB_InitFSLSPClkSel:

00000000 <USB_InitFSLSPClkSel>:
   0:	b510      	push	{r4, lr}
   2:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	f023 0303 	bic.w	r3, r3, #3
   a:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f8d0 3400 	ldr.w	r3, [r0, #1024]	; 0x400
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	f001 0403 	and.w	r4, r1, #3
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	4323      	orrs	r3, r4
  18:	2901      	cmp	r1, #1
  1a:	f500 6280 	add.w	r2, r0, #1024	; 0x400

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  22:	d103      	bne.n	2c <USB_InitFSLSPClkSel+0x2c>
  24:	f64b 3380 	movw	r3, #48000	; 0xbb80
  28:	6053      	str	r3, [r2, #4]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	e004      	b.n	36 <USB_InitFSLSPClkSel+0x36>
  2c:	2902      	cmp	r1, #2
  2e:	bf04      	itt	eq
  30:	f241 7370 	movweq	r3, #6000	; 0x1770
    if(cfg.use_external_vbus == 1U)
  34:	6053      	streq	r3, [r2, #4]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	2000      	movs	r0, #0
  38:	bd10      	pop	{r4, pc}

Disassembly of section .text.USB_ResetPort:

00000000 <USB_ResetPort>:
   0:	b513      	push	{r0, r1, r4, lr}
   2:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	9301      	str	r3, [sp, #4]
   8:	9b01      	ldr	r3, [sp, #4]
   a:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	9301      	str	r3, [sp, #4]
  10:	9b01      	ldr	r3, [sp, #4]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	4604      	mov	r4, r0
  18:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  1c:	200a      	movs	r0, #10

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	f7ff fffe 	bl	0 <HAL_Delay>
  22:	9b01      	ldr	r3, [sp, #4]
  24:	2000      	movs	r0, #0
  26:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  2e:	b002      	add	sp, #8
  30:	bd10      	pop	{r4, pc}

Disassembly of section .text.USB_DriveVbus:

00000000 <USB_DriveVbus>:
   0:	b082      	sub	sp, #8
   2:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	9301      	str	r3, [sp, #4]
   8:	9b01      	ldr	r3, [sp, #4]
   a:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	9301      	str	r3, [sp, #4]
  10:	9b01      	ldr	r3, [sp, #4]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	04da      	lsls	r2, r3, #19
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	d406      	bmi.n	24 <USB_DriveVbus+0x24>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	2901      	cmp	r1, #1
  18:	bf02      	ittt	eq
  1a:	9b01      	ldreq	r3, [sp, #4]
  1c:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	f8c0 3440 	streq.w	r3, [r0, #1088]	; 0x440
  24:	9b01      	ldr	r3, [sp, #4]
  26:	04db      	lsls	r3, r3, #19
  28:	d505      	bpl.n	36 <USB_DriveVbus+0x36>
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	b921      	cbnz	r1, 36 <USB_DriveVbus+0x36>
  2c:	9b01      	ldr	r3, [sp, #4]
  2e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    if(cfg.use_external_vbus == 1U)
  32:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	2000      	movs	r0, #0
  38:	b002      	add	sp, #8
  3a:	4770      	bx	lr

Disassembly of section .text.USB_GetHostSpeed:

00000000 <USB_GetHostSpeed>:
   0:	b082      	sub	sp, #8
   2:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   6:	9301      	str	r3, [sp, #4]
   8:	9801      	ldr	r0, [sp, #4]
   a:	f3c0 4041 	ubfx	r0, r0, #17, #2
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	b002      	add	sp, #8
  10:	4770      	bx	lr

Disassembly of section .text.USB_GetCurrentFrame:

00000000 <USB_GetCurrentFrame>:
   0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	6880      	ldr	r0, [r0, #8]
   6:	b280      	uxth	r0, r0
   8:	4770      	bx	lr

Disassembly of section .text.USB_HC_Init:

00000000 <USB_HC_Init>:
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	f500 64a0 	add.w	r4, r0, #1280	; 0x500
   6:	eb04 1441 	add.w	r4, r4, r1, lsl #5
   a:	f89d 5018 	ldrb.w	r5, [sp, #24]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f04f 36ff 	mov.w	r6, #4294967295
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	60a6      	str	r6, [r4, #8]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	b256      	sxtb	r6, r2
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	2d03      	cmp	r5, #3
  18:	d823      	bhi.n	62 <USB_HC_Init+0x62>
  1a:	e8df f005 	tbb	[pc, r5]

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	1902      	.short	0x1902
  20:	0f02      	.short	0x0f02
  22:	f240 479d 	movw	r7, #1181	; 0x49d
  26:	2e00      	cmp	r6, #0
  28:	60e7      	str	r7, [r4, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	db0c      	blt.n	46 <USB_HC_Init+0x46>
  2c:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  30:	d017      	beq.n	62 <USB_HC_Init+0x62>
    if(cfg.use_external_vbus == 1U)
  32:	68e7      	ldr	r7, [r4, #12]
  34:	f047 0760 	orr.w	r7, r7, #96	; 0x60
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  38:	60e7      	str	r7, [r4, #12]
  3a:	e012      	b.n	62 <USB_HC_Init+0x62>
  3c:	f240 679d 	movw	r7, #1693	; 0x69d
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	2e00      	cmp	r6, #0
  42:	60e7      	str	r7, [r4, #12]
  44:	da0d      	bge.n	62 <USB_HC_Init+0x62>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	68e7      	ldr	r7, [r4, #12]
  48:	f447 7780 	orr.w	r7, r7, #256	; 0x100
  4c:	60e7      	str	r7, [r4, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	e008      	b.n	62 <USB_HC_Init+0x62>
  50:	f240 2725 	movw	r7, #549	; 0x225
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  54:	60e7      	str	r7, [r4, #12]
  56:	2e00      	cmp	r6, #0
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	bfbe      	ittt	lt
  5a:	68e7      	ldrlt	r7, [r4, #12]
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	f447 77c0 	orrlt.w	r7, r7, #384	; 0x180
  60:	60e7      	strlt	r7, [r4, #12]
  62:	f8d0 7418 	ldr.w	r7, [r0, #1048]	; 0x418
  }  

  return HAL_OK;
}
  66:	f04f 0e01 	mov.w	lr, #1
  6a:	fa0e f101 	lsl.w	r1, lr, r1
  6e:	4339      	orrs	r1, r7
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	f8c0 1418 	str.w	r1, [r0, #1048]	; 0x418
  74:	6981      	ldr	r1, [r0, #24]
  76:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
  return HAL_OK;
}
  7a:	6181      	str	r1, [r0, #24]
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7c:	0599      	lsls	r1, r3, #22
  7e:	f89d 3014 	ldrb.w	r3, [sp, #20]
  82:	2e00      	cmp	r6, #0
  return HAL_OK;
}
  84:	bfb4      	ite	lt
  86:	f44f 4600 	movlt.w	r6, #32768	; 0x8000
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	2600      	movge	r6, #0
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	2b02      	cmp	r3, #2
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8e:	ea4f 4385 	mov.w	r3, r5, lsl #18
  92:	f403 2740 	and.w	r7, r3, #786432	; 0xc0000
  
  if ( mode == USB_OTG_HOST_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  96:	ea4f 22c2 	mov.w	r2, r2, lsl #11
  9a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
  9e:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	f001 51fe 	and.w	r1, r1, #532676608	; 0x1fc00000
  a6:	ea41 0102 	orr.w	r1, r1, r2
  }
  HAL_Delay(50U);
  aa:	f3c3 030a 	ubfx	r3, r3, #0, #11
  ae:	ea43 0201 	orr.w	r2, r3, r1
  
  return HAL_OK;
}
  b2:	ea47 0302 	orr.w	r3, r7, r2
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b6:	bf0c      	ite	eq
  b8:	f44f 3000 	moveq.w	r0, #131072	; 0x20000
  bc:	2000      	movne	r0, #0
  be:	4333      	orrs	r3, r6
  c0:	4303      	orrs	r3, r0
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	6023      	str	r3, [r4, #0]
  c4:	2d03      	cmp	r5, #3
  c6:	bf02      	ittt	eq
  c8:	6823      	ldreq	r3, [r4, #0]
  ca:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
  ce:	6023      	streq	r3, [r4, #0]
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	2000      	movs	r0, #0
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

Disassembly of section .text.USB_HC_StartXfer:

00000000 <USB_HC_StartXfer>:
   0:	b580      	push	{r7, lr}
   2:	b08a      	sub	sp, #40	; 0x28
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	af02      	add	r7, sp, #8
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	4613      	mov	r3, r2
   c:	71fb      	strb	r3, [r7, #7]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	2300      	movs	r3, #0
  10:	777b      	strb	r3, [r7, #29]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	2300      	movs	r3, #0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	837b      	strh	r3, [r7, #26]
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	2300      	movs	r3, #0
  18:	83fb      	strh	r3, [r7, #30]
  1a:	f44f 7380 	mov.w	r3, #256	; 0x100

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	833b      	strh	r3, [r7, #24]
  20:	2300      	movs	r3, #0
  22:	617b      	str	r3, [r7, #20]
  24:	68fb      	ldr	r3, [r7, #12]
  26:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	d02b      	beq.n	84 <USB_HC_StartXfer+0x84>
  2c:	68bb      	ldr	r3, [r7, #8]
  2e:	791b      	ldrb	r3, [r3, #4]
  30:	2b00      	cmp	r3, #0
    if(cfg.use_external_vbus == 1U)
  32:	d127      	bne.n	84 <USB_HC_StartXfer+0x84>
  34:	79fb      	ldrb	r3, [r7, #7]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	2b00      	cmp	r3, #0
  38:	d10b      	bne.n	52 <USB_HC_StartXfer+0x52>
  3a:	68bb      	ldr	r3, [r7, #8]
  3c:	795b      	ldrb	r3, [r3, #5]
  3e:	2b01      	cmp	r3, #1
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	d107      	bne.n	52 <USB_HC_StartXfer+0x52>
  42:	68bb      	ldr	r3, [r7, #8]
  44:	785b      	ldrb	r3, [r3, #1]
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	4619      	mov	r1, r3
  48:	68f8      	ldr	r0, [r7, #12]
  4a:	f7ff fffe 	bl	0 <USB_HC_StartXfer>
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	2300      	movs	r3, #0
  50:	e10d      	b.n	26e <USB_HC_StartXfer+0x26e>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	79fb      	ldrb	r3, [r7, #7]
  54:	2b01      	cmp	r3, #1
  56:	d115      	bne.n	84 <USB_HC_StartXfer+0x84>
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	68bb      	ldr	r3, [r7, #8]
  5a:	785b      	ldrb	r3, [r3, #1]
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	015a      	lsls	r2, r3, #5
  5e:	68fb      	ldr	r3, [r7, #12]
  60:	4413      	add	r3, r2
  62:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }  

  return HAL_OK;
}
  66:	4619      	mov	r1, r3
  68:	68bb      	ldr	r3, [r7, #8]
  6a:	785b      	ldrb	r3, [r3, #1]
  6c:	015a      	lsls	r2, r3, #5
  6e:	68fb      	ldr	r3, [r7, #12]
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	4413      	add	r3, r2
  72:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  76:	68db      	ldr	r3, [r3, #12]
  return HAL_OK;
}
  78:	f023 0360 	bic.w	r3, r3, #96	; 0x60
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7c:	60cb      	str	r3, [r1, #12]
  7e:	68bb      	ldr	r3, [r7, #8]
  80:	2200      	movs	r2, #0
  82:	715a      	strb	r2, [r3, #5]
  return HAL_OK;
}
  84:	68bb      	ldr	r3, [r7, #8]
  86:	691b      	ldr	r3, [r3, #16]
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  88:	2b00      	cmp	r3, #0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	d019      	beq.n	c0 <USB_HC_StartXfer+0xc0>
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	68bb      	ldr	r3, [r7, #8]
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8e:	691b      	ldr	r3, [r3, #16]
  90:	68ba      	ldr	r2, [r7, #8]
  92:	8912      	ldrh	r2, [r2, #8]
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	4413      	add	r3, r2
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  96:	3b01      	subs	r3, #1
  98:	68ba      	ldr	r2, [r7, #8]
  9a:	8912      	ldrh	r2, [r2, #8]
  9c:	fbb3 f3f2 	udiv	r3, r3, r2
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  a0:	83fb      	strh	r3, [r7, #30]
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	8bfa      	ldrh	r2, [r7, #30]
  a4:	8b3b      	ldrh	r3, [r7, #24]
  a6:	429a      	cmp	r2, r3
  a8:	d90c      	bls.n	c4 <USB_HC_StartXfer+0xc4>
  }
  HAL_Delay(50U);
  aa:	8b3b      	ldrh	r3, [r7, #24]
  ac:	83fb      	strh	r3, [r7, #30]
  ae:	8bfb      	ldrh	r3, [r7, #30]
  
  return HAL_OK;
}
  b0:	68ba      	ldr	r2, [r7, #8]
  b2:	8912      	ldrh	r2, [r2, #8]
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	fb02 f303 	mul.w	r3, r2, r3
  b8:	461a      	mov	r2, r3
  ba:	68bb      	ldr	r3, [r7, #8]
  bc:	611a      	str	r2, [r3, #16]
  be:	e001      	b.n	c4 <USB_HC_StartXfer+0xc4>
  c0:	2301      	movs	r3, #1
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	83fb      	strh	r3, [r7, #30]
  c4:	68bb      	ldr	r3, [r7, #8]
  c6:	78db      	ldrb	r3, [r3, #3]
  c8:	2b00      	cmp	r3, #0
  ca:	d007      	beq.n	dc <USB_HC_StartXfer+0xdc>
  cc:	8bfb      	ldrh	r3, [r7, #30]
  ce:	68ba      	ldr	r2, [r7, #8]
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	8912      	ldrh	r2, [r2, #8]
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	fb02 f303 	mul.w	r3, r2, r3
  d6:	461a      	mov	r2, r3
  d8:	68bb      	ldr	r3, [r7, #8]
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  da:	611a      	str	r2, [r3, #16]
  dc:	68bb      	ldr	r3, [r7, #8]
  de:	785b      	ldrb	r3, [r3, #1]

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e0:	015a      	lsls	r2, r3, #5
  e2:	68fb      	ldr	r3, [r7, #12]
  e4:	4413      	add	r3, r2
  e6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  ea:	4619      	mov	r1, r3

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  ec:	68bb      	ldr	r3, [r7, #8]
  ee:	691b      	ldr	r3, [r3, #16]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  f0:	f3c3 0212 	ubfx	r2, r3, #0, #19
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
  f4:	8bfb      	ldrh	r3, [r7, #30]
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
  f6:	04db      	lsls	r3, r3, #19
  f8:	4618      	mov	r0, r3
  fa:	4b5f      	ldr	r3, [pc, #380]	; (278 <USB_HC_StartXfer+0x278>)
  fc:	4003      	ands	r3, r0
  fe:	431a      	orrs	r2, r3
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 100:	68bb      	ldr	r3, [r7, #8]
 102:	7a9b      	ldrb	r3, [r3, #10]
 104:	075b      	lsls	r3, r3, #29
 106:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 10a:	4313      	orrs	r3, r2
 10c:	610b      	str	r3, [r1, #16]
 10e:	79fb      	ldrb	r3, [r7, #7]
  USB_FlushRxFifo(USBx);
 110:	2b00      	cmp	r3, #0
 112:	d00a      	beq.n	12a <USB_HC_StartXfer+0x12a>
 114:	68bb      	ldr	r3, [r7, #8]
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 116:	785b      	ldrb	r3, [r3, #1]
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 118:	015a      	lsls	r2, r3, #5
 11a:	68fb      	ldr	r3, [r7, #12]
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 11c:	4413      	add	r3, r2
 11e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 122:	461a      	mov	r2, r3
 124:	68bb      	ldr	r3, [r7, #8]
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 126:	68db      	ldr	r3, [r3, #12]
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 128:	6153      	str	r3, [r2, #20]
 12a:	68fb      	ldr	r3, [r7, #12]
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 12c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 130:	689b      	ldr	r3, [r3, #8]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 132:	f003 0301 	and.w	r3, r3, #1
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 136:	2b00      	cmp	r3, #0
 138:	bf0c      	ite	eq
 13a:	2301      	moveq	r3, #1
 13c:	2300      	movne	r3, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 13e:	b2db      	uxtb	r3, r3
 140:	777b      	strb	r3, [r7, #29]
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 142:	68bb      	ldr	r3, [r7, #8]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 144:	785b      	ldrb	r3, [r3, #1]
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 146:	015a      	lsls	r2, r3, #5
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 148:	68fb      	ldr	r3, [r7, #12]
 14a:	4413      	add	r3, r2
 14c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 150:	4619      	mov	r1, r3
 152:	68bb      	ldr	r3, [r7, #8]
 154:	785b      	ldrb	r3, [r3, #1]
 156:	015a      	lsls	r2, r3, #5
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 158:	68fb      	ldr	r3, [r7, #12]
 15a:	4413      	add	r3, r2
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 15c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 160:	681b      	ldr	r3, [r3, #0]
 162:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 166:	600b      	str	r3, [r1, #0]
 168:	68bb      	ldr	r3, [r7, #8]
 16a:	785b      	ldrb	r3, [r3, #1]
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 16c:	015a      	lsls	r2, r3, #5
 16e:	68fb      	ldr	r3, [r7, #12]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 170:	4413      	add	r3, r2
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 172:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 176:	4619      	mov	r1, r3
 178:	68bb      	ldr	r3, [r7, #8]
 17a:	785b      	ldrb	r3, [r3, #1]
 17c:	015a      	lsls	r2, r3, #5
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 17e:	68fb      	ldr	r3, [r7, #12]
  
  if (cfg.dma_enable == 1U)
 180:	4413      	add	r3, r2
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 182:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 186:	681b      	ldr	r3, [r3, #0]
  
  if (cfg.dma_enable == 1U)
 188:	7f7a      	ldrb	r2, [r7, #29]
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 18a:	0752      	lsls	r2, r2, #29
 18c:	4313      	orrs	r3, r2
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 18e:	600b      	str	r3, [r1, #0]
 190:	68bb      	ldr	r3, [r7, #8]
 192:	785b      	ldrb	r3, [r3, #1]
 194:	015a      	lsls	r2, r3, #5
 196:	68fb      	ldr	r3, [r7, #12]
 198:	4413      	add	r3, r2
    
    i= USBx_DEVICE->DTHRCTL;
 19a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 19e:	681b      	ldr	r3, [r3, #0]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 1a0:	617b      	str	r3, [r7, #20]
 1a2:	697b      	ldr	r3, [r7, #20]
 1a4:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 1a8:	617b      	str	r3, [r7, #20]
 1aa:	697b      	ldr	r3, [r7, #20]
 1ac:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 1b0:	617b      	str	r3, [r7, #20]
 1b2:	68bb      	ldr	r3, [r7, #8]
 1b4:	785b      	ldrb	r3, [r3, #1]
 1b6:	015a      	lsls	r2, r3, #5
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 1b8:	68fb      	ldr	r3, [r7, #12]
 1ba:	4413      	add	r3, r2
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 1bc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 1c0:	461a      	mov	r2, r3
 1c2:	697b      	ldr	r3, [r7, #20]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 1c4:	6013      	str	r3, [r2, #0]
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 1c6:	79fb      	ldrb	r3, [r7, #7]
 1c8:	2b00      	cmp	r3, #0
 1ca:	d14f      	bne.n	26c <USB_HC_StartXfer+0x26c>
 1cc:	68bb      	ldr	r3, [r7, #8]
 1ce:	78db      	ldrb	r3, [r3, #3]
 1d0:	2b00      	cmp	r3, #0
 1d2:	d14b      	bne.n	26c <USB_HC_StartXfer+0x26c>
  }
  
  return HAL_OK;
}
 1d4:	68bb      	ldr	r3, [r7, #8]
 1d6:	691b      	ldr	r3, [r3, #16]
 1d8:	2b00      	cmp	r3, #0
 1da:	d047      	beq.n	26c <USB_HC_StartXfer+0x26c>
 1dc:	68bb      	ldr	r3, [r7, #8]
 1de:	79db      	ldrb	r3, [r3, #7]
 1e0:	2b03      	cmp	r3, #3
 1e2:	d831      	bhi.n	248 <USB_HC_StartXfer+0x248>
 1e4:	a201      	add	r2, pc, #4	; (adr r2, 1ec <USB_HC_StartXfer+0x1ec>)
 1e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0U;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 1ea:	bf00      	nop
 1ec:	000001fd 	.word	0x000001fd
 1f0:	00000221 	.word	0x00000221
 
  do
  {
    if (++count > 200000U)
 1f4:	000001fd 	.word	0x000001fd
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 1f8:	00000221 	.word	0x00000221
 1fc:	68bb      	ldr	r3, [r7, #8]
  
  return HAL_OK;
 1fe:	691b      	ldr	r3, [r3, #16]
 200:	3303      	adds	r3, #3
 
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 202:	089b      	lsrs	r3, r3, #2
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
  
  return HAL_OK;
}
 204:	837b      	strh	r3, [r7, #26]
 206:	8b7a      	ldrh	r2, [r7, #26]
 208:	68fb      	ldr	r3, [r7, #12]
 20a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 20c:	b29b      	uxth	r3, r3
 20e:	429a      	cmp	r2, r3
 210:	d91c      	bls.n	24c <USB_HC_StartXfer+0x24c>
  
  do
  {
    if (++count > 200000U)
 212:	68fb      	ldr	r3, [r7, #12]
 214:	699b      	ldr	r3, [r3, #24]
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 216:	f043 0220 	orr.w	r2, r3, #32
 21a:	68fb      	ldr	r3, [r7, #12]
 21c:	619a      	str	r2, [r3, #24]
  
  return HAL_OK;
 21e:	e015      	b.n	24c <USB_HC_StartXfer+0x24c>
 220:	68bb      	ldr	r3, [r7, #8]
  
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 222:	691b      	ldr	r3, [r3, #16]
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
  
  return HAL_OK;
}
 224:	3303      	adds	r3, #3
 226:	089b      	lsrs	r3, r3, #2
 228:	837b      	strh	r3, [r7, #26]
 22a:	8b7a      	ldrh	r2, [r7, #26]
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 22c:	68fb      	ldr	r3, [r7, #12]
 22e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 232:	691b      	ldr	r3, [r3, #16]
 234:	b29b      	uxth	r3, r3
  return HAL_OK;
}
 236:	429a      	cmp	r2, r3
 238:	d90a      	bls.n	250 <USB_HC_StartXfer+0x250>
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 23a:	68fb      	ldr	r3, [r7, #12]
 23c:	699b      	ldr	r3, [r3, #24]
 23e:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 242:	68fb      	ldr	r3, [r7, #12]
 244:	619a      	str	r2, [r3, #24]
 246:	e003      	b.n	250 <USB_HC_StartXfer+0x250>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 248:	bf00      	nop
 24a:	e002      	b.n	252 <USB_HC_StartXfer+0x252>
 24c:	bf00      	nop
 24e:	e000      	b.n	252 <USB_HC_StartXfer+0x252>
 250:	bf00      	nop
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 252:	68bb      	ldr	r3, [r7, #8]
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 254:	68d9      	ldr	r1, [r3, #12]
 256:	68bb      	ldr	r3, [r7, #8]
 258:	785a      	ldrb	r2, [r3, #1]
 25a:	68bb      	ldr	r3, [r7, #8]
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 25c:	691b      	ldr	r3, [r3, #16]
 25e:	b298      	uxth	r0, r3
 260:	2300      	movs	r3, #0
 262:	9300      	str	r3, [sp, #0]
  {
    speed = USB_OTG_SPEED_LOW;
 264:	4603      	mov	r3, r0
 266:	68f8      	ldr	r0, [r7, #12]
 268:	f7ff fffe 	bl	0 <USB_HC_StartXfer>
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
 26c:	2300      	movs	r3, #0
  {
    speed = USB_OTG_SPEED_LOW;
  }
  
  return speed;
}
 26e:	4618      	mov	r0, r3
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 270:	3720      	adds	r7, #32
  if (ep->is_in == 1U)
 272:	46bd      	mov	sp, r7
 274:	bd80      	pop	{r7, pc}
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 276:	bf00      	nop
 278:	1ff80000 	.word	0x1ff80000

Disassembly of section .text.USB_HC_ReadInterrupt:

00000000 <USB_HC_ReadInterrupt>:
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	687b      	ldr	r3, [r7, #4]
   a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	695b      	ldr	r3, [r3, #20]
  10:	b29b      	uxth	r3, r3
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	4618      	mov	r0, r3
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	370c      	adds	r7, #12
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	46bd      	mov	sp, r7
  18:	bc80      	pop	{r7}
  1a:	4770      	bx	lr

Disassembly of section .text.USB_HC_Halt:

00000000 <USB_HC_Halt>:
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
   c:	2300      	movs	r3, #0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	60fb      	str	r3, [r7, #12]
  10:	78fb      	ldrb	r3, [r7, #3]
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	015a      	lsls	r2, r3, #5
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	687b      	ldr	r3, [r7, #4]
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	4413      	add	r3, r2
  18:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  1c:	681b      	ldr	r3, [r3, #0]

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  1e:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  22:	0c9b      	lsrs	r3, r3, #18
  24:	2b00      	cmp	r3, #0
  26:	d00b      	beq.n	40 <USB_HC_Halt+0x40>
  28:	78fb      	ldrb	r3, [r7, #3]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	015a      	lsls	r2, r3, #5
  2c:	687b      	ldr	r3, [r7, #4]
  2e:	4413      	add	r3, r2
  30:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    if(cfg.use_external_vbus == 1U)
  34:	681b      	ldr	r3, [r3, #0]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  3a:	0c9b      	lsrs	r3, r3, #18
  3c:	2b02      	cmp	r3, #2
  3e:	d15d      	bne.n	fc <USB_HC_Halt+0xfc>
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	78fb      	ldrb	r3, [r7, #3]
  42:	015a      	lsls	r2, r3, #5
  44:	687b      	ldr	r3, [r7, #4]
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	4413      	add	r3, r2
  48:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  4c:	4619      	mov	r1, r3
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	78fb      	ldrb	r3, [r7, #3]
  50:	015a      	lsls	r2, r3, #5
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	687b      	ldr	r3, [r7, #4]
  54:	4413      	add	r3, r2
  56:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }
 
  if(cfg.dma_enable == ENABLE)
  5a:	681b      	ldr	r3, [r3, #0]
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  60:	600b      	str	r3, [r1, #0]
  62:	687b      	ldr	r3, [r7, #4]
  64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  }  

  return HAL_OK;
}
  66:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  6a:	2b00      	cmp	r3, #0
  6c:	d132      	bne.n	d4 <USB_HC_Halt+0xd4>
  6e:	78fb      	ldrb	r3, [r7, #3]
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	015a      	lsls	r2, r3, #5
  72:	687b      	ldr	r3, [r7, #4]
  74:	4413      	add	r3, r2
  76:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  return HAL_OK;
}
  7a:	4619      	mov	r1, r3
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7c:	78fb      	ldrb	r3, [r7, #3]
  7e:	015a      	lsls	r2, r3, #5
  80:	687b      	ldr	r3, [r7, #4]
  82:	4413      	add	r3, r2
  return HAL_OK;
}
  84:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  88:	681b      	ldr	r3, [r3, #0]
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  8e:	600b      	str	r3, [r1, #0]
  90:	78fb      	ldrb	r3, [r7, #3]
  92:	015a      	lsls	r2, r3, #5
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	687b      	ldr	r3, [r7, #4]
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  96:	4413      	add	r3, r2
  98:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  9c:	4619      	mov	r1, r3
  9e:	78fb      	ldrb	r3, [r7, #3]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  a0:	015a      	lsls	r2, r3, #5
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	687b      	ldr	r3, [r7, #4]
  a4:	4413      	add	r3, r2
  a6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }
  HAL_Delay(50U);
  aa:	681b      	ldr	r3, [r3, #0]
  ac:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  
  return HAL_OK;
}
  b0:	600b      	str	r3, [r1, #0]
  b2:	68fb      	ldr	r3, [r7, #12]
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	3301      	adds	r3, #1
  b6:	60fb      	str	r3, [r7, #12]
  b8:	68fb      	ldr	r3, [r7, #12]
  ba:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  be:	d81b      	bhi.n	f8 <USB_HC_Halt+0xf8>
  c0:	78fb      	ldrb	r3, [r7, #3]
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	015a      	lsls	r2, r3, #5
  c4:	687b      	ldr	r3, [r7, #4]
  c6:	4413      	add	r3, r2
  c8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  cc:	681b      	ldr	r3, [r3, #0]
  ce:	2b00      	cmp	r3, #0
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	dbef      	blt.n	b2 <USB_HC_Halt+0xb2>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	e071      	b.n	1b8 <USB_HC_Halt+0x1b8>
  d4:	78fb      	ldrb	r3, [r7, #3]
  d6:	015a      	lsls	r2, r3, #5
  d8:	687b      	ldr	r3, [r7, #4]
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  da:	4413      	add	r3, r2
  dc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e0:	4619      	mov	r1, r3
  e2:	78fb      	ldrb	r3, [r7, #3]
  e4:	015a      	lsls	r2, r3, #5
  e6:	687b      	ldr	r3, [r7, #4]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  e8:	4413      	add	r3, r2
  ea:	f503 63a0 	add.w	r3, r3, #1280	; 0x500

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  ee:	681b      	ldr	r3, [r3, #0]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  f0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
  f4:	600b      	str	r3, [r1, #0]
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
  f6:	e05f      	b.n	1b8 <USB_HC_Halt+0x1b8>
  f8:	bf00      	nop
  fa:	e05d      	b.n	1b8 <USB_HC_Halt+0x1b8>
  fc:	78fb      	ldrb	r3, [r7, #3]
  fe:	015a      	lsls	r2, r3, #5
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 100:	687b      	ldr	r3, [r7, #4]
 102:	4413      	add	r3, r2
 104:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 108:	4619      	mov	r1, r3
 10a:	78fb      	ldrb	r3, [r7, #3]
 10c:	015a      	lsls	r2, r3, #5
 10e:	687b      	ldr	r3, [r7, #4]
  USB_FlushRxFifo(USBx);
 110:	4413      	add	r3, r2
 112:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 116:	681b      	ldr	r3, [r3, #0]
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 118:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 11c:	600b      	str	r3, [r1, #0]
 11e:	687b      	ldr	r3, [r7, #4]
  USBx_DEVICE->DOEPMSK = 0U;
 120:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 124:	691b      	ldr	r3, [r3, #16]
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 126:	b29b      	uxth	r3, r3
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 128:	2b00      	cmp	r3, #0
 12a:	d132      	bne.n	192 <USB_HC_Halt+0x192>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 12c:	78fb      	ldrb	r3, [r7, #3]
 12e:	015a      	lsls	r2, r3, #5
 130:	687b      	ldr	r3, [r7, #4]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 132:	4413      	add	r3, r2
 134:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 138:	4619      	mov	r1, r3
 13a:	78fb      	ldrb	r3, [r7, #3]
 13c:	015a      	lsls	r2, r3, #5
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 13e:	687b      	ldr	r3, [r7, #4]
 140:	4413      	add	r3, r2
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 142:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 146:	681b      	ldr	r3, [r3, #0]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 148:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 14c:	600b      	str	r3, [r1, #0]
 14e:	78fb      	ldrb	r3, [r7, #3]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 150:	015a      	lsls	r2, r3, #5
 152:	687b      	ldr	r3, [r7, #4]
 154:	4413      	add	r3, r2
 156:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 15a:	4619      	mov	r1, r3
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 15c:	78fb      	ldrb	r3, [r7, #3]
 15e:	015a      	lsls	r2, r3, #5
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 160:	687b      	ldr	r3, [r7, #4]
 162:	4413      	add	r3, r2
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 164:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 168:	681b      	ldr	r3, [r3, #0]
 16a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 16e:	600b      	str	r3, [r1, #0]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 170:	68fb      	ldr	r3, [r7, #12]
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 172:	3301      	adds	r3, #1
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 174:	60fb      	str	r3, [r7, #12]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 176:	68fb      	ldr	r3, [r7, #12]
 178:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 17c:	d81b      	bhi.n	1b6 <USB_HC_Halt+0x1b6>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 17e:	78fb      	ldrb	r3, [r7, #3]
  
  if (cfg.dma_enable == 1U)
 180:	015a      	lsls	r2, r3, #5
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 182:	687b      	ldr	r3, [r7, #4]
 184:	4413      	add	r3, r2
 186:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  
  if (cfg.dma_enable == 1U)
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 18a:	681b      	ldr	r3, [r3, #0]
 18c:	2b00      	cmp	r3, #0
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 18e:	dbef      	blt.n	170 <USB_HC_Halt+0x170>
 190:	e012      	b.n	1b8 <USB_HC_Halt+0x1b8>
 192:	78fb      	ldrb	r3, [r7, #3]
 194:	015a      	lsls	r2, r3, #5
 196:	687b      	ldr	r3, [r7, #4]
 198:	4413      	add	r3, r2
    
    i= USBx_DEVICE->DTHRCTL;
 19a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 19e:	4619      	mov	r1, r3
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 1a0:	78fb      	ldrb	r3, [r7, #3]
 1a2:	015a      	lsls	r2, r3, #5
 1a4:	687b      	ldr	r3, [r7, #4]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 1a6:	4413      	add	r3, r2
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 1a8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 1ac:	681b      	ldr	r3, [r3, #0]
 1ae:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 1b2:	600b      	str	r3, [r1, #0]
 1b4:	e000      	b.n	1b8 <USB_HC_Halt+0x1b8>
 1b6:	bf00      	nop
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 1b8:	2300      	movs	r3, #0
 1ba:	4618      	mov	r0, r3
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 1bc:	3714      	adds	r7, #20
 1be:	46bd      	mov	sp, r7
 1c0:	bc80      	pop	{r7}
 1c2:	4770      	bx	lr

Disassembly of section .text.USB_DoPing:

00000000 <USB_DoPing>:
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
   c:	2301      	movs	r3, #1
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	73fb      	strb	r3, [r7, #15]
  10:	2300      	movs	r3, #0
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	60bb      	str	r3, [r7, #8]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	78fb      	ldrb	r3, [r7, #3]
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	015a      	lsls	r2, r3, #5
  18:	687b      	ldr	r3, [r7, #4]
  1a:	4413      	add	r3, r2
  1c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	461a      	mov	r2, r3
  22:	7bfb      	ldrb	r3, [r7, #15]
  24:	04db      	lsls	r3, r3, #19
  26:	4619      	mov	r1, r3
  28:	4b11      	ldr	r3, [pc, #68]	; (70 <USB_DoPing+0x70>)
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	400b      	ands	r3, r1
  2c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  30:	6113      	str	r3, [r2, #16]
    if(cfg.use_external_vbus == 1U)
  32:	78fb      	ldrb	r3, [r7, #3]
  34:	015a      	lsls	r2, r3, #5
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	687b      	ldr	r3, [r7, #4]
  38:	4413      	add	r3, r2
  3a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  3e:	681b      	ldr	r3, [r3, #0]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	60bb      	str	r3, [r7, #8]
  42:	68bb      	ldr	r3, [r7, #8]
  44:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  48:	60bb      	str	r3, [r7, #8]
  4a:	68bb      	ldr	r3, [r7, #8]
  4c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  50:	60bb      	str	r3, [r7, #8]
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	78fb      	ldrb	r3, [r7, #3]
  54:	015a      	lsls	r2, r3, #5
  56:	687b      	ldr	r3, [r7, #4]
  }
 
  if(cfg.dma_enable == ENABLE)
  58:	4413      	add	r3, r2
  5a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5e:	461a      	mov	r2, r3
  60:	68bb      	ldr	r3, [r7, #8]
  62:	6013      	str	r3, [r2, #0]
  64:	2300      	movs	r3, #0
  }  

  return HAL_OK;
}
  66:	4618      	mov	r0, r3
  68:	3714      	adds	r7, #20
  6a:	46bd      	mov	sp, r7
  6c:	bc80      	pop	{r7}
  6e:	4770      	bx	lr
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	1ff80000 	.word	0x1ff80000

Disassembly of section .text.USB_StopHost:

00000000 <USB_StopHost>:
   0:	b580      	push	{r7, lr}
   2:	b086      	sub	sp, #24
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	2300      	movs	r3, #0
   a:	613b      	str	r3, [r7, #16]
   c:	6878      	ldr	r0, [r7, #4]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   e:	f7ff fffe 	bl	0 <USB_StopHost>
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  12:	2110      	movs	r1, #16
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
  14:	6878      	ldr	r0, [r7, #4]
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
  16:	f7ff fffe 	bl	0 <USB_StopHost>
  1a:	6878      	ldr	r0, [r7, #4]
  1c:	f7ff fffe 	bl	0 <USB_StopHost>

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
  20:	2300      	movs	r3, #0
  22:	75fb      	strb	r3, [r7, #23]
  24:	e01f      	b.n	66 <USB_StopHost+0x66>
  26:	7dfb      	ldrb	r3, [r7, #23]
  28:	015a      	lsls	r2, r3, #5
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	4413      	add	r3, r2
  2e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
    if(cfg.use_external_vbus == 1U)
  32:	681b      	ldr	r3, [r3, #0]
  34:	60fb      	str	r3, [r7, #12]
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
  36:	68fb      	ldr	r3, [r7, #12]
  38:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  3c:	60fb      	str	r3, [r7, #12]
  3e:	68fb      	ldr	r3, [r7, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
  40:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  44:	60fb      	str	r3, [r7, #12]
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
  46:	68fb      	ldr	r3, [r7, #12]
  48:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  4c:	60fb      	str	r3, [r7, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
  4e:	7dfb      	ldrb	r3, [r7, #23]
  50:	015a      	lsls	r2, r3, #5
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  52:	687b      	ldr	r3, [r7, #4]
  54:	4413      	add	r3, r2
  56:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  }
 
  if(cfg.dma_enable == ENABLE)
  5a:	461a      	mov	r2, r3
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
  5c:	68fb      	ldr	r3, [r7, #12]
  5e:	6013      	str	r3, [r2, #0]
  60:	7dfb      	ldrb	r3, [r7, #23]
  62:	3301      	adds	r3, #1
  64:	75fb      	strb	r3, [r7, #23]
  }  

  return HAL_OK;
}
  66:	7dfb      	ldrb	r3, [r7, #23]
  68:	2b0f      	cmp	r3, #15
  6a:	d9dc      	bls.n	26 <USB_StopHost+0x26>
  6c:	2300      	movs	r3, #0
  6e:	75fb      	strb	r3, [r7, #23]
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
  70:	e031      	b.n	d6 <USB_StopHost+0xd6>
  72:	7dfb      	ldrb	r3, [r7, #23]
  74:	015a      	lsls	r2, r3, #5
  76:	687b      	ldr	r3, [r7, #4]
  return HAL_OK;
}
  78:	4413      	add	r3, r2
  7a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
  7e:	681b      	ldr	r3, [r3, #0]
  80:	60fb      	str	r3, [r7, #12]
  82:	68fb      	ldr	r3, [r7, #12]
  return HAL_OK;
}
  84:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  88:	60fb      	str	r3, [r7, #12]
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  8a:	68fb      	ldr	r3, [r7, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
  8c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
  90:	60fb      	str	r3, [r7, #12]
  92:	68fb      	ldr	r3, [r7, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
  94:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
  98:	60fb      	str	r3, [r7, #12]
  9a:	7dfb      	ldrb	r3, [r7, #23]
  9c:	015a      	lsls	r2, r3, #5
  9e:	687b      	ldr	r3, [r7, #4]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  a0:	4413      	add	r3, r2
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  a2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  a6:	461a      	mov	r2, r3
  a8:	68fb      	ldr	r3, [r7, #12]
  }
  HAL_Delay(50U);
  aa:	6013      	str	r3, [r2, #0]
  ac:	693b      	ldr	r3, [r7, #16]
  ae:	3301      	adds	r3, #1
  
  return HAL_OK;
}
  b0:	613b      	str	r3, [r7, #16]
  b2:	693b      	ldr	r3, [r7, #16]
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
  b4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  b8:	d809      	bhi.n	ce <USB_StopHost+0xce>
  ba:	7dfb      	ldrb	r3, [r7, #23]
  bc:	015a      	lsls	r2, r3, #5
  be:	687b      	ldr	r3, [r7, #4]
  c0:	4413      	add	r3, r2
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
  c2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
  c6:	681b      	ldr	r3, [r3, #0]
  c8:	2b00      	cmp	r3, #0
  ca:	dbef      	blt.n	ac <USB_StopHost+0xac>
  cc:	e000      	b.n	d0 <USB_StopHost+0xd0>
  ce:	bf00      	nop
  
  if (cfg.vbus_sensing_enable == 0U)
  d0:	7dfb      	ldrb	r3, [r7, #23]
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
  d2:	3301      	adds	r3, #1
  d4:	75fb      	strb	r3, [r7, #23]
  d6:	7dfb      	ldrb	r3, [r7, #23]
  d8:	2b0f      	cmp	r3, #15
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  da:	d9ca      	bls.n	72 <USB_StopHost+0x72>
  dc:	687b      	ldr	r3, [r7, #4]
  de:	f503 6380 	add.w	r3, r3, #1024	; 0x400

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  e2:	461a      	mov	r2, r3
  e4:	f04f 33ff 	mov.w	r3, #4294967295
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  e8:	6153      	str	r3, [r2, #20]
  ea:	687b      	ldr	r3, [r7, #4]

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  ec:	f04f 32ff 	mov.w	r2, #4294967295
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  f0:	615a      	str	r2, [r3, #20]
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
  f2:	6878      	ldr	r0, [r7, #4]
  f4:	f7ff fffe 	bl	0 <USB_StopHost>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
  f8:	2300      	movs	r3, #0
  fa:	4618      	mov	r0, r3
  fc:	3718      	adds	r7, #24
  fe:	46bd      	mov	sp, r7
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 100:	bd80      	pop	{r7, pc}

stm32f4xx_hal_gpio.o:     file format elf32-littlearm


Disassembly of section .text.HAL_GPIO_Init:

00000000 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
   4:	4c76      	ldr	r4, [pc, #472]	; (1e0 <HAL_GPIO_Init+0x1e0>)
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 1e8 <HAL_GPIO_Init+0x1e8>
   a:	f8df e1e0 	ldr.w	lr, [pc, #480]	; 1ec <HAL_GPIO_Init+0x1ec>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
   e:	2300      	movs	r3, #0
  10:	4626      	mov	r6, r4
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
  12:	2201      	movs	r2, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
  14:	680d      	ldr	r5, [r1, #0]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
  16:	409a      	lsls	r2, r3
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
  18:	ea32 0505 	bics.w	r5, r2, r5
  1c:	f040 80d8 	bne.w	1d0 <HAL_GPIO_Init+0x1d0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  20:	684d      	ldr	r5, [r1, #4]
  22:	f025 0510 	bic.w	r5, r5, #16
  26:	2d02      	cmp	r5, #2
  28:	d116      	bne.n	58 <HAL_GPIO_Init+0x58>
  2a:	ea4f 08d3 	mov.w	r8, r3, lsr #3
  2e:	eb00 0888 	add.w	r8, r0, r8, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
  32:	f003 0a07 	and.w	sl, r3, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
  36:	f8d8 b020 	ldr.w	fp, [r8, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
  3a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
  3e:	f04f 0c0f 	mov.w	ip, #15
  42:	fa0c f50a 	lsl.w	r5, ip, sl
  46:	ea2b 0c05 	bic.w	ip, fp, r5
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
  4a:	690d      	ldr	r5, [r1, #16]
  4c:	fa05 f50a 	lsl.w	r5, r5, sl
  50:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3U] = temp;
  54:	f8c8 5020 	str.w	r5, [r8, #32]
  58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
  5c:	f04f 0803 	mov.w	r8, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
  60:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
  62:	fa08 f80c 	lsl.w	r8, r8, ip
  66:	ea6f 0808 	mvn.w	r8, r8
  6a:	ea05 0a08 	and.w	sl, r5, r8
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
  6e:	684d      	ldr	r5, [r1, #4]
  70:	f005 0503 	and.w	r5, r5, #3
  74:	fa05 f50c 	lsl.w	r5, r5, ip
  78:	ea45 050a 	orr.w	r5, r5, sl
      GPIOx->MODER = temp;
  7c:	6005      	str	r5, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  7e:	684d      	ldr	r5, [r1, #4]
  80:	f025 0510 	bic.w	r5, r5, #16
  84:	3d01      	subs	r5, #1
  86:	2d01      	cmp	r5, #1
  88:	d812      	bhi.n	b0 <HAL_GPIO_Init+0xb0>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
  8a:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
  8c:	68cf      	ldr	r7, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
  8e:	ea08 0505 	and.w	r5, r8, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
  92:	fa07 fa0c 	lsl.w	sl, r7, ip
  96:	ea4a 0505 	orr.w	r5, sl, r5
        GPIOx->OSPEEDR = temp;
  9a:	6085      	str	r5, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
  9c:	6845      	ldr	r5, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
  9e:	ea25 0a02 	bic.w	sl, r5, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
  a2:	684d      	ldr	r5, [r1, #4]
  a4:	f3c5 1500 	ubfx	r5, r5, #4, #1
  a8:	409d      	lsls	r5, r3
  aa:	ea45 050a 	orr.w	r5, r5, sl
        GPIOx->OTYPER = temp;
  ae:	6045      	str	r5, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
  b0:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
  b2:	ea08 0805 	and.w	r8, r8, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
  b6:	688d      	ldr	r5, [r1, #8]
  b8:	fa05 f50c 	lsl.w	r5, r5, ip
  bc:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
  c0:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
  c2:	684d      	ldr	r5, [r1, #4]
  c4:	00ed      	lsls	r5, r5, #3
  c6:	f140 8083 	bpl.w	1d0 <HAL_GPIO_Init+0x1d0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  ca:	4f46      	ldr	r7, [pc, #280]	; (1e4 <HAL_GPIO_Init+0x1e4>)
  cc:	2500      	movs	r5, #0
  ce:	9501      	str	r5, [sp, #4]
  d0:	f8d7 c044 	ldr.w	ip, [r7, #68]	; 0x44
  d4:	f44c 4c80 	orr.w	ip, ip, #16384	; 0x4000
  d8:	f8c7 c044 	str.w	ip, [r7, #68]	; 0x44
  dc:	f8d7 c044 	ldr.w	ip, [r7, #68]	; 0x44
  e0:	f023 0803 	bic.w	r8, r3, #3
  e4:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
  e8:	f40c 4c80 	and.w	ip, ip, #16384	; 0x4000
  ec:	f508 389c 	add.w	r8, r8, #79872	; 0x13800
  f0:	f8cd c004 	str.w	ip, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
  f4:	f003 0a03 	and.w	sl, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  f8:	f8dd c004 	ldr.w	ip, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
  fc:	f8d8 b008 	ldr.w	fp, [r8, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 100:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 104:	f04f 0c0f 	mov.w	ip, #15
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 108:	f5a7 5760 	sub.w	r7, r7, #14336	; 0x3800
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 10c:	fa0c fc0a 	lsl.w	ip, ip, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 110:	42b8      	cmp	r0, r7
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 112:	ea2b 0c0c 	bic.w	ip, fp, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 116:	d033      	beq.n	180 <HAL_GPIO_Init+0x180>
 118:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 11c:	f505 3501 	add.w	r5, r5, #132096	; 0x20400
 120:	42a8      	cmp	r0, r5
 122:	d01e      	beq.n	162 <HAL_GPIO_Init+0x162>
 124:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 128:	42a8      	cmp	r0, r5
 12a:	d01c      	beq.n	166 <HAL_GPIO_Init+0x166>
 12c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 130:	42a8      	cmp	r0, r5
 132:	d01a      	beq.n	16a <HAL_GPIO_Init+0x16a>
 134:	4548      	cmp	r0, r9
 136:	d01a      	beq.n	16e <HAL_GPIO_Init+0x16e>
 138:	4570      	cmp	r0, lr
 13a:	d01a      	beq.n	172 <HAL_GPIO_Init+0x172>
 13c:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 140:	42a8      	cmp	r0, r5
 142:	d018      	beq.n	176 <HAL_GPIO_Init+0x176>
 144:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 148:	42a8      	cmp	r0, r5
 14a:	d016      	beq.n	17a <HAL_GPIO_Init+0x17a>
 14c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 150:	42a8      	cmp	r0, r5
 152:	d014      	beq.n	17e <HAL_GPIO_Init+0x17e>
 154:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 158:	42a8      	cmp	r0, r5
 15a:	bf0c      	ite	eq
 15c:	2509      	moveq	r5, #9
 15e:	250a      	movne	r5, #10
 160:	e00e      	b.n	180 <HAL_GPIO_Init+0x180>
 162:	2501      	movs	r5, #1
 164:	e00c      	b.n	180 <HAL_GPIO_Init+0x180>
 166:	2502      	movs	r5, #2
 168:	e00a      	b.n	180 <HAL_GPIO_Init+0x180>
 16a:	2503      	movs	r5, #3
 16c:	e008      	b.n	180 <HAL_GPIO_Init+0x180>
 16e:	2504      	movs	r5, #4
 170:	e006      	b.n	180 <HAL_GPIO_Init+0x180>
 172:	2505      	movs	r5, #5
 174:	e004      	b.n	180 <HAL_GPIO_Init+0x180>
 176:	2506      	movs	r5, #6
 178:	e002      	b.n	180 <HAL_GPIO_Init+0x180>
 17a:	2507      	movs	r5, #7
 17c:	e000      	b.n	180 <HAL_GPIO_Init+0x180>
 17e:	2508      	movs	r5, #8
 180:	fa05 f50a 	lsl.w	r5, r5, sl
 184:	ea45 050c 	orr.w	r5, r5, ip
        SYSCFG->EXTICR[position >> 2U] = temp;
 188:	f8c8 5008 	str.w	r5, [r8, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 18c:	684f      	ldr	r7, [r1, #4]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 18e:	6825      	ldr	r5, [r4, #0]
        temp &= ~((uint32_t)iocurrent);
 190:	ea6f 0c02 	mvn.w	ip, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 194:	03ff      	lsls	r7, r7, #15
        {
          temp |= iocurrent;
 196:	bf4c      	ite	mi
 198:	4315      	orrmi	r5, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 19a:	ea05 050c 	andpl.w	r5, r5, ip
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 19e:	6035      	str	r5, [r6, #0]

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 1a0:	684f      	ldr	r7, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
 1a2:	6875      	ldr	r5, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 1a4:	03bf      	lsls	r7, r7, #14
        {
          temp |= iocurrent;
 1a6:	bf4c      	ite	mi
 1a8:	4315      	orrmi	r5, r2
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 1aa:	ea0c 0505 	andpl.w	r5, ip, r5
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 1ae:	6065      	str	r5, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 1b0:	684f      	ldr	r7, [r1, #4]
          temp |= iocurrent;
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 1b2:	68a5      	ldr	r5, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 1b4:	02ff      	lsls	r7, r7, #11
        {
          temp |= iocurrent;
 1b6:	bf4c      	ite	mi
 1b8:	4315      	orrmi	r5, r2
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 1ba:	ea0c 0505 	andpl.w	r5, ip, r5
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 1be:	60b5      	str	r5, [r6, #8]

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 1c0:	684f      	ldr	r7, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
 1c2:	68f5      	ldr	r5, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 1c4:	02bf      	lsls	r7, r7, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 1c6:	bf54      	ite	pl
 1c8:	ea0c 0205 	andpl.w	r2, ip, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 1cc:	432a      	orrmi	r2, r5
        }
        EXTI->FTSR = temp;
 1ce:	60e2      	str	r2, [r4, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 1d0:	3301      	adds	r3, #1
 1d2:	2b10      	cmp	r3, #16
 1d4:	f47f af1d 	bne.w	12 <HAL_GPIO_Init+0x12>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 1d8:	b003      	add	sp, #12
 1da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1de:	bf00      	nop
 1e0:	40013c00 	.word	0x40013c00
 1e4:	40023800 	.word	0x40023800
 1e8:	40021000 	.word	0x40021000
 1ec:	40021400 	.word	0x40021400

Disassembly of section .text.HAL_GPIO_DeInit:

00000000 <HAL_GPIO_DeInit>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
   4:	4c4d      	ldr	r4, [pc, #308]	; (13c <HAL_GPIO_DeInit+0x13c>)
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	f8df a13c 	ldr.w	sl, [pc, #316]	; 144 <HAL_GPIO_DeInit+0x144>
   a:	f8df b13c 	ldr.w	fp, [pc, #316]	; 148 <HAL_GPIO_DeInit+0x148>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
   e:	2200      	movs	r2, #0
  10:	f04f 0901 	mov.w	r9, #1
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
  14:	fa09 f502 	lsl.w	r5, r9, r2
  18:	ea35 0301 	bics.w	r3, r5, r1
  1c:	f040 8087 	bne.w	12e <HAL_GPIO_DeInit+0x12e>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  20:	2303      	movs	r3, #3
  22:	fa02 f609 	lsl.w	r6, r2, r9
  26:	6807      	ldr	r7, [r0, #0]
  28:	fa03 f606 	lsl.w	r6, r3, r6
  2c:	43f6      	mvns	r6, r6
  2e:	fa22 fc03 	lsr.w	ip, r2, r3
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
  32:	4037      	ands	r7, r6
  34:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
  38:	6007      	str	r7, [r0, #0]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
  3a:	f002 0e07 	and.w	lr, r2, #7
  3e:	f8dc 8020 	ldr.w	r8, [ip, #32]
  42:	270f      	movs	r7, #15
  44:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
  48:	fa07 fe0e 	lsl.w	lr, r7, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
  4c:	ea28 0e0e 	bic.w	lr, r8, lr
  50:	f8cc e020 	str.w	lr, [ip, #32]
        GPIOx->AFR[position >> 3U] = temp;
  54:	f8d0 e008 	ldr.w	lr, [r0, #8]
  58:	ea06 0e0e 	and.w	lr, r6, lr
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
  5c:	f8c0 e008 	str.w	lr, [r0, #8]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
  60:	f8d0 e004 	ldr.w	lr, [r0, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
  64:	43ed      	mvns	r5, r5
  66:	ea0e 0e05 	and.w	lr, lr, r5
  6a:	f8c0 e004 	str.w	lr, [r0, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
  6e:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  72:	ea06 060e 	and.w	r6, r6, lr
  76:	60c6      	str	r6, [r0, #12]
  78:	f022 0603 	bic.w	r6, r2, #3
      GPIOx->MODER = temp;
  7c:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  80:	f506 369c 	add.w	r6, r6, #79872	; 0x13800
  84:	ea02 0e03 	and.w	lr, r2, r3
  88:	4b2d      	ldr	r3, [pc, #180]	; (140 <HAL_GPIO_DeInit+0x140>)
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
  8a:	f8d6 c008 	ldr.w	ip, [r6, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
  8e:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        temp |= (GPIO_Init->Speed << (position * 2U));
  92:	fa07 f70e 	lsl.w	r7, r7, lr
  96:	4298      	cmp	r0, r3
  98:	ea0c 0c07 	and.w	ip, ip, r7
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
  9c:	d022      	beq.n	e4 <HAL_GPIO_DeInit+0xe4>
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
  9e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
  a2:	4298      	cmp	r0, r3
  a4:	d020      	beq.n	e8 <HAL_GPIO_DeInit+0xe8>
  a6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  aa:	4298      	cmp	r0, r3
  ac:	d01e      	beq.n	ec <HAL_GPIO_DeInit+0xec>
        GPIOx->OTYPER = temp;
  ae:	f503 6380 	add.w	r3, r3, #1024	; 0x400
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
  b2:	4298      	cmp	r0, r3
  b4:	d01c      	beq.n	f0 <HAL_GPIO_DeInit+0xf0>
      temp |= ((GPIO_Init->Pull) << (position * 2U));
  b6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  ba:	4298      	cmp	r0, r3
  bc:	d01a      	beq.n	f4 <HAL_GPIO_DeInit+0xf4>
  be:	f503 6380 	add.w	r3, r3, #1024	; 0x400
      GPIOx->PUPDR = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
  c2:	4298      	cmp	r0, r3
  c4:	d018      	beq.n	f8 <HAL_GPIO_DeInit+0xf8>
  c6:	4550      	cmp	r0, sl
  c8:	d018      	beq.n	fc <HAL_GPIO_DeInit+0xfc>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  ca:	4558      	cmp	r0, fp
  cc:	d018      	beq.n	100 <HAL_GPIO_DeInit+0x100>
  ce:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
  d2:	4298      	cmp	r0, r3
  d4:	d016      	beq.n	104 <HAL_GPIO_DeInit+0x104>
  d6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  da:	4298      	cmp	r0, r3
  dc:	bf0c      	ite	eq
  de:	2309      	moveq	r3, #9
  e0:	230a      	movne	r3, #10
  e2:	e010      	b.n	106 <HAL_GPIO_DeInit+0x106>
  e4:	2300      	movs	r3, #0
  e6:	e00e      	b.n	106 <HAL_GPIO_DeInit+0x106>
  e8:	464b      	mov	r3, r9
  ea:	e00c      	b.n	106 <HAL_GPIO_DeInit+0x106>
  ec:	2302      	movs	r3, #2
  ee:	e00a      	b.n	106 <HAL_GPIO_DeInit+0x106>
  f0:	2303      	movs	r3, #3
  f2:	e008      	b.n	106 <HAL_GPIO_DeInit+0x106>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
  f4:	2304      	movs	r3, #4
  f6:	e006      	b.n	106 <HAL_GPIO_DeInit+0x106>
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  f8:	2305      	movs	r3, #5
  fa:	e004      	b.n	106 <HAL_GPIO_DeInit+0x106>

        temp = SYSCFG->EXTICR[position >> 2U];
  fc:	2306      	movs	r3, #6
  fe:	e002      	b.n	106 <HAL_GPIO_DeInit+0x106>
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 100:	2307      	movs	r3, #7
 102:	e000      	b.n	106 <HAL_GPIO_DeInit+0x106>
 104:	2308      	movs	r3, #8
 106:	fa03 f30e 	lsl.w	r3, r3, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 10a:	459c      	cmp	ip, r3
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 10c:	d10f      	bne.n	12e <HAL_GPIO_DeInit+0x12e>
 10e:	68b3      	ldr	r3, [r6, #8]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 110:	ea23 0707 	bic.w	r7, r3, r7
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 114:	60b7      	str	r7, [r6, #8]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 116:	6823      	ldr	r3, [r4, #0]
 118:	402b      	ands	r3, r5
 11a:	6023      	str	r3, [r4, #0]
 11c:	6863      	ldr	r3, [r4, #4]
 11e:	402b      	ands	r3, r5
 120:	6063      	str	r3, [r4, #4]
 122:	68a3      	ldr	r3, [r4, #8]
 124:	402b      	ands	r3, r5
 126:	60a3      	str	r3, [r4, #8]
 128:	68e3      	ldr	r3, [r4, #12]
 12a:	401d      	ands	r5, r3
 12c:	60e5      	str	r5, [r4, #12]
 12e:	3201      	adds	r2, #1
 130:	2a10      	cmp	r2, #16
 132:	f47f af6d 	bne.w	10 <HAL_GPIO_DeInit+0x10>
 136:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 13a:	bf00      	nop
 13c:	40013c00 	.word	0x40013c00
 140:	40020000 	.word	0x40020000
 144:	40021800 	.word	0x40021800
 148:	40021c00 	.word	0x40021c00

Disassembly of section .text.HAL_GPIO_ReadPin:

00000000 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	6903      	ldr	r3, [r0, #16]
   2:	4219      	tst	r1, r3
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
   4:	bf14      	ite	ne
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	2001      	movne	r0, #1
   8:	2000      	moveq	r0, #0
   a:	4770      	bx	lr

Disassembly of section .text.HAL_GPIO_WritePin:

00000000 <HAL_GPIO_WritePin>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	b902      	cbnz	r2, 4 <HAL_GPIO_WritePin+0x4>
   2:	0409      	lsls	r1, r1, #16
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
   4:	6181      	str	r1, [r0, #24]
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	4770      	bx	lr

Disassembly of section .text.HAL_GPIO_TogglePin:

00000000 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	6943      	ldr	r3, [r0, #20]
   2:	4059      	eors	r1, r3
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
   4:	6141      	str	r1, [r0, #20]
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	4770      	bx	lr

Disassembly of section .text.HAL_GPIO_LockPin:

00000000 <HAL_GPIO_LockPin>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	b082      	sub	sp, #8
   2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	9301      	str	r3, [sp, #4]
   8:	9b01      	ldr	r3, [sp, #4]
   a:	430b      	orrs	r3, r1
   c:	9301      	str	r3, [sp, #4]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
   e:	9b01      	ldr	r3, [sp, #4]
  10:	61c3      	str	r3, [r0, #28]
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
  12:	61c1      	str	r1, [r0, #28]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
  14:	9b01      	ldr	r3, [sp, #4]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
  16:	61c3      	str	r3, [r0, #28]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
  18:	69c3      	ldr	r3, [r0, #28]
  1a:	9301      	str	r3, [sp, #4]
  1c:	69c0      	ldr	r0, [r0, #28]
  1e:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  22:	f3c0 4000 	ubfx	r0, r0, #16, #1
  26:	b002      	add	sp, #8
  28:	4770      	bx	lr

Disassembly of section .text.HAL_GPIO_EXTI_Callback:

00000000 <HAL_GPIO_EXTI_Callback>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
   0:	4770      	bx	lr

Disassembly of section .text.HAL_GPIO_EXTI_IRQHandler:

00000000 <HAL_GPIO_EXTI_IRQHandler>:
   0:	b508      	push	{r3, lr}
   2:	4b04      	ldr	r3, [pc, #16]	; (14 <HAL_GPIO_EXTI_IRQHandler+0x14>)
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
   4:	6959      	ldr	r1, [r3, #20]
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   6:	4201      	tst	r1, r0
   8:	d002      	beq.n	10 <HAL_GPIO_EXTI_IRQHandler+0x10>
   a:	6158      	str	r0, [r3, #20]
   c:	f7ff fffe 	bl	0 <HAL_GPIO_EXTI_IRQHandler>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  10:	bd08      	pop	{r3, pc}
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
  12:	bf00      	nop
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
  14:	40013c00 	.word	0x40013c00

stm32f4xx_hal_rcc.o:     file format elf32-littlearm


Disassembly of section .text.HAL_RCC_DeInit:

00000000 <HAL_RCC_DeInit>:
   0:	4770      	bx	lr

Disassembly of section .text.HAL_RCC_OscConfig:

00000000 <HAL_RCC_OscConfig>:
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	6803      	ldr	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	07d8      	lsls	r0, r3, #31
   a:	d403      	bmi.n	14 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	6823      	ldr	r3, [r4, #0]
   e:	0799      	lsls	r1, r3, #30
  10:	d437      	bmi.n	82 <HAL_RCC_OscConfig+0x82>
  12:	e087      	b.n	124 <HAL_RCC_OscConfig+0x124>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	4ba7      	ldr	r3, [pc, #668]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
  16:	689a      	ldr	r2, [r3, #8]
  18:	f002 020c 	and.w	r2, r2, #12
  1c:	2a04      	cmp	r2, #4
  1e:	d007      	beq.n	30 <HAL_RCC_OscConfig+0x30>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	689a      	ldr	r2, [r3, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  22:	f002 020c 	and.w	r2, r2, #12
  26:	2a08      	cmp	r2, #8
  28:	d10b      	bne.n	42 <HAL_RCC_OscConfig+0x42>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  2a:	685b      	ldr	r3, [r3, #4]
  2c:	025a      	lsls	r2, r3, #9
  2e:	d508      	bpl.n	42 <HAL_RCC_OscConfig+0x42>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  30:	4ba0      	ldr	r3, [pc, #640]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
  32:	681b      	ldr	r3, [r3, #0]
  34:	039b      	lsls	r3, r3, #14
  36:	d5e9      	bpl.n	c <HAL_RCC_OscConfig+0xc>
  38:	6863      	ldr	r3, [r4, #4]
  3a:	2b00      	cmp	r3, #0
  3c:	d1e6      	bne.n	c <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
  3e:	2001      	movs	r0, #1
  40:	e134      	b.n	2ac <HAL_RCC_OscConfig+0x2ac>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  42:	4b9d      	ldr	r3, [pc, #628]	; (2b8 <HAL_RCC_OscConfig+0x2b8>)
  44:	7922      	ldrb	r2, [r4, #4]
  46:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
  48:	6863      	ldr	r3, [r4, #4]
  4a:	b16b      	cbz	r3, 68 <HAL_RCC_OscConfig+0x68>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  4c:	f7ff fffe 	bl	0 <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  50:	4d98      	ldr	r5, [pc, #608]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  52:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  54:	682b      	ldr	r3, [r5, #0]
  56:	039f      	lsls	r7, r3, #14
  58:	d4d8      	bmi.n	c <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  5a:	f7ff fffe 	bl	0 <HAL_GetTick>
  5e:	1b80      	subs	r0, r0, r6
  60:	2864      	cmp	r0, #100	; 0x64
  62:	d9f7      	bls.n	54 <HAL_RCC_OscConfig+0x54>
          {
            return HAL_TIMEOUT;
  64:	2003      	movs	r0, #3
  66:	e121      	b.n	2ac <HAL_RCC_OscConfig+0x2ac>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  68:	f7ff fffe 	bl	0 <HAL_GetTick>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  6c:	4d91      	ldr	r5, [pc, #580]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  6e:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  70:	682b      	ldr	r3, [r5, #0]
  72:	0398      	lsls	r0, r3, #14
  74:	d5ca      	bpl.n	c <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  76:	f7ff fffe 	bl	0 <HAL_GetTick>
  7a:	1b80      	subs	r0, r0, r6
  7c:	2864      	cmp	r0, #100	; 0x64
  7e:	d9f7      	bls.n	70 <HAL_RCC_OscConfig+0x70>
  80:	e7f0      	b.n	64 <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  82:	4b8c      	ldr	r3, [pc, #560]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
  84:	689a      	ldr	r2, [r3, #8]
  86:	f012 0f0c 	tst.w	r2, #12
  8a:	d007      	beq.n	9c <HAL_RCC_OscConfig+0x9c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  8c:	689a      	ldr	r2, [r3, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  8e:	f002 020c 	and.w	r2, r2, #12
  92:	2a08      	cmp	r2, #8
  94:	d117      	bne.n	c6 <HAL_RCC_OscConfig+0xc6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  96:	685b      	ldr	r3, [r3, #4]
  98:	0259      	lsls	r1, r3, #9
  9a:	d414      	bmi.n	c6 <HAL_RCC_OscConfig+0xc6>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  9c:	4b85      	ldr	r3, [pc, #532]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
  9e:	681a      	ldr	r2, [r3, #0]
  a0:	0792      	lsls	r2, r2, #30
  a2:	d502      	bpl.n	aa <HAL_RCC_OscConfig+0xaa>
  a4:	68e2      	ldr	r2, [r4, #12]
  a6:	2a01      	cmp	r2, #1
  a8:	d1c9      	bne.n	3e <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  aa:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
  ac:	21f8      	movs	r1, #248	; 0xf8
  ae:	fa91 f1a1 	rbit	r1, r1
  b2:	6920      	ldr	r0, [r4, #16]
  b4:	fab1 f181 	clz	r1, r1
  b8:	fa00 f101 	lsl.w	r1, r0, r1
  bc:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
  c0:	430a      	orrs	r2, r1
  c2:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  c4:	e02e      	b.n	124 <HAL_RCC_OscConfig+0x124>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
  c6:	68e2      	ldr	r2, [r4, #12]
  c8:	4b7c      	ldr	r3, [pc, #496]	; (2bc <HAL_RCC_OscConfig+0x2bc>)
  ca:	b1ea      	cbz	r2, 108 <HAL_RCC_OscConfig+0x108>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
  cc:	2201      	movs	r2, #1
  ce:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  d0:	f7ff fffe 	bl	0 <HAL_GetTick>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  d4:	4d77      	ldr	r5, [pc, #476]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  d6:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  d8:	682b      	ldr	r3, [r5, #0]
  da:	4876      	ldr	r0, [pc, #472]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
  dc:	079b      	lsls	r3, r3, #30
  de:	d405      	bmi.n	ec <HAL_RCC_OscConfig+0xec>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
  e0:	f7ff fffe 	bl	0 <HAL_GetTick>
  e4:	1b80      	subs	r0, r0, r6
  e6:	2802      	cmp	r0, #2
  e8:	d9f6      	bls.n	d8 <HAL_RCC_OscConfig+0xd8>
  ea:	e7bb      	b.n	64 <HAL_RCC_OscConfig+0x64>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  ec:	6803      	ldr	r3, [r0, #0]
  ee:	22f8      	movs	r2, #248	; 0xf8
  f0:	fa92 f2a2 	rbit	r2, r2
  f4:	6921      	ldr	r1, [r4, #16]
  f6:	fab2 f282 	clz	r2, r2
  fa:	fa01 f202 	lsl.w	r2, r1, r2
  fe:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 102:	4313      	orrs	r3, r2
 104:	6003      	str	r3, [r0, #0]
 106:	e00d      	b.n	124 <HAL_RCC_OscConfig+0x124>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 108:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 10a:	f7ff fffe 	bl	0 <HAL_GetTick>
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 10e:	4d69      	ldr	r5, [pc, #420]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 110:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 112:	682b      	ldr	r3, [r5, #0]
 114:	079f      	lsls	r7, r3, #30
 116:	d505      	bpl.n	124 <HAL_RCC_OscConfig+0x124>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 118:	f7ff fffe 	bl	0 <HAL_GetTick>
 11c:	1b80      	subs	r0, r0, r6
 11e:	2802      	cmp	r0, #2
 120:	d9f7      	bls.n	112 <HAL_RCC_OscConfig+0x112>
 122:	e79f      	b.n	64 <HAL_RCC_OscConfig+0x64>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 124:	6823      	ldr	r3, [r4, #0]
 126:	071e      	lsls	r6, r3, #28
 128:	d403      	bmi.n	132 <HAL_RCC_OscConfig+0x132>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 12a:	6823      	ldr	r3, [r4, #0]
 12c:	075d      	lsls	r5, r3, #29
 12e:	d545      	bpl.n	1bc <HAL_RCC_OscConfig+0x1bc>
 130:	e01f      	b.n	172 <HAL_RCC_OscConfig+0x172>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 132:	6962      	ldr	r2, [r4, #20]
 134:	4b62      	ldr	r3, [pc, #392]	; (2c0 <HAL_RCC_OscConfig+0x2c0>)
 136:	b172      	cbz	r2, 156 <HAL_RCC_OscConfig+0x156>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 138:	2201      	movs	r2, #1
 13a:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 13c:	f7ff fffe 	bl	0 <HAL_GetTick>
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 140:	4d5c      	ldr	r5, [pc, #368]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 142:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 144:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 146:	0798      	lsls	r0, r3, #30
 148:	d4ef      	bmi.n	12a <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 14a:	f7ff fffe 	bl	0 <HAL_GetTick>
 14e:	1b80      	subs	r0, r0, r6
 150:	2802      	cmp	r0, #2
 152:	d9f7      	bls.n	144 <HAL_RCC_OscConfig+0x144>
 154:	e786      	b.n	64 <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 156:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 158:	f7ff fffe 	bl	0 <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 15c:	4d55      	ldr	r5, [pc, #340]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 15e:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 160:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 162:	0799      	lsls	r1, r3, #30
 164:	d5e1      	bpl.n	12a <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 166:	f7ff fffe 	bl	0 <HAL_GetTick>
 16a:	1b80      	subs	r0, r0, r6
 16c:	2802      	cmp	r0, #2
 16e:	d9f7      	bls.n	160 <HAL_RCC_OscConfig+0x160>
 170:	e778      	b.n	64 <HAL_RCC_OscConfig+0x64>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 172:	2300      	movs	r3, #0
 174:	9301      	str	r3, [sp, #4]
 176:	4b4f      	ldr	r3, [pc, #316]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 178:	4d52      	ldr	r5, [pc, #328]	; (2c4 <HAL_RCC_OscConfig+0x2c4>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 17a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 17c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 180:	641a      	str	r2, [r3, #64]	; 0x40
 182:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 184:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 188:	9301      	str	r3, [sp, #4]
 18a:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 18c:	682b      	ldr	r3, [r5, #0]
 18e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 192:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 194:	f7ff fffe 	bl	0 <HAL_GetTick>
 198:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 19a:	682b      	ldr	r3, [r5, #0]
 19c:	05da      	lsls	r2, r3, #23
 19e:	d510      	bpl.n	1c2 <HAL_RCC_OscConfig+0x1c2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 1a0:	4b49      	ldr	r3, [pc, #292]	; (2c8 <HAL_RCC_OscConfig+0x2c8>)
 1a2:	7a22      	ldrb	r2, [r4, #8]
 1a4:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 1a6:	68a3      	ldr	r3, [r4, #8]
 1a8:	b1bb      	cbz	r3, 1da <HAL_RCC_OscConfig+0x1da>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 1aa:	f7ff fffe 	bl	0 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 1ae:	4d41      	ldr	r5, [pc, #260]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 1b0:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 1b2:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 1b6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 1b8:	079b      	lsls	r3, r3, #30
 1ba:	d508      	bpl.n	1ce <HAL_RCC_OscConfig+0x1ce>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 1bc:	69a2      	ldr	r2, [r4, #24]
 1be:	b9da      	cbnz	r2, 1f8 <HAL_RCC_OscConfig+0x1f8>
 1c0:	e059      	b.n	276 <HAL_RCC_OscConfig+0x276>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 1c2:	f7ff fffe 	bl	0 <HAL_GetTick>
 1c6:	1b80      	subs	r0, r0, r6
 1c8:	2802      	cmp	r0, #2
 1ca:	d9e6      	bls.n	19a <HAL_RCC_OscConfig+0x19a>
 1cc:	e74a      	b.n	64 <HAL_RCC_OscConfig+0x64>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 1ce:	f7ff fffe 	bl	0 <HAL_GetTick>
 1d2:	1b80      	subs	r0, r0, r6
 1d4:	42b8      	cmp	r0, r7
 1d6:	d9ee      	bls.n	1b6 <HAL_RCC_OscConfig+0x1b6>
 1d8:	e744      	b.n	64 <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 1da:	f7ff fffe 	bl	0 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 1de:	4d35      	ldr	r5, [pc, #212]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 1e0:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 1e2:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 1e6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 1e8:	0798      	lsls	r0, r3, #30
 1ea:	d5e7      	bpl.n	1bc <HAL_RCC_OscConfig+0x1bc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 1ec:	f7ff fffe 	bl	0 <HAL_GetTick>
 1f0:	1b80      	subs	r0, r0, r6
 1f2:	42b8      	cmp	r0, r7
 1f4:	d9f7      	bls.n	1e6 <HAL_RCC_OscConfig+0x1e6>
 1f6:	e735      	b.n	64 <HAL_RCC_OscConfig+0x64>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 1f8:	4d2e      	ldr	r5, [pc, #184]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
 1fa:	68ab      	ldr	r3, [r5, #8]
 1fc:	f003 030c 	and.w	r3, r3, #12
 200:	2b08      	cmp	r3, #8
 202:	f43f af1c 	beq.w	3e <HAL_RCC_OscConfig+0x3e>
 206:	4e31      	ldr	r6, [pc, #196]	; (2cc <HAL_RCC_OscConfig+0x2cc>)
 208:	2300      	movs	r3, #0
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 20a:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 20c:	6033      	str	r3, [r6, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 20e:	d141      	bne.n	294 <HAL_RCC_OscConfig+0x294>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 210:	f7ff fffe 	bl	0 <HAL_GetTick>
 214:	4680      	mov	r8, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 216:	682b      	ldr	r3, [r5, #0]
 218:	4f26      	ldr	r7, [pc, #152]	; (2b4 <HAL_RCC_OscConfig+0x2b4>)
 21a:	0199      	lsls	r1, r3, #6
 21c:	d42d      	bmi.n	27a <HAL_RCC_OscConfig+0x27a>
 21e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 222:	fa92 f2a2 	rbit	r2, r2
 226:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 22a:	fab2 fe82 	clz	lr, r2
 22e:	fa93 f3a3 	rbit	r3, r3
 232:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 236:	fab3 f583 	clz	r5, r3
 23a:	fa92 f2a2 	rbit	r2, r2
 23e:	69e0      	ldr	r0, [r4, #28]
 240:	6a23      	ldr	r3, [r4, #32]
 242:	fab2 f182 	clz	r1, r2
 246:	6a62      	ldr	r2, [r4, #36]	; 0x24
 248:	4303      	orrs	r3, r0
 24a:	fa02 f20e 	lsl.w	r2, r2, lr
 24e:	ea43 0002 	orr.w	r0, r3, r2
 252:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 254:	085a      	lsrs	r2, r3, #1
 256:	3a01      	subs	r2, #1
 258:	fa02 f305 	lsl.w	r3, r2, r5
 25c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 25e:	4303      	orrs	r3, r0
 260:	408a      	lsls	r2, r1
 262:	4313      	orrs	r3, r2
 264:	607b      	str	r3, [r7, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 266:	2301      	movs	r3, #1
 268:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 26a:	f7ff fffe 	bl	0 <HAL_GetTick>
 26e:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 270:	683b      	ldr	r3, [r7, #0]
 272:	019a      	lsls	r2, r3, #6
 274:	d508      	bpl.n	288 <HAL_RCC_OscConfig+0x288>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 276:	2000      	movs	r0, #0
 278:	e018      	b.n	2ac <HAL_RCC_OscConfig+0x2ac>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 27a:	f7ff fffe 	bl	0 <HAL_GetTick>
 27e:	ebc8 0000 	rsb	r0, r8, r0
 282:	2802      	cmp	r0, #2
 284:	d9c7      	bls.n	216 <HAL_RCC_OscConfig+0x216>
 286:	e6ed      	b.n	64 <HAL_RCC_OscConfig+0x64>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 288:	f7ff fffe 	bl	0 <HAL_GetTick>
 28c:	1b00      	subs	r0, r0, r4
 28e:	2802      	cmp	r0, #2
 290:	d9ee      	bls.n	270 <HAL_RCC_OscConfig+0x270>
 292:	e6e7      	b.n	64 <HAL_RCC_OscConfig+0x64>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 294:	f7ff fffe 	bl	0 <HAL_GetTick>
 298:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 29a:	682b      	ldr	r3, [r5, #0]
 29c:	019b      	lsls	r3, r3, #6
 29e:	d5ea      	bpl.n	276 <HAL_RCC_OscConfig+0x276>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 2a0:	f7ff fffe 	bl	0 <HAL_GetTick>
 2a4:	1b00      	subs	r0, r0, r4
 2a6:	2802      	cmp	r0, #2
 2a8:	d9f7      	bls.n	29a <HAL_RCC_OscConfig+0x29a>
 2aa:	e6db      	b.n	64 <HAL_RCC_OscConfig+0x64>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 2ac:	b002      	add	sp, #8
 2ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 2b2:	bf00      	nop
 2b4:	40023800 	.word	0x40023800
 2b8:	40023802 	.word	0x40023802
 2bc:	42470000 	.word	0x42470000
 2c0:	42470e80 	.word	0x42470e80
 2c4:	40007000 	.word	0x40007000
 2c8:	40023870 	.word	0x40023870
 2cc:	42470060 	.word	0x42470060

Disassembly of section .text.HAL_RCC_MCOConfig:

00000000 <HAL_RCC_MCOConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	b088      	sub	sp, #32
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	4616      	mov	r6, r2
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	4c1f      	ldr	r4, [pc, #124]	; (88 <HAL_RCC_MCOConfig+0x88>)
   a:	b9e0      	cbnz	r0, 46 <HAL_RCC_MCOConfig+0x46>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	9001      	str	r0, [sp, #4]
   e:	6b23      	ldr	r3, [r4, #48]	; 0x30
  10:	f043 0301 	orr.w	r3, r3, #1
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	6323      	str	r3, [r4, #48]	; 0x30
  16:	6b23      	ldr	r3, [r4, #48]	; 0x30
  18:	9005      	str	r0, [sp, #20]
  1a:	f003 0301 	and.w	r3, r3, #1
  1e:	9301      	str	r3, [sp, #4]
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	9b01      	ldr	r3, [sp, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  22:	9007      	str	r0, [sp, #28]
  24:	f44f 7380 	mov.w	r3, #256	; 0x100
  28:	9303      	str	r3, [sp, #12]
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  2a:	2302      	movs	r3, #2
  2c:	9304      	str	r3, [sp, #16]
  2e:	a903      	add	r1, sp, #12
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  30:	2303      	movs	r3, #3
  32:	4816      	ldr	r0, [pc, #88]	; (8c <HAL_RCC_MCOConfig+0x8c>)
  34:	9306      	str	r3, [sp, #24]
  36:	f7ff fffe 	bl	0 <HAL_GPIO_Init>
  3a:	68a1      	ldr	r1, [r4, #8]
  3c:	f021 61ec 	bic.w	r1, r1, #123731968	; 0x7600000
      {
        return HAL_ERROR;
  40:	4331      	orrs	r1, r6
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  42:	4329      	orrs	r1, r5
  44:	e01d      	b.n	82 <HAL_RCC_MCOConfig+0x82>
  46:	2300      	movs	r3, #0
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
  48:	9302      	str	r3, [sp, #8]
  4a:	6b22      	ldr	r2, [r4, #48]	; 0x30
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  4c:	4810      	ldr	r0, [pc, #64]	; (90 <HAL_RCC_MCOConfig+0x90>)
  4e:	f042 0204 	orr.w	r2, r2, #4
  52:	6322      	str	r2, [r4, #48]	; 0x30
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  54:	6b22      	ldr	r2, [r4, #48]	; 0x30
  56:	9305      	str	r3, [sp, #20]
  58:	f002 0204 	and.w	r2, r2, #4
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  5c:	9202      	str	r2, [sp, #8]
  5e:	9a02      	ldr	r2, [sp, #8]
  60:	9307      	str	r3, [sp, #28]
  62:	f44f 7200 	mov.w	r2, #512	; 0x200
          {
            return HAL_TIMEOUT;
  66:	9203      	str	r2, [sp, #12]
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  68:	2202      	movs	r2, #2
  6a:	9204      	str	r2, [sp, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  6c:	a903      	add	r1, sp, #12
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  6e:	2203      	movs	r2, #3

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  70:	9206      	str	r2, [sp, #24]
  72:	f7ff fffe 	bl	0 <HAL_GPIO_Init>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  76:	68a3      	ldr	r3, [r4, #8]
  78:	ea45 01c6 	orr.w	r1, r5, r6, lsl #3
  7c:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
  80:	4319      	orrs	r1, r3
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  82:	60a1      	str	r1, [r4, #8]
  84:	b008      	add	sp, #32
  86:	bd70      	pop	{r4, r5, r6, pc}
  88:	40023800 	.word	0x40023800
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  8c:	40020000 	.word	0x40020000
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  90:	40020800 	.word	0x40020800

Disassembly of section .text.HAL_RCC_EnableCSS:

00000000 <HAL_RCC_EnableCSS>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <HAL_RCC_EnableCSS+0x8>)
   2:	2201      	movs	r2, #1
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	601a      	str	r2, [r3, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	4770      	bx	lr
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	4247004c 	.word	0x4247004c

Disassembly of section .text.HAL_RCC_DisableCSS:

00000000 <HAL_RCC_DisableCSS>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <HAL_RCC_DisableCSS+0x8>)
   2:	2200      	movs	r2, #0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	601a      	str	r2, [r3, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	4770      	bx	lr
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	4247004c 	.word	0x4247004c

Disassembly of section .text.HAL_RCC_GetSysClockFreq:

00000000 <HAL_RCC_GetSysClockFreq>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	491b      	ldr	r1, [pc, #108]	; (70 <HAL_RCC_GetSysClockFreq+0x70>)
   2:	688b      	ldr	r3, [r1, #8]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	f003 030c 	and.w	r3, r3, #12
   8:	2b04      	cmp	r3, #4
   a:	d02c      	beq.n	66 <HAL_RCC_GetSysClockFreq+0x66>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	2b08      	cmp	r3, #8
   e:	d12c      	bne.n	6a <HAL_RCC_GetSysClockFreq+0x6a>
  10:	6848      	ldr	r0, [r1, #4]
  12:	684b      	ldr	r3, [r1, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	f000 003f 	and.w	r0, r0, #63	; 0x3f
  18:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
  1c:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	684b      	ldr	r3, [r1, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  22:	fa92 f2a2 	rbit	r2, r2
  26:	f647 71c0 	movw	r1, #32704	; 0x7fc0
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  2a:	fab2 f282 	clz	r2, r2
  2e:	ea01 0103 	and.w	r1, r1, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  32:	fa21 f102 	lsr.w	r1, r1, r2
  36:	bf14      	ite	ne
  38:	4a0e      	ldrne	r2, [pc, #56]	; (74 <HAL_RCC_GetSysClockFreq+0x74>)
  3a:	4a0f      	ldreq	r2, [pc, #60]	; (78 <HAL_RCC_GetSysClockFreq+0x78>)
  3c:	fbb2 f0f0 	udiv	r0, r2, r0
      {
        return HAL_ERROR;
  40:	4a0b      	ldr	r2, [pc, #44]	; (70 <HAL_RCC_GetSysClockFreq+0x70>)
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  42:	fb00 f301 	mul.w	r3, r0, r1
  46:	6852      	ldr	r2, [r2, #4]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
  48:	f44f 3040 	mov.w	r0, #196608	; 0x30000
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  4c:	fa90 f0a0 	rbit	r0, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  50:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  54:	fab0 f080 	clz	r0, r0
  58:	fa22 f000 	lsr.w	r0, r2, r0
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  5c:	3001      	adds	r0, #1
  5e:	0040      	lsls	r0, r0, #1
  60:	fbb3 f0f0 	udiv	r0, r3, r0
          {
            return HAL_TIMEOUT;
  64:	4770      	bx	lr
  66:	4803      	ldr	r0, [pc, #12]	; (74 <HAL_RCC_GetSysClockFreq+0x74>)
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  68:	4770      	bx	lr
  6a:	4803      	ldr	r0, [pc, #12]	; (78 <HAL_RCC_GetSysClockFreq+0x78>)

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  6c:	4770      	bx	lr
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  6e:	bf00      	nop

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  70:	40023800 	.word	0x40023800
  74:	00b71b00 	.word	0x00b71b00
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  78:	00f42400 	.word	0x00f42400

Disassembly of section .text.HAL_RCC_ClockConfig:

00000000 <HAL_RCC_ClockConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	4b55      	ldr	r3, [pc, #340]	; (15c <HAL_RCC_ClockConfig+0x15c>)
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	681a      	ldr	r2, [r3, #0]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	f002 020f 	and.w	r2, r2, #15
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	428a      	cmp	r2, r1
   e:	4605      	mov	r5, r0
  10:	460e      	mov	r6, r1
  12:	d30a      	bcc.n	2a <HAL_RCC_ClockConfig+0x2a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	682b      	ldr	r3, [r5, #0]
  16:	0798      	lsls	r0, r3, #30
  18:	d511      	bpl.n	3e <HAL_RCC_ClockConfig+0x3e>
  1a:	4951      	ldr	r1, [pc, #324]	; (160 <HAL_RCC_ClockConfig+0x160>)
  1c:	688b      	ldr	r3, [r1, #8]
  1e:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
  22:	68ab      	ldr	r3, [r5, #8]
  24:	4313      	orrs	r3, r2
  26:	608b      	str	r3, [r1, #8]
  28:	e009      	b.n	3e <HAL_RCC_ClockConfig+0x3e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  2a:	b2ca      	uxtb	r2, r1
  2c:	701a      	strb	r2, [r3, #0]
  2e:	681b      	ldr	r3, [r3, #0]
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  30:	f003 030f 	and.w	r3, r3, #15
  34:	4299      	cmp	r1, r3
  36:	d0ed      	beq.n	14 <HAL_RCC_ClockConfig+0x14>
  38:	2001      	movs	r0, #1
  3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      {
        return HAL_ERROR;
  3e:	682b      	ldr	r3, [r5, #0]
  40:	07d9      	lsls	r1, r3, #31
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  42:	d406      	bmi.n	52 <HAL_RCC_ClockConfig+0x52>
  44:	4b45      	ldr	r3, [pc, #276]	; (15c <HAL_RCC_ClockConfig+0x15c>)
  46:	681a      	ldr	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
  48:	f002 020f 	and.w	r2, r2, #15
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  4c:	4296      	cmp	r6, r2
  4e:	d351      	bcc.n	f4 <HAL_RCC_ClockConfig+0xf4>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  50:	e057      	b.n	102 <HAL_RCC_ClockConfig+0x102>
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  52:	686b      	ldr	r3, [r5, #4]
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  54:	4a42      	ldr	r2, [pc, #264]	; (160 <HAL_RCC_ClockConfig+0x160>)
  56:	2b01      	cmp	r3, #1
  58:	d103      	bne.n	62 <HAL_RCC_ClockConfig+0x62>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  5a:	6812      	ldr	r2, [r2, #0]
  5c:	f412 3f00 	tst.w	r2, #131072	; 0x20000
  60:	e008      	b.n	74 <HAL_RCC_ClockConfig+0x74>
  62:	1e99      	subs	r1, r3, #2
          {
            return HAL_TIMEOUT;
  64:	2901      	cmp	r1, #1
  66:	6812      	ldr	r2, [r2, #0]
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  68:	d802      	bhi.n	70 <HAL_RCC_ClockConfig+0x70>
  6a:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
  6e:	e001      	b.n	74 <HAL_RCC_ClockConfig+0x74>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  70:	f012 0f02 	tst.w	r2, #2
  74:	d0e0      	beq.n	38 <HAL_RCC_ClockConfig+0x38>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  76:	4c3a      	ldr	r4, [pc, #232]	; (160 <HAL_RCC_ClockConfig+0x160>)
  78:	68a2      	ldr	r2, [r4, #8]
  7a:	f022 0203 	bic.w	r2, r2, #3
  7e:	4313      	orrs	r3, r2
  80:	60a3      	str	r3, [r4, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  82:	f7ff fffe 	bl	0 <HAL_GetTick>
  86:	686b      	ldr	r3, [r5, #4]
  88:	2b01      	cmp	r3, #1
  8a:	4607      	mov	r7, r0
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  8c:	f241 3888 	movw	r8, #5000	; 0x1388
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  90:	d10c      	bne.n	ac <HAL_RCC_ClockConfig+0xac>
  92:	68a3      	ldr	r3, [r4, #8]
  94:	f003 030c 	and.w	r3, r3, #12
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  98:	2b04      	cmp	r3, #4
  9a:	d0d3      	beq.n	44 <HAL_RCC_ClockConfig+0x44>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  9c:	f7ff fffe 	bl	0 <HAL_GetTick>
  a0:	1bc0      	subs	r0, r0, r7
  a2:	4540      	cmp	r0, r8
  a4:	d9f5      	bls.n	92 <HAL_RCC_ClockConfig+0x92>
  a6:	2003      	movs	r0, #3
  a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  ac:	2b02      	cmp	r3, #2
  ae:	d10a      	bne.n	c6 <HAL_RCC_ClockConfig+0xc6>
  b0:	68a3      	ldr	r3, [r4, #8]
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  b2:	f003 030c 	and.w	r3, r3, #12
  b6:	2b08      	cmp	r3, #8
  b8:	d0c4      	beq.n	44 <HAL_RCC_ClockConfig+0x44>
  ba:	f7ff fffe 	bl	0 <HAL_GetTick>
  be:	1bc0      	subs	r0, r0, r7
  c0:	4540      	cmp	r0, r8
  c2:	d9f5      	bls.n	b0 <HAL_RCC_ClockConfig+0xb0>
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  c4:	e7ef      	b.n	a6 <HAL_RCC_ClockConfig+0xa6>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
  c6:	2b03      	cmp	r3, #3
  c8:	d10f      	bne.n	ea <HAL_RCC_ClockConfig+0xea>
  ca:	68a3      	ldr	r3, [r4, #8]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
  cc:	f003 030c 	and.w	r3, r3, #12

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  d0:	2b0c      	cmp	r3, #12
  d2:	d0b7      	beq.n	44 <HAL_RCC_ClockConfig+0x44>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  d4:	f7ff fffe 	bl	0 <HAL_GetTick>
  d8:	1bc0      	subs	r0, r0, r7
  da:	4540      	cmp	r0, r8
  dc:	d9f5      	bls.n	ca <HAL_RCC_ClockConfig+0xca>
  de:	e7e2      	b.n	a6 <HAL_RCC_ClockConfig+0xa6>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
  e0:	f7ff fffe 	bl	0 <HAL_GetTick>
  e4:	1bc0      	subs	r0, r0, r7
  e6:	4540      	cmp	r0, r8
  e8:	d8dd      	bhi.n	a6 <HAL_RCC_ClockConfig+0xa6>
  ea:	68a3      	ldr	r3, [r4, #8]
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  ec:	f013 0f0c 	tst.w	r3, #12
  f0:	d1f6      	bne.n	e0 <HAL_RCC_ClockConfig+0xe0>
  f2:	e7a7      	b.n	44 <HAL_RCC_ClockConfig+0x44>
  f4:	b2f2      	uxtb	r2, r6
  f6:	701a      	strb	r2, [r3, #0]
  f8:	681b      	ldr	r3, [r3, #0]
  fa:	f003 030f 	and.w	r3, r3, #15
  fe:	429e      	cmp	r6, r3
 100:	d19a      	bne.n	38 <HAL_RCC_ClockConfig+0x38>
 102:	682b      	ldr	r3, [r5, #0]
 104:	075a      	lsls	r2, r3, #29
 106:	d506      	bpl.n	116 <HAL_RCC_ClockConfig+0x116>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 108:	4915      	ldr	r1, [pc, #84]	; (160 <HAL_RCC_ClockConfig+0x160>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 10a:	688b      	ldr	r3, [r1, #8]
 10c:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 110:	68eb      	ldr	r3, [r5, #12]
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 112:	4313      	orrs	r3, r2
 114:	608b      	str	r3, [r1, #8]
 116:	682b      	ldr	r3, [r5, #0]
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 118:	071b      	lsls	r3, r3, #28
 11a:	d507      	bpl.n	12c <HAL_RCC_ClockConfig+0x12c>
 11c:	4a10      	ldr	r2, [pc, #64]	; (160 <HAL_RCC_ClockConfig+0x160>)
 11e:	6929      	ldr	r1, [r5, #16]
 120:	6893      	ldr	r3, [r2, #8]
 122:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 126:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 12a:	6093      	str	r3, [r2, #8]
 12c:	f7ff fffe 	bl	0 <HAL_RCC_ClockConfig>
 130:	4b0b      	ldr	r3, [pc, #44]	; (160 <HAL_RCC_ClockConfig+0x160>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 132:	22f0      	movs	r2, #240	; 0xf0
 134:	689b      	ldr	r3, [r3, #8]
 136:	fa92 f2a2 	rbit	r2, r2
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 13a:	fab2 f282 	clz	r2, r2
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 13e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 142:	40d3      	lsrs	r3, r2
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 144:	4a07      	ldr	r2, [pc, #28]	; (164 <HAL_RCC_ClockConfig+0x164>)
 146:	5cd3      	ldrb	r3, [r2, r3]
 148:	40d8      	lsrs	r0, r3
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 14a:	4b07      	ldr	r3, [pc, #28]	; (168 <HAL_RCC_ClockConfig+0x168>)
 14c:	6018      	str	r0, [r3, #0]
 14e:	2000      	movs	r0, #0
 150:	f7ff fffe 	bl	0 <HAL_InitTick>
 154:	2000      	movs	r0, #0
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 156:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 15a:	bf00      	nop
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 15c:	40023c00 	.word	0x40023c00
 160:	40023800 	.word	0x40023800
	...

Disassembly of section .text.HAL_RCC_GetHCLKFreq:

00000000 <HAL_RCC_GetHCLKFreq>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <HAL_RCC_GetHCLKFreq+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	4770      	bx	lr
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	bf00      	nop
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	00000000 	.word	0x00000000

Disassembly of section .text.HAL_RCC_GetPCLK1Freq:

00000000 <HAL_RCC_GetPCLK1Freq>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	4b08      	ldr	r3, [pc, #32]	; (24 <HAL_RCC_GetPCLK1Freq+0x24>)
   2:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
   6:	689b      	ldr	r3, [r3, #8]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	fa92 f2a2 	rbit	r2, r2
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	fab2 f282 	clz	r2, r2
  10:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	40d3      	lsrs	r3, r2
  16:	4a04      	ldr	r2, [pc, #16]	; (28 <HAL_RCC_GetPCLK1Freq+0x28>)
  18:	5cd3      	ldrb	r3, [r2, r3]
  1a:	4a04      	ldr	r2, [pc, #16]	; (2c <HAL_RCC_GetPCLK1Freq+0x2c>)
  1c:	6810      	ldr	r0, [r2, #0]
  1e:	40d8      	lsrs	r0, r3
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	4770      	bx	lr
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  22:	bf00      	nop
  24:	40023800 	.word	0x40023800
	...

Disassembly of section .text.HAL_RCC_GetPCLK2Freq:

00000000 <HAL_RCC_GetPCLK2Freq>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	4b08      	ldr	r3, [pc, #32]	; (24 <HAL_RCC_GetPCLK2Freq+0x24>)
   2:	f44f 4260 	mov.w	r2, #57344	; 0xe000
   6:	689b      	ldr	r3, [r3, #8]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	fa92 f2a2 	rbit	r2, r2
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	fab2 f282 	clz	r2, r2
  10:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	40d3      	lsrs	r3, r2
  16:	4a04      	ldr	r2, [pc, #16]	; (28 <HAL_RCC_GetPCLK2Freq+0x28>)
  18:	5cd3      	ldrb	r3, [r2, r3]
  1a:	4a04      	ldr	r2, [pc, #16]	; (2c <HAL_RCC_GetPCLK2Freq+0x2c>)
  1c:	6810      	ldr	r0, [r2, #0]
  1e:	40d8      	lsrs	r0, r3
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	4770      	bx	lr
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  22:	bf00      	nop
  24:	40023800 	.word	0x40023800
	...

Disassembly of section .text.HAL_RCC_GetOscConfig:

00000000 <HAL_RCC_GetOscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	b510      	push	{r4, lr}
   2:	230f      	movs	r3, #15
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	6003      	str	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	4b31      	ldr	r3, [pc, #196]	; (cc <HAL_RCC_GetOscConfig+0xcc>)
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	681a      	ldr	r2, [r3, #0]
   a:	0351      	lsls	r1, r2, #13
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	d501      	bpl.n	12 <HAL_RCC_GetOscConfig+0x12>
   e:	2205      	movs	r2, #5
  10:	e004      	b.n	1c <HAL_RCC_GetOscConfig+0x1c>
  12:	681a      	ldr	r2, [r3, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	f412 3280 	ands.w	r2, r2, #65536	; 0x10000
  18:	bf18      	it	ne
  1a:	2201      	movne	r2, #1
  1c:	6042      	str	r2, [r0, #4]
  1e:	681b      	ldr	r3, [r3, #0]
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	f013 0301 	ands.w	r3, r3, #1
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  24:	bf18      	it	ne
  26:	2301      	movne	r3, #1
  28:	60c3      	str	r3, [r0, #12]
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  2a:	4b28      	ldr	r3, [pc, #160]	; (cc <HAL_RCC_GetOscConfig+0xcc>)
  2c:	21f8      	movs	r1, #248	; 0xf8
  2e:	681a      	ldr	r2, [r3, #0]
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  30:	fa91 f1a1 	rbit	r1, r1
  34:	fab1 f181 	clz	r1, r1
  38:	f002 02f8 	and.w	r2, r2, #248	; 0xf8
  3c:	40ca      	lsrs	r2, r1
      {
        return HAL_ERROR;
  3e:	6102      	str	r2, [r0, #16]
  40:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  42:	0752      	lsls	r2, r2, #29
  44:	d501      	bpl.n	4a <HAL_RCC_GetOscConfig+0x4a>
  46:	2205      	movs	r2, #5
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
  48:	e004      	b.n	54 <HAL_RCC_GetOscConfig+0x54>
  4a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  4c:	f012 0201 	ands.w	r2, r2, #1
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  50:	bf18      	it	ne
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  52:	2201      	movne	r2, #1
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  54:	6082      	str	r2, [r0, #8]
  56:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  58:	4a1c      	ldr	r2, [pc, #112]	; (cc <HAL_RCC_GetOscConfig+0xcc>)
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  5a:	f013 0301 	ands.w	r3, r3, #1
  5e:	bf18      	it	ne
  60:	2301      	movne	r3, #1
  62:	6143      	str	r3, [r0, #20]
          {
            return HAL_TIMEOUT;
  64:	6813      	ldr	r3, [r2, #0]
  66:	01db      	lsls	r3, r3, #7
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  68:	bf4c      	ite	mi
  6a:	2302      	movmi	r3, #2

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  6c:	2301      	movpl	r3, #1
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  6e:	6183      	str	r3, [r0, #24]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  70:	6853      	ldr	r3, [r2, #4]
  72:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
  76:	61c3      	str	r3, [r0, #28]
  78:	6853      	ldr	r3, [r2, #4]
  7a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  7e:	6203      	str	r3, [r0, #32]
  80:	6854      	ldr	r4, [r2, #4]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
  82:	f647 73c0 	movw	r3, #32704	; 0x7fc0
  86:	fa93 f3a3 	rbit	r3, r3
  8a:	fab3 f183 	clz	r1, r3
  8e:	f647 73c0 	movw	r3, #32704	; 0x7fc0
  92:	4023      	ands	r3, r4
  94:	40cb      	lsrs	r3, r1
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  96:	6243      	str	r3, [r0, #36]	; 0x24
  98:	6853      	ldr	r3, [r2, #4]
  9a:	f44f 3140 	mov.w	r1, #196608	; 0x30000
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  9e:	fa91 f1a1 	rbit	r1, r1
  a2:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  a6:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  aa:	fab1 f181 	clz	r1, r1
  ae:	005b      	lsls	r3, r3, #1
  b0:	40cb      	lsrs	r3, r1
  b2:	6283      	str	r3, [r0, #40]	; 0x28
  b4:	6853      	ldr	r3, [r2, #4]
  b6:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
  ba:	fa92 f2a2 	rbit	r2, r2
  be:	fab2 f282 	clz	r2, r2
  c2:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
  c6:	40d3      	lsrs	r3, r2
  c8:	62c3      	str	r3, [r0, #44]	; 0x2c
  ca:	bd10      	pop	{r4, pc}
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
  cc:	40023800 	.word	0x40023800

Disassembly of section .text.HAL_RCC_GetClockConfig:

00000000 <HAL_RCC_GetClockConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	230f      	movs	r3, #15
   2:	6003      	str	r3, [r0, #0]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	4b0b      	ldr	r3, [pc, #44]	; (34 <HAL_RCC_GetClockConfig+0x34>)
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	689a      	ldr	r2, [r3, #8]
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	f002 0203 	and.w	r2, r2, #3
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   c:	6042      	str	r2, [r0, #4]
   e:	689a      	ldr	r2, [r3, #8]
  10:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	6082      	str	r2, [r0, #8]
  16:	689a      	ldr	r2, [r3, #8]
  18:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
  1c:	60c2      	str	r2, [r0, #12]
  1e:	689b      	ldr	r3, [r3, #8]
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  20:	08db      	lsrs	r3, r3, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  22:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
  26:	6103      	str	r3, [r0, #16]
  28:	4b03      	ldr	r3, [pc, #12]	; (38 <HAL_RCC_GetClockConfig+0x38>)
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  2a:	681b      	ldr	r3, [r3, #0]
  2c:	f003 030f 	and.w	r3, r3, #15
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  30:	600b      	str	r3, [r1, #0]
  32:	4770      	bx	lr
  34:	40023800 	.word	0x40023800
  38:	40023c00 	.word	0x40023c00

Disassembly of section .text.HAL_RCC_CSSCallback:

00000000 <HAL_RCC_CSSCallback>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   0:	4770      	bx	lr

Disassembly of section .text.HAL_RCC_NMI_IRQHandler:

00000000 <HAL_RCC_NMI_IRQHandler>:
   0:	b508      	push	{r3, lr}
   2:	4b05      	ldr	r3, [pc, #20]	; (18 <HAL_RCC_NMI_IRQHandler+0x18>)
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   4:	68db      	ldr	r3, [r3, #12]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
   6:	061b      	lsls	r3, r3, #24
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   8:	d504      	bpl.n	14 <HAL_RCC_NMI_IRQHandler+0x14>
   a:	f7ff fffe 	bl	0 <HAL_RCC_NMI_IRQHandler>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   e:	4b03      	ldr	r3, [pc, #12]	; (1c <HAL_RCC_NMI_IRQHandler+0x1c>)
  10:	2280      	movs	r2, #128	; 0x80
  12:	701a      	strb	r2, [r3, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
  14:	bd08      	pop	{r3, pc}
  16:	bf00      	nop
  18:	40023800 	.word	0x40023800
  1c:	4002380e 	.word	0x4002380e

usbd_core.o:     file format elf32-littlearm


Disassembly of section .text.USBD_Init:

00000000 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	b180      	cbz	r0, 26 <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
   8:	b113      	cbz	r3, 10 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
   a:	2300      	movs	r3, #0
   c:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	b109      	cbz	r1, 16 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
  12:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  16:	2301      	movs	r3, #1
  18:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
  1c:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  1e:	f7ff fffe 	bl	0 <USBD_LL_Init>
  
  return USBD_OK; 
  22:	2000      	movs	r0, #0
  24:	bd08      	pop	{r3, pc}
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  26:	2002      	movs	r0, #2
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}
  28:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_DeInit:

00000000 <USBD_DeInit>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b510      	push	{r4, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	2301      	movs	r3, #1
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
   8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  {
    pdev->pClass = NULL;
   c:	7901      	ldrb	r1, [r0, #4]
   e:	685b      	ldr	r3, [r3, #4]
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	4604      	mov	r4, r0
  {
    pdev->pDesc = pdesc;
  12:	4798      	blx	r3
  14:	4620      	mov	r0, r4
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  16:	f7ff fffe 	bl	0 <USBD_LL_Stop>
  1a:	4620      	mov	r0, r4
  pdev->id = id;
  1c:	f7ff fffe 	bl	0 <USBD_LL_DeInit>
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  20:	2000      	movs	r0, #0
  
  return USBD_OK; 
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.USBD_RegisterClass:

00000000 <USBD_RegisterClass>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b119      	cbz	r1, a <USBD_RegisterClass+0xa>
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	2000      	movs	r0, #0
   8:	4770      	bx	lr
  {
    pdev->pClass = NULL;
   a:	2002      	movs	r0, #2
   c:	4770      	bx	lr

Disassembly of section .text.USBD_Start:

00000000 <USBD_Start>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f7ff fffe 	bl	0 <USBD_LL_Start>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_Stop:

00000000 <USBD_Stop>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b510      	push	{r4, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	7901      	ldrb	r1, [r0, #4]
   8:	685b      	ldr	r3, [r3, #4]
  {
    pdev->pClass = NULL;
   a:	4604      	mov	r4, r0
   c:	4798      	blx	r3
   e:	4620      	mov	r0, r4
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	f7ff fffe 	bl	0 <USBD_LL_Stop>
  {
    pdev->pDesc = pdesc;
  14:	2000      	movs	r0, #0
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.USBD_RunTestMode:

00000000 <USBD_RunTestMode>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	2000      	movs	r0, #0
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	4770      	bx	lr

Disassembly of section .text.USBD_SetClassConfig:

00000000 <USBD_SetClassConfig>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	b90b      	cbnz	r3, c <USBD_SetClassConfig+0xc>
   8:	2002      	movs	r0, #2
  {
    pdev->pClass = NULL;
   a:	bd08      	pop	{r3, pc}
   c:	681b      	ldr	r3, [r3, #0]
   e:	4798      	blx	r3
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	2800      	cmp	r0, #0
  {
    pdev->pDesc = pdesc;
  12:	d1f9      	bne.n	8 <USBD_SetClassConfig+0x8>
  14:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_ClrClassConfig:

00000000 <USBD_ClrClassConfig>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	685b      	ldr	r3, [r3, #4]
   8:	4798      	blx	r3
  {
    pdev->pClass = NULL;
   a:	2000      	movs	r0, #0
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_SetupStage:

00000000 <USBD_LL_SetupStage>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b538      	push	{r3, r4, r5, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	4604      	mov	r4, r0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	f500 7502 	add.w	r5, r0, #520	; 0x208
   8:	4628      	mov	r0, r5
  {
    pdev->pClass = NULL;
   a:	f7ff fffe 	bl	0 <USBD_ParseSetupRequest>
   e:	2301      	movs	r3, #1
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
  {
    pdev->pDesc = pdesc;
  14:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  18:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
  pdev->id = id;
  1c:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  20:	f001 031f 	and.w	r3, r1, #31
  
  return USBD_OK; 
  24:	2b01      	cmp	r3, #1
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  26:	d00c      	beq.n	42 <USBD_LL_SetupStage+0x42>
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}
  28:	d306      	bcc.n	38 <USBD_LL_SetupStage+0x38>
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  2a:	2b02      	cmp	r3, #2
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  2c:	d10e      	bne.n	4c <USBD_LL_SetupStage+0x4c>
  2e:	4629      	mov	r1, r5
  30:	4620      	mov	r0, r4
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  32:	f7ff fffe 	bl	0 <USBD_StdEPReq>
  36:	e00e      	b.n	56 <USBD_LL_SetupStage+0x56>
  38:	4629      	mov	r1, r5
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  3a:	4620      	mov	r0, r4
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  3c:	f7ff fffe 	bl	0 <USBD_StdDevReq>
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
  40:	e009      	b.n	56 <USBD_LL_SetupStage+0x56>
  42:	4629      	mov	r1, r5
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <USBD_StdItfReq>
  
  return USBD_OK;
}
  4a:	e004      	b.n	56 <USBD_LL_SetupStage+0x56>
  4c:	f001 0180 	and.w	r1, r1, #128	; 0x80
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <USBD_LL_StallEP>
    status = USBD_OK;
  56:	2000      	movs	r0, #0
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  58:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.USBD_LL_DataOutStage:

00000000 <USBD_LL_DataOutStage>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b538      	push	{r3, r4, r5, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	4604      	mov	r4, r0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	4615      	mov	r5, r2
   6:	bb09      	cbnz	r1, 4c <USBD_LL_DataOutStage+0x4c>
   8:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
  {
    pdev->pClass = NULL;
   c:	2b03      	cmp	r3, #3
   e:	d126      	bne.n	5e <USBD_LL_DataOutStage+0x5e>
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
  {
    pdev->pDesc = pdesc;
  14:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  18:	4291      	cmp	r1, r2
  1a:	d90a      	bls.n	32 <USBD_LL_DataOutStage+0x32>
  pdev->id = id;
  1c:	1a8b      	subs	r3, r1, r2
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  1e:	429a      	cmp	r2, r3
  20:	bf28      	it	cs
  
  return USBD_OK; 
  22:	461a      	movcs	r2, r3
  24:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
}
  28:	b292      	uxth	r2, r2
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  2a:	4629      	mov	r1, r5
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  2c:	f7ff fffe 	bl	0 <USBD_CtlContinueRx>
  30:	e015      	b.n	5e <USBD_LL_DataOutStage+0x5e>
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  32:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  36:	691b      	ldr	r3, [r3, #16]
  38:	b123      	cbz	r3, 44 <USBD_LL_DataOutStage+0x44>
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  3a:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
  3e:	2a03      	cmp	r2, #3
  40:	d100      	bne.n	44 <USBD_LL_DataOutStage+0x44>
  42:	4798      	blx	r3
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <USBD_CtlSendStatus>
  
  return USBD_OK;
}
  4a:	e008      	b.n	5e <USBD_LL_DataOutStage+0x5e>
  4c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
  50:	699b      	ldr	r3, [r3, #24]
  52:	b123      	cbz	r3, 5e <USBD_LL_DataOutStage+0x5e>
    status = USBD_OK;
  54:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  58:	2a03      	cmp	r2, #3
  }
  
  return status;
}
  5a:	d100      	bne.n	5e <USBD_LL_DataOutStage+0x5e>
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
  5c:	4798      	blx	r3
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
  5e:	2000      	movs	r0, #0
  60:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.USBD_LL_DataInStage:

00000000 <USBD_LL_DataInStage>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b570      	push	{r4, r5, r6, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	4613      	mov	r3, r2
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	4604      	mov	r4, r0
   6:	460e      	mov	r6, r1
   8:	2900      	cmp	r1, #0
  {
    pdev->pClass = NULL;
   a:	d13c      	bne.n	86 <USBD_LL_DataInStage+0x86>
   c:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	2a02      	cmp	r2, #2
  {
    pdev->pDesc = pdesc;
  12:	d130      	bne.n	76 <USBD_LL_DataInStage+0x76>
  14:	69c5      	ldr	r5, [r0, #28]
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  16:	6a02      	ldr	r2, [r0, #32]
  18:	4295      	cmp	r5, r2
  1a:	d907      	bls.n	2c <USBD_LL_DataInStage+0x2c>
  pdev->id = id;
  1c:	1aaa      	subs	r2, r5, r2
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  1e:	61c2      	str	r2, [r0, #28]
  20:	4619      	mov	r1, r3
  
  return USBD_OK; 
  22:	b292      	uxth	r2, r2
  24:	f7ff fffe 	bl	0 <USBD_CtlContinueSendData>
}
  28:	4633      	mov	r3, r6
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  2a:	e011      	b.n	50 <USBD_LL_DataInStage+0x50>
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  2c:	6983      	ldr	r3, [r0, #24]
  2e:	fbb3 f5f2 	udiv	r5, r3, r2
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  32:	fb02 3515 	mls	r5, r2, r5, r3
  36:	b98d      	cbnz	r5, 5c <USBD_LL_DataInStage+0x5c>
  38:	429a      	cmp	r2, r3
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  3a:	d80f      	bhi.n	5c <USBD_LL_DataInStage+0x5c>
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  3c:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
  40:	4293      	cmp	r3, r2
  42:	d20b      	bcs.n	5c <USBD_LL_DataInStage+0x5c>
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
  44:	462a      	mov	r2, r5
  46:	f7ff fffe 	bl	0 <USBD_CtlContinueSendData>
  
  return USBD_OK;
}
  4a:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
  4e:	462b      	mov	r3, r5
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
  50:	461a      	mov	r2, r3
  52:	4619      	mov	r1, r3
    status = USBD_OK;
  54:	4620      	mov	r0, r4
  56:	f7ff fffe 	bl	0 <USBD_LL_PrepareReceive>
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  }
  
  return status;
}
  5a:	e00c      	b.n	76 <USBD_LL_DataInStage+0x76>
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
  5c:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
  60:	68db      	ldr	r3, [r3, #12]
  
  return USBD_OK;  
}
  62:	b12b      	cbz	r3, 70 <USBD_LL_DataInStage+0x70>
  64:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  68:	2a03      	cmp	r2, #3
  6a:	d101      	bne.n	70 <USBD_LL_DataInStage+0x70>
  6c:	4620      	mov	r0, r4
  6e:	4798      	blx	r3
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
  70:	4620      	mov	r0, r4
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  72:	f7ff fffe 	bl	0 <USBD_CtlReceiveStatus>

  /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
  76:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
  
  return USBD_OK;  
}
  7a:	2b01      	cmp	r3, #1
  7c:	d10c      	bne.n	98 <USBD_LL_DataInStage+0x98>
  7e:	2300      	movs	r3, #0
  80:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
  84:	e008      	b.n	98 <USBD_LL_DataInStage+0x98>
  86:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
  8a:	695b      	ldr	r3, [r3, #20]
  8c:	b123      	cbz	r3, 98 <USBD_LL_DataInStage+0x98>
  
  if(pdev->pClass != NULL)
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
  8e:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  92:	2a03      	cmp	r2, #3
  94:	d100      	bne.n	98 <USBD_LL_DataInStage+0x98>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
  96:	4798      	blx	r3
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  98:	2000      	movs	r0, #0
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
  9a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.USBD_LL_Reset:

00000000 <USBD_LL_Reset>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b538      	push	{r3, r4, r5, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	2200      	movs	r2, #0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	4604      	mov	r4, r0
   6:	4611      	mov	r1, r2
   8:	2540      	movs	r5, #64	; 0x40
  {
    pdev->pClass = NULL;
   a:	2340      	movs	r3, #64	; 0x40
   c:	f7ff fffe 	bl	0 <USBD_LL_OpenEP>
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	462b      	mov	r3, r5
  {
    pdev->pDesc = pdesc;
  12:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  16:	2200      	movs	r2, #0
  18:	2180      	movs	r1, #128	; 0x80
  1a:	4620      	mov	r0, r4
  pdev->id = id;
  1c:	f7ff fffe 	bl	0 <USBD_LL_OpenEP>
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  20:	2301      	movs	r3, #1
  
  return USBD_OK; 
  22:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  26:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  2a:	6225      	str	r5, [r4, #32]
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  2c:	b12b      	cbz	r3, 3a <USBD_LL_Reset+0x3a>
  2e:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  32:	7921      	ldrb	r1, [r4, #4]
  34:	685b      	ldr	r3, [r3, #4]
  36:	4620      	mov	r0, r4
  38:	4798      	blx	r3
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  3a:	2000      	movs	r0, #0
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
  3c:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.USBD_LL_SetSpeed:

00000000 <USBD_LL_SetSpeed>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	7401      	strb	r1, [r0, #16]
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	2000      	movs	r0, #0
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	4770      	bx	lr

Disassembly of section .text.USBD_LL_Suspend:

00000000 <USBD_LL_Suspend>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
   8:	2304      	movs	r3, #4
  {
    pdev->pClass = NULL;
   a:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
   e:	2000      	movs	r0, #0
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	4770      	bx	lr

Disassembly of section .text.USBD_LL_Resume:

00000000 <USBD_LL_Resume>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
   8:	2000      	movs	r0, #0
  {
    pdev->pClass = NULL;
   a:	4770      	bx	lr

Disassembly of section .text.USBD_LL_SOF:

00000000 <USBD_LL_SOF>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	2a03      	cmp	r2, #3
   8:	d104      	bne.n	14 <USBD_LL_SOF+0x14>
  {
    pdev->pClass = NULL;
   a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
   e:	69db      	ldr	r3, [r3, #28]
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	b103      	cbz	r3, 14 <USBD_LL_SOF+0x14>
  {
    pdev->pDesc = pdesc;
  12:	4798      	blx	r3
  14:	2000      	movs	r0, #0
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  16:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_IsoINIncomplete:

00000000 <USBD_LL_IsoINIncomplete>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	6a1b      	ldr	r3, [r3, #32]
   8:	4798      	blx	r3
  {
    pdev->pClass = NULL;
   a:	2000      	movs	r0, #0
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_IsoOUTIncomplete:

00000000 <USBD_LL_IsoOUTIncomplete>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8:	4798      	blx	r3
  {
    pdev->pClass = NULL;
   a:	2000      	movs	r0, #0
   c:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_LL_DevConnected:

00000000 <USBD_LL_DevConnected>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	2000      	movs	r0, #0
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	4770      	bx	lr

Disassembly of section .text.USBD_LL_DevDisconnected:

00000000 <USBD_LL_DevDisconnected>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
   0:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
   2:	2201      	movs	r2, #1
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
   4:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
   8:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
  {
    pdev->pClass = NULL;
   c:	7901      	ldrb	r1, [r0, #4]
   e:	6852      	ldr	r2, [r2, #4]
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  10:	4790      	blx	r2
  {
    pdev->pDesc = pdesc;
  12:	2000      	movs	r0, #0
  14:	bd08      	pop	{r3, pc}

usbd_ctlreq.o:     file format elf32-littlearm


Disassembly of section .text.USBD_ParseSetupRequest:

00000000 <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
   0:	780b      	ldrb	r3, [r1, #0]
   2:	7003      	strb	r3, [r0, #0]
   4:	784b      	ldrb	r3, [r1, #1]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
   6:	7043      	strb	r3, [r0, #1]
   8:	78ca      	ldrb	r2, [r1, #3]
  req->wValue        = SWAPBYTE      (pdata +  2);
   a:	788b      	ldrb	r3, [r1, #2]
   c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  10:	8043      	strh	r3, [r0, #2]
  12:	794a      	ldrb	r2, [r1, #5]
  req->wIndex        = SWAPBYTE      (pdata +  4);
  14:	790b      	ldrb	r3, [r1, #4]
  16:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  1a:	8083      	strh	r3, [r0, #4]
  1c:	79ca      	ldrb	r2, [r1, #7]
  req->wLength       = SWAPBYTE      (pdata +  6);
  1e:	798b      	ldrb	r3, [r1, #6]
  20:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  24:	80c3      	strh	r3, [r0, #6]
  26:	4770      	bx	lr

Disassembly of section .text.USBD_CtlError:

00000000 <USBD_CtlError>:
   0:	b510      	push	{r4, lr}
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
   2:	2180      	movs	r1, #128	; 0x80
   4:	4604      	mov	r4, r0
  req->bRequest      = *(uint8_t *)  (pdata +  1);
   6:	f7ff fffe 	bl	0 <USBD_LL_StallEP>
  req->wValue        = SWAPBYTE      (pdata +  2);
   a:	4620      	mov	r0, r4
   c:	2100      	movs	r1, #0
   e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  12:	f7ff bffe 	b.w	0 <USBD_LL_StallEP>

Disassembly of section .text.USBD_StdDevReq:

00000000 <USBD_StdDevReq>:
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
   2:	784b      	ldrb	r3, [r1, #1]
   4:	4604      	mov	r4, r0
  req->bRequest      = *(uint8_t *)  (pdata +  1);
   6:	460d      	mov	r5, r1
   8:	2b09      	cmp	r3, #9
  req->wValue        = SWAPBYTE      (pdata +  2);
   a:	f200 80f9 	bhi.w	200 <USBD_StdDevReq+0x200>
   e:	e8df f013 	tbh	[pc, r3, lsl #1]
  12:	00cb      	.short	0x00cb
  req->wIndex        = SWAPBYTE      (pdata +  4);
  14:	00f700e2 	.word	0x00f700e2
  18:	00f700de 	.word	0x00f700de
  1c:	000a0075 	.word	0x000a0075
  req->wLength       = SWAPBYTE      (pdata +  6);
  20:	00bb00f7 	.word	0x00bb00f7
  24:	0091      	.short	0x0091
  26:	884b      	ldrh	r3, [r1, #2]
  28:	0a1a      	lsrs	r2, r3, #8
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  2a:	3a01      	subs	r2, #1
  USBD_LL_StallEP(pdev , 0x80);
  2c:	2a06      	cmp	r2, #6
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  2e:	f200 80e7 	bhi.w	200 <USBD_StdDevReq+0x200>
  USBD_LL_StallEP(pdev , 0x80);
  32:	e8df f012 	tbh	[pc, r2, lsl #1]
  USBD_LL_StallEP(pdev , 0);
  36:	0007      	.short	0x0007
}
  38:	0017000b 	.word	0x0017000b

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
  3c:	00e500e5 	.word	0x00e500e5
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
  40:	0047003c 	.word	0x0047003c
  44:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
  48:	681b      	ldr	r3, [r3, #0]
  4a:	e017      	b.n	7c <USBD_StdDevReq+0x7c>
  4c:	7c02      	ldrb	r2, [r0, #16]
  4e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  52:	b90a      	cbnz	r2, 58 <USBD_StdDevReq+0x58>
  54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  56:	e000      	b.n	5a <USBD_StdDevReq+0x5a>
  58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  5a:	f10d 0006 	add.w	r0, sp, #6
  5e:	4798      	blx	r3
  60:	2302      	movs	r3, #2
  62:	e03a      	b.n	da <USBD_StdDevReq+0xda>
  64:	b2db      	uxtb	r3, r3
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
  66:	2b05      	cmp	r3, #5
  68:	f200 80ca 	bhi.w	200 <USBD_StdDevReq+0x200>
  6c:	e8df f003 	tbb	[pc, r3]
  70:	130f0b03 	.word	0x130f0b03
  74:	1b17      	.short	0x1b17
  76:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
  7a:	685b      	ldr	r3, [r3, #4]
  7c:	7c20      	ldrb	r0, [r4, #16]
  7e:	f10d 0106 	add.w	r1, sp, #6
  82:	4798      	blx	r3
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
  84:	e02a      	b.n	dc <USBD_StdDevReq+0xdc>
  86:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
  8a:	689b      	ldr	r3, [r3, #8]
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
  8c:	e7f6      	b.n	7c <USBD_StdDevReq+0x7c>
  8e:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
  92:	68db      	ldr	r3, [r3, #12]
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
  94:	e7f2      	b.n	7c <USBD_StdDevReq+0x7c>
  96:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
  9a:	691b      	ldr	r3, [r3, #16]
  9c:	e7ee      	b.n	7c <USBD_StdDevReq+0x7c>
  9e:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
  a2:	695b      	ldr	r3, [r3, #20]
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
  a4:	e7ea      	b.n	7c <USBD_StdDevReq+0x7c>
  a6:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
  aa:	699b      	ldr	r3, [r3, #24]
  ac:	e7e6      	b.n	7c <USBD_StdDevReq+0x7c>
  ae:	7c03      	ldrb	r3, [r0, #16]
  b0:	2b00      	cmp	r3, #0
  b2:	f040 80a5 	bne.w	200 <USBD_StdDevReq+0x200>
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
  b6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  ba:	f10d 0006 	add.w	r0, sp, #6
  be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  c0:	4798      	blx	r3
  c2:	e00b      	b.n	dc <USBD_StdDevReq+0xdc>
  c4:	7c03      	ldrb	r3, [r0, #16]
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
  c6:	2b00      	cmp	r3, #0
  c8:	f040 809a 	bne.w	200 <USBD_StdDevReq+0x200>
  cc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
  d0:	f10d 0006 	add.w	r0, sp, #6
  d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
  d6:	4798      	blx	r3
  d8:	2307      	movs	r3, #7
  da:	7043      	strb	r3, [r0, #1]
  dc:	f8bd 2006 	ldrh.w	r2, [sp, #6]
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
  e0:	2a00      	cmp	r2, #0
  e2:	f000 8091 	beq.w	208 <USBD_StdDevReq+0x208>
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
  e6:	88eb      	ldrh	r3, [r5, #6]
  e8:	2b00      	cmp	r3, #0
  ea:	f000 808d 	beq.w	208 <USBD_StdDevReq+0x208>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
  ee:	429a      	cmp	r2, r3
  f0:	bf28      	it	cs
  f2:	461a      	movcs	r2, r3
  f4:	f8ad 2006 	strh.w	r2, [sp, #6]
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
  f8:	4601      	mov	r1, r0
  fa:	e064      	b.n	1c6 <USBD_StdDevReq+0x1c6>
  fc:	888b      	ldrh	r3, [r1, #4]
  fe:	2b00      	cmp	r3, #0
 100:	d17e      	bne.n	200 <USBD_StdDevReq+0x200>
 102:	88cb      	ldrh	r3, [r1, #6]
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 104:	2b00      	cmp	r3, #0
 106:	d17b      	bne.n	200 <USBD_StdDevReq+0x200>
 108:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 10c:	788e      	ldrb	r6, [r1, #2]
 10e:	2b03      	cmp	r3, #3
 110:	f006 067f 	and.w	r6, r6, #127	; 0x7f
 114:	d074      	beq.n	200 <USBD_StdDevReq+0x200>
 116:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 11a:	4631      	mov	r1, r6
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 11c:	f7ff fffe 	bl	0 <USBD_LL_SetUSBAddress>
 120:	4620      	mov	r0, r4
 122:	f7ff fffe 	bl	0 <USBD_CtlSendStatus>
 126:	b10e      	cbz	r6, 12c <USBD_StdDevReq+0x12c>
 128:	2302      	movs	r3, #2
 12a:	e000      	b.n	12e <USBD_StdDevReq+0x12e>
 12c:	2301      	movs	r3, #1
  {
    
    len = MIN(len , req->wLength);
 12e:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 132:	e069      	b.n	208 <USBD_StdDevReq+0x208>
 134:	7889      	ldrb	r1, [r1, #2]
 136:	4e36      	ldr	r6, [pc, #216]	; (210 <USBD_StdDevReq+0x210>)
    
    USBD_CtlSendData (pdev, 
 138:	2901      	cmp	r1, #1
 13a:	7031      	strb	r1, [r6, #0]
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 13c:	d860      	bhi.n	200 <USBD_StdDevReq+0x200>
 13e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 142:	2b02      	cmp	r3, #2
 144:	d002      	beq.n	14c <USBD_StdDevReq+0x14c>
 146:	2b03      	cmp	r3, #3
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 148:	d008      	beq.n	15c <USBD_StdDevReq+0x15c>
 14a:	e059      	b.n	200 <USBD_StdDevReq+0x200>
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 14c:	2900      	cmp	r1, #0
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 14e:	d053      	beq.n	1f8 <USBD_StdDevReq+0x1f8>
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 150:	2101      	movs	r1, #1
 152:	2303      	movs	r3, #3
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 154:	6041      	str	r1, [r0, #4]
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 156:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 15a:	e00f      	b.n	17c <USBD_StdDevReq+0x17c>
 15c:	b931      	cbnz	r1, 16c <USBD_StdDevReq+0x16c>
 15e:	2302      	movs	r3, #2
      USBD_CtlSendStatus(pdev);                         
 160:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
 164:	6041      	str	r1, [r0, #4]
      
      if (dev_addr != 0) 
 166:	f7ff fffe 	bl	0 <USBD_ClrClassConfig>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 16a:	e045      	b.n	1f8 <USBD_StdDevReq+0x1f8>
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 16c:	6841      	ldr	r1, [r0, #4]
 16e:	2901      	cmp	r1, #1
 170:	d042      	beq.n	1f8 <USBD_StdDevReq+0x1f8>
 172:	b2c9      	uxtb	r1, r1
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 174:	f7ff fffe 	bl	0 <USBD_ClrClassConfig>
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 178:	7831      	ldrb	r1, [r6, #0]
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 17a:	6061      	str	r1, [r4, #4]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 17c:	4620      	mov	r0, r4
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
 17e:	f7ff fffe 	bl	0 <USBD_SetClassConfig>
 182:	2802      	cmp	r0, #2
 184:	d138      	bne.n	1f8 <USBD_StdDevReq+0x1f8>
 186:	e03b      	b.n	200 <USBD_StdDevReq+0x200>
 188:	88ca      	ldrh	r2, [r1, #6]
 18a:	2a01      	cmp	r2, #1
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 18c:	d138      	bne.n	200 <USBD_StdDevReq+0x200>
 18e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
        pdev->dev_state = USBD_STATE_CONFIGURED;
 192:	2b02      	cmp	r3, #2
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 194:	d003      	beq.n	19e <USBD_StdDevReq+0x19e>
        pdev->dev_state = USBD_STATE_CONFIGURED;
 196:	2b03      	cmp	r3, #3
 198:	d132      	bne.n	200 <USBD_StdDevReq+0x200>
 19a:	1d01      	adds	r1, r0, #4
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 19c:	e013      	b.n	1c6 <USBD_StdDevReq+0x1c6>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 19e:	4601      	mov	r1, r0
 1a0:	2300      	movs	r3, #0
 1a2:	f841 3f08 	str.w	r3, [r1, #8]!
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
 1a6:	e00e      	b.n	1c6 <USBD_StdDevReq+0x1c6>
 1a8:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 1ac:	3b02      	subs	r3, #2
 1ae:	2b01      	cmp	r3, #1
 1b0:	d826      	bhi.n	200 <USBD_StdDevReq+0x200>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 1b2:	2301      	movs	r3, #1
 1b4:	60c3      	str	r3, [r0, #12]
 1b6:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 1ba:	b10b      	cbz	r3, 1c0 <USBD_StdDevReq+0x1c0>
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 1bc:	2303      	movs	r3, #3
 1be:	60c3      	str	r3, [r0, #12]
 1c0:	2202      	movs	r2, #2
 1c2:	f104 010c 	add.w	r1, r4, #12
 1c6:	4620      	mov	r0, r4
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
 1c8:	f7ff fffe 	bl	0 <USBD_CtlSendData>
 1cc:	e01c      	b.n	208 <USBD_StdDevReq+0x208>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
 1ce:	884b      	ldrh	r3, [r1, #2]
 1d0:	2b01      	cmp	r3, #1
 1d2:	d119      	bne.n	208 <USBD_StdDevReq+0x208>
 1d4:	e008      	b.n	1e8 <USBD_StdDevReq+0x1e8>
 1d6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
 1da:	3b02      	subs	r3, #2
 1dc:	2b01      	cmp	r3, #1
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 1de:	d80f      	bhi.n	200 <USBD_StdDevReq+0x200>
 1e0:	884b      	ldrh	r3, [r1, #2]
 1e2:	2b01      	cmp	r3, #1
 1e4:	d110      	bne.n	208 <USBD_StdDevReq+0x208>
 1e6:	2300      	movs	r3, #0
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
 1e8:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
 1ec:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 1f0:	4629      	mov	r1, r5
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 1f2:	689b      	ldr	r3, [r3, #8]
 1f4:	4620      	mov	r0, r4
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 1f6:	4798      	blx	r3
 1f8:	4620      	mov	r0, r4
 1fa:	f7ff fffe 	bl	0 <USBD_CtlSendStatus>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 1fe:	e003      	b.n	208 <USBD_StdDevReq+0x208>
    }
    
    USBD_CtlSendData (pdev, 
 200:	4629      	mov	r1, r5
 202:	4620      	mov	r0, r4
 204:	f7ff fffe 	bl	0 <USBD_StdDevReq>
 208:	2000      	movs	r0, #0
 20a:	b002      	add	sp, #8
 20c:	bd70      	pop	{r4, r5, r6, pc}
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 20e:	bf00      	nop
 210:	00000000 	.word	0x00000000

Disassembly of section .text.USBD_StdItfReq:

00000000 <USBD_StdItfReq>:
   0:	b538      	push	{r3, r4, r5, lr}
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
   2:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
  req->bRequest      = *(uint8_t *)  (pdata +  1);
   6:	2b03      	cmp	r3, #3
   8:	4604      	mov	r4, r0
  req->wValue        = SWAPBYTE      (pdata +  2);
   a:	460d      	mov	r5, r1
   c:	d10c      	bne.n	28 <USBD_StdItfReq+0x28>
   e:	790b      	ldrb	r3, [r1, #4]
  10:	2b01      	cmp	r3, #1
  12:	d809      	bhi.n	28 <USBD_StdItfReq+0x28>
  req->wIndex        = SWAPBYTE      (pdata +  4);
  14:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  18:	689b      	ldr	r3, [r3, #8]
  1a:	4798      	blx	r3
  1c:	88eb      	ldrh	r3, [r5, #6]
  req->wLength       = SWAPBYTE      (pdata +  6);
  1e:	b92b      	cbnz	r3, 2c <USBD_StdItfReq+0x2c>
  20:	4620      	mov	r0, r4
  22:	f7ff fffe 	bl	0 <USBD_CtlSendStatus>
  26:	e001      	b.n	6 <USBD_StdItfReq+0x6>
  28:	f7ff fffe 	bl	0 <USBD_StdItfReq>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  2c:	2000      	movs	r0, #0
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  2e:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.USBD_StdEPReq:

00000000 <USBD_StdEPReq>:
   0:	b570      	push	{r4, r5, r6, lr}
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
   2:	780a      	ldrb	r2, [r1, #0]
   4:	888e      	ldrh	r6, [r1, #4]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
   6:	f002 0260 	and.w	r2, r2, #96	; 0x60
  req->wValue        = SWAPBYTE      (pdata +  2);
   a:	2a20      	cmp	r2, #32
   c:	4604      	mov	r4, r0
   e:	460d      	mov	r5, r1
  10:	b2f3      	uxtb	r3, r6
  12:	d104      	bne.n	1e <USBD_StdEPReq+0x1e>
  req->wIndex        = SWAPBYTE      (pdata +  4);
  14:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  18:	689b      	ldr	r3, [r3, #8]
  1a:	4798      	blx	r3
  1c:	e051      	b.n	c2 <USBD_StdEPReq+0xc2>
  req->wLength       = SWAPBYTE      (pdata +  6);
  1e:	784a      	ldrb	r2, [r1, #1]
  20:	2a01      	cmp	r2, #1
  22:	d010      	beq.n	46 <USBD_StdEPReq+0x46>
  24:	d326      	bcc.n	74 <USBD_StdEPReq+0x74>
  26:	2a03      	cmp	r2, #3
  28:	d14b      	bne.n	c2 <USBD_StdEPReq+0xc2>
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  2a:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  2e:	2a02      	cmp	r2, #2
  USBD_LL_StallEP(pdev , 0x80);
  30:	d027      	beq.n	82 <USBD_StdEPReq+0x82>
  32:	2a03      	cmp	r2, #3
  USBD_LL_StallEP(pdev , 0);
  34:	d143      	bne.n	be <USBD_StdEPReq+0xbe>
  36:	884a      	ldrh	r2, [r1, #2]
}
  38:	b992      	cbnz	r2, 60 <USBD_StdEPReq+0x60>
  3a:	065e      	lsls	r6, r3, #25

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
  3c:	d010      	beq.n	60 <USBD_StdEPReq+0x60>
  3e:	4619      	mov	r1, r3
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
  40:	f7ff fffe 	bl	0 <USBD_LL_StallEP>
  44:	e00c      	b.n	60 <USBD_StdEPReq+0x60>
  46:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
  4a:	2a02      	cmp	r2, #2
  4c:	d019      	beq.n	82 <USBD_StdEPReq+0x82>
  4e:	2a03      	cmp	r2, #3
  50:	d135      	bne.n	be <USBD_StdEPReq+0xbe>
  52:	884a      	ldrh	r2, [r1, #2]
  54:	bbaa      	cbnz	r2, c2 <USBD_StdEPReq+0xc2>
  56:	0659      	lsls	r1, r3, #25
  58:	d008      	beq.n	6c <USBD_StdEPReq+0x6c>
  5a:	4619      	mov	r1, r3
  5c:	f7ff fffe 	bl	0 <USBD_LL_ClearStallEP>
  60:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
  64:	4629      	mov	r1, r5
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
  66:	689b      	ldr	r3, [r3, #8]
  68:	4620      	mov	r0, r4
  6a:	4798      	blx	r3
  6c:	4620      	mov	r0, r4
  6e:	f7ff fffe 	bl	0 <USBD_CtlSendStatus>
  72:	e026      	b.n	c2 <USBD_StdEPReq+0xc2>
  74:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  78:	2a02      	cmp	r2, #2
  7a:	d002      	beq.n	82 <USBD_StdEPReq+0x82>
  7c:	2a03      	cmp	r2, #3
  7e:	d006      	beq.n	8e <USBD_StdEPReq+0x8e>
  80:	e01d      	b.n	be <USBD_StdEPReq+0xbe>
  82:	065a      	lsls	r2, r3, #25
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
  84:	d01d      	beq.n	c2 <USBD_StdEPReq+0xc2>
  86:	4619      	mov	r1, r3
  88:	f7ff fffe 	bl	0 <USBD_LL_StallEP>
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
  8c:	e019      	b.n	c2 <USBD_StdEPReq+0xc2>
  8e:	f003 057f 	and.w	r5, r3, #127	; 0x7f
  92:	f016 0f80 	tst.w	r6, #128	; 0x80
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
  96:	eb00 1505 	add.w	r5, r0, r5, lsl #4
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
  9a:	4619      	mov	r1, r3
  9c:	bf14      	ite	ne
  9e:	3514      	addne	r5, #20
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
  a0:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
  a4:	f7ff fffe 	bl	0 <USBD_LL_IsStallEP>
  a8:	b110      	cbz	r0, b0 <USBD_StdEPReq+0xb0>
  aa:	2301      	movs	r3, #1
  ac:	602b      	str	r3, [r5, #0]
  ae:	e000      	b.n	b2 <USBD_StdEPReq+0xb2>
  b0:	6028      	str	r0, [r5, #0]
  b2:	2202      	movs	r2, #2
  b4:	4629      	mov	r1, r5
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
  b6:	4620      	mov	r0, r4
  b8:	f7ff fffe 	bl	0 <USBD_CtlSendData>
  bc:	e001      	b.n	6 <USBD_StdEPReq+0x6>
  be:	f7ff fffe 	bl	0 <USBD_StdEPReq>
  c2:	2000      	movs	r0, #0
  c4:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.USBD_GetString:

00000000 <USBD_GetString>:
   0:	b530      	push	{r4, r5, lr}
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
   2:	b1c0      	cbz	r0, 36 <USBD_GetString+0x36>
   4:	4605      	mov	r5, r0
  req->bRequest      = *(uint8_t *)  (pdata +  1);
   6:	1a2b      	subs	r3, r5, r0
   8:	f815 4b01 	ldrb.w	r4, [r5], #1
  req->wValue        = SWAPBYTE      (pdata +  2);
   c:	b2db      	uxtb	r3, r3
   e:	2c00      	cmp	r4, #0
  10:	d1f9      	bne.n	6 <USBD_GetString+0x6>
  12:	005b      	lsls	r3, r3, #1
  req->wIndex        = SWAPBYTE      (pdata +  4);
  14:	3302      	adds	r3, #2
  16:	8013      	strh	r3, [r2, #0]
  18:	700b      	strb	r3, [r1, #0]
  1a:	2303      	movs	r3, #3
  1c:	704b      	strb	r3, [r1, #1]
  req->wLength       = SWAPBYTE      (pdata +  6);
  1e:	3801      	subs	r0, #1
  20:	2302      	movs	r3, #2
  22:	f810 5f01 	ldrb.w	r5, [r0, #1]!
  26:	b135      	cbz	r5, 36 <USBD_GetString+0x36>
  28:	1c5a      	adds	r2, r3, #1
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  2a:	b2d2      	uxtb	r2, r2
  USBD_LL_StallEP(pdev , 0x80);
  2c:	54cd      	strb	r5, [r1, r3]
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  2e:	3302      	adds	r3, #2
  USBD_LL_StallEP(pdev , 0x80);
  30:	b2db      	uxtb	r3, r3
  32:	548c      	strb	r4, [r1, r2]
  USBD_LL_StallEP(pdev , 0);
  34:	e7f5      	b.n	22 <USBD_GetString+0x22>
  36:	bd30      	pop	{r4, r5, pc}

usbd_ioreq.o:     file format elf32-littlearm


Disassembly of section .text.USBD_CtlSendData:

00000000 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b510      	push	{r4, lr}
   2:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   4:	2202      	movs	r2, #2
   6:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
   a:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
   c:	460a      	mov	r2, r1
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
   e:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
  10:	2100      	movs	r1, #0
  12:	f7ff fffe 	bl	0 <USBD_LL_Transmit>
  
  return USBD_OK;
}
  16:	2000      	movs	r0, #0
  18:	bd10      	pop	{r4, pc}

Disassembly of section .text.USBD_CtlContinueSendData:

00000000 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b508      	push	{r3, lr}
   2:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   4:	460a      	mov	r2, r1
   6:	2100      	movs	r1, #0
   8:	f7ff fffe 	bl	0 <USBD_LL_Transmit>
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
   c:	2000      	movs	r0, #0
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
   e:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_CtlPrepareRx:

00000000 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b510      	push	{r4, lr}
   2:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   4:	2203      	movs	r2, #3
   6:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
   a:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_in[0].rem_length   = len;
   e:	460a      	mov	r2, r1
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
  10:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  14:	2100      	movs	r1, #0
  
  return USBD_OK;
}
  16:	f7ff fffe 	bl	0 <USBD_LL_PrepareReceive>
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
  1a:	2000      	movs	r0, #0
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
  1c:	bd10      	pop	{r4, pc}

Disassembly of section .text.USBD_CtlContinueRx:

00000000 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b508      	push	{r3, lr}
   2:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   4:	460a      	mov	r2, r1
   6:	2100      	movs	r1, #0
   8:	f7ff fffe 	bl	0 <USBD_LL_PrepareReceive>
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
   c:	2000      	movs	r0, #0
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
   e:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_CtlSendStatus:

00000000 <USBD_CtlSendStatus>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b508      	push	{r3, lr}
   2:	2304      	movs	r3, #4
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   4:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
   8:	2300      	movs	r3, #0
  pdev->ep_in[0].total_length = len;
   a:	461a      	mov	r2, r3
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
   c:	4619      	mov	r1, r3
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
   e:	f7ff fffe 	bl	0 <USBD_LL_Transmit>
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
  12:	2000      	movs	r0, #0
  14:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_CtlReceiveStatus:

00000000 <USBD_CtlReceiveStatus>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b508      	push	{r3, lr}
   2:	2305      	movs	r3, #5
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   4:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
   8:	2300      	movs	r3, #0
  pdev->ep_in[0].total_length = len;
   a:	461a      	mov	r2, r3
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
   c:	4619      	mov	r1, r3
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
   e:	f7ff fffe 	bl	0 <USBD_LL_PrepareReceive>
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
  12:	2000      	movs	r0, #0
  14:	bd08      	pop	{r3, pc}

Disassembly of section .text.USBD_GetRxCount:

00000000 <USBD_GetRxCount>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
   0:	b508      	push	{r3, lr}
   2:	f7ff fffe 	bl	0 <USBD_LL_GetRxDataSize>
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
   6:	b280      	uxth	r0, r0
   8:	bd08      	pop	{r3, pc}

usbd_audio.o:     file format elf32-littlearm


Disassembly of section .text.USBD_AUDIO_GetCfgDesc:

00000000 <USBD_AUDIO_GetCfgDesc>:
 * @param  length : pointer data length
 * @retval pointer to descriptor buffer
 */
static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_AUDIO_CfgDesc);
   0:	f240 23db 	movw	r3, #731	; 0x2db
   4:	8003      	strh	r3, [r0, #0]
   6:	4801      	ldr	r0, [pc, #4]	; (c <USBD_AUDIO_GetCfgDesc+0xc>)
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	00000000 	.word	0x00000000

Disassembly of section .text.USBD_AUDIO_DataIn:

00000000 <USBD_AUDIO_DataIn>:
   0:	4a03      	ldr	r2, [pc, #12]	; (10 <USBD_AUDIO_DataIn+0x10>)
   2:	4b04      	ldr	r3, [pc, #16]	; (14 <USBD_AUDIO_DataIn+0x14>)
   4:	2000      	movs	r0, #0
   6:	7018      	strb	r0, [r3, #0]
   8:	6813      	ldr	r3, [r2, #0]
   a:	3301      	adds	r3, #1
   c:	6013      	str	r3, [r2, #0]
   e:	4770      	bx	lr
	...

Disassembly of section .text.USBD_AUDIO_EP0_RxReady:

00000000 <USBD_AUDIO_EP0_RxReady>:
   0:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
   4:	781a      	ldrb	r2, [r3, #0]
   6:	2a81      	cmp	r2, #129	; 0x81
   8:	d107      	bne.n	1a <USBD_AUDIO_EP0_RxReady+0x1a>
   a:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   e:	2a02      	cmp	r2, #2
  10:	bf02      	ittt	eq
  12:	2200      	moveq	r2, #0
  14:	701a      	strbeq	r2, [r3, #0]
  16:	f883 2041 	strbeq.w	r2, [r3, #65]	; 0x41
  1a:	2000      	movs	r0, #0
  1c:	4770      	bx	lr

Disassembly of section .text.USBD_AUDIO_EP0_TxReady:

00000000 <USBD_AUDIO_EP0_TxReady>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.USBD_AUDIO_IsoOutIncomplete:

00000000 <USBD_AUDIO_IsoOutIncomplete>:
   0:	4a02      	ldr	r2, [pc, #8]	; (c <USBD_AUDIO_IsoOutIncomplete+0xc>)
   2:	68d3      	ldr	r3, [r2, #12]
   4:	3301      	adds	r3, #1
   6:	60d3      	str	r3, [r2, #12]
   8:	2000      	movs	r0, #0
   a:	4770      	bx	lr
   c:	00000000 	.word	0x00000000

Disassembly of section .text.USBD_AUDIO_GetDeviceQualifierDesc:

00000000 <USBD_AUDIO_GetDeviceQualifierDesc>:
   0:	230a      	movs	r3, #10
   2:	8003      	strh	r3, [r0, #0]
   4:	4800      	ldr	r0, [pc, #0]	; (8 <USBD_AUDIO_GetDeviceQualifierDesc+0x8>)
   6:	4770      	bx	lr
   8:	000002dc 	.word	0x000002dc

Disassembly of section .text.USBD_AUDIO_SOF:

00000000 <USBD_AUDIO_SOF>:
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4a26      	ldr	r2, [pc, #152]	; (9c <USBD_AUDIO_SOF+0x9c>)
   4:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
   8:	681d      	ldr	r5, [r3, #0]
   a:	6913      	ldr	r3, [r2, #16]
   c:	3301      	adds	r3, #1
   e:	6113      	str	r3, [r2, #16]
  10:	4b23      	ldr	r3, [pc, #140]	; (a0 <USBD_AUDIO_SOF+0xa0>)
  12:	6859      	ldr	r1, [r3, #4]
  14:	4616      	mov	r6, r2
  16:	2900      	cmp	r1, #0
  18:	d03e      	beq.n	98 <USBD_AUDIO_SOF+0x98>
  1a:	4a22      	ldr	r2, [pc, #136]	; (a4 <USBD_AUDIO_SOF+0xa4>)
  1c:	6892      	ldr	r2, [r2, #8]
  1e:	2a04      	cmp	r2, #4
  20:	d906      	bls.n	30 <USBD_AUDIO_SOF+0x30>
  22:	4a21      	ldr	r2, [pc, #132]	; (a8 <USBD_AUDIO_SOF+0xa8>)
  24:	6892      	ldr	r2, [r2, #8]
  26:	2a04      	cmp	r2, #4
  28:	bf8c      	ite	hi
  2a:	2200      	movhi	r2, #0
  2c:	2201      	movls	r2, #1
  2e:	e000      	b.n	32 <USBD_AUDIO_SOF+0x32>
  30:	2201      	movs	r2, #1
  32:	685c      	ldr	r4, [r3, #4]
  34:	4f1d      	ldr	r7, [pc, #116]	; (ac <USBD_AUDIO_SOF+0xac>)
  36:	491a      	ldr	r1, [pc, #104]	; (a0 <USBD_AUDIO_SOF+0xa0>)
  38:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  3c:	4422      	add	r2, r4
  3e:	eb07 0282 	add.w	r2, r7, r2, lsl #2
  42:	6952      	ldr	r2, [r2, #20]
  44:	609a      	str	r2, [r3, #8]
  46:	689a      	ldr	r2, [r3, #8]
  48:	6172      	str	r2, [r6, #20]
  4a:	685a      	ldr	r2, [r3, #4]
  4c:	61f2      	str	r2, [r6, #28]
  4e:	68da      	ldr	r2, [r3, #12]
  50:	3201      	adds	r2, #1
  52:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  56:	60da      	str	r2, [r3, #12]
  58:	d10c      	bne.n	74 <USBD_AUDIO_SOF+0x74>
  5a:	684a      	ldr	r2, [r1, #4]
  5c:	241c      	movs	r4, #28
  5e:	fb04 7402 	mla	r4, r4, r2, r7
  62:	690a      	ldr	r2, [r1, #16]
  64:	6924      	ldr	r4, [r4, #16]
  66:	fbb2 f2f4 	udiv	r2, r2, r4
  6a:	4c0c      	ldr	r4, [pc, #48]	; (9c <USBD_AUDIO_SOF+0x9c>)
  6c:	61a2      	str	r2, [r4, #24]
  6e:	2200      	movs	r2, #0
  70:	610a      	str	r2, [r1, #16]
  72:	60ca      	str	r2, [r1, #12]
  74:	781b      	ldrb	r3, [r3, #0]
  76:	4c0a      	ldr	r4, [pc, #40]	; (a0 <USBD_AUDIO_SOF+0xa0>)
  78:	b973      	cbnz	r3, 98 <USBD_AUDIO_SOF+0x98>
  7a:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
  7e:	6962      	ldr	r2, [r4, #20]
  80:	f403 7380 	and.w	r3, r3, #256	; 0x100
  84:	4293      	cmp	r3, r2
  86:	d107      	bne.n	98 <USBD_AUDIO_SOF+0x98>
  88:	2303      	movs	r3, #3
  8a:	f104 0208 	add.w	r2, r4, #8
  8e:	2181      	movs	r1, #129	; 0x81
  90:	f7ff fffe 	bl	0 <USBD_LL_Transmit>
  94:	2301      	movs	r3, #1
  96:	7023      	strb	r3, [r4, #0]
  98:	2000      	movs	r0, #0
  9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

Disassembly of section .text.USBD_AUDIO_DeInit:

00000000 <USBD_AUDIO_DeInit>:
   0:	b510      	push	{r4, lr}
   2:	2181      	movs	r1, #129	; 0x81
   4:	4604      	mov	r4, r0
   6:	f7ff fffe 	bl	0 <USBD_LL_FlushEP>
   a:	2101      	movs	r1, #1
   c:	4620      	mov	r0, r4
   e:	f7ff fffe 	bl	0 <USBD_LL_FlushEP>
  12:	2181      	movs	r1, #129	; 0x81
  14:	4620      	mov	r0, r4
  16:	f7ff fffe 	bl	0 <USBD_LL_CloseEP>
  1a:	2101      	movs	r1, #1
  1c:	4620      	mov	r0, r4
  1e:	f7ff fffe 	bl	0 <USBD_LL_CloseEP>
  22:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
  26:	b128      	cbz	r0, 34 <USBD_AUDIO_DeInit+0x34>
  28:	3814      	subs	r0, #20
  2a:	f7ff fffe 	bl	0 <bFree>
  2e:	2300      	movs	r3, #0
  30:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
  34:	2000      	movs	r0, #0
  36:	bd10      	pop	{r4, pc}

Disassembly of section .text.USBD_AUDIO_Init:

00000000 <USBD_AUDIO_Init>:
   0:	2201      	movs	r2, #1
   2:	b538      	push	{r3, r4, r5, lr}
   4:	4611      	mov	r1, r2
   6:	4604      	mov	r4, r0
   8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   c:	f7ff fffe 	bl	0 <USBD_LL_OpenEP>
  10:	2303      	movs	r3, #3
  12:	2201      	movs	r2, #1
  14:	2181      	movs	r1, #129	; 0x81
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <USBD_LL_OpenEP>
  1c:	2181      	movs	r1, #129	; 0x81
  1e:	4620      	mov	r0, r4
  20:	f7ff fffe 	bl	0 <USBD_LL_FlushEP>
  24:	2043      	movs	r0, #67	; 0x43
  26:	f7ff fffe 	bl	0 <bAlloc>
  2a:	b100      	cbz	r0, 2e <USBD_AUDIO_Init+0x2e>
  2c:	3014      	adds	r0, #20
  2e:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  32:	b180      	cbz	r0, 56 <USBD_AUDIO_Init+0x56>
  34:	4d09      	ldr	r5, [pc, #36]	; (5c <USBD_AUDIO_Init+0x5c>)
  36:	69ab      	ldr	r3, [r5, #24]
  38:	b923      	cbnz	r3, 44 <USBD_AUDIO_Init+0x44>
  3a:	f44f 6080 	mov.w	r0, #1024	; 0x400
  3e:	f7ff fffe 	bl	0 <bAlloc>
  42:	61a8      	str	r0, [r5, #24]
  44:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  48:	4a05      	ldr	r2, [pc, #20]	; (60 <USBD_AUDIO_Init+0x60>)
  4a:	2101      	movs	r1, #1
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <USBD_LL_PrepareReceive>
  52:	2000      	movs	r0, #0
  54:	bd38      	pop	{r3, r4, r5, pc}
  56:	2002      	movs	r0, #2
  58:	bd38      	pop	{r3, r4, r5, pc}
  5a:	bf00      	nop
  5c:	00000000 	.word	0x00000000
  60:	0000001c 	.word	0x0000001c

Disassembly of section .text.USBD_AUDIO_IsoINIncomplete:

00000000 <USBD_AUDIO_IsoINIncomplete>:
   0:	b508      	push	{r3, lr}
   2:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
   6:	681b      	ldr	r3, [r3, #0]
   8:	f8d3 2808 	ldr.w	r2, [r3, #2056]	; 0x808
   c:	4b08      	ldr	r3, [pc, #32]	; (30 <USBD_AUDIO_IsoINIncomplete+0x30>)
   e:	f402 7280 	and.w	r2, r2, #256	; 0x100
  12:	615a      	str	r2, [r3, #20]
  14:	781a      	ldrb	r2, [r3, #0]
  16:	b142      	cbz	r2, 2a <USBD_AUDIO_IsoINIncomplete+0x2a>
  18:	4906      	ldr	r1, [pc, #24]	; (34 <USBD_AUDIO_IsoINIncomplete+0x34>)
  1a:	688a      	ldr	r2, [r1, #8]
  1c:	3201      	adds	r2, #1
  1e:	608a      	str	r2, [r1, #8]
  20:	2200      	movs	r2, #0
  22:	2181      	movs	r1, #129	; 0x81
  24:	701a      	strb	r2, [r3, #0]
  26:	f7ff fffe 	bl	0 <USBD_LL_FlushEP>
  2a:	2000      	movs	r0, #0
  2c:	bd08      	pop	{r3, pc}
  2e:	bf00      	nop
	...

Disassembly of section .text.USBD_AUDIO_DataOut:

00000000 <USBD_AUDIO_DataOut>:
   0:	2901      	cmp	r1, #1
   2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   6:	4607      	mov	r7, r0
   8:	d17c      	bne.n	104 <USBD_AUDIO_DataOut+0x104>
   a:	4a40      	ldr	r2, [pc, #256]	; (10c <USBD_AUDIO_DataOut+0x10c>)
   c:	4d40      	ldr	r5, [pc, #256]	; (110 <USBD_AUDIO_DataOut+0x110>)
   e:	6853      	ldr	r3, [r2, #4]
  10:	f8d0 6220 	ldr.w	r6, [r0, #544]	; 0x220
  14:	3301      	adds	r3, #1
  16:	6053      	str	r3, [r2, #4]
  18:	69ab      	ldr	r3, [r5, #24]
  1a:	f8d6 4210 	ldr.w	r4, [r6, #528]	; 0x210
  1e:	b923      	cbnz	r3, 2a <USBD_AUDIO_DataOut+0x2a>
  20:	f44f 6080 	mov.w	r0, #1024	; 0x400
  24:	f7ff fffe 	bl	0 <bAlloc>
  28:	61a8      	str	r0, [r5, #24]
  2a:	f8d5 9018 	ldr.w	r9, [r5, #24]
  2e:	4a38      	ldr	r2, [pc, #224]	; (110 <USBD_AUDIO_DataOut+0x110>)
  30:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 120 <USBD_AUDIO_DataOut+0x120>
  34:	f1b9 0f00 	cmp.w	r9, #0
  38:	d042      	beq.n	c0 <USBD_AUDIO_DataOut+0xc0>
  3a:	f892 341c 	ldrb.w	r3, [r2, #1052]	; 0x41c
  3e:	b123      	cbz	r3, 4a <USBD_AUDIO_DataOut+0x4a>
  40:	2300      	movs	r3, #0
  42:	f882 341c 	strb.w	r3, [r2, #1052]	; 0x41c
  46:	f8a9 3000 	strh.w	r3, [r9]
  4a:	f8b9 0000 	ldrh.w	r0, [r9]
  4e:	686a      	ldr	r2, [r5, #4]
  50:	f8d6 3210 	ldr.w	r3, [r6, #528]	; 0x210
  54:	211c      	movs	r1, #28
  56:	f5c0 6480 	rsb	r4, r0, #1024	; 0x400
  5a:	fb01 8202 	mla	r2, r1, r2, r8
  5e:	42a3      	cmp	r3, r4
  60:	bf28      	it	cs
  62:	4623      	movcs	r3, r4
  64:	68d1      	ldr	r1, [r2, #12]
  66:	18c4      	adds	r4, r0, r3
  68:	fb94 f2f1 	sdiv	r2, r4, r1
  6c:	fb01 4412 	mls	r4, r1, r2, r4
  70:	1b1c      	subs	r4, r3, r4
  72:	4448      	add	r0, r9
  74:	4927      	ldr	r1, [pc, #156]	; (114 <USBD_AUDIO_DataOut+0x114>)
  76:	4622      	mov	r2, r4
  78:	3014      	adds	r0, #20
  7a:	f7ff fffe 	bl	0 <memcpy>
  7e:	f8b9 3000 	ldrh.w	r3, [r9]
  82:	692a      	ldr	r2, [r5, #16]
  84:	4423      	add	r3, r4
  86:	b29b      	uxth	r3, r3
  88:	f8a9 3000 	strh.w	r3, [r9]
  8c:	4648      	mov	r0, r9
  8e:	4413      	add	r3, r2
  90:	612b      	str	r3, [r5, #16]
  92:	f7ff fffe 	bl	0 <bCopy>
  96:	4682      	mov	sl, r0
  98:	69a8      	ldr	r0, [r5, #24]
  9a:	f7ff fffe 	bl	0 <bCopy>
  9e:	4651      	mov	r1, sl
  a0:	4681      	mov	r9, r0
  a2:	481d      	ldr	r0, [pc, #116]	; (118 <USBD_AUDIO_DataOut+0x118>)
  a4:	f7ff fffe 	bl	0 <bEnqueue>
  a8:	b110      	cbz	r0, b0 <USBD_AUDIO_DataOut+0xb0>
  aa:	4650      	mov	r0, sl
  ac:	f7ff fffe 	bl	0 <bFree>
  b0:	4649      	mov	r1, r9
  b2:	481a      	ldr	r0, [pc, #104]	; (11c <USBD_AUDIO_DataOut+0x11c>)
  b4:	f7ff fffe 	bl	0 <bEnqueue>
  b8:	b110      	cbz	r0, c0 <USBD_AUDIO_DataOut+0xc0>
  ba:	4648      	mov	r0, r9
  bc:	f7ff fffe 	bl	0 <bFree>
  c0:	69ab      	ldr	r3, [r5, #24]
  c2:	b92b      	cbnz	r3, d0 <USBD_AUDIO_DataOut+0xd0>
  c4:	f44f 6080 	mov.w	r0, #1024	; 0x400
  c8:	f7ff fffe 	bl	0 <bAlloc>
  cc:	4b10      	ldr	r3, [pc, #64]	; (110 <USBD_AUDIO_DataOut+0x110>)
  ce:	6198      	str	r0, [r3, #24]
  d0:	69a8      	ldr	r0, [r5, #24]
  d2:	2300      	movs	r3, #0
  d4:	8003      	strh	r3, [r0, #0]
  d6:	f8d6 2210 	ldr.w	r2, [r6, #528]	; 0x210
  da:	42a2      	cmp	r2, r4
  dc:	d907      	bls.n	ee <USBD_AUDIO_DataOut+0xee>
  de:	1b12      	subs	r2, r2, r4
  e0:	490c      	ldr	r1, [pc, #48]	; (114 <USBD_AUDIO_DataOut+0x114>)
  e2:	b292      	uxth	r2, r2
  e4:	f820 2b14 	strh.w	r2, [r0], #20
  e8:	4421      	add	r1, r4
  ea:	f7ff fffe 	bl	0 <memcpy>
  ee:	686b      	ldr	r3, [r5, #4]
  f0:	221c      	movs	r2, #28
  f2:	fb02 8803 	mla	r8, r2, r3, r8
  f6:	2101      	movs	r1, #1
  f8:	f8b8 3008 	ldrh.w	r3, [r8, #8]
  fc:	4a05      	ldr	r2, [pc, #20]	; (114 <USBD_AUDIO_DataOut+0x114>)
  fe:	4638      	mov	r0, r7
 100:	f7ff fffe 	bl	0 <USBD_LL_PrepareReceive>
 104:	2000      	movs	r0, #0
 106:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 10a:	bf00      	nop
	...
 114:	0000001c 	.word	0x0000001c
	...

Disassembly of section .text.USBD_AUDIO_Setup:

00000000 <USBD_AUDIO_Setup>:
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2:	780b      	ldrb	r3, [r1, #0]
   4:	f013 0460 	ands.w	r4, r3, #96	; 0x60
   8:	4606      	mov	r6, r0
   a:	460d      	mov	r5, r1
   c:	f000 80be 	beq.w	18c <USBD_AUDIO_Setup+0x18c>
  10:	2c20      	cmp	r4, #32
  12:	f040 80f9 	bne.w	208 <USBD_AUDIO_Setup+0x208>
  16:	784a      	ldrb	r2, [r1, #1]
  18:	2a01      	cmp	r2, #1
  1a:	d002      	beq.n	22 <USBD_AUDIO_Setup+0x22>
  1c:	2a02      	cmp	r2, #2
  1e:	d05f      	beq.n	e0 <USBD_AUDIO_Setup+0xe0>
  20:	e0ee      	b.n	200 <USBD_AUDIO_Setup+0x200>
  22:	0619      	lsls	r1, r3, #24
  24:	d551      	bpl.n	ca <USBD_AUDIO_Setup+0xca>
  26:	886b      	ldrh	r3, [r5, #2]
  28:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  2c:	d103      	bne.n	36 <USBD_AUDIO_Setup+0x36>
  2e:	a902      	add	r1, sp, #8
  30:	f801 2d08 	strb.w	r2, [r1, #-8]!
  34:	e039      	b.n	aa <USBD_AUDIO_Setup+0xaa>
  36:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  3a:	d138      	bne.n	ae <USBD_AUDIO_Setup+0xae>
  3c:	4c74      	ldr	r4, [pc, #464]	; (210 <USBD_AUDIO_Setup+0x210>)
  3e:	4b75      	ldr	r3, [pc, #468]	; (214 <USBD_AUDIO_Setup+0x214>)
  40:	6866      	ldr	r6, [r4, #4]
  42:	4975      	ldr	r1, [pc, #468]	; (218 <USBD_AUDIO_Setup+0x218>)
  44:	221c      	movs	r2, #28
  46:	fb02 3606 	mla	r6, r2, r6, r3
  4a:	6876      	ldr	r6, [r6, #4]
  4c:	700e      	strb	r6, [r1, #0]
  4e:	6866      	ldr	r6, [r4, #4]
  50:	fb02 3606 	mla	r6, r2, r6, r3
  54:	6876      	ldr	r6, [r6, #4]
  56:	1236      	asrs	r6, r6, #8
  58:	704e      	strb	r6, [r1, #1]
  5a:	6866      	ldr	r6, [r4, #4]
  5c:	fb02 3606 	mla	r6, r2, r6, r3
  60:	f9b6 6006 	ldrsh.w	r6, [r6, #6]
  64:	708e      	strb	r6, [r1, #2]
  66:	6866      	ldr	r6, [r4, #4]
  68:	fb02 3606 	mla	r6, r2, r6, r3
  6c:	f996 6007 	ldrsb.w	r6, [r6, #7]
  70:	70ce      	strb	r6, [r1, #3]
  72:	6866      	ldr	r6, [r4, #4]
  74:	fb02 3606 	mla	r6, r2, r6, r3
  78:	6876      	ldr	r6, [r6, #4]
  7a:	710e      	strb	r6, [r1, #4]
  7c:	6866      	ldr	r6, [r4, #4]
  7e:	fb02 3606 	mla	r6, r2, r6, r3
  82:	6876      	ldr	r6, [r6, #4]
  84:	1236      	asrs	r6, r6, #8
  86:	714e      	strb	r6, [r1, #5]
  88:	6866      	ldr	r6, [r4, #4]
  8a:	6864      	ldr	r4, [r4, #4]
  8c:	fb02 3606 	mla	r6, r2, r6, r3
  90:	fb02 3304 	mla	r3, r2, r4, r3
  94:	f9b6 6006 	ldrsh.w	r6, [r6, #6]
  98:	f993 3007 	ldrsb.w	r3, [r3, #7]
  9c:	71cb      	strb	r3, [r1, #7]
  9e:	2300      	movs	r3, #0
  a0:	718e      	strb	r6, [r1, #6]
  a2:	720b      	strb	r3, [r1, #8]
  a4:	724b      	strb	r3, [r1, #9]
  a6:	728b      	strb	r3, [r1, #10]
  a8:	72cb      	strb	r3, [r1, #11]
  aa:	88ea      	ldrh	r2, [r5, #6]
  ac:	e00a      	b.n	c4 <USBD_AUDIO_Setup+0xc4>
  ae:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  b2:	3401      	adds	r4, #1
  b4:	2240      	movs	r2, #64	; 0x40
  b6:	2100      	movs	r1, #0
  b8:	4620      	mov	r0, r4
  ba:	f7ff fffe 	bl	0 <memset>
  be:	88ea      	ldrh	r2, [r5, #6]
  c0:	4621      	mov	r1, r4
  c2:	4630      	mov	r0, r6
  c4:	f7ff fffe 	bl	0 <USBD_CtlSendData>
  c8:	e09e      	b.n	208 <USBD_AUDIO_Setup+0x208>
  ca:	88ea      	ldrh	r2, [r5, #6]
  cc:	2a00      	cmp	r2, #0
  ce:	f000 809b 	beq.w	208 <USBD_AUDIO_Setup+0x208>
  d2:	886b      	ldrh	r3, [r5, #2]
  d4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  d8:	f040 8096 	bne.w	208 <USBD_AUDIO_Setup+0x208>
  dc:	494f      	ldr	r1, [pc, #316]	; (21c <USBD_AUDIO_Setup+0x21c>)
  de:	e052      	b.n	186 <USBD_AUDIO_Setup+0x186>
  e0:	061b      	lsls	r3, r3, #24
  e2:	d548      	bpl.n	176 <USBD_AUDIO_Setup+0x176>
  e4:	884b      	ldrh	r3, [r1, #2]
  e6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  ea:	f040 808d 	bne.w	208 <USBD_AUDIO_Setup+0x208>
  ee:	4e48      	ldr	r6, [pc, #288]	; (210 <USBD_AUDIO_Setup+0x210>)
  f0:	4949      	ldr	r1, [pc, #292]	; (218 <USBD_AUDIO_Setup+0x218>)
  f2:	6877      	ldr	r7, [r6, #4]
  f4:	4a47      	ldr	r2, [pc, #284]	; (214 <USBD_AUDIO_Setup+0x214>)
  f6:	2301      	movs	r3, #1
  f8:	700b      	strb	r3, [r1, #0]
  fa:	231c      	movs	r3, #28
  fc:	fb07 3703 	mla	r7, r7, r3, r3
 100:	4417      	add	r7, r2
 102:	2400      	movs	r4, #0
 104:	687f      	ldr	r7, [r7, #4]
 106:	708f      	strb	r7, [r1, #2]
 108:	6877      	ldr	r7, [r6, #4]
 10a:	704c      	strb	r4, [r1, #1]
 10c:	fb07 3703 	mla	r7, r7, r3, r3
 110:	4417      	add	r7, r2
 112:	728c      	strb	r4, [r1, #10]
 114:	687f      	ldr	r7, [r7, #4]
 116:	72cc      	strb	r4, [r1, #11]
 118:	123f      	asrs	r7, r7, #8
 11a:	70cf      	strb	r7, [r1, #3]
 11c:	6877      	ldr	r7, [r6, #4]
 11e:	730c      	strb	r4, [r1, #12]
 120:	fb07 3703 	mla	r7, r7, r3, r3
 124:	4417      	add	r7, r2
 126:	734c      	strb	r4, [r1, #13]
 128:	f9b7 7006 	ldrsh.w	r7, [r7, #6]
 12c:	710f      	strb	r7, [r1, #4]
 12e:	6877      	ldr	r7, [r6, #4]
 130:	fb07 3703 	mla	r7, r7, r3, r3
 134:	4417      	add	r7, r2
 136:	f997 7007 	ldrsb.w	r7, [r7, #7]
 13a:	714f      	strb	r7, [r1, #5]
 13c:	6877      	ldr	r7, [r6, #4]
 13e:	fb07 3703 	mla	r7, r7, r3, r3
 142:	4417      	add	r7, r2
 144:	687f      	ldr	r7, [r7, #4]
 146:	718f      	strb	r7, [r1, #6]
 148:	6877      	ldr	r7, [r6, #4]
 14a:	fb07 3703 	mla	r7, r7, r3, r3
 14e:	4417      	add	r7, r2
 150:	687f      	ldr	r7, [r7, #4]
 152:	123f      	asrs	r7, r7, #8
 154:	71cf      	strb	r7, [r1, #7]
 156:	6877      	ldr	r7, [r6, #4]
 158:	6876      	ldr	r6, [r6, #4]
 15a:	fb07 3703 	mla	r7, r7, r3, r3
 15e:	fb06 3303 	mla	r3, r6, r3, r3
 162:	4417      	add	r7, r2
 164:	4413      	add	r3, r2
 166:	f9b7 7006 	ldrsh.w	r7, [r7, #6]
 16a:	f993 3007 	ldrsb.w	r3, [r3, #7]
 16e:	720f      	strb	r7, [r1, #8]
 170:	724b      	strb	r3, [r1, #9]
 172:	88ea      	ldrh	r2, [r5, #6]
 174:	e01d      	b.n	1b2 <USBD_AUDIO_Setup+0x1b2>
 176:	88ca      	ldrh	r2, [r1, #6]
 178:	2a00      	cmp	r2, #0
 17a:	d045      	beq.n	208 <USBD_AUDIO_Setup+0x208>
 17c:	884b      	ldrh	r3, [r1, #2]
 17e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 182:	d141      	bne.n	208 <USBD_AUDIO_Setup+0x208>
 184:	4924      	ldr	r1, [pc, #144]	; (218 <USBD_AUDIO_Setup+0x218>)
 186:	f7ff fffe 	bl	0 <USBD_CtlPrepareRx>
 18a:	e03d      	b.n	208 <USBD_AUDIO_Setup+0x208>
 18c:	784b      	ldrb	r3, [r1, #1]
 18e:	2b0a      	cmp	r3, #10
 190:	d00d      	beq.n	1ae <USBD_AUDIO_Setup+0x1ae>
 192:	2b0b      	cmp	r3, #11
 194:	d010      	beq.n	1b8 <USBD_AUDIO_Setup+0x1b8>
 196:	2b06      	cmp	r3, #6
 198:	d132      	bne.n	200 <USBD_AUDIO_Setup+0x200>
 19a:	884b      	ldrh	r3, [r1, #2]
 19c:	0a1b      	lsrs	r3, r3, #8
 19e:	2b21      	cmp	r3, #33	; 0x21
 1a0:	d132      	bne.n	208 <USBD_AUDIO_Setup+0x208>
 1a2:	88ca      	ldrh	r2, [r1, #6]
 1a4:	491e      	ldr	r1, [pc, #120]	; (220 <USBD_AUDIO_Setup+0x220>)
 1a6:	2a09      	cmp	r2, #9
 1a8:	bf28      	it	cs
 1aa:	2209      	movcs	r2, #9
 1ac:	e001      	b.n	1b2 <USBD_AUDIO_Setup+0x1b2>
 1ae:	491d      	ldr	r1, [pc, #116]	; (224 <USBD_AUDIO_Setup+0x224>)
 1b0:	2201      	movs	r2, #1
 1b2:	f7ff fffe 	bl	0 <USBD_CtlSendData>
 1b6:	e021      	b.n	1fc <USBD_AUDIO_Setup+0x1fc>
 1b8:	788b      	ldrb	r3, [r1, #2]
 1ba:	2b0c      	cmp	r3, #12
 1bc:	d81c      	bhi.n	1f8 <USBD_AUDIO_Setup+0x1f8>
 1be:	4d14      	ldr	r5, [pc, #80]	; (210 <USBD_AUDIO_Setup+0x210>)
 1c0:	606b      	str	r3, [r5, #4]
 1c2:	686b      	ldr	r3, [r5, #4]
 1c4:	2001      	movs	r0, #1
 1c6:	f885 041c 	strb.w	r0, [r5, #1052]	; 0x41c
 1ca:	b1eb      	cbz	r3, 208 <USBD_AUDIO_Setup+0x208>
 1cc:	4f11      	ldr	r7, [pc, #68]	; (214 <USBD_AUDIO_Setup+0x214>)
 1ce:	686b      	ldr	r3, [r5, #4]
 1d0:	686a      	ldr	r2, [r5, #4]
 1d2:	261c      	movs	r6, #28
 1d4:	4373      	muls	r3, r6
 1d6:	fb06 7202 	mla	r2, r6, r2, r7
 1da:	5cf9      	ldrb	r1, [r7, r3]
 1dc:	6852      	ldr	r2, [r2, #4]
 1de:	f7ff fffe 	bl	0 <formatChange>
 1e2:	686a      	ldr	r2, [r5, #4]
 1e4:	686b      	ldr	r3, [r5, #4]
 1e6:	fb06 7303 	mla	r3, r6, r3, r7
 1ea:	4356      	muls	r6, r2
 1ec:	2002      	movs	r0, #2
 1ee:	685a      	ldr	r2, [r3, #4]
 1f0:	5db9      	ldrb	r1, [r7, r6]
 1f2:	f7ff fffe 	bl	0 <formatChange>
 1f6:	e001      	b.n	6 <USBD_CtlError+0x6>
 1f8:	f7ff fffe 	bl	0 <USBD_CtlError>
 1fc:	4620      	mov	r0, r4
 1fe:	e004      	b.n	20a <USBD_AUDIO_Setup+0x20a>
 200:	f7ff fffe 	bl	0 <USBD_CtlError>
 204:	2002      	movs	r0, #2
 206:	e000      	b.n	20a <USBD_AUDIO_Setup+0x20a>
 208:	2000      	movs	r0, #0
 20a:	b003      	add	sp, #12
 20c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 20e:	bf00      	nop
	...
 220:	00000012 	.word	0x00000012
 224:	00000004 	.word	0x00000004
